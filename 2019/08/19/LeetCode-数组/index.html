
<!DOCTYPE html>
<html lang="">


  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="theme-color" content="#202020">
    <meta http-equiv="x-ua-compatible" content="ie=edge">

    
        <meta name="keywords" content="">
        

          
              <meta name="description" content="数组、链表">
              

                <link rel="icon" type="image/x-icon" href="data:image/png;base64,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">
                <title>
                  数组、链表 [ 开发笔记 ]
                </title>
                
                  <!-- stylesheets list from config.yml -->
                  
                    <link rel="stylesheet" href="/css/microb.css">
                    
                      
  </head>

<body>
  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
        <div class="tab">
            <a href="/"><img src="/left.png" /></a>
            <span><a href="/">开发笔记</a></span>
            <!-- <span><a class="tab-search" href="/search/">搜索</a></span> -->
            
              <span><a class="tab-title" id="#Browser" href="/#Browser">Browser</a></span>
            
              <span><a class="tab-title" id="#Bug" href="/#Bug">Bug</a></span>
            
              <span><a class="tab-title" id="#CSS" href="/#CSS">CSS</a></span>
            
              <span><a class="tab-title" id="#HTML" href="/#HTML">HTML</a></span>
            
              <span><a class="tab-title" id="#HTTP" href="/#HTTP">HTTP</a></span>
            
              <span><a class="tab-title" id="#JS" href="/#JS">JS</a></span>
            
              <span><a class="tab-title" id="#LeetCode" href="/#LeetCode">LeetCode</a></span>
            
              <span><a class="tab-title" id="#NodeJS" href="/#NodeJS">NodeJS</a></span>
            
              <span><a class="tab-title" id="#Other" href="/#Other">Other</a></span>
            
              <span><a class="tab-title" id="#Work" href="/#Work">Work</a></span>
            
              <span><a class="tab-title" id="#随笔" href="/#随笔">随笔</a></span>
            
          </div>
      
  <div id="toc" class="toc-article">
    <!--<strong class="toc-title">目录</strong>-->
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#📚-数组、链表"><span class="toc-text">📚 数组、链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#🤔-解题思路"><span class="toc-text">🤔 解题思路</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#🏫-经典题目"><span class="toc-text">🏫 经典题目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#283-移动零-双指针-快慢指针"><span class="toc-text">283.移动零(双指针 - 快慢指针)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-盛水最多的容器（双指针-左右夹击）"><span class="toc-text">11. 盛水最多的容器（双指针 - 左右夹击）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-三数之和-（双指针-左右夹击）"><span class="toc-text">15. 三数之和 （双指针 - 左右夹击）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#239-滑动窗口的最大值-滑动窗口"><span class="toc-text">239. 滑动窗口的最大值(滑动窗口)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-无重复字符的最长子串-滑动窗口"><span class="toc-text">3. 无重复字符的最长子串(滑动窗口)</span></a></li></ol></li></ol>
  </div>


<div class="section">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        数组、链表
      </h1>
      
      <time class="time" datetime="2019-08-19T03:52:56.000Z">
        2019-08-19
      </time>
      
      <hr>
    </header>
    <div class="post-content">
      <h1 id="📚-数组、链表"><a href="#📚-数组、链表" class="headerlink" title="📚 数组、链表"></a>📚 数组、链表</h1><ol>
<li><p>数组</p>
<p>分配一块连续的内存，每个元素只需要通过索引就可以访问，效率为<em><code>O(1)</code></em>.数组进行增删操作时，会涉及大量片段的复制群移元素，效率为<code>O(n)</code>。</p>
</li>
<li><p>链表</p>
<p>这时候用链表可以省去这些操作，它的移动修改操作效率为<em><code>O(1)</code></em>。同时也是因为这样的结构，要访问链表里的元素变得不那么简单，效率为<em><code>O(n)</code></em>。<br><em>单向链表</em>：链表 Linked List，每个元素有<code>value</code> 和 <code>next</code>，next 指向下一个元素。最后一个元素的 next 指向空 None<br><em>循环列表</em>：头指针为 Head, 尾指针为 Tail, Tail 的 next 指向 Head<br><em>双向链表</em>：有两个指针 <code>prev</code> 和 <code>next</code>可以往前走，也可以往后走</p>
</li>
<li><p>跳表<br>跳表对标的是平衡树和二分查找，是一种插入/删除/搜索都是<code>O(log n)</code>的数据结构。</p>
</li>
</ol>
<p><br></p>
<h1 id="🤔-解题思路"><a href="#🤔-解题思路" class="headerlink" title="🤔 解题思路"></a>🤔 解题思路</h1><ol>
<li>暴力循环</li>
<li><p>双指针<br>双指针，是指用两个变量在线性结构上遍历而解决的问题。双指针算法是基于暴力解法的优化。</p>
<ul>
<li>对于数组，指两个变量在数组上相向移动解决的问题</li>
<li>对于链表，指两个变量在链表上同向移动解决的问题，也称为「快慢指针」问题</li>
<li>左右指针夹逼</li>
</ul>
<p>左右指针分别指向左右两端，根据情况向中间移动。适用于<strong>两数之和</strong>，<strong>三数之和</strong>，<strong>四数之和</strong>, <strong>盛最多水的容器</strong>这样的 LeetCode 题目，先对数组进行排序，然后左右夹逼求值。</p>
<ul>
<li>快慢指针</li>
</ul>
<p>不断维护一维数组的双指针来做一些事情</p>
</li>
<li>滑动窗口</li>
</ol>
<p><br></p>
<h1 id="🏫-经典题目"><a href="#🏫-经典题目" class="headerlink" title="🏫 经典题目"></a>🏫 经典题目</h1><h2 id="283-移动零-双指针-快慢指针"><a href="#283-移动零-双指针-快慢指针" class="headerlink" title="283.移动零(双指针 - 快慢指针)"></a>283.移动零(双指针 - 快慢指针)</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。必须在不复制数组的情况下原地对数组进行操作。<br>输入：[0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>思路：for 循环双指针，i 指针指向遍历的元素，j 指针 0 元素的索引。nums[i] !== 0 时，nums[j] = nums[i]，同时让 nums[i] = 0, j++。<br>套路：不断维护一维数组的双指针来做一些事情<br>时间复杂度：n</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] !== <span class="number">0</span>) &#123;</span><br><span class="line">      nums[j] = nums[i];</span><br><span class="line">      <span class="keyword">if</span> (i !== j) &#123;</span><br><span class="line">        nums[i] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="11-盛水最多的容器（双指针-左右夹击）"><a href="#11-盛水最多的容器（双指针-左右夹击）" class="headerlink" title="11. 盛水最多的容器（双指针 - 左右夹击）"></a>11. 盛水最多的容器（双指针 - 左右夹击）</h2><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。<br>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>返回容器可以储存的最大水量。<br>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>题解：左右指针夹逼，每次移动短的指针，因为移动长的指针，容器的高度不会增加，宽度会减少，所以面积只会减小。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxArea = <span class="function">(<span class="params">height</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> l = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> r = height.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> maxArea = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="keyword">const</span> area = <span class="built_in">Math</span>.min(height[l], height[r]) * (r - l);</span><br><span class="line">    maxArea = <span class="built_in">Math</span>.max(maxArea, area);</span><br><span class="line">    <span class="keyword">if</span> (height[l] &lt; height[r]) &#123;</span><br><span class="line">      l++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      r--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="15-三数之和-（双指针-左右夹击）"><a href="#15-三数之和-（双指针-左右夹击）" class="headerlink" title="15. 三数之和 （双指针 - 左右夹击）"></a>15. 三数之和 （双指针 - 左右夹击）</h2><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。<br>题解：数组先排序，三指针，定住一个指针，剩下两个指针左右指针夹逼。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; nums.length - <span class="number">2</span>; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[k] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 跳过重复的k值</span></span><br><span class="line">    <span class="keyword">let</span> i = k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">const</span> sum = nums[k] + nums[i] + nums[j];</span><br><span class="line">      <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">        arr.push([nums[k], nums[i], nums[j]]);</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] === nums[++i]) &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] === nums[--j]) &#123;&#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] === nums[++i]) &#123;&#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] === nums[--j]) &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="239-滑动窗口的最大值-滑动窗口"><a href="#239-滑动窗口的最大值-滑动窗口" class="headerlink" title="239. 滑动窗口的最大值(滑动窗口)"></a>239. 滑动窗口的最大值(滑动窗口)</h2><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回 滑动窗口中的最大值 。</p>
<p>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置 最大值</p>
<hr>
<p>[1 3 -1] -3 5 3 6 7 3<br>1 [3 -1 -3] 5 3 6 7 3<br>1 3 [-1 -3 5] 3 6 7 5<br>1 3 -1 [-3 5 3] 6 7 5<br>1 3 -1 -3 [5 3 6] 7 6<br>1 3 -1 -3 5 [3 6 7] 7</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxSlidingWindow = <span class="function">(<span class="params">nums, k</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> q = []; <span class="comment">// 存放优先队列的元素下标，为了取值方便</span></span><br><span class="line">  <span class="keyword">const</span> result = []; <span class="comment">// 结果数组</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果队列不为空，当前元素大于队列里的其他元素，则弹出</span></span><br><span class="line">    <span class="keyword">while</span> (q.length &amp;&amp; nums[i] &gt;= nums[q[q.length - <span class="number">1</span>]]) &#123;</span><br><span class="line">      q.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前元素下标入栈</span></span><br><span class="line">    q.push(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前最大值是否在窗口中，若不在则让其出队</span></span><br><span class="line">    <span class="keyword">while</span> (q[<span class="number">0</span>] &lt;= i - k) &#123;</span><br><span class="line">      q.shift();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 达到窗口大小时，就向结果添加数据</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) result.push(nums[q[<span class="number">0</span>]]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="3-无重复字符的最长子串-滑动窗口"><a href="#3-无重复字符的最长子串-滑动窗口" class="headerlink" title="3. 无重复字符的最长子串(滑动窗口)"></a>3. 无重复字符的最长子串(滑动窗口)</h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p><strong>滑动窗口</strong><br>维护一个滑动窗口，窗口内都是没有重复的字符，尽可能去扩大窗口的大小</p>
<ol>
<li>如果当前遍历到的字符从未出现，直接扩大右边界</li>
<li>如果当前遍历到的字符出现过，则缩小窗口（左边索引向右移动），继续观察</li>
<li>重复 1，2，知道左边索引无法再移动</li>
<li>维护 res，更新无重复字符的最长子串</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lengthOfLongestSubstring = <span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dict = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">let</span> minIndex = <span class="number">0</span>, <span class="comment">// 滑动窗口的左指针</span></span><br><span class="line">    maxLength = <span class="number">0</span>,</span><br><span class="line">    curIndex; <span class="comment">// 表示和滑动窗口的右指针元素相同的最新的索引</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="comment">// i是滑动窗口的右指针</span></span><br><span class="line">    curIndex = dict.get(s[i]);</span><br><span class="line">    <span class="keyword">if</span> (curIndex &gt;= minIndex) &#123;</span><br><span class="line">      <span class="comment">// 元素重复,将左指针移动上次出现这个字符的索引的下一位</span></span><br><span class="line">      minIndex = curIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dict.set(s[i], i); <span class="comment">// 记录字符的最新索引</span></span><br><span class="line">    maxLength = <span class="built_in">Math</span>.max(i + <span class="number">1</span> - minIndex, maxLength);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    </div>
  </article>
    <!-- 
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2019/08/16/HTTP/" rel="next" title="🤔 HTTP常见问题">
          🤔 HTTP常见问题
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
        
          <a href="/2019/08/21/vue组件通信/" rel="prev" title="Vue2 组件通信的多种方式">
            Vue2 组件通信的多种方式
          </a>
          <span>〉</span>
        
      </div>
    </div>
   -->
</div>


<script>
var link = document.getElementsByClassName('toc-link');
var hash = decodeURIComponent(location.hash);
if (hash){
} else {
  link[0].classList.add('toc-link-active');
}

var h3 = document.getElementsByTagName('h3');
var h4 = document.getElementsByTagName('h4');
var h5 = document.getElementsByTagName('h5');
var link_arr = [];
function addToArr(arr){
  for(var i = 0; i < arr.length; i++){
    link_arr.push(arr[i].offsetTop);
  }
}
addToArr(h3);
addToArr(h4);
addToArr(h5);


var compare = function (x, y) {
    if (x < y) {
        return -1;
    } else if (x > y) {
        return 1;
    } else {
        return 0;
    }
}

link_arr.sort(compare);


window.onscroll = function(){
  var height = document.documentElement.scrollTop;
  for (var i = 0; i < link_arr.length; i++){
    if (link_arr[i] > height){
      for(var j = 0; j < link.length; j++){
        link[j].classList.remove('toc-link-active');
      }
      document.getElementsByClassName('toc-link')[i].classList.add('toc-link-active');
      break;
    } 
  }
}

</script>
    </div>
  </div>
   

<script src="/js/pangu.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    // listen to any DOM change and automatically perform spacing via MutationObserver()
    pangu.autoSpacingPage();
  });

  // window.addEventListener("load", event => {
  //   // 判断浏览器是否支持
  //   if ("serviceWorker" in navigator) {
  //     window.navigator.serviceWorker
  //       .register("/sw.js", {
  //         scope: "/"
  //       })
  //   }
  // });
</script>

</body>
</html>

