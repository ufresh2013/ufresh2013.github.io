
<!DOCTYPE html>
<html lang="">


  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="theme-color" content="#202020">
    <meta http-equiv="x-ua-compatible" content="ie=edge">

    
        <meta name="keywords" content="">
        

          
              <meta name="description" content="数据结构与算法（小争哥）">
              

                <link rel="icon" type="image/x-icon" href="data:image/png;base64,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">
                <title>
                  数据结构与算法（小争哥） [ 开发笔记 ]
                </title>
                
                  <!-- stylesheets list from config.yml -->
                  
                    <link rel="stylesheet" href="/css/microb.css">
                    
                      
  </head>

<body>
  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
        <div class="tab">
            <a href="/"><img src="/left.png" /></a>
            <span><a href="/">开发笔记</a></span>
            <!-- <span><a class="tab-search" href="/search/">搜索</a></span> -->
            
              <span><a class="tab-title" id="#Browser" href="/#Browser">Browser</a></span>
            
              <span><a class="tab-title" id="#Bug" href="/#Bug">Bug</a></span>
            
              <span><a class="tab-title" id="#CSS" href="/#CSS">CSS</a></span>
            
              <span><a class="tab-title" id="#HTML" href="/#HTML">HTML</a></span>
            
              <span><a class="tab-title" id="#HTTP" href="/#HTTP">HTTP</a></span>
            
              <span><a class="tab-title" id="#JS" href="/#JS">JS</a></span>
            
              <span><a class="tab-title" id="#LeetCode" href="/#LeetCode">LeetCode</a></span>
            
              <span><a class="tab-title" id="#NodeJS" href="/#NodeJS">NodeJS</a></span>
            
              <span><a class="tab-title" id="#Other" href="/#Other">Other</a></span>
            
              <span><a class="tab-title" id="#Work" href="/#Work">Work</a></span>
            
              <span><a class="tab-title" id="#随笔" href="/#随笔">随笔</a></span>
            
          </div>
      
  <div id="toc" class="toc-article">
    <!--<strong class="toc-title">目录</strong>-->
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-数组"><span class="toc-text">1. 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-链表"><span class="toc-text">2. 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-单链表"><span class="toc-text">2.1 单链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-双向链表"><span class="toc-text">2.2 双向链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-指针的含义"><span class="toc-text">2.3 指针的含义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-栈"><span class="toc-text">3. 栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-队列"><span class="toc-text">4. 队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-递归"><span class="toc-text">5. 递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-排序"><span class="toc-text">6. 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-冒泡排序"><span class="toc-text">6.1 冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-插入排序"><span class="toc-text">6.2 插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-选择排序"><span class="toc-text">6.3 选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-归并排序"><span class="toc-text">6.4 归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-快速排序"><span class="toc-text">6.5 快速排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-堆"><span class="toc-text">7. 堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-回溯"><span class="toc-text">8. 回溯</span></a></li></ol>
  </div>


<div class="section">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        数据结构与算法（小争哥）
      </h1>
      
      <time class="time" datetime="2019-03-14T05:58:10.000Z">
        2019-03-14
      </time>
      
      <hr>
    </header>
    <div class="post-content">
      <h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h3><p>数组(Array)是一种线性表数据结构。它用一组连续的内存空间，来存储一组相同类型的数据。</p>
<ul>
<li><p>线性表<br>线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等都是线性表结构。<br><img src="/2019/03/14/LeetCode-数据结构与算法/1.jpg" style="max-width: 500px; margin-top: 20px"></p>
</li>
<li><p><em>随机访问</em><br>连续的内存空间和相同类型的数据。因为有了这个限制，它才有了一个堪称“杀手锏”的特性：<strong>随机访问</strong>。也因为这两个限制，让数组的很多操作变得非常低效，比如删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p>
</li>
<li><p>数组如何通过下标随机访问?<br>通过寻址共识，计算出存储元素的内存地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size</span><br><span class="line"></span><br><span class="line">// 二位数组内存寻址</span><br><span class="line">对于m * n的数组, a[i][j]( i &lt; m, j &lt; n)的地址为</span><br><span class="line">a[i][j]_address = base_address + ( i * n + j ) * data_type_size</span><br></pre></td></tr></table></figure>
</li>
<li><p><em>低效的“插入”和“删除”</em><br><strong>为了保持内存数组的连续性</strong>，将一个数据插入到数组中的第k个位置，我们需要将第k~n这部分的元素都顺序往后挪以为。平均情况时间复杂度为(1+2+..+n)/n = O(n).</p>
</li>
<li><p>改进方法（舍弃数组的连续性）<br><em>快排</em>:  直接将第k位的数据搬移到数组元素的最后，把新的元素直接放入第k个位置。时间复杂度降为O(1)<br><em>JVM标记清除垃圾</em>:  删除操作，只是记录数据已经被删除。当数组没有更多空间存储数据时，才触发执行一次真正的删除操作。大大减少了数据搬移的次数。</p>
</li>
<li><p>数组的访问越界问题</p>
</li>
<li>为什么数组要从0开始编号?<br>如果从1开始编号，每次随机访问数组元素都多了一次减法运算。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 从0开始</span><br><span class="line">a[k]_address = base_address + k * type_size</span><br><span class="line"></span><br><span class="line">// 从1开始</span><br><span class="line">a[k]_address = base_address + ( k - 1 ) * type_size</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h3><p>数组需要一块连续的内存空间来存储，而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组<strong>零散的内存块</strong>串联起来使用。<br><img src="/2019/03/14/LeetCode-数据结构与算法/2.jpg" style="max-width: 500px; margin-top: 20px"></p>
<h4 id="2-1-单链表"><a href="#2-1-单链表" class="headerlink" title="2.1 单链表"></a>2.1 单链表</h4><p>为了将所有节点串起来，每个链表的节点除了存储数据之外，还需要记录链上的下一个结点的地址。我们把这个记录下个节点地址的指针叫作<strong>后续指针 next</strong>。<br><img src="/2019/03/14/LeetCode-数据结构与算法/3.jpg" style="max-width: 500px; margin: 20px auto"></p>
<p>与数组一样，链表也支持数据的查找、插入和删除。在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，我们只需要考虑相邻结点的指针改变，时间复杂度是O(1)。<br><img src="/2019/03/14/LeetCode-数据结构与算法/4.jpg" style="max-width: 500px; margin: 20px auto"></p>
<p>但是，链表想要随机访问第k个元素，就无法像数组那样，通过寻址公式直接计算出对应的内存地址。而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点，时间复杂度是O(n)。</p>
<ul>
<li><strong>循环链表</strong><br>单链表的尾结点指针指向空地址，来表示这是最后的结点。而循环链表的尾结点指向链表的头结点。</li>
</ul>
<h4 id="2-2-双向链表"><a href="#2-2-双向链表" class="headerlink" title="2.2 双向链表"></a>2.2 双向链表</h4><p>每个结点不止有一个后续指针<code>next</code>指向后面的结点，还有一个前驱指针<code>prev</code>指向签名的节点。<br><img src="/2019/03/14/LeetCode-数据结构与算法/5.jpg" style="max-width: 500px; margin: 20px auto"></p>
<ul>
<li><strong>相比单链表，双向链表适合解决哪种问题？</strong><br>在实际的开发中，从链表中删除一个数据无外乎这两种情况：<br><em>- 删除结点中“值等于某个给定值”的结点</em><br>此时，无论是单链表还是双链表，都需要从头结点一个个遍历对比，知道遭到给定值的结点。时间复杂度是O(n)。<br><em>- 删除给定指针指向的结点</em><br>删除某个结点需要知道其前驱结点，而单链表不能直接获取。为了找到前驱结点，我们还要从头结点开始遍历链表，知道p-&gt;next = q。时间复杂度为O(n)，而双向链表只需O(1)。</li>
</ul>
<ul>
<li><strong>有序链表</strong><br>对于有序链表，双向链表的按值查询的效率更高。我们可以记录上次查找的位置p，每次查询时，根据要查找的值与p的大小关系，决定往前还是往后查找，平均只需要查找一半的数据。 Java LinkedHashMap</li>
</ul>
<ul>
<li><strong>实现LRU缓存淘汰算法</strong><blockquote>
<p>缓存是一种提高数据读取性能的技术，常见的有CPU缓存、数据库缓存、浏览器缓存等。缓存的大小有限，当缓存被用满时，哪些数据应该被清理，哪些数据应该被保留。这就需要缓存淘汰策略来决定。常见的策略有三种: 先进先出策略(FIFO - first in, first out), 最少使用策略(LFU - least frequently used), 最近最少使用策略(LRU - least recently used)。</p>
</blockquote>
</li>
</ul>
<p><em>实现思路: 越靠近尾部的结点是越早前访问的。</em></p>
<ol>
<li>维护一个有序单链表</li>
<li>当要访问一个数据时，我们从链表头开始遍历链表。<br>如果数据已经存在于链表中，将其从原来的文职删除，再插入到链表的头部。<br>如果数据不存在于链表中，此时缓存未满，将此结点直接插入到链表的头部。<br>如果数据不存在与链表中，此时缓存已满，则删除链表尾结点，将新数据插入链表的头部。</li>
</ol>
<ul>
<li><strong>判断一个字符串是否是回文字符串</strong><br>使用快慢两个指针找到链表中点，慢指针每次前进1步，快指针每次前进2步。在慢指针前进的过程中，同时修改其next指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等。</li>
</ul>
<h4 id="2-3-指针的含义"><a href="#2-3-指针的含义" class="headerlink" title="2.3 指针的含义"></a>2.3 指针的含义</h4><p>有的语言有“指针”的概念，有的没有，取而代之的是“引用”。无论是“指针”还是“引用”，指的都是存储所指对象的内存位置。</p>
<p><em>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// p结点的next指针存储了q结点的内存地址</span><br><span class="line">p-&gt;next=q</span><br><span class="line"></span><br><span class="line">// p结点的next指针存储了p结点的下下一个结点的内存地址</span><br><span class="line">p-&gt;next = p-&gt;next-&gt;next</span><br></pre></td></tr></table></figure>
<ul>
<li><p>单链表的插入删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 插入一个新结点</span><br><span class="line">new_node-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = new_node;</span><br><span class="line"></span><br><span class="line">// 向一个空链表插入第一个结点</span><br><span class="line">if( head == null )&#123;</span><br><span class="line">  head = new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除结点</span><br><span class="line">p-&gt;next = p-&gt;next-&gt;next</span><br><span class="line"></span><br><span class="line">// 删除最后一个结点</span><br><span class="line">if( head-&gt;next == null )&#123;</span><br><span class="line">  head = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>哨兵结点<br>哨兵结点是不存储数据的。</p>
</li>
</ul>
<h3 id="3-栈"><a href="#3-栈" class="headerlink" title="3. 栈"></a>3. 栈</h3><p>后进者先出，先进者后出，这就是典型的“栈”结构。从操作特性来看，栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。</p>
<ul>
<li>用数组实现栈</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String[] items; <span class="comment">// 数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;      <span class="comment">// 栈中元素个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;          <span class="comment">// 栈的大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化数组，申请一个大小为n的数组空间</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> String[n];</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入栈操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(String item)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == n) <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">// 数组空间不够了，入栈失败，返回false</span></span><br><span class="line">    items[count] = item;</span><br><span class="line">    ++count;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出栈操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 返回下标为count - 1 的数组元素，并且栈中元素个数count-1</span></span><br><span class="line">    String tmp = items[count - <span class="number">1</span>];</span><br><span class="line">    --count;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数调用栈</li>
</ul>
<p>我们知道，操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”，用来储存函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  ret = add(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">  res = a + ret;</span><br><span class="line">  printf(<span class="string">"%d"</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  sum = x + y;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/14/LeetCode-数据结构与算法/6.jpg" style="max-width: 400px"></p>
<ul>
<li>表达式求值<code>3+5/*8-6</code></li>
</ul>
<p>编译器通过两个栈实现。其中一个保存操作数的栈，另一个保存运算符的栈。我们从左向右遍历表达式，当遇到数字，压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。如果比运算符栈顶元素的优先级高，就压入栈。如果比栈顶元素优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取2个操作数，进行计算，再把计算完的结果压入操作数栈。继续比较。<br><img src="/2019/03/14/LeetCode-数据结构与算法/7.jpg" style="max-width: 700px"></p>
<ul>
<li>检查表达式中的括号是否匹配</li>
</ul>
<p>表达式中包括三种括号<code>() {} []</code>，<code>{[{}]}, [{()}([])]</code>等都为合法格式，而<code>{[}()], [({)]</code>为不合法合适。如何检查它是否合法？</p>
<p>从左到右扫描字符串，当扫描到左括号时，将其压入栈中；当扫描到有右括号时，从栈顶取出一个左括号。如果能够匹配，则继续扫描剩下的字符串。如果不能匹配，或栈中没有数据，则说明为非法格式。</p>
<ul>
<li><strong>实现浏览器前进后退功能</strong></li>
</ul>
<p>当你依次访问完一串页面a-b-c之后，点击浏览器的后退按钮，就可以看到b和a。当你后退到a，点击前进，就可以重新查看b和c。但是，如果你后退到b后，点击了新的页面d，就无法通过前进、后退功能查看c了。</p>
<p>当你顺序看了a,b,c三个页面，依次把a,b,c压入栈X。通过浏览器的后退按钮，从页面c退到页面a，我们依次把c,b从栈X中弹出，并且依次放入栈Y。<br><img src="/2019/03/14/LeetCode-数据结构与算法/8.jpg" style="max-width: 500px"></p>
<p>这时，你在b页面上跳转到新页面d，页面c就无法再通过前进、后退按钮重复查看了，所以清空栈Y。<br><img src="/2019/03/14/LeetCode-数据结构与算法/9.jpg" style="max-width: 500px"></p>
<h3 id="4-队列"><a href="#4-队列" class="headerlink" title="4. 队列"></a>4. 队列</h3><p>先进者新出，和栈相似，队列有两个基本操作：入队，放一个数据到队列尾部；出队，从队列头部取一个元素。</p>
<ul>
<li><em>用数组实现队列</em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span></span>&#123;</span><br><span class="line">  <span class="comment">// 数组 items, 数组大小 n</span></span><br><span class="line">  <span class="keyword">private</span> String[] items;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// head 表示队头下标; tail 表示队尾下标</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请一个大小为capacity的数组</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    items = <span class="keyword">new</span> String[capacity];</span><br><span class="line">    n = capacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span></span>&#123;</span><br><span class="line">    <span class="comment">// tail == n 表示队列末尾没有空间了</span></span><br><span class="line">    <span class="keyword">if</span> (tail == n) &#123;</span><br><span class="line">      <span class="comment">// tail == n &amp;&amp; head == 0 表示整个队列占满了</span></span><br><span class="line">      <span class="keyword">if</span> (head == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 数据搬移</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; tail; i++)&#123;</span><br><span class="line">        items[i-head] = items[i]</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 数据搬移后重新更新head和tail</span></span><br><span class="line">      tail -= head;</span><br><span class="line">      head = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    ++tail;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// head == tail 表示队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == tial) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    String ret = items[head];</span><br><span class="line">    ++head;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于栈来说，我们只需要一个<strong>栈顶指针</strong>。但是队列需要两个指针：一个是head指针，指向队头；一个是tail指针，指向队尾。<br><img src="/2019/03/14/LeetCode-数据结构与算法/10.jpg" style="max-width: 600px"></p>
<ul>
<li><em>循环队列：避免数据搬移</em></li>
</ul>
<p>队满时，<code>(tail+1)%n=head</code>。可以发现，队满时，图中的tail指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个存储空间。<br><img src="/2019/03/14/LeetCode-数据结构与算法/11.jpg" style="max-width: 600px"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularQueue</span></span>&#123;</span><br><span class="line">  <span class="comment">// 数组 items, 数组大小 n</span></span><br><span class="line">  <span class="keyword">private</span> String[] items;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请一个大小为capacity的数组</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CircularQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    items = <span class="keyword">new</span> String[capacity];</span><br><span class="line">    n = capacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 队列满了</span></span><br><span class="line">    <span class="keyword">if</span> ((tail + <span class="number">1</span>) % n == head) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    tial = (tial + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果 head == tial 表示队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    String ret = items[head];</span><br><span class="line">    head = (head + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>阻塞队列： 生产者-消费者模型<br>当队列为空的时候，因为没有数据可取，从队头取数据会被阻塞。当队列已经满了，插入数据的操作就会被阻塞，知道队列中有空闲位置后才能插入数据。</li>
</ul>
<h3 id="5-递归"><a href="#5-递归" class="headerlink" title="5. 递归"></a>5. 递归</h3><p>递归就是用栈的数据结构，加上一个简单的逻辑算法实现了业务功能。所有的递归问题都可以用递推公式来表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n - 1) + 1; 其中f(1) = 1;</span><br></pre></td></tr></table></figure></p>
<p>f(n)表示你想知道自己在哪一排，f(n-1)表示前面一排的排数，f(1)=1表示第一排的人知道自己在第一排。有了这个递推公式，我们可以得到递归代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><em>写出递推公式，找到终止条件</em></li>
</ul>
<p>假设有n个台阶，每次你可以跨1或2个台阶，问走这n个台阶共有多种种走法？实际上，可以根据第一步的走法把所有走法分为两类，一类是先走1阶后，n-1个台阶的走法 + 先走2阶后，n-2个台阶的走法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-1) + f(n-2)</span><br></pre></td></tr></table></figure></p>
<p>当有1个台阶且走1阶，或有2个台阶走2阶时，即f(1) = 1, f(2) = 2，就不需要再递归。最终的递归代码是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>警惕栈堆溢出<br>每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险（需要考虑这部分的空间开销）。可以限制递归调用的最大深度来解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  ++depth;</span><br><span class="line">  <span class="keyword">if</span>(depth &gt; <span class="number">10000</span>) <span class="keyword">throw</span> exception;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>警惕重复计算<br>从图中，我们可以直观地看到，想要计算f(5)，需先计算f(4)和f(3)。计算f(4)还要计算f(3)。因此，f(3)被计算了很多次。我们可以通过一个散列表来保存已经求解过的f(k)。当递归调用f(k)，如果已经求解过，可以直接从散列表中取值返回。<br><img src="/2019/03/14/LeetCode-数据结构与算法/12.jpg" style="max-width: 500px"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hasSolvedList.containKey(n))&#123;</span><br><span class="line">    <span class="keyword">return</span> hasSolvedList.get(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ret = f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">  hasSolvedList.put(n, ret);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>无限递归<br>比如demo环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据，出现A-B-C-A这样的死循环。可以用限制递归深度解决，也可以自动检测A-B-C-A（用散列表记录已经查过的数据）。</p>
</li>
</ul>
<h3 id="6-排序"><a href="#6-排序" class="headerlink" title="6. 排序"></a>6. 排序</h3><p>原地排序：空间复杂度为O(1)的算法<br>稳定排序：相同的元素在排序后保持原有的顺序不变<br>有序度: 接近有序/完全无序。<br><em>有序度</em>是数组中具有有序关系的元素对的个数。</p>
<h4 id="6-1-冒泡排序"><a href="#6-1-冒泡排序" class="headerlink" title="6.1 冒泡排序"></a>6.1 冒泡排序</h4><p>对一组数组4,5,6,3,2,1从小到大进行排序。<br><img src="/2019/03/14/LeetCode-数据结构与算法/13.jpg" style="max-width: 500px"></p>
<p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会比较相邻的两个元素，看要不要让它们互换位置。一次冒泡会让至少一个元素移动到它应该的位置，重复n次，就完成了n个数据的排序工作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j)&#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">        a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">        a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">        flag = <span class="keyword">true</span>; <span class="comment">// 表示有数据交换</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;  <span class="comment">// 没有数据交换，提前退出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>冒泡排序是原地排序算法，是稳定的排序算法，最好情况时间复杂度是O(n)，最坏情况时间复杂度是O(n²)</p>
<h4 id="6-2-插入排序"><a href="#6-2-插入排序" class="headerlink" title="6.2 插入排序"></a>6.2 插入排序</h4><p>插入排序将数组中的数据分为两个区间，<strong>已排序区间</strong>和<strong>未排序区间</strong>。初始已排序区间只有一个元素，就是数组的第一个元素。然后取未排序区间中的元素，在已排序区间中找到合适的位置插入，并保证已排序区间数据一直有序。<br><img src="/2019/03/14/LeetCode-数据结构与算法/14.jpg" style="max-width: 500px"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    <span class="comment">// value 要插入的元素</span></span><br><span class="line">    <span class="keyword">int</span> value a = [i];</span><br><span class="line">    <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查找插入的位置</span></span><br><span class="line">    <span class="keyword">for</span>(; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; value)&#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 已排序区间中比value大的元素均往后移一格</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j+<span class="number">1</span>] = value; <span class="comment">// 插入数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>插入排序是原地排序算法，是稳定的排序算法，最好情况时间复杂度是O(n)，最坏情况时间复杂度是O(n²)</p>
<h4 id="6-3-选择排序"><a href="#6-3-选择排序" class="headerlink" title="6.3 选择排序"></a>6.3 选择排序</h4><p>选择排序每会从末排序区间中找到最小的元素，将其放到已排序区间的末尾。<br><img src="/2019/03/14/LeetCode-数据结构与算法/15.jpg" style="max-width: 500px"><br>选择排序是原地排序算法，是一种不稳定的排序算法，最好情况事件复杂度和最坏情况时间复杂度都是O(n²)</p>
<h4 id="6-4-归并排序"><a href="#6-4-归并排序" class="headerlink" title="6.4 归并排序"></a>6.4 归并排序</h4><p>先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就有序了。<br><img src="/2019/03/14/LeetCode-数据结构与算法/16.jpg" style="max-width: 500px"></p>
<h4 id="6-5-快速排序"><a href="#6-5-快速排序" class="headerlink" title="6.5 快速排序"></a>6.5 快速排序</h4><h3 id="7-堆"><a href="#7-堆" class="headerlink" title="7. 堆"></a>7. 堆</h3><h3 id="8-回溯"><a href="#8-回溯" class="headerlink" title="8. 回溯"></a>8. 回溯</h3><p>很多经典的数学问题可以用回溯算法解决，如数独、八皇后、0-1背包、图的着色、旅行商问题、全排列等。</p>
<p>我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，都会面对一个岔路口，我们先选一条路走，当发现这条路走不通的时候，就回退到上一个岔路口，另选一种走法继续走。</p>
<ul>
<li>0-1背包问题：背包总的承载重量是 W kg，现在有 n 个物品，每个物品重量不等，并且不可分割。如何让背包中物品的总重量最大？</li>
</ul>
<p>n个物品，总的装法就有2^n种。我们如何才能不重复穷举这2^n种装法？</p>

    </div>
  </article>
    <!-- 
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2019/02/26/BOM文档/" rel="next" title="BOM - 访问浏览器的功能">
          BOM - 访问浏览器的功能
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
        
          <a href="/2019/03/14/LeetCode-数据结构与算法总览/" rel="prev" title="数据结构与算法总览">
            数据结构与算法总览
          </a>
          <span>〉</span>
        
      </div>
    </div>
   -->
</div>


<script>
var link = document.getElementsByClassName('toc-link');
var hash = decodeURIComponent(location.hash);
if (hash){
} else {
  link[0].classList.add('toc-link-active');
}

var h3 = document.getElementsByTagName('h3');
var h4 = document.getElementsByTagName('h4');
var h5 = document.getElementsByTagName('h5');
var link_arr = [];
function addToArr(arr){
  for(var i = 0; i < arr.length; i++){
    link_arr.push(arr[i].offsetTop);
  }
}
addToArr(h3);
addToArr(h4);
addToArr(h5);


var compare = function (x, y) {
    if (x < y) {
        return -1;
    } else if (x > y) {
        return 1;
    } else {
        return 0;
    }
}

link_arr.sort(compare);


window.onscroll = function(){
  var height = document.documentElement.scrollTop;
  for (var i = 0; i < link_arr.length; i++){
    if (link_arr[i] > height){
      for(var j = 0; j < link.length; j++){
        link[j].classList.remove('toc-link-active');
      }
      document.getElementsByClassName('toc-link')[i].classList.add('toc-link-active');
      break;
    } 
  }
}

</script>
    </div>
  </div>
   

<script src="/js/pangu.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    // listen to any DOM change and automatically perform spacing via MutationObserver()
    pangu.autoSpacingPage();
  });

  // window.addEventListener("load", event => {
  //   // 判断浏览器是否支持
  //   if ("serviceWorker" in navigator) {
  //     window.navigator.serviceWorker
  //       .register("/sw.js", {
  //         scope: "/"
  //       })
  //   }
  // });
</script>

</body>
</html>

