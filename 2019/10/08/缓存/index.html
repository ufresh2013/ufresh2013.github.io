
<!DOCTYPE html>
<html lang="">


  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="theme-color" content="#202020">
    <meta http-equiv="x-ua-compatible" content="ie=edge">

    
        <meta name="keywords" content="">
        

          
              <meta name="description" content="🤔 浏览器缓存（强缓存、协议缓存）、离线缓存">
              

                <link rel="icon" type="image/x-icon" href="data:image/png;base64,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">
                <title>
                  🤔 浏览器缓存（强缓存、协议缓存）、离线缓存 [ 开发笔记 ]
                </title>
                
                  <!-- stylesheets list from config.yml -->
                  
                    <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
                    
                    <link rel="stylesheet" href="/css/microb.css">
                    
                      
  </head>

<body>
  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
        <div class="tab">
            <a href="/"><img src="/left.png" /></a>
            <span><a href="/">开发笔记</a></span>
            <!-- <span><a class="tab-search" href="/search/">搜索</a></span> -->
            
              <span><a class="tab-title" id="#Basic" href="/#Basic">Basic</a></span>
            
              <span><a class="tab-title" id="#Browser" href="/#Browser">Browser</a></span>
            
              <span><a class="tab-title" id="#Bug" href="/#Bug">Bug</a></span>
            
              <span><a class="tab-title" id="#CSS" href="/#CSS">CSS</a></span>
            
              <span><a class="tab-title" id="#HTML" href="/#HTML">HTML</a></span>
            
              <span><a class="tab-title" id="#HTTP" href="/#HTTP">HTTP</a></span>
            
              <span><a class="tab-title" id="#JS" href="/#JS">JS</a></span>
            
              <span><a class="tab-title" id="#LeetCode" href="/#LeetCode">LeetCode</a></span>
            
              <span><a class="tab-title" id="#NodeJS" href="/#NodeJS">NodeJS</a></span>
            
              <span><a class="tab-title" id="#React" href="/#React">React</a></span>
            
              <span><a class="tab-title" id="#Vue" href="/#Vue">Vue</a></span>
            
              <span><a class="tab-title" id="#Work" href="/#Work">Work</a></span>
            
              <span><a class="tab-title" id="#全栈" href="/#全栈">全栈</a></span>
            
              <span><a class="tab-title" id="#动画/媒体" href="/#动画/媒体">动画/媒体</a></span>
            
          </div>
      
  <div id="toc" class="toc-article">
    <!--<strong class="toc-title">目录</strong>-->
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-简介"><span class="toc-text">1. 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-HTTP-header缓存机制"><span class="toc-text">2. HTTP header缓存机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-状态码"><span class="toc-text">2.1 状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-强缓存"><span class="toc-text">2.1 强缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-协商缓存"><span class="toc-text">2.2 协商缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-缓存策略"><span class="toc-text">2.3 缓存策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-数据存储"><span class="toc-text">3. 数据存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-离线缓存PWA"><span class="toc-text">4. 离线缓存PWA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol>
  </div>


<div class="section">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        🤔 浏览器缓存（强缓存、协议缓存）、离线缓存
      </h1>
      
      <time class="time" datetime="2019-10-08T06:31:23.000Z">
        2019-10-08
      </time>
      
      <hr>
    </header>
    <div class="post-content">
      <h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p><em>碰到的缓存问题…</em></p>
<ul>
<li>每次都加载同样的静态文件？</li>
<li>协商缓存还是要和服务器通信，怎样可以省掉这个请求？</li>
<li>这些数据、文件的有效时间要怎么定，会不会太容易失效？</li>
<li>重复的无效请求太多？数据需要缓存起来，应该放在那里？</li>
<li>如何更新缓存，更新的依据是什么？</li>
<li>什么是Memory Cache, Disk Cache, Push Cache</li>
</ul>
<p><strong>这里罗列了缓存的所有分类..</strong><br><img src="/2019/10/08/缓存/1.png"></p>
<p><br></p>
<p><br></p>
<h3 id="2-HTTP-header缓存机制"><a href="#2-HTTP-header缓存机制" class="headerlink" title="2. HTTP header缓存机制"></a>2. HTTP header缓存机制</h3><h4 id="2-1-状态码"><a href="#2-1-状态码" class="headerlink" title="2.1 状态码"></a>2.1 状态码</h4><p>浏览器根据第一次请求资源时返回的 <em>响应头</em> 来确定，一个资源该不该被缓存。如果这是个可以被缓存的资源，浏览器会把它存到内存(memory cache)或者磁盘(disk cache)中，同时把缓存标识记录下来。<br><img src="/2019/10/08/缓存/6.png" style="max-width: 500px; margin: 30px auto;"></p>
<p>第二次请求资源时，会返回这些<em>状态码</em>。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td style="text-align:center">强缓存 Expires/Cache-Control失效时，并且协议缓存过期，返回新的资源文件</td>
</tr>
<tr>
<td>200(from cache)</td>
<td style="text-align:center">强缓存 Expires/Cache-Control未过期，浏览器从本地获取资源成功。<br></td>
</tr>
<tr>
<td>304(Not Modified)</td>
<td style="text-align:center">协商缓存Last-modified/Etag没有过期时，服务端返回状态码304</td>
</tr>
</tbody>
</table>
<p><img src="/2019/10/08/缓存/5.png" style="max-width: 300px; margin: 20px auto;"></p>
<p><br><br><br></p>
<h4 id="2-1-强缓存"><a href="#2-1-强缓存" class="headerlink" title="2.1 强缓存"></a>2.1 强缓存</h4><p>不会向服务器发送请求，直接从缓存中读取资源。强缓存通过Expires和Cache-Control两种响应头实现。</p>
<p><em>1. Expires</em><br>Expires是HTTP 1.0提出的一个表示资源过期时间的字段，描述一个绝对时间，由服务器返回。Expires受限于本地时间，如果修改了本地时间，可能会造成缓存失效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 11 May 2018 07:20:00 GMT</span><br></pre></td></tr></table></figure></p>
<p><br><br><em>2. Cache-Control</em><br>出现于HTTP 1.1，优先级高于Expires， 表示的是相对时间<br><code>Cache-Control: no-store</code> 浏览器和缓存服务器，不缓存数据到本地磁盘中<br><code>Cache-Control: no-cache</code> 浏览器和缓存服务器不应该缓存页面信息<br><code>Cache-Control: public</code> 可以被所有用户缓存，包括终端和CDN等中间代理服务器<br><code>Cache-Control: private</code> 只能被终端浏览器缓存，不允许中继缓存服务器进行缓存<br><code>Cache-Control: max-age=30</code>缓存30秒后就过期，需要重新请求<br><code>Cache-Control: s-maxage=30</code>覆盖max-age，作用一样，只在代理服务器生效</p>
<p><br></p>
<h4 id="2-2-协商缓存"><a href="#2-2-协商缓存" class="headerlink" title="2.2 协商缓存"></a>2.2 协商缓存</h4><p>强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存。协商缓存利用<code>Last-Modified</code>, <code>If-Modified-Since</code>和<code>ETag</code>, <code>If-None-Match</code>这两对标识来管理。<br><img src="/2019/10/08/缓存/7.png" style="max-width:600px;margin: 30px auto"></p>
<p><em>1. Last-Modified， If-Modified-Since</em><br>表示本地文件最后修改日期。<br>浏览器会在request header加上<em><code>If-Modified-Since</code></em>(上次响应头中的Last-Modified)，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。但是如果在本地打开缓存文件，就会造成Last-Modified被修改，所以在HTTP / 1.1出现了ETag。</p>
<p><br><br><em>2. ETag, If-None-Match</em><br>ETag像一个指纹，资源变化都会导致ETag变化，它可以保证每一个资源是唯一的。<br>浏览器会在request header加上<em><code>If-None-Match</code></em>(上次相应头中的ETag)发送给服务器，询问该资源的ETag是否有更新，有变动就会发送新的资源回来。</p>
<p><img src="/2019/10/08/缓存/3.png"></p>
<p>ETag的优先级比Last-Modified更高，优先使用ETag有下面几种情况考虑：</p>
<ul>
<li>一些文件也许会周期性的更改，但它的内容并不改变（仅仅改变的是修改时间）</li>
<li>某些文件修改非常频繁，If-Modified-Since能检查到的粒度是s级，对于秒以下的修改则无法判断</li>
<li>某些服务器不能精确的得到文件的最后修改时间</li>
</ul>
<p><br></p>
<h4 id="2-3-缓存策略"><a href="#2-3-缓存策略" class="headerlink" title="2.3 缓存策略"></a>2.3 缓存策略</h4><ul>
<li>配置超长时间的本地缓存</li>
<li>采用内容摘要作为缓存更新依据  —— 精确控制缓存</li>
<li>静态资源部署CDN</li>
<li>静态资源文件通过Service Worker进行缓存控制和离线化加载</li>
<li>更新资源实现非覆盖式发布</li>
</ul>
<p><strong>具体操作</strong></p>
<ul>
<li>对于不需要缓存的资源，使用<em><code>Cache-control: no-store</code></em></li>
<li>对于频繁变动的资源（比如经常需要刷新的首页，资讯论坛新闻类），可以使用<em><code>Cache-control: no-cache</code></em>并配合<em><code>ETag</code></em>，表示该资源已被缓存，但是每次都会发送请求询问资源是否需要更新</li>
<li>对于代码文件，通常使用<em><code>Cache-control: max-age=31536000</code></em>强缓存，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件</li>
</ul>
<p><br></p>
<h3 id="3-数据存储"><a href="#3-数据存储" class="headerlink" title="3. 数据存储"></a>3. 数据存储</h3><p>除了请求缓存，我们还会把存储从服务器获取的数据，也是页面需要频繁用到的数据<br><em>cookie</em>：4K，可以手动设置失效期<br><em>localStorage</em>：5M，除非手动清除，否则一直存在<br><em>sessionStorage</em>：5M，不可以跨标签访问，页面关闭就清理<br><em>indexedDB</em> ：浏览器端数据库，无限容量，除非手动清除，否则一直存在</p>
<p><strong>共同点</strong></p>
<ul>
<li>都是保存在浏览器端、且同源的<br><br></li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下</li>
<li>存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</li>
<li>数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭</li>
<li>作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的</li>
<li>web Storage支持事件通知机制，可以将数据更新的通知发送给监听者。接口使用更方便</li>
</ul>
<p><br></p>
<h3 id="4-离线缓存PWA"><a href="#4-离线缓存PWA" class="headerlink" title="4. 离线缓存PWA"></a>4. 离线缓存PWA</h3><p>使用Service Worker实现离线可用的应用，甚至在离线时，可以应用XHR数据，提高响应速度。<br><a href="">查看Demo</a><br><img src="/2019/10/08/缓存/8.png" style="max-width:500px; margin: 30px auto"></p>
<ul>
<li>在index.js中注册Service Worker(sw.js)</li>
<li>在sw.js中列一个资源列表(离线时显示的页面)，当Server Worker被激活时，将列表中的资源缓存进cache</li>
<li>拦截浏览器请求：当浏览器请求各类静态资源(html/js/css/img)时， Service Worker拦截该请求，并查询当前cache。若存在cache则直接返回，先渲染数据。然后通过fetch方法向服务端发起请求。</li>
</ul>
<p><br></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://github.com/amandakelake/blog/issues/43" target="_blank" rel="noopener">缓存总览：从性能优化的角度看缓存</a></li>
<li><a href="https://blog.csdn.net/garrettzxd/article/details/80684880" target="_blank" rel="noopener">from memory cache与from disk cache详解</a></li>
<li><a href="https://www.jianshu.com/p/54cc04190252" target="_blank" rel="noopener">深入理解浏览器的缓存机制</a></li>
<li><a href="https://juejin.im/post/5c4528a6f265da611a4822cc" target="_blank" rel="noopener">实践这一次,彻底搞懂浏览器缓存机制</a></li>
<li><a href="https://juejin.im/post/5aca14b6f265da237c692e6f" target="_blank" rel="noopener">【PWA学习与实践】(3) 让你的WebApp离线可用</a></li>
</ul>

    </div>
  </article>
    
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2019/09/30/性能优化/" rel="next" title="性能优化">
          性能优化
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
        
          <a href="/2019/10/11/Vue API/" rel="prev" title="Vue2 的 API 是真的好用！">
            Vue2 的 API 是真的好用！
          </a>
          <span>〉</span>
        
      </div>
    </div>
  
</div>


<script>
var link = document.getElementsByClassName('toc-link');
var hash = decodeURIComponent(location.hash);
if (hash){
} else {
  link[0].classList.add('toc-link-active');
}

var h3 = document.getElementsByTagName('h3');
var h4 = document.getElementsByTagName('h4');
var h5 = document.getElementsByTagName('h5');
var link_arr = [];
function addToArr(arr){
  for(var i = 0; i < arr.length; i++){
    link_arr.push(arr[i].offsetTop);
  }
}
addToArr(h3);
addToArr(h4);
addToArr(h5);


var compare = function (x, y) {
    if (x < y) {
        return -1;
    } else if (x > y) {
        return 1;
    } else {
        return 0;
    }
}

link_arr.sort(compare);


window.onscroll = function(){
  var height = document.documentElement.scrollTop;
  for (var i = 0; i < link_arr.length; i++){
    if (link_arr[i] > height){
      for(var j = 0; j < link.length; j++){
        link[j].classList.remove('toc-link-active');
      }
      document.getElementsByClassName('toc-link')[i].classList.add('toc-link-active');
      break;
    } 
  }
}

</script>
    </div>
  </div>
  




    <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
      
    
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        // listen to any DOM change and automatically perform spacing via MutationObserver()
        pangu.autoSpacingPage();
      });

      window.addEventListener("load", event => {
        // 判断浏览器是否支持
        if ("serviceWorker" in navigator) {
          window.navigator.serviceWorker
            .register("/sw.js", {
              scope: "/"
            })
        }
      });
    </script>
</body>
</html>

