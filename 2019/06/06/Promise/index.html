
<!DOCTYPE html>
<html lang="">


  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="theme-color" content="#202020">
    <meta http-equiv="x-ua-compatible" content="ie=edge">

    
        <meta name="keywords" content="">
        

          
              <meta name="description" content="Promise使用场景与实现">
              

                <link rel="icon" type="image/x-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAAEzo7pQAAACzVBMVEXHx8fLy8vMzMzNzc3Ozs7Pz8/Q0NDR0dHS0tLT09PU1NTV1dXW1tbX19fY2NjZ2dna2trb29vc3Nzd3d3e3t7f39/g4ODh4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojp6enq6urr6+vs7Ozt7e3y8vL09PT19fX29vb39/f4+Pj6+vr9/f3+/v7////Ozs7Pz8/Q0NDS0tLU1NTW1tbX19fY2NjZ2dna2trb29vc3Nzd3d3e3t7S0tLV1dXZ2dna2trc3NzY2Njc3Nzj4+PV1dXT09PX19fZ2dnc3NzU1NTU1NTY2Nji4uLS0tLS0tLW1tbU1NTf39/Hx8fT09PJycnIyMjDw8PGxsbHx8fBwcHFxcXf39/JycnS0tK8vLy3t7fBwcG4uLi8vLzCwsKwsLCioqKhoaGdnZ2ZmZmbm5uXl5ehoaGZmZmPj4+ampqJiYmVlZWGhoaDg4OSkpKFhYWAgICQkJB2dnZ9fX16enp4eHh0dHRvb29ycnJ1dXVra2tubm5tbW1eXl5paWllZWVkZGR4eHhYWFhcXFxaWlpbW1tOTk5NTU1MTExOTk5QUFBISEhgYGBEREQ3NzdBQUFISEhCQkJBQUE0NDQ6Ojo2NjY2NjYxMTEzMzMnJycwMDApKSkrKysZGRkpKSkTExMVFRUfHx8gICAiIiItLS0cHBwdHR0lJSUZGRkiIiIdHR0XFxcjIyMREREiIiIAAAABAQEDAwMEBAQGBgYHBwcICAgJCQkKCgoLCwsMDAwNDQ0ODg4PDw8QEBARERESEhITExMUFBQVFRUWFhYXFxcYGBgZGRkaGhobGxscHBwdHR0eHh4fHx8gICAhISEiIiIjIyMkJCQmJiYnJycoKCgrKyssLCwwMDAxMTE3NzdDQ0NLS0tPT09WVlZZWVlkZGRoaGhra2tsbGxzc3N2dnZ9fX2BgYGNjY2Pj4+dnZ1edkJeAAAAtHRSTlMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQECAgICAgMDAwQFBggICQoKDA4QEBMUFhYYGRocHB8hIiMkKSw1ODg9RkpOUFNVV1lmaGtsbnFydHd5eYWHiImMj4+Sk5OVlpuipKaqq622v8DBwsPHyMzOz9HS1NXb3uDm5ujq7Ozw8fLy8vLy8vP09vf6+/z8/v5Qqz//AAADDklEQVQYGW3BS2icVRgG4Pf9zvnnkpnMJZPr5GpMa6NISJTEpolaSRG7KBVBcCMIRRAEleJWXbtyobgTFVwILtyIWbltSw2VSK01KcQ0pdGZZEybmT//zH/OZyKNi+jzQCZNYJP3Pn6c6StKOQPCSHbcIv3LUs6WelzBfOt2rzKL/rhkandoZt/vBvQZsQvdIDjPi68SgNaNYCo+vl1uN5nEJ8uprq7fxUnyvbMfibPRKz0YwuRlSZzfzHbVzlhrBmV3t+hPyLChApXALAoJ9GaYAlQGclaoyt9AkyBN6bNTi5ubOv36zqqzFpDXOkpfAdDbv6JprPZ8OQ3bklYrkR+9XJdW67mc2g0LKQlGTxpr5ppK1weYOlC/5M3why8YPMBq9Kd5d8LjkJamyxSAE7reOCY3wz4STAEoxKMGVPhbgLWAuZD5tKzWVTQCxHsfdJx+tnpntfHB552gVdDF7RfeWNqbGPkh9LAB0POoK2CeqK+F6qUeZt8eAUBATpUFkkqdf9K7HZGGIjtIFY8M0Te+Uyvn0fF8KhBXeCrA+vVcWtaA7rSz2ugAUikE20VlGBmZya4pACVIvT3UtPm5SRyKw7as7ToteECl8+48vxsA8a/1r8WQOERNe7bhgEJwgiIQelVAVqE2wD624QAlPde9qJ0BSECJ1gofvgECzOAfiY43H/FXv/kDYwCo98Ynoi8asQJWsE8FaHLM9mxUvw87G0/nX4oGVlZ+3HIe1uOALw53pqNyWcKXEZlCIrC3lpe3lULTJiLHtx+authdBKA2k8m3BwIn/n5tz6kajWMXz7wz1Z+ga1kcYjL21xuIYQJCumYeKwN/9ecsQxP7nIQWyGXSa3ugCWh6zy30WoBIaTWJrbFMEjsBlFqvNCIbQ3brYdMQiVYFaaBvo5LPtSkZ1u43JG2DlhGxhgBB7HNBGQ6EBIVs0HB2Nti7lmw6JY6IuLx07BptdvnsW4UicYQi+mnL3Jjd44sLI0OKo5SgbsqlKz+bc0+Uif8gVCVbnTwZ28FqDf9HSc+bUf1vzMAvsrtVWjkAAAAASUVORK5CYII=">
                <title>
                  Promise使用场景与实现 [ 日常笔记 ]
                </title>
                
                  <!-- stylesheets list from config.yml -->
                  
                    <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
                    
                    <link rel="stylesheet" href="/css/microb.css">
                    
                      
  </head>

<body>
  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
        <div class="tab">
            <a href="/"><img src="/left.png" /></a>
            <span><a href="/">日常笔记</a></span>
            <span><a class="tab-search" href="/search/">搜索</a></span>
            
              <span><a class="tab-title" id="#Basic" href="/#Basic">Basic</a></span>
            
              <span><a class="tab-title" id="#Browser" href="/#Browser">Browser</a></span>
            
              <span><a class="tab-title" id="#CSS" href="/#CSS">CSS</a></span>
            
              <span><a class="tab-title" id="#Debug" href="/#Debug">Debug</a></span>
            
              <span><a class="tab-title" id="#HTML" href="/#HTML">HTML</a></span>
            
              <span><a class="tab-title" id="#JS" href="/#JS">JS</a></span>
            
              <span><a class="tab-title" id="#NodeJS" href="/#NodeJS">NodeJS</a></span>
            
              <span><a class="tab-title" id="#React" href="/#React">React</a></span>
            
              <span><a class="tab-title" id="#Vue" href="/#Vue">Vue</a></span>
            
              <span><a class="tab-title" id="#Webpack" href="/#Webpack">Webpack</a></span>
            
              <span><a class="tab-title" id="#其他" href="/#其他">其他</a></span>
            
          </div>
      
  <div id="toc" class="toc-article">
    <!--<strong class="toc-title">目录</strong>-->
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-地狱回调"><span class="toc-text">1. 地狱回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-常见异步编程方案"><span class="toc-text">2. 常见异步编程方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-回调函数"><span class="toc-text">2.1 回调函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-事件监听"><span class="toc-text">2.2 事件监听</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-发布-订阅"><span class="toc-text">2.3 发布/订阅</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Promise"><span class="toc-text">3. Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Promise-API"><span class="toc-text">2. Promise API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-Promise-all"><span class="toc-text">2.1 Promise.all</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-Promise-resolve"><span class="toc-text">2.2 Promise.resolve()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-Promise-reject"><span class="toc-text">2.3 Promise.reject()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-Promise-race"><span class="toc-text">2.4 Promise.race()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-Promise-prototype-then"><span class="toc-text">2.5 Promise.prototype.then</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-实现一个简单版Promise"><span class="toc-text">3. 实现一个简单版Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Promise题目"><span class="toc-text">4. Promise题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol>
  </div>


<div class="section">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        Promise使用场景与实现
      </h1>
      
      <time class="time" datetime="2019-06-06T12:38:50.000Z">
        2019-06-06
      </time>
      
      <hr>
    </header>
    <div class="post-content">
      <h3 id="1-地狱回调"><a href="#1-地狱回调" class="headerlink" title="1. 地狱回调"></a>1. 地狱回调</h3><p>在Promise出现之前，当我们需要根据第一个网络请求的结果，再去执行第二个网络请求….代码大概如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">fs.readFile(<span class="string">'./a.txt'</span>,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">  fs.readFile(data,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">    fs.readFile(data,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>回调地狱 出现了。这时，有人提议用一种更加友好的代码组织方式，解决异步嵌套的问题。于是Promise规范诞生了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">funtion read(url) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(url, <span class="string">'urf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      error &amp;&amp; reject(error);</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read(<span class="string">'./a.txt'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> read(data)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> read(data)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="2-常见异步编程方案"><a href="#2-常见异步编程方案" class="headerlink" title="2. 常见异步编程方案"></a>2. 常见异步编程方案</h3><h4 id="2-1-回调函数"><a href="#2-1-回调函数" class="headerlink" title="2.1 回调函数"></a>2.1 回调函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ajax readystatechange == 4 执行回调函数</span></span><br><span class="line">$.ajax(<span class="string">'http://www.baidu.com'</span>, &#123;</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// jquery加载完执行callback</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="2-2-事件监听"><a href="#2-2-事件监听" class="headerlink" title="2.2 事件监听"></a>2.2 事件监听</h4><p>start的执行不取决于代码的顺序，而取决于事件是否发生。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 响应事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'start'</span>).addEventListerner(<span class="string">'click'</span>, start, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h4 id="2-3-发布-订阅"><a href="#2-3-发布-订阅" class="headerlink" title="2.3 发布/订阅"></a>2.3 发布/订阅</h4><p>事件可以理解成“信号”， 如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”一个信号。其他任务可以向信号中心“订阅”(subscribe)这个信号，从而知道什么时候自己可以开始执行。这叫做“发布/定于模式”，又称“观察者模式”。</p>
<p>f1执行完成后，向信号中心jQuery发布done信号，从而引发f2的执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jQuery.subscribe(<span class="string">'done'</span>, f2);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    jQuery.publish(<span class="string">'done'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="3-Promise"><a href="#3-Promise" class="headerlink" title="3. Promise"></a>3. Promise</h3><p>在浏览器里,回调主要出现在ajax, file API, 事件监听里，这个时候问题尚不严重。有了Node.js以后，无阻塞高并发的特点，产生了大量操作依赖回调函数。</p>
<p><em>异步函数的问题</em></p>
<ul>
<li>异步函数在一个新的栈里面执行，外面的栈无法通过try()catch{}捕获这个栈的错误信息</li>
<li>无法判断多个异步函数的完成顺序，我们需要把返回结果存储在外层作用域。这时候外部变量容易出现错误</li>
</ul>
<p>基于这些问题，Promise提出了一套将异步操作队列化，使异步计算按照期望的顺序执行的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">  <span class="comment">// 执行器</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 一段耗时很长的异步操作</span></span><br><span class="line">    resolve(); <span class="comment">// 数据处理完成，调用resolve，改变promise实例的状态</span></span><br><span class="line">    reject();  <span class="comment">// 数据处理出错，调用reject，改变promise实例的状态</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 上面的resolve执行后，执行这里</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 上面的reject执行后，执行这里</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>一个Promise表示一个现在、将来或永不可能可用的值。</li>
<li>Promise有3个状态：pending(初始状态), fulfilled(操作成功), rejected(操作失败)</li>
<li>Promise状态发生改变，就会触发.then()里的响应函数处理后续步骤</li>
<li>Promise状态已经修改，不会再变</li>
<li>Promise实例一经创建，执行器立即执行</li>
<li>.then()接受两个函数作为参数，分别代表fulfilled和rejected。当前面的Promise状态改变时，.then()根据其最终状态，选择特定的状态响应函数执行。</li>
<li>.then()返回一个新的Promise实例，所以它可以链式调用</li>
<li>如果.then()返回其他任何值，则会立即执行下一级.then()</li>
<li>错误处理的两种做法： <code>reject(&#39;错误信息&#39;).then(null, message =&gt; {})</code>; <code>throw new Error(&#39;错误信息&#39;).catch(message =&gt; {})</code>。建议在队列的最后面加上<code>.catch()</code>，以避免漏掉错误处理。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'hello'</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">'world'</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value + <span class="string">'world'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2s hello</span></span><br><span class="line"><span class="comment">// 再过2s hello world</span></span><br></pre></td></tr></table></figure>
<p>另一个例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'the promise fulfilled'</span>);</span><br><span class="line">    resolve(<span class="string">'hello world'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// 1s后 the promise fulfilled</span></span><br><span class="line"><span class="comment">// 再过2s hello world</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="2-Promise-API"><a href="#2-Promise-API" class="headerlink" title="2. Promise API"></a>2. Promise API</h3><h4 id="2-1-Promise-all"><a href="#2-1-Promise-all" class="headerlink" title="2.1 Promise.all"></a>2.1 Promise.all</h4><p><em><code>Promise.all([p1, p2, p3...])</code></em>用于将多个Promise实例，包装成一个新的Promise实例。</p>
<ul>
<li>它接受一个数组作为参数，数组里可以是Promise对象，也可以是别的值，只有Promise会等待状态改变。</li>
<li>当所有子Promise都完成，该Promise完成，返回值是全部值的数组。</li>
<li>有任何一个失败，该Promise失败，返回值是第一个失败的子Promise的结果</li>
<li>Promise.all()最常见是和.map()连用<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLargest</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FileSystem.readDir(dir, <span class="string">'utf-8'</span>)</span><br><span class="line">    .then( <span class="function"><span class="params">files</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(files.map( <span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">          fs.stat(path.join(dir, file), (err, stat) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">            <span class="keyword">if</span> (stat.isDirectory())&#123;</span><br><span class="line">              <span class="keyword">return</span> resolve(&#123;</span><br><span class="line">                size: <span class="number">0</span></span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            stat.file = file;</span><br><span class="line">            resolve(stat);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-2-Promise-resolve"><a href="#2-2-Promise-resolve" class="headerlink" title="2.2 Promise.resolve()"></a>2.2 Promise.resolve()</h4><p>返回一个状态已变成resolved状态的Promise实例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.reslove($.ajax(<span class="string">'/test/test.json'</span>));</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">valeu</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="2-3-Promise-reject"><a href="#2-3-Promise-reject" class="headerlink" title="2.3 Promise.reject()"></a>2.3 Promise.reject()</h4><p>返回一个状态已变成rejected的Promise实例</p>
<h4 id="2-4-Promise-race"><a href="#2-4-Promise-race" class="headerlink" title="2.4 Promise.race()"></a>2.4 Promise.race()</h4><p>类似Promise.all(),区别在于它有任意一个完成就算完成。</p>
<h4 id="2-5-Promise-prototype-then"><a href="#2-5-Promise-prototype-then" class="headerlink" title="2.5 Promise.prototype.then"></a>2.5 Promise.prototype.then</h4><p>为Promise注册回调函数。then方法可以被同一个promise调用多次。当promise成功执行时，所有onFulfilled需按照其注册顺序依次回调。当promise被拒绝执行时，所有的onRejected需按照其注册顺序依次回调。</p>
<p><br></p>
<h3 id="3-实现一个简单版Promise"><a href="#3-实现一个简单版Promise" class="headerlink" title="3. 实现一个简单版Promise"></a>3. 实现一个简单版Promise</h3><p>使用宏观任务机制(setTimeout),确保onFulfilledCallbacks，onRejectedCallbacks在then方法被调用的那一轮事件循环之后的新执行栈中执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AjPromise</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="comment">// 当前状态</span></span><br><span class="line">    <span class="keyword">this</span>.state = PENDING;</span><br><span class="line">    <span class="comment">// 终值</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 拒因</span></span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 成功态回调队列</span></span><br><span class="line">    <span class="keyword">this</span>.onFulfilledCallbacks = [];</span><br><span class="line">    <span class="comment">// 拒绝态回调队列</span></span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功态回调</span></span><br><span class="line">    <span class="comment">// 当前异步操作执行完毕，调用then方法里的第一个方法</span></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 使用macro-task机制(setTimeout)， 确保onFulfilled在then方法被调用的那一轮事件循环之后的新执行栈中执行</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">          <span class="comment">// pending态迁移至fulfilled，保证调用次数不超过一次</span></span><br><span class="line">          <span class="keyword">this</span>.state = FULFILLED;</span><br><span class="line">          <span class="keyword">this</span>.value = value;</span><br><span class="line">          <span class="keyword">this</span>.onFulfilledCallbacks.map(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = cb(<span class="keyword">this</span>.value)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拒绝态回调</span></span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 使用macro-task机制(setTimeout)，确保onRejected在then方法被调用的那一轮事件循环之后的新执行栈中执行</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">          <span class="comment">// pending态迁移至fulfilled态，保证调用次数不超过一次</span></span><br><span class="line">          <span class="keyword">this</span>.state = REJECTED;</span><br><span class="line">          <span class="keyword">this</span>.reason = reason;</span><br><span class="line">          <span class="keyword">this</span>.onRejectedCallbacks.map(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.reason = cb(<span class="keyword">this</span>.reason);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fn(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulfilled, onRejected)&#123;</span><br><span class="line">    <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> AjPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 2s后执行成功</span></span><br><span class="line">    <span class="comment">// 执行成功后，调用resolve()，通知promise当前异步操作执行完成</span></span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2s后出现</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="4-Promise题目"><a href="#4-Promise题目" class="headerlink" title="4. Promise题目"></a>4. Promise题目</h3><ul>
<li>实现一个sleep函数，sleep(1000)以为这等待1000毫秒<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">t</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, t)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
<ul>
<li><p>promise构造函数是同步执行还是异步执行？then呢？<br>promise构造函数是同步执行的，then方法是异步执行的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, rejcet</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 执行结果是1243</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  resolve(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行结果是1243</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>setTimeout, promise, async/await的区别</p>
</li>
</ul>
<ul>
<li>Promise.all使用、原理实现及错误处理<br>Promise.all()接受一个由promise任务组成</li>
</ul>
<p><br></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://juejin.im/post/5c41297cf265da613356d4ec" target="_blank" rel="noopener">你能手写一个Promise吗？Yes I promise。</a></li>
<li><a href="https://juejin.im/post/5b31a4b7f265da595725f322" target="_blank" rel="noopener">https://juejin.im/post/5b31a4b7f265da595725f322</a></li>
<li><a href="https://juejin.im/post/5b32f552f265da59991155f0" target="_blank" rel="noopener">https://juejin.im/post/5b32f552f265da59991155f0</a></li>
<li><a href="https://juejin.im/post/5aa7868b6fb9a028dd4de672" target="_blank" rel="noopener">https://juejin.im/post/5aa7868b6fb9a028dd4de672</a></li>
<li><a href="https://wangdoc.com/javascript/async/index.html" target="_blank" rel="noopener">https://wangdoc.com/javascript/async/index.html</a></li>
<li><a href="https://www.jianshu.com/p/8d5c3a9e6181" target="_blank" rel="noopener">https://www.jianshu.com/p/8d5c3a9e6181</a></li>
<li><a href="https://www.jianshu.com/p/fe5f173276bd" target="_blank" rel="noopener">前端基础进阶（十三）：透彻掌握Promise的使用，读这篇就够了</a></li>
</ul>

    </div>
  </article>
    
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2019/05/29/React/" rel="next" title="React">
          React
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
        
          <a href="/2019/06/06/HTTP缓存/" rel="prev" title="HTTP缓存">
            HTTP缓存
          </a>
          <span>〉</span>
        
      </div>
    </div>
  
</div>


<script>
var link = document.getElementsByClassName('toc-link');
var hash = decodeURIComponent(location.hash);
if (hash){
} else {
  link[0].classList.add('toc-link-active');
}

var h3 = document.getElementsByTagName('h3');
var h4 = document.getElementsByTagName('h4');
var h5 = document.getElementsByTagName('h5');
var link_arr = [];
function addToArr(arr){
  for(var i = 0; i < arr.length; i++){
    link_arr.push(arr[i].offsetTop);
  }
}
addToArr(h3);
addToArr(h4);
addToArr(h5);


var compare = function (x, y) {
    if (x < y) {
        return -1;
    } else if (x > y) {
        return 1;
    } else {
        return 0;
    }
}

link_arr.sort(compare);


window.onscroll = function(){
  var height = document.documentElement.scrollTop;
  for (var i = 0; i < link_arr.length; i++){
    if (link_arr[i] > height){
      for(var j = 0; j < link.length; j++){
        link[j].classList.remove('toc-link-active');
      }
      document.getElementsByClassName('toc-link')[i].classList.add('toc-link-active');
      break;
    } 
  }
}

</script>
    </div>
  </div>
  




    <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
    
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        // listen to any DOM change and automatically perform spacing via MutationObserver()
        pangu.autoSpacingPage();
      });
    </script>
</body>
</html>

