
<!DOCTYPE html>
<html lang="">


  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="theme-color" content="#202020">
    <meta http-equiv="x-ua-compatible" content="ie=edge">

    
        <meta name="keywords" content="">
        

          
              <meta name="description" content="跨域请求">
              

                <link rel="icon" type="image/x-icon" href="data:image/png;base64,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">
                <title>
                  跨域请求 [ 开发笔记 ]
                </title>
                
                  <!-- stylesheets list from config.yml -->
                  
                    <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
                    
                    <link rel="stylesheet" href="/css/microb.css">
                    
                      
  </head>

<body>
  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
        <div class="tab">
            <a href="/"><img src="/left.png" /></a>
            <span><a href="/">开发笔记</a></span>
            <!-- <span><a class="tab-search" href="/search/">搜索</a></span> -->
            
              <span><a class="tab-title" id="#Browser" href="/#Browser">Browser</a></span>
            
              <span><a class="tab-title" id="#Bug" href="/#Bug">Bug</a></span>
            
              <span><a class="tab-title" id="#CSS" href="/#CSS">CSS</a></span>
            
              <span><a class="tab-title" id="#HTML" href="/#HTML">HTML</a></span>
            
              <span><a class="tab-title" id="#HTTP" href="/#HTTP">HTTP</a></span>
            
              <span><a class="tab-title" id="#JS" href="/#JS">JS</a></span>
            
              <span><a class="tab-title" id="#LeetCode" href="/#LeetCode">LeetCode</a></span>
            
              <span><a class="tab-title" id="#NodeJS" href="/#NodeJS">NodeJS</a></span>
            
              <span><a class="tab-title" id="#Other" href="/#Other">Other</a></span>
            
              <span><a class="tab-title" id="#Work" href="/#Work">Work</a></span>
            
              <span><a class="tab-title" id="#随笔" href="/#随笔">随笔</a></span>
            
          </div>
      
  <div id="toc" class="toc-article">
    <!--<strong class="toc-title">目录</strong>-->
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-同源策略"><span class="toc-text">1. 同源策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-受同源策略约束的交互"><span class="toc-text">1.1 受同源策略约束的交互</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-可执行的跨源访问"><span class="toc-text">1.2 可执行的跨源访问</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-跨域解决方案"><span class="toc-text">2. 跨域解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-CORS"><span class="toc-text">2.1 CORS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-触发预请求"><span class="toc-text">2.1.1 触发预请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-2-简单请求"><span class="toc-text">2.2.2 简单请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-3-非简单请求"><span class="toc-text">2.2.3 非简单请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-4-withCredentials"><span class="toc-text">2.2.4 withCredentials</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-jsonp"><span class="toc-text">2.2 jsonp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-服务器代理"><span class="toc-text">2.3 服务器代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-document-domain"><span class="toc-text">2.4 document.domain</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-window-name"><span class="toc-text">2.5 window.name</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol>
  </div>


<div class="section">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        跨域请求
      </h1>
      
      <time class="time" datetime="2018-11-06T09:57:46.000Z">
        2018-11-06
      </time>
      
      <hr>
    </header>
    <div class="post-content">
      <h3 id="1-同源策略"><a href="#1-同源策略" class="headerlink" title="1. 同源策略"></a>1. 同源策略</h3><p>为什么会出现跨域？因为存在同源策略。</p>
<blockquote>
<p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。（同源: 如果两个页面的协议，端口和域名都相同，则两个页面具有相同的源。）</p>
</blockquote>
<h4 id="1-1-受同源策略约束的交互"><a href="#1-1-受同源策略约束的交互" class="headerlink" title="1.1 受同源策略约束的交互"></a>1.1 受同源策略约束的交互</h4><ul>
<li><em>dom同源策略</em><br>禁止对不同源页面DOM进行操作。这里主要场景是iframe跨域的情况，不同域名的iframe是限制互相访问的。</li>
<li><em>XmlHttpRequest同源策略</em><br>禁止使用XHR对象向不同源的服务器地址发起HTTP请求。</li>
</ul>
<h4 id="1-2-可执行的跨源访问"><a href="#1-2-可执行的跨源访问" class="headerlink" title="1.2 可执行的跨源访问"></a>1.2 可执行的跨源访问</h4><ul>
<li><code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code> 标签嵌入跨域脚本 </li>
<li><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot;&gt;</code> 标签嵌入CSS</li>
<li><code>&lt;img&gt;</code>嵌入图片</li>
<li><code>&lt;video&gt; 和 &lt;audio&gt;</code> 嵌入多媒体资源。</li>
<li><code>&lt;object&gt;, &lt;embed&gt; 和 &lt;applet&gt;</code>的插件</li>
<li><code>@font-face</code> 引入的字体</li>
<li><code>&lt;frame&gt; 和 &lt;iframe&gt;</code> 载入的任何资源。站点可以使用X-Frame-Options消息头来阻止这种形式的跨域交互。</li>
<li><code>CORS</code>跨域资源共享机制，允许跨域访问</li>
</ul>
<h3 id="2-跨域解决方案"><a href="#2-跨域解决方案" class="headerlink" title="2. 跨域解决方案"></a>2. 跨域解决方案</h3><h4 id="2-1-CORS"><a href="#2-1-CORS" class="headerlink" title="2.1 CORS"></a>2.1 CORS</h4><p>CORS 跨域资源共享，它允许浏览器向跨域服务器，发出XMLHttpRequest请求，从而克服ajax只能同源使用的限制。</p>
<p>整个CORS通信过程，由浏览器自动完成，对开发者来说，CORS通信与ajax没有差别。浏览器一旦发现ajax请求跨源，会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。浏览器将CORS请求分成两类：简单请求和非简单请求。</p>
<h5 id="2-1-1-触发预请求"><a href="#2-1-1-触发预请求" class="headerlink" title="2.1.1 触发预请求"></a>2.1.1 触发预请求</h5><p>当请求满足下述任一条件时，即会触发预检请求：</p>
<ul>
<li><p>使用了下面任一HTTP方法：</p>
<ul>
<li>PUT</li>
<li>DELETE</li>
<li>CONNECT</li>
<li>OPTIONS</li>
<li>TRACE</li>
<li>PATCH</li>
</ul>
</li>
<li><p>人为设置了下面字段以外的其他首部字段：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type</li>
<li>DPR</li>
<li>Downlink</li>
<li>Save-Data</li>
<li>Viewport-Width</li>
<li>Width</li>
</ul>
</li>
<li><p><code>Content-Type</code>的值不属于下列之一</p>
<ul>
<li>application/x-www-form-urlencoded</li>
<li>multipart/form-data</li>
<li>text/plain</li>
</ul>
</li>
<li><p>请求中的<code>XMLHttpRequestUpload</code>对象注册了任一多个事件监听器</p>
</li>
<li>请求中使用<code>ReadableStream</code>对象</li>
</ul>
<p><em>Q: 有一个需求复杂的老项目，每个请求都会触发预请求。怎样消除预请求，减少请求数？</em></p>
<h5 id="2-2-2-简单请求"><a href="#2-2-2-简单请求" class="headerlink" title="2.2.2 简单请求"></a>2.2.2 简单请求</h5><p>对于简单请求，浏览器直接发出CORS请求，并在头信息中，增加<code>Origin</code>字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br></pre></td></tr></table></figure></p>
<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应，回应头信息中没有<code>Access-Control-Allow-Origin</code>字段，就知道错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。</p>
<p>如果<code>Origin</code>指定的源在许可范围内，服务器返回的响应，会多出几个头信息字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com  // 接受哪些域名的请求</span><br><span class="line">Access-Control-Allow-Credentials: true           // 是否允许发送cookie</span><br><span class="line">Access-Control-Expose-Headers: FooBar            // 可选</span><br></pre></td></tr></table></figure></p>
<h5 id="2-2-3-非简单请求"><a href="#2-2-3-非简单请求" class="headerlink" title="2.2.3 非简单请求"></a>2.2.3 非简单请求</h5><p>非简单请求，会在正式通信之前，增加一次HTTP查询请求，称为“预检”（preflight）。<br><em>预检请求</em>用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 预检请求的头信息</span><br><span class="line">OPTIONS /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line"></span><br><span class="line">// 指定浏览器CORS请求会额外发送的头信息字段</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header </span><br><span class="line">Host: api.alice.com</span><br></pre></td></tr></table></figure></p>
<p>服务器收到“预检”请求号，检查了<code>Origin, Access-Control-Request-Method 和 Access-Control-Request-Headers</code>字段后，确定允许跨域请求，做出回应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OKs</span><br><span class="line">// 服务器回应的CORS相关字段</span><br><span class="line">Access-Control-Allow-Origin: http://api.bob.coms</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure></p>
<p>如果服务器否定了“预检”请求，会返回一个正常的HTTP回应，但没有任何CORS相关的头信息字段。浏览器会认定服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。</p>
<h5 id="2-2-4-withCredentials"><a href="#2-2-4-withCredentials" class="headerlink" title="2.2.4 withCredentials"></a>2.2.4 withCredentials</h5><p>CORS请求默认不发送Cookie和HTTP认证信息。如果要把cookie发到服务器，服务器需要指定<code>Access-Control-Allow-Credentials</code>字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure></p>
<p>开发者必须在ajax请求中打开<code>withCredentials</code>属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = true;</span><br></pre></td></tr></table></figure></p>
<p>注意，如果要发送Cookie，<code>Access-Control-Allow-Origin</code>不能设为星号，必须指定明确的，与请求网页一致的域名。同时，Cookie仍遵循同源政策，跨源(原网页代码中)的<code>document.cookie</code>无法读取服务器域名下的Cookie。</p>
<h4 id="2-2-jsonp"><a href="#2-2-jsonp" class="headerlink" title="2.2 jsonp"></a>2.2 jsonp</h4><p>利用<code>&lt;script&gt;</code>标签没有跨域限制的”漏洞“来达到和第三方通信的目的。<br>需要通讯时，创建一个<code>&lt;script&gt;</code>元素，地址指向第三方API网址，并提供一个回调参数来接收数据。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 请求中可以增加参数</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'http://xxx.com/xxxx?prams=xxx&amp;callback=functionHandler'</span>;</span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.setAttribute(<span class="string">'src'</span>, url);</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(script);</span><br></pre></td></tr></table></figure></p>
<p>服务器返回的script文件内容<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback(data)</span><br></pre></td></tr></table></figure></p>
<h4 id="2-3-服务器代理"><a href="#2-3-服务器代理" class="headerlink" title="2.3 服务器代理"></a>2.3 服务器代理</h4><p>在服务器端配置好代理，浏览器端就不会出现跨域的问题<br>在开发阶段比较常实现<br>devsever的proxy就是用来该原理<br>在devsever中配置代理，原指向devserver的请求被代理到目标地址，在服务器中http请求没有跨域限制，所以解决了浏览器js跨域的问题</p>
<h4 id="2-4-document-domain"><a href="#2-4-document-domain" class="headerlink" title="2.4 document.domain"></a>2.4 document.domain</h4><p>修改<code>document.domain</code>实现子域不同的页面进行跨域交互。<code>document.domain</code>存放的是载入文档的服务器的主机名，可以手动设置这个属性，但只能设置成当前域名或上级域名，如id.qq.com, qq.com。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.domain = 顶级域名</span><br></pre></td></tr></table></figure></p>
<h4 id="2-5-window-name"><a href="#2-5-window-name" class="headerlink" title="2.5 window.name"></a>2.5 window.name</h4><p><code>window.name</code>利用同一窗体下加载不同的页面，window.name的值不会清除，达到传递数据的效果。（数据大小支持到2MB）。具体操作需要3个页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a 域名下的 origin page</span><br><span class="line">a 域名下的 proxy page</span><br><span class="line">b 域名下的 data page</span><br></pre></td></tr></table></figure></p>
<p>a 域名下origin page 通过动态的iframe 加载 data page, data page中设置了window.name = data数据。</p>
<p>可是此时 origin page的域名与data page域名不一致，浏览器限制交互，所以需要将iframe跳转到proxy page（即iframe的scr值设置为proxy page）。此时iframe与 origin page同源，可以操作获取到iframe 的window.name中的数据，获取完毕后销毁iframe。</p>
<p>这样origin page就可以获取到非同源下的 data page数据。</p>
<p>a域名下的 origin page<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="built_in">document</span>.getElementsByTagName(<span class="string">"button"</span>)[<span class="number">0</span>];</span><br><span class="line">a.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;                               </span><br><span class="line">    <span class="keyword">var</span> inf=<span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>);       <span class="comment">//创建iframe</span></span><br><span class="line">    inf.src=<span class="string">"http://www.b.com/data.html"</span>+<span class="string">"?h=5"</span>     <span class="comment">//加载数据页www.b.com/data.html?h=5</span></span><br><span class="line">    <span class="keyword">var</span> body=<span class="built_in">document</span>.getElementsByTagName(<span class="string">"body"</span>)[<span class="number">0</span>];</span><br><span class="line">    body.appendChild(inf);                          <span class="comment">//引入a页面</span></span><br><span class="line"></span><br><span class="line">    inf.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        inf.src=<span class="string">'http://www.a.com/proxy.html'</span>       <span class="comment">//iframe加载完成，加载www.a.com域下边的空白页proxy.html</span></span><br><span class="line">        <span class="built_in">console</span>.log(inf.contentWindow.name)        <span class="comment">//输出window.name中的数据</span></span><br><span class="line">        body.removeChild(inf)                      <span class="comment">//清除iframe</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>b域名下 data page<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // var str = window.location.href.substr(-1,1);      //获取url中携带的参数值h=5</span><br><span class="line">    // 因为已经是b域名下的页面了，可以通过请求各种b域名下的数据再设置window.name的值</span><br><span class="line">    window.name = &apos;some data&apos;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://www.xiaolai.cc/2018/11/02/js%E8%B7%A8%E5%9F%9F/" target="_blank" rel="noopener">js跨域</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></li>
</ul>

    </div>
  </article>
    
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2018/11/06/Sass笔记/" rel="next" title="Sass常用命令">
          Sass常用命令
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
        
          <a href="/2018/11/06/CSS变量换肤/" rel="prev" title="CSS变量实现主题换肤">
            CSS变量实现主题换肤
          </a>
          <span>〉</span>
        
      </div>
    </div>
  
</div>


<script>
var link = document.getElementsByClassName('toc-link');
var hash = decodeURIComponent(location.hash);
if (hash){
} else {
  link[0].classList.add('toc-link-active');
}

var h3 = document.getElementsByTagName('h3');
var h4 = document.getElementsByTagName('h4');
var h5 = document.getElementsByTagName('h5');
var link_arr = [];
function addToArr(arr){
  for(var i = 0; i < arr.length; i++){
    link_arr.push(arr[i].offsetTop);
  }
}
addToArr(h3);
addToArr(h4);
addToArr(h5);


var compare = function (x, y) {
    if (x < y) {
        return -1;
    } else if (x > y) {
        return 1;
    } else {
        return 0;
    }
}

link_arr.sort(compare);


window.onscroll = function(){
  var height = document.documentElement.scrollTop;
  for (var i = 0; i < link_arr.length; i++){
    if (link_arr[i] > height){
      for(var j = 0; j < link.length; j++){
        link[j].classList.remove('toc-link-active');
      }
      document.getElementsByClassName('toc-link')[i].classList.add('toc-link-active');
      break;
    } 
  }
}

</script>
    </div>
  </div>
  




    <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
      
    
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        // listen to any DOM change and automatically perform spacing via MutationObserver()
        pangu.autoSpacingPage();
      });

      window.addEventListener("load", event => {
        // 判断浏览器是否支持
        if ("serviceWorker" in navigator) {
          window.navigator.serviceWorker
            .register("/sw.js", {
              scope: "/"
            })
        }
      });
    </script>
</body>
</html>

