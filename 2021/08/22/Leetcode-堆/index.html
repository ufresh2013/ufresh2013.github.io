
<!DOCTYPE html>
<html lang="">


  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="theme-color" content="#202020">
    <meta http-equiv="x-ua-compatible" content="ie=edge">

    
        <meta name="keywords" content="">
        

          
              <meta name="description" content="堆">
              

                <link rel="icon" type="image/x-icon" href="data:image/png;base64,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">
                <title>
                  堆 [ 开发笔记 ]
                </title>
                
                  <!-- stylesheets list from config.yml -->
                  
                    <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
                    
                    <link rel="stylesheet" href="/css/microb.css">
                    
                      
  </head>

<body>
  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
        <div class="tab">
            <a href="/"><img src="/left.png" /></a>
            <span><a href="/">开发笔记</a></span>
            <!-- <span><a class="tab-search" href="/search/">搜索</a></span> -->
            
              <span><a class="tab-title" id="#Basic" href="/#Basic">Basic</a></span>
            
              <span><a class="tab-title" id="#Browser" href="/#Browser">Browser</a></span>
            
              <span><a class="tab-title" id="#Bug" href="/#Bug">Bug</a></span>
            
              <span><a class="tab-title" id="#CSS" href="/#CSS">CSS</a></span>
            
              <span><a class="tab-title" id="#HTML" href="/#HTML">HTML</a></span>
            
              <span><a class="tab-title" id="#HTTP" href="/#HTTP">HTTP</a></span>
            
              <span><a class="tab-title" id="#JS" href="/#JS">JS</a></span>
            
              <span><a class="tab-title" id="#LeetCode" href="/#LeetCode">LeetCode</a></span>
            
              <span><a class="tab-title" id="#NodeJS" href="/#NodeJS">NodeJS</a></span>
            
              <span><a class="tab-title" id="#React" href="/#React">React</a></span>
            
              <span><a class="tab-title" id="#Vue" href="/#Vue">Vue</a></span>
            
              <span><a class="tab-title" id="#Work" href="/#Work">Work</a></span>
            
              <span><a class="tab-title" id="#全栈" href="/#全栈">全栈</a></span>
            
              <span><a class="tab-title" id="#动画/媒体" href="/#动画/媒体">动画/媒体</a></span>
            
          </div>
      
  <div id="toc" class="toc-article">
    <!--<strong class="toc-title">目录</strong>-->
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-堆-Heap"><span class="toc-text">1. 堆(Heap)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-相关LeetCode题目"><span class="toc-text">2. 相关LeetCode题目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Offer40-最小的K个数"><span class="toc-text">Offer40.最小的K个数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-JS如何实现堆"><span class="toc-text">3. JS如何实现堆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-如何表示一个堆"><span class="toc-text">3.1 如何表示一个堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-实现大顶堆"><span class="toc-text">3.2 实现大顶堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-实现小顶堆"><span class="toc-text">3.3 实现小顶堆</span></a></li></ol></li></ol>
  </div>


<div class="section">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        堆
      </h1>
      
      <time class="time" datetime="2021-08-22T07:47:10.000Z">
        2021-08-22
      </time>
      
      <hr>
    </header>
    <div class="post-content">
      <blockquote>
<p>假设我们有10 亿个搜索关键词，如何能快速获取到Top 10的关键词呢?<br>如何实现定时器SetTimeout? 按照任务设定的执行时间，如何快速地拿到最先执行的任务？<br>借助于堆(Heap)这种数据结构，快速获取数据流中最大值，最小值。</p>
</blockquote>
<p><br></p>
<h3 id="1-堆-Heap"><a href="#1-堆-Heap" class="headerlink" title="1. 堆(Heap)"></a>1. 堆(Heap)</h3><p>堆是一种特殊的树。只要满足这两点，它就是一个堆</p>
<ul>
<li>堆是一个完全二叉树。<br>完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</li>
<li>堆中每个节点的值都必须大于等于(或小于等于)其子树中每个节点的值<br>对于每个节点的值都大于等于子树中每个节点值的堆，我们叫做<strong>大顶堆</strong><br>对于每个节点的值都小于等于子树中每个节点值的堆，我们叫做<strong>小顶堆</strong></li>
</ul>
<p>大顶堆和小顶堆，就是我们想要的数据结构。它总是保持着堆顶元素是最大/最小的。这里假设我们已经实现了<em>大顶堆</em>和<em>小顶堆</em>，它允许初始化一个数组，对数组中的元素进行堆排序。向堆中插入新元素，获取堆顶元素的时间复杂度只要 O(nlogn)，并且还是原地排序算法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现堆的代码在下面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (nums) &#123;&#125; <span class="comment">// 接受一个数组，一开始对nums进行堆排序</span></span><br><span class="line">  insert (num) &#123;&#125; <span class="comment">// 往堆里插入元素</span></span><br><span class="line">  removeMax () &#123;&#125; <span class="comment">// 获取堆顶元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>堆的初始化，插入元素，获取堆顶元素的方法都有了。Leetcode题就是简单地对数组进行堆排序，然后取值了。</p>
<p><br></p>
<h3 id="2-相关LeetCode题目"><a href="#2-相关LeetCode题目" class="headerlink" title="2. 相关LeetCode题目"></a>2. 相关LeetCode题目</h3><p>包括查找数组中的最大K个数，最小K个数。</p>
<ul>
<li><a href="https://github.com/ufresh2013/-algorithm015/blob/master/Heap/215.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.md" target="_blank" rel="noopener">215.数组中的第K个最大元素</a> </li>
<li><a href="https://github.com/ufresh2013/-algorithm015/blob/master/Heap/692.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.md" target="_blank" rel="noopener">347.前K个高频元素</a> </li>
<li><a href="https://github.com/ufresh2013/-algorithm015/blob/master/Heap/692.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D.md" target="_blank" rel="noopener">692.前K个高频单词</a> </li>
<li><a href="https://github.com/ufresh2013/-algorithm015/blob/master/Heap/Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.md" target="_blank" rel="noopener">Offer40.最小的K个数</a> </li>
</ul>
<p><br></p>
<h4 id="Offer40-最小的K个数"><a href="#Offer40-最小的K个数" class="headerlink" title="Offer40.最小的K个数"></a><strong>Offer40.最小的K个数</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (nums) &#123;&#125; <span class="comment">// 接受一个数组，一开始对nums进行堆排序</span></span><br><span class="line">  insert (num) &#123;&#125; <span class="comment">// 往堆里插入元素</span></span><br><span class="line">  removeMin () &#123;&#125; <span class="comment">// 获取堆顶元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getLeastNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">arr, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> heap = <span class="keyword">new</span> MinHeap(arr)</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    result.push(heap.removeMin())</span><br><span class="line">    k--</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，<code>MinHeap</code>最小堆怎么实现呢？由于JS没有堆这种基础数据，我们要自己手动实现堆。</p>
<p><br></p>
<h3 id="3-JS如何实现堆"><a href="#3-JS如何实现堆" class="headerlink" title="3. JS如何实现堆"></a>3. JS如何实现堆</h3><h4 id="3-1-如何表示一个堆"><a href="#3-1-如何表示一个堆" class="headerlink" title="3.1 如何表示一个堆"></a>3.1 如何表示一个堆</h4><p>完全二叉树适合用数组来存储。我们不需要存储左右子节点的指针，单纯通过数组的下标，就可以找到一个节点的左右子节点和父节点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">7</span></span><br><span class="line">  /   \</span><br><span class="line">  <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">/ \   /  \</span><br><span class="line"><span class="number">4</span>  <span class="number">2</span>  <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用数组存储堆的例子</span></span><br><span class="line"><span class="comment">// 下标为i的节点, 其左子节点的下标是 i * 2，其右子节点的下标是 i * 2 + 1, 其父节点下标为 Math.floor(i / 2)</span></span><br><span class="line">[<span class="literal">undefined</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h4 id="3-2-实现大顶堆"><a href="#3-2-实现大顶堆" class="headerlink" title="3.2 实现大顶堆"></a>3.2 实现大顶堆</h4><p>保证堆顶元素最大<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">- 往堆中插入一个元素</span></span><br><span class="line"><span class="comment">【 从下往上的堆化方法 】插入后使其重新满足堆的特性，这个过程，叫做堆化(heapify)。把节点放在最后，如果不满足子节点小于等于父节点的大小关系，就互换两个节点，一直重复这个过程，直到满足这种大小关系。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 删除堆顶元素</span></span><br><span class="line"><span class="comment">任何节点的值都大于等于（或小于等于）子树节点的值，我们可以发现，堆顶元素就是堆中数据的最大值或最小值。</span></span><br><span class="line"><span class="comment">【 从上往下的堆化方法 】我们把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点关系的，互换两个节点，并重复进行这个过程。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">arr, idx1, idx2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> temp = arr[idx1]</span><br><span class="line">  arr[idx1] = arr[idx2]</span><br><span class="line">  arr[idx2] = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (arr) &#123;</span><br><span class="line">    <span class="keyword">this</span>.arr = [] <span class="comment">// 从下标1开始存储数据</span></span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span> <span class="comment">// 堆已经存储的数据个数</span></span><br><span class="line">    arr.forEach(<span class="function"><span class="params">v</span> =&gt;</span> <span class="keyword">this</span>.insert(v))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  insert (data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.count++</span><br><span class="line">    <span class="keyword">this</span>.arr[<span class="keyword">this</span>.count] = data</span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.count</span><br><span class="line">    <span class="comment">// 把节点放在最后，对比当前节点与父节点的关系，如果不满足，则互换节点</span></span><br><span class="line">    <span class="keyword">while</span> ((i / <span class="number">2</span> | <span class="number">0</span>) &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.arr[i] &gt; <span class="keyword">this</span>.arr[(i / <span class="number">2</span> | <span class="number">0</span>)]) &#123; <span class="comment">// 自下往上堆化</span></span><br><span class="line">      swap(<span class="keyword">this</span>.arr, i, (i / <span class="number">2</span> | <span class="number">0</span>))</span><br><span class="line">      i = i / <span class="number">2</span> | <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeMax () &#123;</span><br><span class="line">    <span class="keyword">const</span> heapify = <span class="function">(<span class="params">arr, n, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 自上往下堆化</span></span><br><span class="line">        <span class="keyword">let</span> maxPos = i</span><br><span class="line">        <span class="keyword">if</span> (i*<span class="number">2</span> &lt;= n &amp;&amp; arr[i] &lt; arr[i*<span class="number">2</span>]) maxPos = i*<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; arr[maxPos] &lt; arr[i*<span class="number">2</span>+<span class="number">1</span>]) maxPos = i*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (maxPos == i) <span class="keyword">break</span></span><br><span class="line">        swap(arr, i, maxPos)</span><br><span class="line">        i = maxPos</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.count === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span> <span class="comment">// 堆中没有数据</span></span><br><span class="line">    <span class="keyword">const</span> max = <span class="keyword">this</span>.arr[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">this</span>.arr[<span class="number">1</span>] = <span class="keyword">this</span>.arr[<span class="keyword">this</span>.count]</span><br><span class="line">    <span class="keyword">this</span>.count--</span><br><span class="line">    heapify(<span class="keyword">this</span>.arr, <span class="keyword">this</span>.count, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h4 id="3-3-实现小顶堆"><a href="#3-3-实现小顶堆" class="headerlink" title="3.3 实现小顶堆"></a>3.3 实现小顶堆</h4><p>保证堆顶元素最小<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">arr, idx1, idx2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> temp = arr[idx1]</span><br><span class="line">  arr[idx1] = arr[idx2]</span><br><span class="line">  arr[idx2] = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (arr) &#123;</span><br><span class="line">    <span class="keyword">this</span>.arr = [] <span class="comment">// 从下标1开始存储数据</span></span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span> <span class="comment">// 堆已经存储的数据个数</span></span><br><span class="line">    arr.forEach(<span class="function"><span class="params">v</span> =&gt;</span> <span class="keyword">this</span>.insert(v)) <span class="comment">// 建堆</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  insert (data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.count++</span><br><span class="line">    <span class="keyword">this</span>.arr[<span class="keyword">this</span>.count] = data</span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.count</span><br><span class="line">    <span class="comment">// 把节点放在最后，对比当前节点与父节点的关系，如果不满足，则互换节点</span></span><br><span class="line">    <span class="keyword">while</span> (i/<span class="number">2</span>|<span class="number">0</span> &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.arr[i] &lt; <span class="keyword">this</span>.arr[i/<span class="number">2</span>|<span class="number">0</span>]) &#123;</span><br><span class="line">      swap(<span class="keyword">this</span>.arr, i, (i / <span class="number">2</span> | <span class="number">0</span>))</span><br><span class="line">      i = i / <span class="number">2</span> | <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  removeMin () &#123;</span><br><span class="line">    <span class="keyword">const</span> heapify = <span class="function">(<span class="params">arr, n, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 自上往下堆化</span></span><br><span class="line">        <span class="keyword">let</span> maxPos = i</span><br><span class="line">        <span class="keyword">if</span> (i*<span class="number">2</span> &lt;= n &amp;&amp; arr[i] &gt; arr[i*<span class="number">2</span>]) maxPos = i*<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; arr[maxPos] &gt; arr[i*<span class="number">2</span>+<span class="number">1</span>]) maxPos = i*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (maxPos == i) <span class="keyword">break</span></span><br><span class="line">        swap(arr, i, maxPos)</span><br><span class="line">        i = maxPos</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.count === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span> <span class="comment">// 堆中没有数据</span></span><br><span class="line">    <span class="keyword">const</span> min = <span class="keyword">this</span>.arr[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">this</span>.arr[<span class="number">1</span>] = <span class="keyword">this</span>.arr[<span class="keyword">this</span>.count]</span><br><span class="line">    <span class="keyword">this</span>.count--</span><br><span class="line">    heapify(<span class="keyword">this</span>.arr, <span class="keyword">this</span>.count, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>

    </div>
  </article>
    
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2021/08/20/ServiceWorker/" rel="next" title="Service Worker 实现离线页面访问">
          Service Worker 实现离线页面访问
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
        
          <a href="/2021/08/23/HTTPS/" rel="prev" title="简述一下HTTPS">
            简述一下HTTPS
          </a>
          <span>〉</span>
        
      </div>
    </div>
  
</div>


<script>
var link = document.getElementsByClassName('toc-link');
var hash = decodeURIComponent(location.hash);
if (hash){
} else {
  link[0].classList.add('toc-link-active');
}

var h3 = document.getElementsByTagName('h3');
var h4 = document.getElementsByTagName('h4');
var h5 = document.getElementsByTagName('h5');
var link_arr = [];
function addToArr(arr){
  for(var i = 0; i < arr.length; i++){
    link_arr.push(arr[i].offsetTop);
  }
}
addToArr(h3);
addToArr(h4);
addToArr(h5);


var compare = function (x, y) {
    if (x < y) {
        return -1;
    } else if (x > y) {
        return 1;
    } else {
        return 0;
    }
}

link_arr.sort(compare);


window.onscroll = function(){
  var height = document.documentElement.scrollTop;
  for (var i = 0; i < link_arr.length; i++){
    if (link_arr[i] > height){
      for(var j = 0; j < link.length; j++){
        link[j].classList.remove('toc-link-active');
      }
      document.getElementsByClassName('toc-link')[i].classList.add('toc-link-active');
      break;
    } 
  }
}

</script>
    </div>
  </div>
  




    <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
      
    
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        // listen to any DOM change and automatically perform spacing via MutationObserver()
        pangu.autoSpacingPage();
      });

      window.addEventListener("load", event => {
        // 判断浏览器是否支持
        if ("serviceWorker" in navigator) {
          window.navigator.serviceWorker
            .register("/sw.js", {
              scope: "/"
            })
        }
      });
    </script>
</body>
</html>

